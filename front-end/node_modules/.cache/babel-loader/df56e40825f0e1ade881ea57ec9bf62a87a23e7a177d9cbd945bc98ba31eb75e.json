{"ast":null,"code":"'use strict';\n\nconst {\n  BalancedPoolMissingUpstreamError,\n  InvalidArgumentError\n} = require('./core/errors');\nconst {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kRemoveClient,\n  kGetDispatcher\n} = require('./pool-base');\nconst Pool = require('./pool');\nconst {\n  kUrl,\n  kInterceptors\n} = require('./core/symbols');\nconst {\n  parseOrigin\n} = require('./core/util');\nconst kFactory = Symbol('factory');\nconst kOptions = Symbol('options');\nconst kGreatestCommonDivisor = Symbol('kGreatestCommonDivisor');\nconst kCurrentWeight = Symbol('kCurrentWeight');\nconst kIndex = Symbol('kIndex');\nconst kWeight = Symbol('kWeight');\nconst kMaxWeightPerServer = Symbol('kMaxWeightPerServer');\nconst kErrorPenalty = Symbol('kErrorPenalty');\nfunction getGreatestCommonDivisor(a, b) {\n  if (b === 0) return a;\n  return getGreatestCommonDivisor(b, a % b);\n}\nfunction defaultFactory(origin, opts) {\n  return new Pool(origin, opts);\n}\nclass BalancedPool extends PoolBase {\n  constructor(upstreams = [], {\n    factory = defaultFactory,\n    ...opts\n  } = {}) {\n    super();\n    this[kOptions] = opts;\n    this[kIndex] = -1;\n    this[kCurrentWeight] = 0;\n    this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;\n    this[kErrorPenalty] = this[kOptions].errorPenalty || 15;\n    if (!Array.isArray(upstreams)) {\n      upstreams = [upstreams];\n    }\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.');\n    }\n    this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];\n    this[kFactory] = factory;\n    for (const upstream of upstreams) {\n      this.addUpstream(upstream);\n    }\n    this._updateBalancedPoolStats();\n  }\n  addUpstream(upstream) {\n    const upstreamOrigin = parseOrigin(upstream).origin;\n    if (this[kClients].find(pool => pool[kUrl].origin === upstreamOrigin && pool.closed !== true && pool.destroyed !== true)) {\n      return this;\n    }\n    const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));\n    this[kAddClient](pool);\n    pool.on('connect', () => {\n      pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);\n    });\n    pool.on('connectionError', () => {\n      pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);\n      this._updateBalancedPoolStats();\n    });\n    pool.on('disconnect', (...args) => {\n      const err = args[2];\n      if (err && err.code === 'UND_ERR_SOCKET') {\n        // decrease the weight of the pool.\n        pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);\n        this._updateBalancedPoolStats();\n      }\n    });\n    for (const client of this[kClients]) {\n      client[kWeight] = this[kMaxWeightPerServer];\n    }\n    this._updateBalancedPoolStats();\n    return this;\n  }\n  _updateBalancedPoolStats() {\n    this[kGreatestCommonDivisor] = this[kClients].map(p => p[kWeight]).reduce(getGreatestCommonDivisor, 0);\n  }\n  removeUpstream(upstream) {\n    const upstreamOrigin = parseOrigin(upstream).origin;\n    const pool = this[kClients].find(pool => pool[kUrl].origin === upstreamOrigin && pool.closed !== true && pool.destroyed !== true);\n    if (pool) {\n      this[kRemoveClient](pool);\n    }\n    return this;\n  }\n  get upstreams() {\n    return this[kClients].filter(dispatcher => dispatcher.closed !== true && dispatcher.destroyed !== true).map(p => p[kUrl].origin);\n  }\n  [kGetDispatcher]() {\n    // We validate that pools is greater than 0,\n    // otherwise we would have to wait until an upstream\n    // is added, which might never happen.\n    if (this[kClients].length === 0) {\n      throw new BalancedPoolMissingUpstreamError();\n    }\n    const dispatcher = this[kClients].find(dispatcher => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);\n    if (!dispatcher) {\n      return;\n    }\n    const allClientsBusy = this[kClients].map(pool => pool[kNeedDrain]).reduce((a, b) => a && b, true);\n    if (allClientsBusy) {\n      return;\n    }\n    let counter = 0;\n    let maxWeightIndex = this[kClients].findIndex(pool => !pool[kNeedDrain]);\n    while (counter++ < this[kClients].length) {\n      this[kIndex] = (this[kIndex] + 1) % this[kClients].length;\n      const pool = this[kClients][this[kIndex]];\n\n      // find pool index with the largest weight\n      if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {\n        maxWeightIndex = this[kIndex];\n      }\n\n      // decrease the current weight every `this[kClients].length`.\n      if (this[kIndex] === 0) {\n        // Set the current weight to the next lower weight.\n        this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];\n        if (this[kCurrentWeight] <= 0) {\n          this[kCurrentWeight] = this[kMaxWeightPerServer];\n        }\n      }\n      if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {\n        return pool;\n      }\n    }\n    this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];\n    this[kIndex] = maxWeightIndex;\n    return this[kClients][maxWeightIndex];\n  }\n}\nmodule.exports = BalancedPool;","map":{"version":3,"names":["BalancedPoolMissingUpstreamError","InvalidArgumentError","require","PoolBase","kClients","kNeedDrain","kAddClient","kRemoveClient","kGetDispatcher","Pool","kUrl","kInterceptors","parseOrigin","kFactory","Symbol","kOptions","kGreatestCommonDivisor","kCurrentWeight","kIndex","kWeight","kMaxWeightPerServer","kErrorPenalty","getGreatestCommonDivisor","a","b","defaultFactory","origin","opts","BalancedPool","constructor","upstreams","factory","maxWeightPerServer","errorPenalty","Array","isArray","interceptors","upstream","addUpstream","_updateBalancedPoolStats","upstreamOrigin","find","pool","closed","destroyed","Object","assign","on","Math","min","max","args","err","code","client","map","p","reduce","removeUpstream","filter","dispatcher","length","allClientsBusy","counter","maxWeightIndex","findIndex","module","exports"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/undici/lib/balanced-pool.js"],"sourcesContent":["'use strict'\n\nconst {\n  BalancedPoolMissingUpstreamError,\n  InvalidArgumentError\n} = require('./core/errors')\nconst {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kRemoveClient,\n  kGetDispatcher\n} = require('./pool-base')\nconst Pool = require('./pool')\nconst { kUrl, kInterceptors } = require('./core/symbols')\nconst { parseOrigin } = require('./core/util')\nconst kFactory = Symbol('factory')\n\nconst kOptions = Symbol('options')\nconst kGreatestCommonDivisor = Symbol('kGreatestCommonDivisor')\nconst kCurrentWeight = Symbol('kCurrentWeight')\nconst kIndex = Symbol('kIndex')\nconst kWeight = Symbol('kWeight')\nconst kMaxWeightPerServer = Symbol('kMaxWeightPerServer')\nconst kErrorPenalty = Symbol('kErrorPenalty')\n\nfunction getGreatestCommonDivisor (a, b) {\n  if (b === 0) return a\n  return getGreatestCommonDivisor(b, a % b)\n}\n\nfunction defaultFactory (origin, opts) {\n  return new Pool(origin, opts)\n}\n\nclass BalancedPool extends PoolBase {\n  constructor (upstreams = [], { factory = defaultFactory, ...opts } = {}) {\n    super()\n\n    this[kOptions] = opts\n    this[kIndex] = -1\n    this[kCurrentWeight] = 0\n\n    this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100\n    this[kErrorPenalty] = this[kOptions].errorPenalty || 15\n\n    if (!Array.isArray(upstreams)) {\n      upstreams = [upstreams]\n    }\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool)\n      ? opts.interceptors.BalancedPool\n      : []\n    this[kFactory] = factory\n\n    for (const upstream of upstreams) {\n      this.addUpstream(upstream)\n    }\n    this._updateBalancedPoolStats()\n  }\n\n  addUpstream (upstream) {\n    const upstreamOrigin = parseOrigin(upstream).origin\n\n    if (this[kClients].find((pool) => (\n      pool[kUrl].origin === upstreamOrigin &&\n      pool.closed !== true &&\n      pool.destroyed !== true\n    ))) {\n      return this\n    }\n    const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]))\n\n    this[kAddClient](pool)\n    pool.on('connect', () => {\n      pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty])\n    })\n\n    pool.on('connectionError', () => {\n      pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty])\n      this._updateBalancedPoolStats()\n    })\n\n    pool.on('disconnect', (...args) => {\n      const err = args[2]\n      if (err && err.code === 'UND_ERR_SOCKET') {\n        // decrease the weight of the pool.\n        pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty])\n        this._updateBalancedPoolStats()\n      }\n    })\n\n    for (const client of this[kClients]) {\n      client[kWeight] = this[kMaxWeightPerServer]\n    }\n\n    this._updateBalancedPoolStats()\n\n    return this\n  }\n\n  _updateBalancedPoolStats () {\n    this[kGreatestCommonDivisor] = this[kClients].map(p => p[kWeight]).reduce(getGreatestCommonDivisor, 0)\n  }\n\n  removeUpstream (upstream) {\n    const upstreamOrigin = parseOrigin(upstream).origin\n\n    const pool = this[kClients].find((pool) => (\n      pool[kUrl].origin === upstreamOrigin &&\n      pool.closed !== true &&\n      pool.destroyed !== true\n    ))\n\n    if (pool) {\n      this[kRemoveClient](pool)\n    }\n\n    return this\n  }\n\n  get upstreams () {\n    return this[kClients]\n      .filter(dispatcher => dispatcher.closed !== true && dispatcher.destroyed !== true)\n      .map((p) => p[kUrl].origin)\n  }\n\n  [kGetDispatcher] () {\n    // We validate that pools is greater than 0,\n    // otherwise we would have to wait until an upstream\n    // is added, which might never happen.\n    if (this[kClients].length === 0) {\n      throw new BalancedPoolMissingUpstreamError()\n    }\n\n    const dispatcher = this[kClients].find(dispatcher => (\n      !dispatcher[kNeedDrain] &&\n      dispatcher.closed !== true &&\n      dispatcher.destroyed !== true\n    ))\n\n    if (!dispatcher) {\n      return\n    }\n\n    const allClientsBusy = this[kClients].map(pool => pool[kNeedDrain]).reduce((a, b) => a && b, true)\n\n    if (allClientsBusy) {\n      return\n    }\n\n    let counter = 0\n\n    let maxWeightIndex = this[kClients].findIndex(pool => !pool[kNeedDrain])\n\n    while (counter++ < this[kClients].length) {\n      this[kIndex] = (this[kIndex] + 1) % this[kClients].length\n      const pool = this[kClients][this[kIndex]]\n\n      // find pool index with the largest weight\n      if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {\n        maxWeightIndex = this[kIndex]\n      }\n\n      // decrease the current weight every `this[kClients].length`.\n      if (this[kIndex] === 0) {\n        // Set the current weight to the next lower weight.\n        this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor]\n\n        if (this[kCurrentWeight] <= 0) {\n          this[kCurrentWeight] = this[kMaxWeightPerServer]\n        }\n      }\n      if (pool[kWeight] >= this[kCurrentWeight] && (!pool[kNeedDrain])) {\n        return pool\n      }\n    }\n\n    this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight]\n    this[kIndex] = maxWeightIndex\n    return this[kClients][maxWeightIndex]\n  }\n}\n\nmodule.exports = BalancedPool\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}