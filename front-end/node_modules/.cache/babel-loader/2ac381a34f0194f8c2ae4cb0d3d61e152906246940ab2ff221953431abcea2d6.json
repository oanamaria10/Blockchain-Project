{"ast":null,"code":"'use strict';\n\nconst Busboy = require('@fastify/busboy');\nconst util = require('../core/util');\nconst {\n  ReadableStreamFrom,\n  isBlobLike,\n  isReadableStreamLike,\n  readableStreamClose,\n  createDeferredPromise,\n  fullyReadBody\n} = require('./util');\nconst {\n  FormData\n} = require('./formdata');\nconst {\n  kState\n} = require('./symbols');\nconst {\n  webidl\n} = require('./webidl');\nconst {\n  DOMException,\n  structuredClone\n} = require('./constants');\nconst {\n  Blob,\n  File: NativeFile\n} = require('buffer');\nconst {\n  kBodyUsed\n} = require('../core/symbols');\nconst assert = require('assert');\nconst {\n  isErrored\n} = require('../core/util');\nconst {\n  isUint8Array,\n  isArrayBuffer\n} = require('util/types');\nconst {\n  File: UndiciFile\n} = require('./file');\nconst {\n  parseMIMEType,\n  serializeAMimeType\n} = require('./dataURL');\nlet ReadableStream = globalThis.ReadableStream;\n\n/** @type {globalThis['File']} */\nconst File = NativeFile ?? UndiciFile;\nconst textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\n\n// https://fetch.spec.whatwg.org/#concept-bodyinit-extract\nfunction extractBody(object, keepalive = false) {\n  if (!ReadableStream) {\n    ReadableStream = require('stream/web').ReadableStream;\n  }\n\n  // 1. Let stream be null.\n  let stream = null;\n\n  // 2. If object is a ReadableStream object, then set stream to object.\n  if (object instanceof ReadableStream) {\n    stream = object;\n  } else if (isBlobLike(object)) {\n    // 3. Otherwise, if object is a Blob object, set stream to the\n    //    result of running object’s get stream.\n    stream = object.stream();\n  } else {\n    // 4. Otherwise, set stream to a new ReadableStream object, and set\n    //    up stream.\n    stream = new ReadableStream({\n      async pull(controller) {\n        controller.enqueue(typeof source === 'string' ? textEncoder.encode(source) : source);\n        queueMicrotask(() => readableStreamClose(controller));\n      },\n      start() {},\n      type: undefined\n    });\n  }\n\n  // 5. Assert: stream is a ReadableStream object.\n  assert(isReadableStreamLike(stream));\n\n  // 6. Let action be null.\n  let action = null;\n\n  // 7. Let source be null.\n  let source = null;\n\n  // 8. Let length be null.\n  let length = null;\n\n  // 9. Let type be null.\n  let type = null;\n\n  // 10. Switch on object:\n  if (typeof object === 'string') {\n    // Set source to the UTF-8 encoding of object.\n    // Note: setting source to a Uint8Array here breaks some mocking assumptions.\n    source = object;\n\n    // Set type to `text/plain;charset=UTF-8`.\n    type = 'text/plain;charset=UTF-8';\n  } else if (object instanceof URLSearchParams) {\n    // URLSearchParams\n\n    // spec says to run application/x-www-form-urlencoded on body.list\n    // this is implemented in Node.js as apart of an URLSearchParams instance toString method\n    // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490\n    // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100\n\n    // Set source to the result of running the application/x-www-form-urlencoded serializer with object’s list.\n    source = object.toString();\n\n    // Set type to `application/x-www-form-urlencoded;charset=UTF-8`.\n    type = 'application/x-www-form-urlencoded;charset=UTF-8';\n  } else if (isArrayBuffer(object)) {\n    // BufferSource/ArrayBuffer\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.slice());\n  } else if (ArrayBuffer.isView(object)) {\n    // BufferSource/ArrayBufferView\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));\n  } else if (util.isFormDataLike(object)) {\n    const boundary = `----formdata-undici-0${`${Math.floor(Math.random() * 1e11)}`.padStart(11, '0')}`;\n    const prefix = `--${boundary}\\r\\nContent-Disposition: form-data`;\n\n    /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n    const escape = str => str.replace(/\\n/g, '%0A').replace(/\\r/g, '%0D').replace(/\"/g, '%22');\n    const normalizeLinefeeds = value => value.replace(/\\r?\\n|\\r/g, '\\r\\n');\n\n    // Set action to this step: run the multipart/form-data\n    // encoding algorithm, with object’s entry list and UTF-8.\n    // - This ensures that the body is immutable and can't be changed afterwords\n    // - That the content-length is calculated in advance.\n    // - And that all parts are pre-encoded and ready to be sent.\n\n    const blobParts = [];\n    const rn = new Uint8Array([13, 10]); // '\\r\\n'\n    length = 0;\n    let hasUnknownSizeValue = false;\n    for (const [name, value] of object) {\n      if (typeof value === 'string') {\n        const chunk = textEncoder.encode(prefix + `; name=\"${escape(normalizeLinefeeds(name))}\"` + `\\r\\n\\r\\n${normalizeLinefeeds(value)}\\r\\n`);\n        blobParts.push(chunk);\n        length += chunk.byteLength;\n      } else {\n        const chunk = textEncoder.encode(`${prefix}; name=\"${escape(normalizeLinefeeds(name))}\"` + (value.name ? `; filename=\"${escape(value.name)}\"` : '') + '\\r\\n' + `Content-Type: ${value.type || 'application/octet-stream'}\\r\\n\\r\\n`);\n        blobParts.push(chunk, value, rn);\n        if (typeof value.size === 'number') {\n          length += chunk.byteLength + value.size + rn.byteLength;\n        } else {\n          hasUnknownSizeValue = true;\n        }\n      }\n    }\n    const chunk = textEncoder.encode(`--${boundary}--`);\n    blobParts.push(chunk);\n    length += chunk.byteLength;\n    if (hasUnknownSizeValue) {\n      length = null;\n    }\n\n    // Set source to object.\n    source = object;\n    action = async function* () {\n      for (const part of blobParts) {\n        if (part.stream) {\n          yield* part.stream();\n        } else {\n          yield part;\n        }\n      }\n    };\n\n    // Set type to `multipart/form-data; boundary=`,\n    // followed by the multipart/form-data boundary string generated\n    // by the multipart/form-data encoding algorithm.\n    type = 'multipart/form-data; boundary=' + boundary;\n  } else if (isBlobLike(object)) {\n    // Blob\n\n    // Set source to object.\n    source = object;\n\n    // Set length to object’s size.\n    length = object.size;\n\n    // If object’s type attribute is not the empty byte sequence, set\n    // type to its value.\n    if (object.type) {\n      type = object.type;\n    }\n  } else if (typeof object[Symbol.asyncIterator] === 'function') {\n    // If keepalive is true, then throw a TypeError.\n    if (keepalive) {\n      throw new TypeError('keepalive');\n    }\n\n    // If object is disturbed or locked, then throw a TypeError.\n    if (util.isDisturbed(object) || object.locked) {\n      throw new TypeError('Response body object should not be disturbed or locked');\n    }\n    stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);\n  }\n\n  // 11. If source is a byte sequence, then set action to a\n  // step that returns source and length to source’s length.\n  if (typeof source === 'string' || util.isBuffer(source)) {\n    length = Buffer.byteLength(source);\n  }\n\n  // 12. If action is non-null, then run these steps in in parallel:\n  if (action != null) {\n    // Run action.\n    let iterator;\n    stream = new ReadableStream({\n      async start() {\n        iterator = action(object)[Symbol.asyncIterator]();\n      },\n      async pull(controller) {\n        const {\n          value,\n          done\n        } = await iterator.next();\n        if (done) {\n          // When running action is done, close stream.\n          queueMicrotask(() => {\n            controller.close();\n          });\n        } else {\n          // Whenever one or more bytes are available and stream is not errored,\n          // enqueue a Uint8Array wrapping an ArrayBuffer containing the available\n          // bytes into stream.\n          if (!isErrored(stream)) {\n            controller.enqueue(new Uint8Array(value));\n          }\n        }\n        return controller.desiredSize > 0;\n      },\n      async cancel(reason) {\n        await iterator.return();\n      },\n      type: undefined\n    });\n  }\n\n  // 13. Let body be a body whose stream is stream, source is source,\n  // and length is length.\n  const body = {\n    stream,\n    source,\n    length\n  };\n\n  // 14. Return (body, type).\n  return [body, type];\n}\n\n// https://fetch.spec.whatwg.org/#bodyinit-safely-extract\nfunction safelyExtractBody(object, keepalive = false) {\n  if (!ReadableStream) {\n    // istanbul ignore next\n    ReadableStream = require('stream/web').ReadableStream;\n  }\n\n  // To safely extract a body and a `Content-Type` value from\n  // a byte sequence or BodyInit object object, run these steps:\n\n  // 1. If object is a ReadableStream object, then:\n  if (object instanceof ReadableStream) {\n    // Assert: object is neither disturbed nor locked.\n    // istanbul ignore next\n    assert(!util.isDisturbed(object), 'The body has already been consumed.');\n    // istanbul ignore next\n    assert(!object.locked, 'The stream is locked.');\n  }\n\n  // 2. Return the results of extracting object.\n  return extractBody(object, keepalive);\n}\nfunction cloneBody(body) {\n  // To clone a body body, run these steps:\n\n  // https://fetch.spec.whatwg.org/#concept-body-clone\n\n  // 1. Let « out1, out2 » be the result of teeing body’s stream.\n  const [out1, out2] = body.stream.tee();\n  const out2Clone = structuredClone(out2, {\n    transfer: [out2]\n  });\n  // This, for whatever reasons, unrefs out2Clone which allows\n  // the process to exit by itself.\n  const [, finalClone] = out2Clone.tee();\n\n  // 2. Set body’s stream to out1.\n  body.stream = out1;\n\n  // 3. Return a body whose stream is out2 and other members are copied from body.\n  return {\n    stream: finalClone,\n    length: body.length,\n    source: body.source\n  };\n}\nasync function* consumeBody(body) {\n  if (body) {\n    if (isUint8Array(body)) {\n      yield body;\n    } else {\n      const stream = body.stream;\n      if (util.isDisturbed(stream)) {\n        throw new TypeError('The body has already been consumed.');\n      }\n      if (stream.locked) {\n        throw new TypeError('The stream is locked.');\n      }\n\n      // Compat.\n      stream[kBodyUsed] = true;\n      yield* stream;\n    }\n  }\n}\nfunction throwIfAborted(state) {\n  if (state.aborted) {\n    throw new DOMException('The operation was aborted.', 'AbortError');\n  }\n}\nfunction bodyMixinMethods(instance) {\n  const methods = {\n    blob() {\n      // The blob() method steps are to return the result of\n      // running consume body with this and the following step\n      // given a byte sequence bytes: return a Blob whose\n      // contents are bytes and whose type attribute is this’s\n      // MIME type.\n      return specConsumeBody(this, bytes => {\n        let mimeType = bodyMimeType(this);\n        if (mimeType === 'failure') {\n          mimeType = '';\n        } else if (mimeType) {\n          mimeType = serializeAMimeType(mimeType);\n        }\n\n        // Return a Blob whose contents are bytes and type attribute\n        // is mimeType.\n        return new Blob([bytes], {\n          type: mimeType\n        });\n      }, instance);\n    },\n    arrayBuffer() {\n      // The arrayBuffer() method steps are to return the result\n      // of running consume body with this and the following step\n      // given a byte sequence bytes: return a new ArrayBuffer\n      // whose contents are bytes.\n      return specConsumeBody(this, bytes => {\n        return new Uint8Array(bytes).buffer;\n      }, instance);\n    },\n    text() {\n      // The text() method steps are to return the result of running\n      // consume body with this and UTF-8 decode.\n      return specConsumeBody(this, utf8DecodeBytes, instance);\n    },\n    json() {\n      // The json() method steps are to return the result of running\n      // consume body with this and parse JSON from bytes.\n      return specConsumeBody(this, parseJSONFromBytes, instance);\n    },\n    async formData() {\n      webidl.brandCheck(this, instance);\n      throwIfAborted(this[kState]);\n      const contentType = this.headers.get('Content-Type');\n\n      // If mimeType’s essence is \"multipart/form-data\", then:\n      if (/multipart\\/form-data/.test(contentType)) {\n        const headers = {};\n        for (const [key, value] of this.headers) headers[key.toLowerCase()] = value;\n        const responseFormData = new FormData();\n        let busboy;\n        try {\n          busboy = new Busboy({\n            headers,\n            preservePath: true\n          });\n        } catch (err) {\n          throw new DOMException(`${err}`, 'AbortError');\n        }\n        busboy.on('field', (name, value) => {\n          responseFormData.append(name, value);\n        });\n        busboy.on('file', (name, value, filename, encoding, mimeType) => {\n          const chunks = [];\n          if (encoding === 'base64' || encoding.toLowerCase() === 'base64') {\n            let base64chunk = '';\n            value.on('data', chunk => {\n              base64chunk += chunk.toString().replace(/[\\r\\n]/gm, '');\n              const end = base64chunk.length - base64chunk.length % 4;\n              chunks.push(Buffer.from(base64chunk.slice(0, end), 'base64'));\n              base64chunk = base64chunk.slice(end);\n            });\n            value.on('end', () => {\n              chunks.push(Buffer.from(base64chunk, 'base64'));\n              responseFormData.append(name, new File(chunks, filename, {\n                type: mimeType\n              }));\n            });\n          } else {\n            value.on('data', chunk => {\n              chunks.push(chunk);\n            });\n            value.on('end', () => {\n              responseFormData.append(name, new File(chunks, filename, {\n                type: mimeType\n              }));\n            });\n          }\n        });\n        const busboyResolve = new Promise((resolve, reject) => {\n          busboy.on('finish', resolve);\n          busboy.on('error', err => reject(new TypeError(err)));\n        });\n        if (this.body !== null) for await (const chunk of consumeBody(this[kState].body)) busboy.write(chunk);\n        busboy.end();\n        await busboyResolve;\n        return responseFormData;\n      } else if (/application\\/x-www-form-urlencoded/.test(contentType)) {\n        // Otherwise, if mimeType’s essence is \"application/x-www-form-urlencoded\", then:\n\n        // 1. Let entries be the result of parsing bytes.\n        let entries;\n        try {\n          let text = '';\n          // application/x-www-form-urlencoded parser will keep the BOM.\n          // https://url.spec.whatwg.org/#concept-urlencoded-parser\n          // Note that streaming decoder is stateful and cannot be reused\n          const streamingDecoder = new TextDecoder('utf-8', {\n            ignoreBOM: true\n          });\n          for await (const chunk of consumeBody(this[kState].body)) {\n            if (!isUint8Array(chunk)) {\n              throw new TypeError('Expected Uint8Array chunk');\n            }\n            text += streamingDecoder.decode(chunk, {\n              stream: true\n            });\n          }\n          text += streamingDecoder.decode();\n          entries = new URLSearchParams(text);\n        } catch (err) {\n          // istanbul ignore next: Unclear when new URLSearchParams can fail on a string.\n          // 2. If entries is failure, then throw a TypeError.\n          throw Object.assign(new TypeError(), {\n            cause: err\n          });\n        }\n\n        // 3. Return a new FormData object whose entries are entries.\n        const formData = new FormData();\n        for (const [name, value] of entries) {\n          formData.append(name, value);\n        }\n        return formData;\n      } else {\n        // Wait a tick before checking if the request has been aborted.\n        // Otherwise, a TypeError can be thrown when an AbortError should.\n        await Promise.resolve();\n        throwIfAborted(this[kState]);\n\n        // Otherwise, throw a TypeError.\n        throw webidl.errors.exception({\n          header: `${instance.name}.formData`,\n          message: 'Could not parse content as FormData.'\n        });\n      }\n    }\n  };\n  return methods;\n}\nfunction mixinBody(prototype) {\n  Object.assign(prototype.prototype, bodyMixinMethods(prototype));\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-consume-body\n * @param {Response|Request} object\n * @param {(value: unknown) => unknown} convertBytesToJSValue\n * @param {Response|Request} instance\n */\nasync function specConsumeBody(object, convertBytesToJSValue, instance) {\n  webidl.brandCheck(object, instance);\n  throwIfAborted(object[kState]);\n\n  // 1. If object is unusable, then return a promise rejected\n  //    with a TypeError.\n  if (bodyUnusable(object[kState].body)) {\n    throw new TypeError('Body is unusable');\n  }\n\n  // 2. Let promise be a new promise.\n  const promise = createDeferredPromise();\n\n  // 3. Let errorSteps given error be to reject promise with error.\n  const errorSteps = error => promise.reject(error);\n\n  // 4. Let successSteps given a byte sequence data be to resolve\n  //    promise with the result of running convertBytesToJSValue\n  //    with data. If that threw an exception, then run errorSteps\n  //    with that exception.\n  const successSteps = data => {\n    try {\n      promise.resolve(convertBytesToJSValue(data));\n    } catch (e) {\n      errorSteps(e);\n    }\n  };\n\n  // 5. If object’s body is null, then run successSteps with an\n  //    empty byte sequence.\n  if (object[kState].body == null) {\n    successSteps(new Uint8Array());\n    return promise.promise;\n  }\n\n  // 6. Otherwise, fully read object’s body given successSteps,\n  //    errorSteps, and object’s relevant global object.\n  await fullyReadBody(object[kState].body, successSteps, errorSteps);\n\n  // 7. Return promise.\n  return promise.promise;\n}\n\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction bodyUnusable(body) {\n  // An object including the Body interface mixin is\n  // said to be unusable if its body is non-null and\n  // its body’s stream is disturbed or locked.\n  return body != null && (body.stream.locked || util.isDisturbed(body.stream));\n}\n\n/**\n * @see https://encoding.spec.whatwg.org/#utf-8-decode\n * @param {Buffer} buffer\n */\nfunction utf8DecodeBytes(buffer) {\n  if (buffer.length === 0) {\n    return '';\n  }\n\n  // 1. Let buffer be the result of peeking three bytes from\n  //    ioQueue, converted to a byte sequence.\n\n  // 2. If buffer is 0xEF 0xBB 0xBF, then read three\n  //    bytes from ioQueue. (Do nothing with those bytes.)\n  if (buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {\n    buffer = buffer.subarray(3);\n  }\n\n  // 3. Process a queue with an instance of UTF-8’s\n  //    decoder, ioQueue, output, and \"replacement\".\n  const output = textDecoder.decode(buffer);\n\n  // 4. Return output.\n  return output;\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#parse-json-bytes-to-a-javascript-value\n * @param {Uint8Array} bytes\n */\nfunction parseJSONFromBytes(bytes) {\n  return JSON.parse(utf8DecodeBytes(bytes));\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-mime-type\n * @param {import('./response').Response|import('./request').Request} object\n */\nfunction bodyMimeType(object) {\n  const {\n    headersList\n  } = object[kState];\n  const contentType = headersList.get('content-type');\n  if (contentType === null) {\n    return 'failure';\n  }\n  return parseMIMEType(contentType);\n}\nmodule.exports = {\n  extractBody,\n  safelyExtractBody,\n  cloneBody,\n  mixinBody\n};","map":{"version":3,"names":["Busboy","require","util","ReadableStreamFrom","isBlobLike","isReadableStreamLike","readableStreamClose","createDeferredPromise","fullyReadBody","FormData","kState","webidl","DOMException","structuredClone","Blob","File","NativeFile","kBodyUsed","assert","isErrored","isUint8Array","isArrayBuffer","UndiciFile","parseMIMEType","serializeAMimeType","ReadableStream","globalThis","textEncoder","TextEncoder","textDecoder","TextDecoder","extractBody","object","keepalive","stream","pull","controller","enqueue","source","encode","queueMicrotask","start","type","undefined","action","length","URLSearchParams","toString","Uint8Array","slice","ArrayBuffer","isView","buffer","byteOffset","byteLength","isFormDataLike","boundary","Math","floor","random","padStart","prefix","escape","str","replace","normalizeLinefeeds","value","blobParts","rn","hasUnknownSizeValue","name","chunk","push","size","part","Symbol","asyncIterator","TypeError","isDisturbed","locked","isBuffer","Buffer","iterator","done","next","close","desiredSize","cancel","reason","return","body","safelyExtractBody","cloneBody","out1","out2","tee","out2Clone","transfer","finalClone","consumeBody","throwIfAborted","state","aborted","bodyMixinMethods","instance","methods","blob","specConsumeBody","bytes","mimeType","bodyMimeType","arrayBuffer","text","utf8DecodeBytes","json","parseJSONFromBytes","formData","brandCheck","contentType","headers","get","test","key","toLowerCase","responseFormData","busboy","preservePath","err","on","append","filename","encoding","chunks","base64chunk","end","from","busboyResolve","Promise","resolve","reject","write","entries","streamingDecoder","ignoreBOM","decode","Object","assign","cause","errors","exception","header","message","mixinBody","prototype","convertBytesToJSValue","bodyUnusable","promise","errorSteps","error","successSteps","data","e","subarray","output","JSON","parse","headersList","module","exports"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/undici/lib/fetch/body.js"],"sourcesContent":["'use strict'\n\nconst Busboy = require('@fastify/busboy')\nconst util = require('../core/util')\nconst {\n  ReadableStreamFrom,\n  isBlobLike,\n  isReadableStreamLike,\n  readableStreamClose,\n  createDeferredPromise,\n  fullyReadBody\n} = require('./util')\nconst { FormData } = require('./formdata')\nconst { kState } = require('./symbols')\nconst { webidl } = require('./webidl')\nconst { DOMException, structuredClone } = require('./constants')\nconst { Blob, File: NativeFile } = require('buffer')\nconst { kBodyUsed } = require('../core/symbols')\nconst assert = require('assert')\nconst { isErrored } = require('../core/util')\nconst { isUint8Array, isArrayBuffer } = require('util/types')\nconst { File: UndiciFile } = require('./file')\nconst { parseMIMEType, serializeAMimeType } = require('./dataURL')\n\nlet ReadableStream = globalThis.ReadableStream\n\n/** @type {globalThis['File']} */\nconst File = NativeFile ?? UndiciFile\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\n// https://fetch.spec.whatwg.org/#concept-bodyinit-extract\nfunction extractBody (object, keepalive = false) {\n  if (!ReadableStream) {\n    ReadableStream = require('stream/web').ReadableStream\n  }\n\n  // 1. Let stream be null.\n  let stream = null\n\n  // 2. If object is a ReadableStream object, then set stream to object.\n  if (object instanceof ReadableStream) {\n    stream = object\n  } else if (isBlobLike(object)) {\n    // 3. Otherwise, if object is a Blob object, set stream to the\n    //    result of running object’s get stream.\n    stream = object.stream()\n  } else {\n    // 4. Otherwise, set stream to a new ReadableStream object, and set\n    //    up stream.\n    stream = new ReadableStream({\n      async pull (controller) {\n        controller.enqueue(\n          typeof source === 'string' ? textEncoder.encode(source) : source\n        )\n        queueMicrotask(() => readableStreamClose(controller))\n      },\n      start () {},\n      type: undefined\n    })\n  }\n\n  // 5. Assert: stream is a ReadableStream object.\n  assert(isReadableStreamLike(stream))\n\n  // 6. Let action be null.\n  let action = null\n\n  // 7. Let source be null.\n  let source = null\n\n  // 8. Let length be null.\n  let length = null\n\n  // 9. Let type be null.\n  let type = null\n\n  // 10. Switch on object:\n  if (typeof object === 'string') {\n    // Set source to the UTF-8 encoding of object.\n    // Note: setting source to a Uint8Array here breaks some mocking assumptions.\n    source = object\n\n    // Set type to `text/plain;charset=UTF-8`.\n    type = 'text/plain;charset=UTF-8'\n  } else if (object instanceof URLSearchParams) {\n    // URLSearchParams\n\n    // spec says to run application/x-www-form-urlencoded on body.list\n    // this is implemented in Node.js as apart of an URLSearchParams instance toString method\n    // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490\n    // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100\n\n    // Set source to the result of running the application/x-www-form-urlencoded serializer with object’s list.\n    source = object.toString()\n\n    // Set type to `application/x-www-form-urlencoded;charset=UTF-8`.\n    type = 'application/x-www-form-urlencoded;charset=UTF-8'\n  } else if (isArrayBuffer(object)) {\n    // BufferSource/ArrayBuffer\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.slice())\n  } else if (ArrayBuffer.isView(object)) {\n    // BufferSource/ArrayBufferView\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength))\n  } else if (util.isFormDataLike(object)) {\n    const boundary = `----formdata-undici-0${`${Math.floor(Math.random() * 1e11)}`.padStart(11, '0')}`\n    const prefix = `--${boundary}\\r\\nContent-Disposition: form-data`\n\n    /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n    const escape = (str) =>\n      str.replace(/\\n/g, '%0A').replace(/\\r/g, '%0D').replace(/\"/g, '%22')\n    const normalizeLinefeeds = (value) => value.replace(/\\r?\\n|\\r/g, '\\r\\n')\n\n    // Set action to this step: run the multipart/form-data\n    // encoding algorithm, with object’s entry list and UTF-8.\n    // - This ensures that the body is immutable and can't be changed afterwords\n    // - That the content-length is calculated in advance.\n    // - And that all parts are pre-encoded and ready to be sent.\n\n    const blobParts = []\n    const rn = new Uint8Array([13, 10]) // '\\r\\n'\n    length = 0\n    let hasUnknownSizeValue = false\n\n    for (const [name, value] of object) {\n      if (typeof value === 'string') {\n        const chunk = textEncoder.encode(prefix +\n          `; name=\"${escape(normalizeLinefeeds(name))}\"` +\n          `\\r\\n\\r\\n${normalizeLinefeeds(value)}\\r\\n`)\n        blobParts.push(chunk)\n        length += chunk.byteLength\n      } else {\n        const chunk = textEncoder.encode(`${prefix}; name=\"${escape(normalizeLinefeeds(name))}\"` +\n          (value.name ? `; filename=\"${escape(value.name)}\"` : '') + '\\r\\n' +\n          `Content-Type: ${\n            value.type || 'application/octet-stream'\n          }\\r\\n\\r\\n`)\n        blobParts.push(chunk, value, rn)\n        if (typeof value.size === 'number') {\n          length += chunk.byteLength + value.size + rn.byteLength\n        } else {\n          hasUnknownSizeValue = true\n        }\n      }\n    }\n\n    const chunk = textEncoder.encode(`--${boundary}--`)\n    blobParts.push(chunk)\n    length += chunk.byteLength\n    if (hasUnknownSizeValue) {\n      length = null\n    }\n\n    // Set source to object.\n    source = object\n\n    action = async function * () {\n      for (const part of blobParts) {\n        if (part.stream) {\n          yield * part.stream()\n        } else {\n          yield part\n        }\n      }\n    }\n\n    // Set type to `multipart/form-data; boundary=`,\n    // followed by the multipart/form-data boundary string generated\n    // by the multipart/form-data encoding algorithm.\n    type = 'multipart/form-data; boundary=' + boundary\n  } else if (isBlobLike(object)) {\n    // Blob\n\n    // Set source to object.\n    source = object\n\n    // Set length to object’s size.\n    length = object.size\n\n    // If object’s type attribute is not the empty byte sequence, set\n    // type to its value.\n    if (object.type) {\n      type = object.type\n    }\n  } else if (typeof object[Symbol.asyncIterator] === 'function') {\n    // If keepalive is true, then throw a TypeError.\n    if (keepalive) {\n      throw new TypeError('keepalive')\n    }\n\n    // If object is disturbed or locked, then throw a TypeError.\n    if (util.isDisturbed(object) || object.locked) {\n      throw new TypeError(\n        'Response body object should not be disturbed or locked'\n      )\n    }\n\n    stream =\n      object instanceof ReadableStream ? object : ReadableStreamFrom(object)\n  }\n\n  // 11. If source is a byte sequence, then set action to a\n  // step that returns source and length to source’s length.\n  if (typeof source === 'string' || util.isBuffer(source)) {\n    length = Buffer.byteLength(source)\n  }\n\n  // 12. If action is non-null, then run these steps in in parallel:\n  if (action != null) {\n    // Run action.\n    let iterator\n    stream = new ReadableStream({\n      async start () {\n        iterator = action(object)[Symbol.asyncIterator]()\n      },\n      async pull (controller) {\n        const { value, done } = await iterator.next()\n        if (done) {\n          // When running action is done, close stream.\n          queueMicrotask(() => {\n            controller.close()\n          })\n        } else {\n          // Whenever one or more bytes are available and stream is not errored,\n          // enqueue a Uint8Array wrapping an ArrayBuffer containing the available\n          // bytes into stream.\n          if (!isErrored(stream)) {\n            controller.enqueue(new Uint8Array(value))\n          }\n        }\n        return controller.desiredSize > 0\n      },\n      async cancel (reason) {\n        await iterator.return()\n      },\n      type: undefined\n    })\n  }\n\n  // 13. Let body be a body whose stream is stream, source is source,\n  // and length is length.\n  const body = { stream, source, length }\n\n  // 14. Return (body, type).\n  return [body, type]\n}\n\n// https://fetch.spec.whatwg.org/#bodyinit-safely-extract\nfunction safelyExtractBody (object, keepalive = false) {\n  if (!ReadableStream) {\n    // istanbul ignore next\n    ReadableStream = require('stream/web').ReadableStream\n  }\n\n  // To safely extract a body and a `Content-Type` value from\n  // a byte sequence or BodyInit object object, run these steps:\n\n  // 1. If object is a ReadableStream object, then:\n  if (object instanceof ReadableStream) {\n    // Assert: object is neither disturbed nor locked.\n    // istanbul ignore next\n    assert(!util.isDisturbed(object), 'The body has already been consumed.')\n    // istanbul ignore next\n    assert(!object.locked, 'The stream is locked.')\n  }\n\n  // 2. Return the results of extracting object.\n  return extractBody(object, keepalive)\n}\n\nfunction cloneBody (body) {\n  // To clone a body body, run these steps:\n\n  // https://fetch.spec.whatwg.org/#concept-body-clone\n\n  // 1. Let « out1, out2 » be the result of teeing body’s stream.\n  const [out1, out2] = body.stream.tee()\n  const out2Clone = structuredClone(out2, { transfer: [out2] })\n  // This, for whatever reasons, unrefs out2Clone which allows\n  // the process to exit by itself.\n  const [, finalClone] = out2Clone.tee()\n\n  // 2. Set body’s stream to out1.\n  body.stream = out1\n\n  // 3. Return a body whose stream is out2 and other members are copied from body.\n  return {\n    stream: finalClone,\n    length: body.length,\n    source: body.source\n  }\n}\n\nasync function * consumeBody (body) {\n  if (body) {\n    if (isUint8Array(body)) {\n      yield body\n    } else {\n      const stream = body.stream\n\n      if (util.isDisturbed(stream)) {\n        throw new TypeError('The body has already been consumed.')\n      }\n\n      if (stream.locked) {\n        throw new TypeError('The stream is locked.')\n      }\n\n      // Compat.\n      stream[kBodyUsed] = true\n\n      yield * stream\n    }\n  }\n}\n\nfunction throwIfAborted (state) {\n  if (state.aborted) {\n    throw new DOMException('The operation was aborted.', 'AbortError')\n  }\n}\n\nfunction bodyMixinMethods (instance) {\n  const methods = {\n    blob () {\n      // The blob() method steps are to return the result of\n      // running consume body with this and the following step\n      // given a byte sequence bytes: return a Blob whose\n      // contents are bytes and whose type attribute is this’s\n      // MIME type.\n      return specConsumeBody(this, (bytes) => {\n        let mimeType = bodyMimeType(this)\n\n        if (mimeType === 'failure') {\n          mimeType = ''\n        } else if (mimeType) {\n          mimeType = serializeAMimeType(mimeType)\n        }\n\n        // Return a Blob whose contents are bytes and type attribute\n        // is mimeType.\n        return new Blob([bytes], { type: mimeType })\n      }, instance)\n    },\n\n    arrayBuffer () {\n      // The arrayBuffer() method steps are to return the result\n      // of running consume body with this and the following step\n      // given a byte sequence bytes: return a new ArrayBuffer\n      // whose contents are bytes.\n      return specConsumeBody(this, (bytes) => {\n        return new Uint8Array(bytes).buffer\n      }, instance)\n    },\n\n    text () {\n      // The text() method steps are to return the result of running\n      // consume body with this and UTF-8 decode.\n      return specConsumeBody(this, utf8DecodeBytes, instance)\n    },\n\n    json () {\n      // The json() method steps are to return the result of running\n      // consume body with this and parse JSON from bytes.\n      return specConsumeBody(this, parseJSONFromBytes, instance)\n    },\n\n    async formData () {\n      webidl.brandCheck(this, instance)\n\n      throwIfAborted(this[kState])\n\n      const contentType = this.headers.get('Content-Type')\n\n      // If mimeType’s essence is \"multipart/form-data\", then:\n      if (/multipart\\/form-data/.test(contentType)) {\n        const headers = {}\n        for (const [key, value] of this.headers) headers[key.toLowerCase()] = value\n\n        const responseFormData = new FormData()\n\n        let busboy\n\n        try {\n          busboy = new Busboy({\n            headers,\n            preservePath: true\n          })\n        } catch (err) {\n          throw new DOMException(`${err}`, 'AbortError')\n        }\n\n        busboy.on('field', (name, value) => {\n          responseFormData.append(name, value)\n        })\n        busboy.on('file', (name, value, filename, encoding, mimeType) => {\n          const chunks = []\n\n          if (encoding === 'base64' || encoding.toLowerCase() === 'base64') {\n            let base64chunk = ''\n\n            value.on('data', (chunk) => {\n              base64chunk += chunk.toString().replace(/[\\r\\n]/gm, '')\n\n              const end = base64chunk.length - base64chunk.length % 4\n              chunks.push(Buffer.from(base64chunk.slice(0, end), 'base64'))\n\n              base64chunk = base64chunk.slice(end)\n            })\n            value.on('end', () => {\n              chunks.push(Buffer.from(base64chunk, 'base64'))\n              responseFormData.append(name, new File(chunks, filename, { type: mimeType }))\n            })\n          } else {\n            value.on('data', (chunk) => {\n              chunks.push(chunk)\n            })\n            value.on('end', () => {\n              responseFormData.append(name, new File(chunks, filename, { type: mimeType }))\n            })\n          }\n        })\n\n        const busboyResolve = new Promise((resolve, reject) => {\n          busboy.on('finish', resolve)\n          busboy.on('error', (err) => reject(new TypeError(err)))\n        })\n\n        if (this.body !== null) for await (const chunk of consumeBody(this[kState].body)) busboy.write(chunk)\n        busboy.end()\n        await busboyResolve\n\n        return responseFormData\n      } else if (/application\\/x-www-form-urlencoded/.test(contentType)) {\n        // Otherwise, if mimeType’s essence is \"application/x-www-form-urlencoded\", then:\n\n        // 1. Let entries be the result of parsing bytes.\n        let entries\n        try {\n          let text = ''\n          // application/x-www-form-urlencoded parser will keep the BOM.\n          // https://url.spec.whatwg.org/#concept-urlencoded-parser\n          // Note that streaming decoder is stateful and cannot be reused\n          const streamingDecoder = new TextDecoder('utf-8', { ignoreBOM: true })\n\n          for await (const chunk of consumeBody(this[kState].body)) {\n            if (!isUint8Array(chunk)) {\n              throw new TypeError('Expected Uint8Array chunk')\n            }\n            text += streamingDecoder.decode(chunk, { stream: true })\n          }\n          text += streamingDecoder.decode()\n          entries = new URLSearchParams(text)\n        } catch (err) {\n          // istanbul ignore next: Unclear when new URLSearchParams can fail on a string.\n          // 2. If entries is failure, then throw a TypeError.\n          throw Object.assign(new TypeError(), { cause: err })\n        }\n\n        // 3. Return a new FormData object whose entries are entries.\n        const formData = new FormData()\n        for (const [name, value] of entries) {\n          formData.append(name, value)\n        }\n        return formData\n      } else {\n        // Wait a tick before checking if the request has been aborted.\n        // Otherwise, a TypeError can be thrown when an AbortError should.\n        await Promise.resolve()\n\n        throwIfAborted(this[kState])\n\n        // Otherwise, throw a TypeError.\n        throw webidl.errors.exception({\n          header: `${instance.name}.formData`,\n          message: 'Could not parse content as FormData.'\n        })\n      }\n    }\n  }\n\n  return methods\n}\n\nfunction mixinBody (prototype) {\n  Object.assign(prototype.prototype, bodyMixinMethods(prototype))\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-consume-body\n * @param {Response|Request} object\n * @param {(value: unknown) => unknown} convertBytesToJSValue\n * @param {Response|Request} instance\n */\nasync function specConsumeBody (object, convertBytesToJSValue, instance) {\n  webidl.brandCheck(object, instance)\n\n  throwIfAborted(object[kState])\n\n  // 1. If object is unusable, then return a promise rejected\n  //    with a TypeError.\n  if (bodyUnusable(object[kState].body)) {\n    throw new TypeError('Body is unusable')\n  }\n\n  // 2. Let promise be a new promise.\n  const promise = createDeferredPromise()\n\n  // 3. Let errorSteps given error be to reject promise with error.\n  const errorSteps = (error) => promise.reject(error)\n\n  // 4. Let successSteps given a byte sequence data be to resolve\n  //    promise with the result of running convertBytesToJSValue\n  //    with data. If that threw an exception, then run errorSteps\n  //    with that exception.\n  const successSteps = (data) => {\n    try {\n      promise.resolve(convertBytesToJSValue(data))\n    } catch (e) {\n      errorSteps(e)\n    }\n  }\n\n  // 5. If object’s body is null, then run successSteps with an\n  //    empty byte sequence.\n  if (object[kState].body == null) {\n    successSteps(new Uint8Array())\n    return promise.promise\n  }\n\n  // 6. Otherwise, fully read object’s body given successSteps,\n  //    errorSteps, and object’s relevant global object.\n  await fullyReadBody(object[kState].body, successSteps, errorSteps)\n\n  // 7. Return promise.\n  return promise.promise\n}\n\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction bodyUnusable (body) {\n  // An object including the Body interface mixin is\n  // said to be unusable if its body is non-null and\n  // its body’s stream is disturbed or locked.\n  return body != null && (body.stream.locked || util.isDisturbed(body.stream))\n}\n\n/**\n * @see https://encoding.spec.whatwg.org/#utf-8-decode\n * @param {Buffer} buffer\n */\nfunction utf8DecodeBytes (buffer) {\n  if (buffer.length === 0) {\n    return ''\n  }\n\n  // 1. Let buffer be the result of peeking three bytes from\n  //    ioQueue, converted to a byte sequence.\n\n  // 2. If buffer is 0xEF 0xBB 0xBF, then read three\n  //    bytes from ioQueue. (Do nothing with those bytes.)\n  if (buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {\n    buffer = buffer.subarray(3)\n  }\n\n  // 3. Process a queue with an instance of UTF-8’s\n  //    decoder, ioQueue, output, and \"replacement\".\n  const output = textDecoder.decode(buffer)\n\n  // 4. Return output.\n  return output\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#parse-json-bytes-to-a-javascript-value\n * @param {Uint8Array} bytes\n */\nfunction parseJSONFromBytes (bytes) {\n  return JSON.parse(utf8DecodeBytes(bytes))\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-mime-type\n * @param {import('./response').Response|import('./request').Request} object\n */\nfunction bodyMimeType (object) {\n  const { headersList } = object[kState]\n  const contentType = headersList.get('content-type')\n\n  if (contentType === null) {\n    return 'failure'\n  }\n\n  return parseMIMEType(contentType)\n}\n\nmodule.exports = {\n  extractBody,\n  safelyExtractBody,\n  cloneBody,\n  mixinBody\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}