{"ast":null,"code":"import * as UCAN from \"./ucan.js\";\nimport * as DID from \"./did.js\";\nimport * as json from \"@ipld/dag-json\";\nimport { base64url } from \"multiformats/bases/base64\";\nimport * as Signature from \"./signature.js\";\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.Model<C>} model\n * @returns {UCAN.JWT<C>}\n */\nexport const format = model => {\n  const header = formatHeader(model.v, model.s.algorithm);\n  const payload = formatPayload(model);\n  const signature = formatSignature(model.s);\n  return /** @type {UCAN.JWT<C>} */`${header}.${payload}.${signature}`;\n};\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.Payload<C>} payload\n * @param {UCAN.Version} version\n * @param {string} alg\n */\nexport const formatSignPayload = (payload, version, alg) => `${formatHeader(version, alg)}.${formatPayload(payload)}`;\n\n/**\n * @param {UCAN.Version} version\n * @param {string} alg\n */\nexport const formatHeader = (version, alg) => base64url.baseEncode(encodeHeader(version, alg));\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.Payload<C>} data\n */\nexport const formatPayload = data => base64url.baseEncode(encodePayload(data));\n\n/**\n * @param {UCAN.Signature<string>} signature\n */\nexport const formatSignature = signature => base64url.baseEncode(signature.raw);\n\n/**\n * @param {UCAN.Version} v\n * @param {string} alg\n * @returns {UCAN.ByteView<UCAN.JWTHeader>}\n */\nconst encodeHeader = (v, alg) => json.encode({\n  alg,\n  ucv: v,\n  typ: \"JWT\"\n});\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.Payload<C>} data\n * @returns {UCAN.ByteView<UCAN.JWTPayload<C>>}\n */\nconst encodePayload = data => json.encode({\n  iss: DID.format(data.iss),\n  aud: DID.format(data.aud),\n  att: data.att,\n  exp: data.exp,\n  prf: data.prf.map(encodeProof),\n  // leave out optionals and empty fields\n  ...(data.fct.length > 0 && {\n    fct: data.fct\n  }),\n  ...(data.nnc && {\n    nnc: data.nnc\n  }),\n  ...(data.nbf && {\n    nbf: data.nbf\n  })\n});\n\n/**\n * @param {UCAN.Link} proof\n * @returns {UCAN.ToString<UCAN.Link>}\n */\nconst encodeProof = proof => ( /** @type {UCAN.ToString<UCAN.Link>} */proof.toString());","map":{"version":3,"names":["UCAN","DID","json","base64url","Signature","format","model","header","formatHeader","v","s","algorithm","payload","formatPayload","signature","formatSignature","formatSignPayload","version","alg","baseEncode","encodeHeader","data","encodePayload","raw","encode","ucv","typ","iss","aud","att","exp","prf","map","encodeProof","fct","length","nnc","nbf","proof","toString"],"sources":["C:/FACULTATE/Proiect/node_modules/@ipld/dag-ucan/src/formatter.js"],"sourcesContent":["import * as UCAN from \"./ucan.js\"\nimport * as DID from \"./did.js\"\nimport * as json from \"@ipld/dag-json\"\nimport { base64url } from \"multiformats/bases/base64\"\nimport * as Signature from \"./signature.js\"\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.Model<C>} model\n * @returns {UCAN.JWT<C>}\n */\nexport const format = model => {\n  const header = formatHeader(model.v, model.s.algorithm)\n  const payload = formatPayload(model)\n  const signature = formatSignature(model.s)\n  return /** @type {UCAN.JWT<C>} */ (`${header}.${payload}.${signature}`)\n}\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.Payload<C>} payload\n * @param {UCAN.Version} version\n * @param {string} alg\n */\nexport const formatSignPayload = (payload, version, alg) =>\n  `${formatHeader(version, alg)}.${formatPayload(payload)}`\n\n/**\n * @param {UCAN.Version} version\n * @param {string} alg\n */\nexport const formatHeader = (version, alg) =>\n  base64url.baseEncode(encodeHeader(version, alg))\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.Payload<C>} data\n */\nexport const formatPayload = data => base64url.baseEncode(encodePayload(data))\n\n/**\n * @param {UCAN.Signature<string>} signature\n */\nexport const formatSignature = signature => base64url.baseEncode(signature.raw)\n\n/**\n * @param {UCAN.Version} v\n * @param {string} alg\n * @returns {UCAN.ByteView<UCAN.JWTHeader>}\n */\nconst encodeHeader = (v, alg) =>\n  json.encode({\n    alg,\n    ucv: v,\n    typ: \"JWT\",\n  })\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.Payload<C>} data\n * @returns {UCAN.ByteView<UCAN.JWTPayload<C>>}\n */\nconst encodePayload = data =>\n  json.encode({\n    iss: DID.format(data.iss),\n    aud: DID.format(data.aud),\n    att: data.att,\n    exp: data.exp,\n    prf: data.prf.map(encodeProof),\n    // leave out optionals and empty fields\n    ...(data.fct.length > 0 && { fct: data.fct }),\n    ...(data.nnc && { nnc: data.nnc }),\n    ...(data.nbf && { nbf: data.nbf }),\n  })\n\n/**\n * @param {UCAN.Link} proof\n * @returns {UCAN.ToString<UCAN.Link>}\n */\nconst encodeProof = proof =>\n  /** @type {UCAN.ToString<UCAN.Link>} */ (proof.toString())\n"],"mappings":"AAAA,OAAO,KAAKA,IAAI,MAAM,WAAW;AACjC,OAAO,KAAKC,GAAG,MAAM,UAAU;AAC/B,OAAO,KAAKC,IAAI,MAAM,gBAAgB;AACtC,SAASC,SAAS,QAAQ,2BAA2B;AACrD,OAAO,KAAKC,SAAS,MAAM,gBAAgB;;AAE3C;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,MAAM,GAAGC,KAAK,IAAI;EAC7B,MAAMC,MAAM,GAAGC,YAAY,CAACF,KAAK,CAACG,CAAC,EAAEH,KAAK,CAACI,CAAC,CAACC,SAAS,CAAC;EACvD,MAAMC,OAAO,GAAGC,aAAa,CAACP,KAAK,CAAC;EACpC,MAAMQ,SAAS,GAAGC,eAAe,CAACT,KAAK,CAACI,CAAC,CAAC;EAC1C,OAAO,0BAA6B,GAAEH,MAAO,IAAGK,OAAQ,IAAGE,SAAU,EAAC;AACxE,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAME,iBAAiB,GAAGA,CAACJ,OAAO,EAAEK,OAAO,EAAEC,GAAG,KACpD,GAAEV,YAAY,CAACS,OAAO,EAAEC,GAAG,CAAE,IAAGL,aAAa,CAACD,OAAO,CAAE,EAAC;;AAE3D;AACA;AACA;AACA;AACA,OAAO,MAAMJ,YAAY,GAAGA,CAACS,OAAO,EAAEC,GAAG,KACvCf,SAAS,CAACgB,UAAU,CAACC,YAAY,CAACH,OAAO,EAAEC,GAAG,CAAC,CAAC;;AAElD;AACA;AACA;AACA;AACA,OAAO,MAAML,aAAa,GAAGQ,IAAI,IAAIlB,SAAS,CAACgB,UAAU,CAACG,aAAa,CAACD,IAAI,CAAC,CAAC;;AAE9E;AACA;AACA;AACA,OAAO,MAAMN,eAAe,GAAGD,SAAS,IAAIX,SAAS,CAACgB,UAAU,CAACL,SAAS,CAACS,GAAG,CAAC;;AAE/E;AACA;AACA;AACA;AACA;AACA,MAAMH,YAAY,GAAGA,CAACX,CAAC,EAAES,GAAG,KAC1BhB,IAAI,CAACsB,MAAM,CAAC;EACVN,GAAG;EACHO,GAAG,EAAEhB,CAAC;EACNiB,GAAG,EAAE;AACP,CAAC,CAAC;;AAEJ;AACA;AACA;AACA;AACA;AACA,MAAMJ,aAAa,GAAGD,IAAI,IACxBnB,IAAI,CAACsB,MAAM,CAAC;EACVG,GAAG,EAAE1B,GAAG,CAACI,MAAM,CAACgB,IAAI,CAACM,GAAG,CAAC;EACzBC,GAAG,EAAE3B,GAAG,CAACI,MAAM,CAACgB,IAAI,CAACO,GAAG,CAAC;EACzBC,GAAG,EAAER,IAAI,CAACQ,GAAG;EACbC,GAAG,EAAET,IAAI,CAACS,GAAG;EACbC,GAAG,EAAEV,IAAI,CAACU,GAAG,CAACC,GAAG,CAACC,WAAW,CAAC;EAC9B;EACA,IAAIZ,IAAI,CAACa,GAAG,CAACC,MAAM,GAAG,CAAC,IAAI;IAAED,GAAG,EAAEb,IAAI,CAACa;EAAI,CAAC,CAAC;EAC7C,IAAIb,IAAI,CAACe,GAAG,IAAI;IAAEA,GAAG,EAAEf,IAAI,CAACe;EAAI,CAAC,CAAC;EAClC,IAAIf,IAAI,CAACgB,GAAG,IAAI;IAAEA,GAAG,EAAEhB,IAAI,CAACgB;EAAI,CAAC;AACnC,CAAC,CAAC;;AAEJ;AACA;AACA;AACA;AACA,MAAMJ,WAAW,GAAGK,KAAK,MACvB,uCAAyCA,KAAK,CAACC,QAAQ,CAAC,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}