{"ast":null,"code":"'use strict';\n\nvar dagPb = require('@ipld/dag-pb');\nvar ipfsUnixfs = require('ipfs-unixfs');\nvar dir = require('./dir.js');\nvar persist = require('./utils/persist.js');\nvar hamtSharding = require('hamt-sharding');\nclass DirSharded extends dir {\n  constructor(props, options) {\n    super(props, options);\n    this._bucket = hamtSharding.createHAMT({\n      hashFn: options.hamtHashFn,\n      bits: options.hamtBucketBits\n    });\n  }\n  async put(name, value) {\n    await this._bucket.put(name, value);\n  }\n  get(name) {\n    return this._bucket.get(name);\n  }\n  childCount() {\n    return this._bucket.leafCount();\n  }\n  directChildrenCount() {\n    return this._bucket.childrenCount();\n  }\n  onlyChild() {\n    return this._bucket.onlyChild();\n  }\n  async *eachChildSeries() {\n    for await (const {\n      key,\n      value\n    } of this._bucket.eachLeafSeries()) {\n      yield {\n        key,\n        child: value\n      };\n    }\n  }\n  async *flush(blockstore) {\n    for await (const entry of flush(this._bucket, blockstore, this, this.options)) {\n      yield {\n        ...entry,\n        path: this.path\n      };\n    }\n  }\n}\nasync function* flush(bucket, blockstore, shardRoot, options) {\n  const children = bucket._children;\n  const links = [];\n  let childrenSize = 0;\n  for (let i = 0; i < children.length; i++) {\n    const child = children.get(i);\n    if (!child) {\n      continue;\n    }\n    const labelPrefix = i.toString(16).toUpperCase().padStart(2, '0');\n    if (child instanceof hamtSharding.Bucket) {\n      let shard;\n      for await (const subShard of await flush(child, blockstore, null, options)) {\n        shard = subShard;\n      }\n      if (!shard) {\n        throw new Error('Could not flush sharded directory, no subshard found');\n      }\n      links.push({\n        Name: labelPrefix,\n        Tsize: shard.size,\n        Hash: shard.cid\n      });\n      childrenSize += shard.size;\n    } else if (typeof child.value.flush === 'function') {\n      const dir = child.value;\n      let flushedDir;\n      for await (const entry of dir.flush(blockstore)) {\n        flushedDir = entry;\n        yield flushedDir;\n      }\n      const label = labelPrefix + child.key;\n      links.push({\n        Name: label,\n        Tsize: flushedDir.size,\n        Hash: flushedDir.cid\n      });\n      childrenSize += flushedDir.size;\n    } else {\n      const value = child.value;\n      if (!value.cid) {\n        continue;\n      }\n      const label = labelPrefix + child.key;\n      const size = value.size;\n      links.push({\n        Name: label,\n        Tsize: size,\n        Hash: value.cid\n      });\n      childrenSize += size;\n    }\n  }\n  const data = Uint8Array.from(children.bitField().reverse());\n  const dir = new ipfsUnixfs.UnixFS({\n    type: 'hamt-sharded-directory',\n    data,\n    fanout: bucket.tableSize(),\n    hashType: options.hamtHashCode,\n    mtime: shardRoot && shardRoot.mtime,\n    mode: shardRoot && shardRoot.mode\n  });\n  const node = {\n    Data: dir.marshal(),\n    Links: links\n  };\n  const buffer = dagPb.encode(dagPb.prepare(node));\n  const cid = await persist(buffer, blockstore, options);\n  const size = buffer.length + childrenSize;\n  yield {\n    cid,\n    unixfs: dir,\n    size\n  };\n}\nmodule.exports = DirSharded;","map":{"version":3,"names":["dagPb","require","ipfsUnixfs","dir","persist","hamtSharding","DirSharded","constructor","props","options","_bucket","createHAMT","hashFn","hamtHashFn","bits","hamtBucketBits","put","name","value","get","childCount","leafCount","directChildrenCount","childrenCount","onlyChild","eachChildSeries","key","eachLeafSeries","child","flush","blockstore","entry","path","bucket","shardRoot","children","_children","links","childrenSize","i","length","labelPrefix","toString","toUpperCase","padStart","Bucket","shard","subShard","Error","push","Name","Tsize","size","Hash","cid","flushedDir","label","data","Uint8Array","from","bitField","reverse","UnixFS","type","fanout","tableSize","hashType","hamtHashCode","mtime","mode","node","Data","marshal","Links","buffer","encode","prepare","unixfs","module","exports"],"sources":["C:/FACULTATE/Proiect/node_modules/ipfs-unixfs-importer/cjs/src/dir-sharded.js"],"sourcesContent":["'use strict';\n\nvar dagPb = require('@ipld/dag-pb');\nvar ipfsUnixfs = require('ipfs-unixfs');\nvar dir = require('./dir.js');\nvar persist = require('./utils/persist.js');\nvar hamtSharding = require('hamt-sharding');\n\nclass DirSharded extends dir {\n  constructor(props, options) {\n    super(props, options);\n    this._bucket = hamtSharding.createHAMT({\n      hashFn: options.hamtHashFn,\n      bits: options.hamtBucketBits\n    });\n  }\n  async put(name, value) {\n    await this._bucket.put(name, value);\n  }\n  get(name) {\n    return this._bucket.get(name);\n  }\n  childCount() {\n    return this._bucket.leafCount();\n  }\n  directChildrenCount() {\n    return this._bucket.childrenCount();\n  }\n  onlyChild() {\n    return this._bucket.onlyChild();\n  }\n  async *eachChildSeries() {\n    for await (const {key, value} of this._bucket.eachLeafSeries()) {\n      yield {\n        key,\n        child: value\n      };\n    }\n  }\n  async *flush(blockstore) {\n    for await (const entry of flush(this._bucket, blockstore, this, this.options)) {\n      yield {\n        ...entry,\n        path: this.path\n      };\n    }\n  }\n}\nasync function* flush(bucket, blockstore, shardRoot, options) {\n  const children = bucket._children;\n  const links = [];\n  let childrenSize = 0;\n  for (let i = 0; i < children.length; i++) {\n    const child = children.get(i);\n    if (!child) {\n      continue;\n    }\n    const labelPrefix = i.toString(16).toUpperCase().padStart(2, '0');\n    if (child instanceof hamtSharding.Bucket) {\n      let shard;\n      for await (const subShard of await flush(child, blockstore, null, options)) {\n        shard = subShard;\n      }\n      if (!shard) {\n        throw new Error('Could not flush sharded directory, no subshard found');\n      }\n      links.push({\n        Name: labelPrefix,\n        Tsize: shard.size,\n        Hash: shard.cid\n      });\n      childrenSize += shard.size;\n    } else if (typeof child.value.flush === 'function') {\n      const dir = child.value;\n      let flushedDir;\n      for await (const entry of dir.flush(blockstore)) {\n        flushedDir = entry;\n        yield flushedDir;\n      }\n      const label = labelPrefix + child.key;\n      links.push({\n        Name: label,\n        Tsize: flushedDir.size,\n        Hash: flushedDir.cid\n      });\n      childrenSize += flushedDir.size;\n    } else {\n      const value = child.value;\n      if (!value.cid) {\n        continue;\n      }\n      const label = labelPrefix + child.key;\n      const size = value.size;\n      links.push({\n        Name: label,\n        Tsize: size,\n        Hash: value.cid\n      });\n      childrenSize += size;\n    }\n  }\n  const data = Uint8Array.from(children.bitField().reverse());\n  const dir = new ipfsUnixfs.UnixFS({\n    type: 'hamt-sharded-directory',\n    data,\n    fanout: bucket.tableSize(),\n    hashType: options.hamtHashCode,\n    mtime: shardRoot && shardRoot.mtime,\n    mode: shardRoot && shardRoot.mode\n  });\n  const node = {\n    Data: dir.marshal(),\n    Links: links\n  };\n  const buffer = dagPb.encode(dagPb.prepare(node));\n  const cid = await persist(buffer, blockstore, options);\n  const size = buffer.length + childrenSize;\n  yield {\n    cid,\n    unixfs: dir,\n    size\n  };\n}\n\nmodule.exports = DirSharded;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}