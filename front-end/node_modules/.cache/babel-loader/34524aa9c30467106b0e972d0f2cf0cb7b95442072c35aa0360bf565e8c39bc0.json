{"ast":null,"code":"'use strict';\n\nconst {\n  kClients\n} = require('../core/symbols');\nconst Agent = require('../agent');\nconst {\n  kAgent,\n  kMockAgentSet,\n  kMockAgentGet,\n  kDispatches,\n  kIsMockActive,\n  kNetConnect,\n  kGetNetConnect,\n  kOptions,\n  kFactory\n} = require('./mock-symbols');\nconst MockClient = require('./mock-client');\nconst MockPool = require('./mock-pool');\nconst {\n  matchValue,\n  buildMockOptions\n} = require('./mock-utils');\nconst {\n  InvalidArgumentError,\n  UndiciError\n} = require('../core/errors');\nconst Dispatcher = require('../dispatcher');\nconst Pluralizer = require('./pluralizer');\nconst PendingInterceptorsFormatter = require('./pending-interceptors-formatter');\nclass FakeWeakRef {\n  constructor(value) {\n    this.value = value;\n  }\n  deref() {\n    return this.value;\n  }\n}\nclass MockAgent extends Dispatcher {\n  constructor(opts) {\n    super(opts);\n    this[kNetConnect] = true;\n    this[kIsMockActive] = true;\n\n    // Instantiate Agent and encapsulate\n    if (opts && opts.agent && typeof opts.agent.dispatch !== 'function') {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent');\n    }\n    const agent = opts && opts.agent ? opts.agent : new Agent(opts);\n    this[kAgent] = agent;\n    this[kClients] = agent[kClients];\n    this[kOptions] = buildMockOptions(opts);\n  }\n  get(origin) {\n    let dispatcher = this[kMockAgentGet](origin);\n    if (!dispatcher) {\n      dispatcher = this[kFactory](origin);\n      this[kMockAgentSet](origin, dispatcher);\n    }\n    return dispatcher;\n  }\n  dispatch(opts, handler) {\n    // Call MockAgent.get to perform additional setup before dispatching as normal\n    this.get(opts.origin);\n    return this[kAgent].dispatch(opts, handler);\n  }\n  async close() {\n    await this[kAgent].close();\n    this[kClients].clear();\n  }\n  deactivate() {\n    this[kIsMockActive] = false;\n  }\n  activate() {\n    this[kIsMockActive] = true;\n  }\n  enableNetConnect(matcher) {\n    if (typeof matcher === 'string' || typeof matcher === 'function' || matcher instanceof RegExp) {\n      if (Array.isArray(this[kNetConnect])) {\n        this[kNetConnect].push(matcher);\n      } else {\n        this[kNetConnect] = [matcher];\n      }\n    } else if (typeof matcher === 'undefined') {\n      this[kNetConnect] = true;\n    } else {\n      throw new InvalidArgumentError('Unsupported matcher. Must be one of String|Function|RegExp.');\n    }\n  }\n  disableNetConnect() {\n    this[kNetConnect] = false;\n  }\n\n  // This is required to bypass issues caused by using global symbols - see:\n  // https://github.com/nodejs/undici/issues/1447\n  get isMockActive() {\n    return this[kIsMockActive];\n  }\n  [kMockAgentSet](origin, dispatcher) {\n    this[kClients].set(origin, new FakeWeakRef(dispatcher));\n  }\n  [kFactory](origin) {\n    const mockOptions = Object.assign({\n      agent: this\n    }, this[kOptions]);\n    return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);\n  }\n  [kMockAgentGet](origin) {\n    // First check if we can immediately find it\n    const ref = this[kClients].get(origin);\n    if (ref) {\n      return ref.deref();\n    }\n\n    // If the origin is not a string create a dummy parent pool and return to user\n    if (typeof origin !== 'string') {\n      const dispatcher = this[kFactory]('http://localhost:9999');\n      this[kMockAgentSet](origin, dispatcher);\n      return dispatcher;\n    }\n\n    // If we match, create a pool and assign the same dispatches\n    for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {\n      const nonExplicitDispatcher = nonExplicitRef.deref();\n      if (nonExplicitDispatcher && typeof keyMatcher !== 'string' && matchValue(keyMatcher, origin)) {\n        const dispatcher = this[kFactory](origin);\n        this[kMockAgentSet](origin, dispatcher);\n        dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];\n        return dispatcher;\n      }\n    }\n  }\n  [kGetNetConnect]() {\n    return this[kNetConnect];\n  }\n  pendingInterceptors() {\n    const mockAgentClients = this[kClients];\n    return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope.deref()[kDispatches].map(dispatch => ({\n      ...dispatch,\n      origin\n    }))).filter(({\n      pending\n    }) => pending);\n  }\n  assertNoPendingInterceptors({\n    pendingInterceptorsFormatter = new PendingInterceptorsFormatter()\n  } = {}) {\n    const pending = this.pendingInterceptors();\n    if (pending.length === 0) {\n      return;\n    }\n    const pluralizer = new Pluralizer('interceptor', 'interceptors').pluralize(pending.length);\n    throw new UndiciError(`\n${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:\n\n${pendingInterceptorsFormatter.format(pending)}\n`.trim());\n  }\n}\nmodule.exports = MockAgent;","map":{"version":3,"names":["kClients","require","Agent","kAgent","kMockAgentSet","kMockAgentGet","kDispatches","kIsMockActive","kNetConnect","kGetNetConnect","kOptions","kFactory","MockClient","MockPool","matchValue","buildMockOptions","InvalidArgumentError","UndiciError","Dispatcher","Pluralizer","PendingInterceptorsFormatter","FakeWeakRef","constructor","value","deref","MockAgent","opts","agent","dispatch","get","origin","dispatcher","handler","close","clear","deactivate","activate","enableNetConnect","matcher","RegExp","Array","isArray","push","disableNetConnect","isMockActive","set","mockOptions","Object","assign","connections","ref","keyMatcher","nonExplicitRef","from","nonExplicitDispatcher","pendingInterceptors","mockAgentClients","entries","flatMap","scope","map","filter","pending","assertNoPendingInterceptors","pendingInterceptorsFormatter","length","pluralizer","pluralize","count","noun","is","format","trim","module","exports"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/undici/lib/mock/mock-agent.js"],"sourcesContent":["'use strict'\n\nconst { kClients } = require('../core/symbols')\nconst Agent = require('../agent')\nconst {\n  kAgent,\n  kMockAgentSet,\n  kMockAgentGet,\n  kDispatches,\n  kIsMockActive,\n  kNetConnect,\n  kGetNetConnect,\n  kOptions,\n  kFactory\n} = require('./mock-symbols')\nconst MockClient = require('./mock-client')\nconst MockPool = require('./mock-pool')\nconst { matchValue, buildMockOptions } = require('./mock-utils')\nconst { InvalidArgumentError, UndiciError } = require('../core/errors')\nconst Dispatcher = require('../dispatcher')\nconst Pluralizer = require('./pluralizer')\nconst PendingInterceptorsFormatter = require('./pending-interceptors-formatter')\n\nclass FakeWeakRef {\n  constructor (value) {\n    this.value = value\n  }\n\n  deref () {\n    return this.value\n  }\n}\n\nclass MockAgent extends Dispatcher {\n  constructor (opts) {\n    super(opts)\n\n    this[kNetConnect] = true\n    this[kIsMockActive] = true\n\n    // Instantiate Agent and encapsulate\n    if ((opts && opts.agent && typeof opts.agent.dispatch !== 'function')) {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent')\n    }\n    const agent = opts && opts.agent ? opts.agent : new Agent(opts)\n    this[kAgent] = agent\n\n    this[kClients] = agent[kClients]\n    this[kOptions] = buildMockOptions(opts)\n  }\n\n  get (origin) {\n    let dispatcher = this[kMockAgentGet](origin)\n\n    if (!dispatcher) {\n      dispatcher = this[kFactory](origin)\n      this[kMockAgentSet](origin, dispatcher)\n    }\n    return dispatcher\n  }\n\n  dispatch (opts, handler) {\n    // Call MockAgent.get to perform additional setup before dispatching as normal\n    this.get(opts.origin)\n    return this[kAgent].dispatch(opts, handler)\n  }\n\n  async close () {\n    await this[kAgent].close()\n    this[kClients].clear()\n  }\n\n  deactivate () {\n    this[kIsMockActive] = false\n  }\n\n  activate () {\n    this[kIsMockActive] = true\n  }\n\n  enableNetConnect (matcher) {\n    if (typeof matcher === 'string' || typeof matcher === 'function' || matcher instanceof RegExp) {\n      if (Array.isArray(this[kNetConnect])) {\n        this[kNetConnect].push(matcher)\n      } else {\n        this[kNetConnect] = [matcher]\n      }\n    } else if (typeof matcher === 'undefined') {\n      this[kNetConnect] = true\n    } else {\n      throw new InvalidArgumentError('Unsupported matcher. Must be one of String|Function|RegExp.')\n    }\n  }\n\n  disableNetConnect () {\n    this[kNetConnect] = false\n  }\n\n  // This is required to bypass issues caused by using global symbols - see:\n  // https://github.com/nodejs/undici/issues/1447\n  get isMockActive () {\n    return this[kIsMockActive]\n  }\n\n  [kMockAgentSet] (origin, dispatcher) {\n    this[kClients].set(origin, new FakeWeakRef(dispatcher))\n  }\n\n  [kFactory] (origin) {\n    const mockOptions = Object.assign({ agent: this }, this[kOptions])\n    return this[kOptions] && this[kOptions].connections === 1\n      ? new MockClient(origin, mockOptions)\n      : new MockPool(origin, mockOptions)\n  }\n\n  [kMockAgentGet] (origin) {\n    // First check if we can immediately find it\n    const ref = this[kClients].get(origin)\n    if (ref) {\n      return ref.deref()\n    }\n\n    // If the origin is not a string create a dummy parent pool and return to user\n    if (typeof origin !== 'string') {\n      const dispatcher = this[kFactory]('http://localhost:9999')\n      this[kMockAgentSet](origin, dispatcher)\n      return dispatcher\n    }\n\n    // If we match, create a pool and assign the same dispatches\n    for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {\n      const nonExplicitDispatcher = nonExplicitRef.deref()\n      if (nonExplicitDispatcher && typeof keyMatcher !== 'string' && matchValue(keyMatcher, origin)) {\n        const dispatcher = this[kFactory](origin)\n        this[kMockAgentSet](origin, dispatcher)\n        dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches]\n        return dispatcher\n      }\n    }\n  }\n\n  [kGetNetConnect] () {\n    return this[kNetConnect]\n  }\n\n  pendingInterceptors () {\n    const mockAgentClients = this[kClients]\n\n    return Array.from(mockAgentClients.entries())\n      .flatMap(([origin, scope]) => scope.deref()[kDispatches].map(dispatch => ({ ...dispatch, origin })))\n      .filter(({ pending }) => pending)\n  }\n\n  assertNoPendingInterceptors ({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {\n    const pending = this.pendingInterceptors()\n\n    if (pending.length === 0) {\n      return\n    }\n\n    const pluralizer = new Pluralizer('interceptor', 'interceptors').pluralize(pending.length)\n\n    throw new UndiciError(`\n${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:\n\n${pendingInterceptorsFormatter.format(pending)}\n`.trim())\n  }\n}\n\nmodule.exports = MockAgent\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}