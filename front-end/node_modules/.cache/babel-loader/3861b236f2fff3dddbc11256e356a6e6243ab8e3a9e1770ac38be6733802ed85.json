{"ast":null,"code":"import http from \"http\";\nimport https from \"https\";\nimport { gunzipSync } from \"zlib\";\nimport { assert, makeError } from \"./errors.js\";\nimport { getBytes } from \"./data.js\";\n/**\n *  @_ignore:\n */\nexport function createGetUrl(options) {\n  async function getUrl(req, signal) {\n    // Make sure we weren't cancelled before sending\n    assert(signal == null || !signal.cancelled, \"request cancelled before sending\", \"CANCELLED\");\n    const protocol = req.url.split(\":\")[0].toLowerCase();\n    assert(protocol === \"http\" || protocol === \"https\", `unsupported protocol ${protocol}`, \"UNSUPPORTED_OPERATION\", {\n      info: {\n        protocol\n      },\n      operation: \"request\"\n    });\n    assert(protocol === \"https\" || !req.credentials || req.allowInsecureAuthentication, \"insecure authorized connections unsupported\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"request\"\n    });\n    const method = req.method;\n    const headers = Object.assign({}, req.headers);\n    const reqOptions = {\n      method,\n      headers\n    };\n    if (options) {\n      if (options.agent) {\n        reqOptions.agent = options.agent;\n      }\n    }\n    // Create a Node-specific AbortController, if available\n    let abort = null;\n    try {\n      abort = new AbortController();\n      reqOptions.abort = abort.signal;\n    } catch (e) {\n      console.log(e);\n    }\n    const request = (protocol === \"http\" ? http : https).request(req.url, reqOptions);\n    request.setTimeout(req.timeout);\n    const body = req.body;\n    if (body) {\n      request.write(Buffer.from(body));\n    }\n    request.end();\n    return new Promise((resolve, reject) => {\n      if (signal) {\n        signal.addListener(() => {\n          if (abort) {\n            abort.abort();\n          }\n          reject(makeError(\"request cancelled\", \"CANCELLED\"));\n        });\n      }\n      request.on(\"timeout\", () => {\n        reject(makeError(\"request timeout\", \"TIMEOUT\"));\n      });\n      request.once(\"response\", resp => {\n        const statusCode = resp.statusCode || 0;\n        const statusMessage = resp.statusMessage || \"\";\n        const headers = Object.keys(resp.headers || {}).reduce((accum, name) => {\n          let value = resp.headers[name] || \"\";\n          if (Array.isArray(value)) {\n            value = value.join(\", \");\n          }\n          accum[name] = value;\n          return accum;\n        }, {});\n        let body = null;\n        //resp.setEncoding(\"utf8\");\n        resp.on(\"data\", chunk => {\n          if (signal) {\n            try {\n              signal.checkSignal();\n            } catch (error) {\n              return reject(error);\n            }\n          }\n          if (body == null) {\n            body = chunk;\n          } else {\n            const newBody = new Uint8Array(body.length + chunk.length);\n            newBody.set(body, 0);\n            newBody.set(chunk, body.length);\n            body = newBody;\n          }\n        });\n        resp.on(\"end\", () => {\n          if (headers[\"content-encoding\"] === \"gzip\" && body) {\n            body = getBytes(gunzipSync(body));\n          }\n          resolve({\n            statusCode,\n            statusMessage,\n            headers,\n            body\n          });\n        });\n        resp.on(\"error\", error => {\n          //@TODO: Should this just return nornal response with a server error?\n          error.response = {\n            statusCode,\n            statusMessage,\n            headers,\n            body\n          };\n          reject(error);\n        });\n      });\n      request.on(\"error\", error => {\n        reject(error);\n      });\n    });\n  }\n  return getUrl;\n}\n// @TODO: remove in v7; provided for backwards compat\nconst defaultGetUrl = createGetUrl({});\n/**\n *  @_ignore:\n */\nexport async function getUrl(req, signal) {\n  return defaultGetUrl(req, signal);\n}","map":{"version":3,"names":["http","https","gunzipSync","assert","makeError","getBytes","createGetUrl","options","getUrl","req","signal","cancelled","protocol","url","split","toLowerCase","info","operation","credentials","allowInsecureAuthentication","method","headers","Object","assign","reqOptions","agent","abort","AbortController","e","console","log","request","setTimeout","timeout","body","write","Buffer","from","end","Promise","resolve","reject","addListener","on","once","resp","statusCode","statusMessage","keys","reduce","accum","name","value","Array","isArray","join","chunk","checkSignal","error","newBody","Uint8Array","length","set","response","defaultGetUrl"],"sources":["C:/Users/Oana/Desktop/Blockchain/Blockchain-Project/node_modules/ethers/lib.esm/utils/geturl.js"],"sourcesContent":["import http from \"http\";\nimport https from \"https\";\nimport { gunzipSync } from \"zlib\";\nimport { assert, makeError } from \"./errors.js\";\nimport { getBytes } from \"./data.js\";\n/**\n *  @_ignore:\n */\nexport function createGetUrl(options) {\n    async function getUrl(req, signal) {\n        // Make sure we weren't cancelled before sending\n        assert(signal == null || !signal.cancelled, \"request cancelled before sending\", \"CANCELLED\");\n        const protocol = req.url.split(\":\")[0].toLowerCase();\n        assert(protocol === \"http\" || protocol === \"https\", `unsupported protocol ${protocol}`, \"UNSUPPORTED_OPERATION\", {\n            info: { protocol },\n            operation: \"request\"\n        });\n        assert(protocol === \"https\" || !req.credentials || req.allowInsecureAuthentication, \"insecure authorized connections unsupported\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"request\"\n        });\n        const method = req.method;\n        const headers = Object.assign({}, req.headers);\n        const reqOptions = { method, headers };\n        if (options) {\n            if (options.agent) {\n                reqOptions.agent = options.agent;\n            }\n        }\n        // Create a Node-specific AbortController, if available\n        let abort = null;\n        try {\n            abort = new AbortController();\n            reqOptions.abort = abort.signal;\n        }\n        catch (e) {\n            console.log(e);\n        }\n        const request = ((protocol === \"http\") ? http : https).request(req.url, reqOptions);\n        request.setTimeout(req.timeout);\n        const body = req.body;\n        if (body) {\n            request.write(Buffer.from(body));\n        }\n        request.end();\n        return new Promise((resolve, reject) => {\n            if (signal) {\n                signal.addListener(() => {\n                    if (abort) {\n                        abort.abort();\n                    }\n                    reject(makeError(\"request cancelled\", \"CANCELLED\"));\n                });\n            }\n            request.on(\"timeout\", () => {\n                reject(makeError(\"request timeout\", \"TIMEOUT\"));\n            });\n            request.once(\"response\", (resp) => {\n                const statusCode = resp.statusCode || 0;\n                const statusMessage = resp.statusMessage || \"\";\n                const headers = Object.keys(resp.headers || {}).reduce((accum, name) => {\n                    let value = resp.headers[name] || \"\";\n                    if (Array.isArray(value)) {\n                        value = value.join(\", \");\n                    }\n                    accum[name] = value;\n                    return accum;\n                }, {});\n                let body = null;\n                //resp.setEncoding(\"utf8\");\n                resp.on(\"data\", (chunk) => {\n                    if (signal) {\n                        try {\n                            signal.checkSignal();\n                        }\n                        catch (error) {\n                            return reject(error);\n                        }\n                    }\n                    if (body == null) {\n                        body = chunk;\n                    }\n                    else {\n                        const newBody = new Uint8Array(body.length + chunk.length);\n                        newBody.set(body, 0);\n                        newBody.set(chunk, body.length);\n                        body = newBody;\n                    }\n                });\n                resp.on(\"end\", () => {\n                    if (headers[\"content-encoding\"] === \"gzip\" && body) {\n                        body = getBytes(gunzipSync(body));\n                    }\n                    resolve({ statusCode, statusMessage, headers, body });\n                });\n                resp.on(\"error\", (error) => {\n                    //@TODO: Should this just return nornal response with a server error?\n                    error.response = { statusCode, statusMessage, headers, body };\n                    reject(error);\n                });\n            });\n            request.on(\"error\", (error) => { reject(error); });\n        });\n    }\n    return getUrl;\n}\n// @TODO: remove in v7; provided for backwards compat\nconst defaultGetUrl = createGetUrl({});\n/**\n *  @_ignore:\n */\nexport async function getUrl(req, signal) {\n    return defaultGetUrl(req, signal);\n}\n//# sourceMappingURL=geturl.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}