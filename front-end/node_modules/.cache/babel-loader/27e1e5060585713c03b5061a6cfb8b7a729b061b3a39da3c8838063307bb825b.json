{"ast":null,"code":"'use strict';\n\nconst {\n  kConstruct\n} = require('./symbols');\nconst {\n  urlEquals,\n  fieldValues: getFieldValues\n} = require('./util');\nconst {\n  kEnumerableProperty,\n  isDisturbed\n} = require('../core/util');\nconst {\n  kHeadersList\n} = require('../core/symbols');\nconst {\n  webidl\n} = require('../fetch/webidl');\nconst {\n  Response,\n  cloneResponse\n} = require('../fetch/response');\nconst {\n  Request\n} = require('../fetch/request');\nconst {\n  kState,\n  kHeaders,\n  kGuard,\n  kRealm\n} = require('../fetch/symbols');\nconst {\n  fetching\n} = require('../fetch/index');\nconst {\n  urlIsHttpHttpsScheme,\n  createDeferredPromise,\n  readAllBytes\n} = require('../fetch/util');\nconst assert = require('assert');\nconst {\n  getGlobalDispatcher\n} = require('../global');\n\n/**\n * @see https://w3c.github.io/ServiceWorker/#dfn-cache-batch-operation\n * @typedef {Object} CacheBatchOperation\n * @property {'delete' | 'put'} type\n * @property {any} request\n * @property {any} response\n * @property {import('../../types/cache').CacheQueryOptions} options\n */\n\n/**\n * @see https://w3c.github.io/ServiceWorker/#dfn-request-response-list\n * @typedef {[any, any][]} requestResponseList\n */\n\nclass Cache {\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list\n   * @type {requestResponseList}\n   */\n  #relevantRequestResponseList;\n  constructor() {\n    if (arguments[0] !== kConstruct) {\n      webidl.illegalConstructor();\n    }\n    this.#relevantRequestResponseList = arguments[1];\n  }\n  async match(request, options = {}) {\n    webidl.brandCheck(this, Cache);\n    webidl.argumentLengthCheck(arguments, 1, {\n      header: 'Cache.match'\n    });\n    request = webidl.converters.RequestInfo(request);\n    options = webidl.converters.CacheQueryOptions(options);\n    const p = await this.matchAll(request, options);\n    if (p.length === 0) {\n      return;\n    }\n    return p[0];\n  }\n  async matchAll(request = undefined, options = {}) {\n    webidl.brandCheck(this, Cache);\n    if (request !== undefined) request = webidl.converters.RequestInfo(request);\n    options = webidl.converters.CacheQueryOptions(options);\n\n    // 1.\n    let r = null;\n\n    // 2.\n    if (request !== undefined) {\n      if (request instanceof Request) {\n        // 2.1.1\n        r = request[kState];\n\n        // 2.1.2\n        if (r.method !== 'GET' && !options.ignoreMethod) {\n          return [];\n        }\n      } else if (typeof request === 'string') {\n        // 2.2.1\n        r = new Request(request)[kState];\n      }\n    }\n\n    // 5.\n    // 5.1\n    const responses = [];\n\n    // 5.2\n    if (request === undefined) {\n      // 5.2.1\n      for (const requestResponse of this.#relevantRequestResponseList) {\n        responses.push(requestResponse[1]);\n      }\n    } else {\n      // 5.3\n      // 5.3.1\n      const requestResponses = this.#queryCache(r, options);\n\n      // 5.3.2\n      for (const requestResponse of requestResponses) {\n        responses.push(requestResponse[1]);\n      }\n    }\n\n    // 5.4\n    // We don't implement CORs so we don't need to loop over the responses, yay!\n\n    // 5.5.1\n    const responseList = [];\n\n    // 5.5.2\n    for (const response of responses) {\n      // 5.5.2.1\n      const responseObject = new Response(response.body?.source ?? null);\n      const body = responseObject[kState].body;\n      responseObject[kState] = response;\n      responseObject[kState].body = body;\n      responseObject[kHeaders][kHeadersList] = response.headersList;\n      responseObject[kHeaders][kGuard] = 'immutable';\n      responseList.push(responseObject);\n    }\n\n    // 6.\n    return Object.freeze(responseList);\n  }\n  async add(request) {\n    webidl.brandCheck(this, Cache);\n    webidl.argumentLengthCheck(arguments, 1, {\n      header: 'Cache.add'\n    });\n    request = webidl.converters.RequestInfo(request);\n\n    // 1.\n    const requests = [request];\n\n    // 2.\n    const responseArrayPromise = this.addAll(requests);\n\n    // 3.\n    return await responseArrayPromise;\n  }\n  async addAll(requests) {\n    webidl.brandCheck(this, Cache);\n    webidl.argumentLengthCheck(arguments, 1, {\n      header: 'Cache.addAll'\n    });\n    requests = webidl.converters['sequence<RequestInfo>'](requests);\n\n    // 1.\n    const responsePromises = [];\n\n    // 2.\n    const requestList = [];\n\n    // 3.\n    for (const request of requests) {\n      if (typeof request === 'string') {\n        continue;\n      }\n\n      // 3.1\n      const r = request[kState];\n\n      // 3.2\n      if (!urlIsHttpHttpsScheme(r.url) || r.method !== 'GET') {\n        throw webidl.errors.exception({\n          header: 'Cache.addAll',\n          message: 'Expected http/s scheme when method is not GET.'\n        });\n      }\n    }\n\n    // 4.\n    /** @type {ReturnType<typeof fetching>[]} */\n    const fetchControllers = [];\n\n    // 5.\n    for (const request of requests) {\n      // 5.1\n      const r = new Request(request)[kState];\n\n      // 5.2\n      if (!urlIsHttpHttpsScheme(r.url)) {\n        throw webidl.errors.exception({\n          header: 'Cache.addAll',\n          message: 'Expected http/s scheme.'\n        });\n      }\n\n      // 5.4\n      r.initiator = 'fetch';\n      r.destination = 'subresource';\n\n      // 5.5\n      requestList.push(r);\n\n      // 5.6\n      const responsePromise = createDeferredPromise();\n\n      // 5.7\n      fetchControllers.push(fetching({\n        request: r,\n        dispatcher: getGlobalDispatcher(),\n        processResponse(response) {\n          // 1.\n          if (response.type === 'error' || response.status === 206 || response.status < 200 || response.status > 299) {\n            responsePromise.reject(webidl.errors.exception({\n              header: 'Cache.addAll',\n              message: 'Received an invalid status code or the request failed.'\n            }));\n          } else if (response.headersList.contains('vary')) {\n            // 2.\n            // 2.1\n            const fieldValues = getFieldValues(response.headersList.get('vary'));\n\n            // 2.2\n            for (const fieldValue of fieldValues) {\n              // 2.2.1\n              if (fieldValue === '*') {\n                responsePromise.reject(webidl.errors.exception({\n                  header: 'Cache.addAll',\n                  message: 'invalid vary field value'\n                }));\n                for (const controller of fetchControllers) {\n                  controller.abort();\n                }\n                return;\n              }\n            }\n          }\n        },\n        processResponseEndOfBody(response) {\n          // 1.\n          if (response.aborted) {\n            responsePromise.reject(new DOMException('aborted', 'AbortError'));\n            return;\n          }\n\n          // 2.\n          responsePromise.resolve(response);\n        }\n      }));\n\n      // 5.8\n      responsePromises.push(responsePromise.promise);\n    }\n\n    // 6.\n    const p = Promise.all(responsePromises);\n\n    // 7.\n    const responses = await p;\n\n    // 7.1\n    const operations = [];\n\n    // 7.2\n    let index = 0;\n\n    // 7.3\n    for (const response of responses) {\n      // 7.3.1\n      /** @type {CacheBatchOperation} */\n      const operation = {\n        type: 'put',\n        // 7.3.2\n        request: requestList[index],\n        // 7.3.3\n        response // 7.3.4\n      };\n      operations.push(operation); // 7.3.5\n\n      index++; // 7.3.6\n    }\n\n    // 7.5\n    const cacheJobPromise = createDeferredPromise();\n\n    // 7.6.1\n    let errorData = null;\n\n    // 7.6.2\n    try {\n      this.#batchCacheOperations(operations);\n    } catch (e) {\n      errorData = e;\n    }\n\n    // 7.6.3\n    queueMicrotask(() => {\n      // 7.6.3.1\n      if (errorData === null) {\n        cacheJobPromise.resolve(undefined);\n      } else {\n        // 7.6.3.2\n        cacheJobPromise.reject(errorData);\n      }\n    });\n\n    // 7.7\n    return cacheJobPromise.promise;\n  }\n  async put(request, response) {\n    webidl.brandCheck(this, Cache);\n    webidl.argumentLengthCheck(arguments, 2, {\n      header: 'Cache.put'\n    });\n    request = webidl.converters.RequestInfo(request);\n    response = webidl.converters.Response(response);\n\n    // 1.\n    let innerRequest = null;\n\n    // 2.\n    if (request instanceof Request) {\n      innerRequest = request[kState];\n    } else {\n      // 3.\n      innerRequest = new Request(request)[kState];\n    }\n\n    // 4.\n    if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== 'GET') {\n      throw webidl.errors.exception({\n        header: 'Cache.put',\n        message: 'Expected an http/s scheme when method is not GET'\n      });\n    }\n\n    // 5.\n    const innerResponse = response[kState];\n\n    // 6.\n    if (innerResponse.status === 206) {\n      throw webidl.errors.exception({\n        header: 'Cache.put',\n        message: 'Got 206 status'\n      });\n    }\n\n    // 7.\n    if (innerResponse.headersList.contains('vary')) {\n      // 7.1.\n      const fieldValues = getFieldValues(innerResponse.headersList.get('vary'));\n\n      // 7.2.\n      for (const fieldValue of fieldValues) {\n        // 7.2.1\n        if (fieldValue === '*') {\n          throw webidl.errors.exception({\n            header: 'Cache.put',\n            message: 'Got * vary field value'\n          });\n        }\n      }\n    }\n\n    // 8.\n    if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {\n      throw webidl.errors.exception({\n        header: 'Cache.put',\n        message: 'Response body is locked or disturbed'\n      });\n    }\n\n    // 9.\n    const clonedResponse = cloneResponse(innerResponse);\n\n    // 10.\n    const bodyReadPromise = createDeferredPromise();\n\n    // 11.\n    if (innerResponse.body != null) {\n      // 11.1\n      const stream = innerResponse.body.stream;\n\n      // 11.2\n      const reader = stream.getReader();\n\n      // 11.3\n      readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);\n    } else {\n      bodyReadPromise.resolve(undefined);\n    }\n\n    // 12.\n    /** @type {CacheBatchOperation[]} */\n    const operations = [];\n\n    // 13.\n    /** @type {CacheBatchOperation} */\n    const operation = {\n      type: 'put',\n      // 14.\n      request: innerRequest,\n      // 15.\n      response: clonedResponse // 16.\n    };\n\n    // 17.\n    operations.push(operation);\n\n    // 19.\n    const bytes = await bodyReadPromise.promise;\n    if (clonedResponse.body != null) {\n      clonedResponse.body.source = bytes;\n    }\n\n    // 19.1\n    const cacheJobPromise = createDeferredPromise();\n\n    // 19.2.1\n    let errorData = null;\n\n    // 19.2.2\n    try {\n      this.#batchCacheOperations(operations);\n    } catch (e) {\n      errorData = e;\n    }\n\n    // 19.2.3\n    queueMicrotask(() => {\n      // 19.2.3.1\n      if (errorData === null) {\n        cacheJobPromise.resolve();\n      } else {\n        // 19.2.3.2\n        cacheJobPromise.reject(errorData);\n      }\n    });\n    return cacheJobPromise.promise;\n  }\n  async delete(request, options = {}) {\n    webidl.brandCheck(this, Cache);\n    webidl.argumentLengthCheck(arguments, 1, {\n      header: 'Cache.delete'\n    });\n    request = webidl.converters.RequestInfo(request);\n    options = webidl.converters.CacheQueryOptions(options);\n\n    /**\n     * @type {Request}\n     */\n    let r = null;\n    if (request instanceof Request) {\n      r = request[kState];\n      if (r.method !== 'GET' && !options.ignoreMethod) {\n        return false;\n      }\n    } else {\n      assert(typeof request === 'string');\n      r = new Request(request)[kState];\n    }\n\n    /** @type {CacheBatchOperation[]} */\n    const operations = [];\n\n    /** @type {CacheBatchOperation} */\n    const operation = {\n      type: 'delete',\n      request: r,\n      options\n    };\n    operations.push(operation);\n    const cacheJobPromise = createDeferredPromise();\n    let errorData = null;\n    let requestResponses;\n    try {\n      requestResponses = this.#batchCacheOperations(operations);\n    } catch (e) {\n      errorData = e;\n    }\n    queueMicrotask(() => {\n      if (errorData === null) {\n        cacheJobPromise.resolve(!!requestResponses?.length);\n      } else {\n        cacheJobPromise.reject(errorData);\n      }\n    });\n    return cacheJobPromise.promise;\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys\n   * @param {any} request\n   * @param {import('../../types/cache').CacheQueryOptions} options\n   * @returns {readonly Request[]}\n   */\n  async keys(request = undefined, options = {}) {\n    webidl.brandCheck(this, Cache);\n    if (request !== undefined) request = webidl.converters.RequestInfo(request);\n    options = webidl.converters.CacheQueryOptions(options);\n\n    // 1.\n    let r = null;\n\n    // 2.\n    if (request !== undefined) {\n      // 2.1\n      if (request instanceof Request) {\n        // 2.1.1\n        r = request[kState];\n\n        // 2.1.2\n        if (r.method !== 'GET' && !options.ignoreMethod) {\n          return [];\n        }\n      } else if (typeof request === 'string') {\n        // 2.2\n        r = new Request(request)[kState];\n      }\n    }\n\n    // 4.\n    const promise = createDeferredPromise();\n\n    // 5.\n    // 5.1\n    const requests = [];\n\n    // 5.2\n    if (request === undefined) {\n      // 5.2.1\n      for (const requestResponse of this.#relevantRequestResponseList) {\n        // 5.2.1.1\n        requests.push(requestResponse[0]);\n      }\n    } else {\n      // 5.3\n      // 5.3.1\n      const requestResponses = this.#queryCache(r, options);\n\n      // 5.3.2\n      for (const requestResponse of requestResponses) {\n        // 5.3.2.1\n        requests.push(requestResponse[0]);\n      }\n    }\n\n    // 5.4\n    queueMicrotask(() => {\n      // 5.4.1\n      const requestList = [];\n\n      // 5.4.2\n      for (const request of requests) {\n        const requestObject = new Request('https://a');\n        requestObject[kState] = request;\n        requestObject[kHeaders][kHeadersList] = request.headersList;\n        requestObject[kHeaders][kGuard] = 'immutable';\n        requestObject[kRealm] = request.client;\n\n        // 5.4.2.1\n        requestList.push(requestObject);\n      }\n\n      // 5.4.3\n      promise.resolve(Object.freeze(requestList));\n    });\n    return promise.promise;\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm\n   * @param {CacheBatchOperation[]} operations\n   * @returns {requestResponseList}\n   */\n  #batchCacheOperations(operations) {\n    // 1.\n    const cache = this.#relevantRequestResponseList;\n\n    // 2.\n    const backupCache = [...cache];\n\n    // 3.\n    const addedItems = [];\n\n    // 4.1\n    const resultList = [];\n    try {\n      // 4.2\n      for (const operation of operations) {\n        // 4.2.1\n        if (operation.type !== 'delete' && operation.type !== 'put') {\n          throw webidl.errors.exception({\n            header: 'Cache.#batchCacheOperations',\n            message: 'operation type does not match \"delete\" or \"put\"'\n          });\n        }\n\n        // 4.2.2\n        if (operation.type === 'delete' && operation.response != null) {\n          throw webidl.errors.exception({\n            header: 'Cache.#batchCacheOperations',\n            message: 'delete operation should not have an associated response'\n          });\n        }\n\n        // 4.2.3\n        if (this.#queryCache(operation.request, operation.options, addedItems).length) {\n          throw new DOMException('???', 'InvalidStateError');\n        }\n\n        // 4.2.4\n        let requestResponses;\n\n        // 4.2.5\n        if (operation.type === 'delete') {\n          // 4.2.5.1\n          requestResponses = this.#queryCache(operation.request, operation.options);\n\n          // TODO: the spec is wrong, this is needed to pass WPTs\n          if (requestResponses.length === 0) {\n            return [];\n          }\n\n          // 4.2.5.2\n          for (const requestResponse of requestResponses) {\n            const idx = cache.indexOf(requestResponse);\n            assert(idx !== -1);\n\n            // 4.2.5.2.1\n            cache.splice(idx, 1);\n          }\n        } else if (operation.type === 'put') {\n          // 4.2.6\n          // 4.2.6.1\n          if (operation.response == null) {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'put operation should have an associated response'\n            });\n          }\n\n          // 4.2.6.2\n          const r = operation.request;\n\n          // 4.2.6.3\n          if (!urlIsHttpHttpsScheme(r.url)) {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'expected http or https scheme'\n            });\n          }\n\n          // 4.2.6.4\n          if (r.method !== 'GET') {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'not get method'\n            });\n          }\n\n          // 4.2.6.5\n          if (operation.options != null) {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'options must not be defined'\n            });\n          }\n\n          // 4.2.6.6\n          requestResponses = this.#queryCache(operation.request);\n\n          // 4.2.6.7\n          for (const requestResponse of requestResponses) {\n            const idx = cache.indexOf(requestResponse);\n            assert(idx !== -1);\n\n            // 4.2.6.7.1\n            cache.splice(idx, 1);\n          }\n\n          // 4.2.6.8\n          cache.push([operation.request, operation.response]);\n\n          // 4.2.6.10\n          addedItems.push([operation.request, operation.response]);\n        }\n\n        // 4.2.7\n        resultList.push([operation.request, operation.response]);\n      }\n\n      // 4.3\n      return resultList;\n    } catch (e) {\n      // 5.\n      // 5.1\n      this.#relevantRequestResponseList.length = 0;\n\n      // 5.2\n      this.#relevantRequestResponseList = backupCache;\n\n      // 5.3\n      throw e;\n    }\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#query-cache\n   * @param {any} requestQuery\n   * @param {import('../../types/cache').CacheQueryOptions} options\n   * @param {requestResponseList} targetStorage\n   * @returns {requestResponseList}\n   */\n  #queryCache(requestQuery, options, targetStorage) {\n    /** @type {requestResponseList} */\n    const resultList = [];\n    const storage = targetStorage ?? this.#relevantRequestResponseList;\n    for (const requestResponse of storage) {\n      const [cachedRequest, cachedResponse] = requestResponse;\n      if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {\n        resultList.push(requestResponse);\n      }\n    }\n    return resultList;\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm\n   * @param {any} requestQuery\n   * @param {any} request\n   * @param {any | null} response\n   * @param {import('../../types/cache').CacheQueryOptions | undefined} options\n   * @returns {boolean}\n   */\n  #requestMatchesCachedItem(requestQuery, request, response = null, options) {\n    // if (options?.ignoreMethod === false && request.method === 'GET') {\n    //   return false\n    // }\n\n    const queryURL = new URL(requestQuery.url);\n    const cachedURL = new URL(request.url);\n    if (options?.ignoreSearch) {\n      cachedURL.search = '';\n      queryURL.search = '';\n    }\n    if (!urlEquals(queryURL, cachedURL, true)) {\n      return false;\n    }\n    if (response == null || options?.ignoreVary || !response.headersList.contains('vary')) {\n      return true;\n    }\n    const fieldValues = getFieldValues(response.headersList.get('vary'));\n    for (const fieldValue of fieldValues) {\n      if (fieldValue === '*') {\n        return false;\n      }\n      const requestValue = request.headersList.get(fieldValue);\n      const queryValue = requestQuery.headersList.get(fieldValue);\n\n      // If one has the header and the other doesn't, or one has\n      // a different value than the other, return false\n      if (requestValue !== queryValue) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\nObject.defineProperties(Cache.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'Cache',\n    configurable: true\n  },\n  match: kEnumerableProperty,\n  matchAll: kEnumerableProperty,\n  add: kEnumerableProperty,\n  addAll: kEnumerableProperty,\n  put: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  keys: kEnumerableProperty\n});\nconst cacheQueryOptionConverters = [{\n  key: 'ignoreSearch',\n  converter: webidl.converters.boolean,\n  defaultValue: false\n}, {\n  key: 'ignoreMethod',\n  converter: webidl.converters.boolean,\n  defaultValue: false\n}, {\n  key: 'ignoreVary',\n  converter: webidl.converters.boolean,\n  defaultValue: false\n}];\nwebidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);\nwebidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([...cacheQueryOptionConverters, {\n  key: 'cacheName',\n  converter: webidl.converters.DOMString\n}]);\nwebidl.converters.Response = webidl.interfaceConverter(Response);\nwebidl.converters['sequence<RequestInfo>'] = webidl.sequenceConverter(webidl.converters.RequestInfo);\nmodule.exports = {\n  Cache\n};","map":{"version":3,"names":["kConstruct","require","urlEquals","fieldValues","getFieldValues","kEnumerableProperty","isDisturbed","kHeadersList","webidl","Response","cloneResponse","Request","kState","kHeaders","kGuard","kRealm","fetching","urlIsHttpHttpsScheme","createDeferredPromise","readAllBytes","assert","getGlobalDispatcher","Cache","relevantRequestResponseList","constructor","arguments","illegalConstructor","match","request","options","brandCheck","argumentLengthCheck","header","converters","RequestInfo","CacheQueryOptions","p","matchAll","length","undefined","r","method","ignoreMethod","responses","requestResponse","push","requestResponses","queryCache","responseList","response","responseObject","body","source","headersList","Object","freeze","add","requests","responseArrayPromise","addAll","responsePromises","requestList","url","errors","exception","message","fetchControllers","initiator","destination","responsePromise","dispatcher","processResponse","type","status","reject","contains","get","fieldValue","controller","abort","processResponseEndOfBody","aborted","DOMException","resolve","promise","Promise","all","operations","index","operation","cacheJobPromise","errorData","batchCacheOperations","e","queueMicrotask","put","innerRequest","innerResponse","stream","locked","clonedResponse","bodyReadPromise","reader","getReader","then","bytes","delete","keys","requestObject","client","#batchCacheOperations","cache","backupCache","addedItems","resultList","idx","indexOf","splice","#queryCache","requestQuery","targetStorage","storage","cachedRequest","cachedResponse","requestMatchesCachedItem","#requestMatchesCachedItem","queryURL","URL","cachedURL","ignoreSearch","search","ignoreVary","requestValue","queryValue","defineProperties","prototype","Symbol","toStringTag","value","configurable","cacheQueryOptionConverters","key","converter","boolean","defaultValue","dictionaryConverter","MultiCacheQueryOptions","DOMString","interfaceConverter","sequenceConverter","module","exports"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/undici/lib/cache/cache.js"],"sourcesContent":["'use strict'\n\nconst { kConstruct } = require('./symbols')\nconst { urlEquals, fieldValues: getFieldValues } = require('./util')\nconst { kEnumerableProperty, isDisturbed } = require('../core/util')\nconst { kHeadersList } = require('../core/symbols')\nconst { webidl } = require('../fetch/webidl')\nconst { Response, cloneResponse } = require('../fetch/response')\nconst { Request } = require('../fetch/request')\nconst { kState, kHeaders, kGuard, kRealm } = require('../fetch/symbols')\nconst { fetching } = require('../fetch/index')\nconst { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require('../fetch/util')\nconst assert = require('assert')\nconst { getGlobalDispatcher } = require('../global')\n\n/**\n * @see https://w3c.github.io/ServiceWorker/#dfn-cache-batch-operation\n * @typedef {Object} CacheBatchOperation\n * @property {'delete' | 'put'} type\n * @property {any} request\n * @property {any} response\n * @property {import('../../types/cache').CacheQueryOptions} options\n */\n\n/**\n * @see https://w3c.github.io/ServiceWorker/#dfn-request-response-list\n * @typedef {[any, any][]} requestResponseList\n */\n\nclass Cache {\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list\n   * @type {requestResponseList}\n   */\n  #relevantRequestResponseList\n\n  constructor () {\n    if (arguments[0] !== kConstruct) {\n      webidl.illegalConstructor()\n    }\n\n    this.#relevantRequestResponseList = arguments[1]\n  }\n\n  async match (request, options = {}) {\n    webidl.brandCheck(this, Cache)\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.match' })\n\n    request = webidl.converters.RequestInfo(request)\n    options = webidl.converters.CacheQueryOptions(options)\n\n    const p = await this.matchAll(request, options)\n\n    if (p.length === 0) {\n      return\n    }\n\n    return p[0]\n  }\n\n  async matchAll (request = undefined, options = {}) {\n    webidl.brandCheck(this, Cache)\n\n    if (request !== undefined) request = webidl.converters.RequestInfo(request)\n    options = webidl.converters.CacheQueryOptions(options)\n\n    // 1.\n    let r = null\n\n    // 2.\n    if (request !== undefined) {\n      if (request instanceof Request) {\n        // 2.1.1\n        r = request[kState]\n\n        // 2.1.2\n        if (r.method !== 'GET' && !options.ignoreMethod) {\n          return []\n        }\n      } else if (typeof request === 'string') {\n        // 2.2.1\n        r = new Request(request)[kState]\n      }\n    }\n\n    // 5.\n    // 5.1\n    const responses = []\n\n    // 5.2\n    if (request === undefined) {\n      // 5.2.1\n      for (const requestResponse of this.#relevantRequestResponseList) {\n        responses.push(requestResponse[1])\n      }\n    } else { // 5.3\n      // 5.3.1\n      const requestResponses = this.#queryCache(r, options)\n\n      // 5.3.2\n      for (const requestResponse of requestResponses) {\n        responses.push(requestResponse[1])\n      }\n    }\n\n    // 5.4\n    // We don't implement CORs so we don't need to loop over the responses, yay!\n\n    // 5.5.1\n    const responseList = []\n\n    // 5.5.2\n    for (const response of responses) {\n      // 5.5.2.1\n      const responseObject = new Response(response.body?.source ?? null)\n      const body = responseObject[kState].body\n      responseObject[kState] = response\n      responseObject[kState].body = body\n      responseObject[kHeaders][kHeadersList] = response.headersList\n      responseObject[kHeaders][kGuard] = 'immutable'\n\n      responseList.push(responseObject)\n    }\n\n    // 6.\n    return Object.freeze(responseList)\n  }\n\n  async add (request) {\n    webidl.brandCheck(this, Cache)\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.add' })\n\n    request = webidl.converters.RequestInfo(request)\n\n    // 1.\n    const requests = [request]\n\n    // 2.\n    const responseArrayPromise = this.addAll(requests)\n\n    // 3.\n    return await responseArrayPromise\n  }\n\n  async addAll (requests) {\n    webidl.brandCheck(this, Cache)\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.addAll' })\n\n    requests = webidl.converters['sequence<RequestInfo>'](requests)\n\n    // 1.\n    const responsePromises = []\n\n    // 2.\n    const requestList = []\n\n    // 3.\n    for (const request of requests) {\n      if (typeof request === 'string') {\n        continue\n      }\n\n      // 3.1\n      const r = request[kState]\n\n      // 3.2\n      if (!urlIsHttpHttpsScheme(r.url) || r.method !== 'GET') {\n        throw webidl.errors.exception({\n          header: 'Cache.addAll',\n          message: 'Expected http/s scheme when method is not GET.'\n        })\n      }\n    }\n\n    // 4.\n    /** @type {ReturnType<typeof fetching>[]} */\n    const fetchControllers = []\n\n    // 5.\n    for (const request of requests) {\n      // 5.1\n      const r = new Request(request)[kState]\n\n      // 5.2\n      if (!urlIsHttpHttpsScheme(r.url)) {\n        throw webidl.errors.exception({\n          header: 'Cache.addAll',\n          message: 'Expected http/s scheme.'\n        })\n      }\n\n      // 5.4\n      r.initiator = 'fetch'\n      r.destination = 'subresource'\n\n      // 5.5\n      requestList.push(r)\n\n      // 5.6\n      const responsePromise = createDeferredPromise()\n\n      // 5.7\n      fetchControllers.push(fetching({\n        request: r,\n        dispatcher: getGlobalDispatcher(),\n        processResponse (response) {\n          // 1.\n          if (response.type === 'error' || response.status === 206 || response.status < 200 || response.status > 299) {\n            responsePromise.reject(webidl.errors.exception({\n              header: 'Cache.addAll',\n              message: 'Received an invalid status code or the request failed.'\n            }))\n          } else if (response.headersList.contains('vary')) { // 2.\n            // 2.1\n            const fieldValues = getFieldValues(response.headersList.get('vary'))\n\n            // 2.2\n            for (const fieldValue of fieldValues) {\n              // 2.2.1\n              if (fieldValue === '*') {\n                responsePromise.reject(webidl.errors.exception({\n                  header: 'Cache.addAll',\n                  message: 'invalid vary field value'\n                }))\n\n                for (const controller of fetchControllers) {\n                  controller.abort()\n                }\n\n                return\n              }\n            }\n          }\n        },\n        processResponseEndOfBody (response) {\n          // 1.\n          if (response.aborted) {\n            responsePromise.reject(new DOMException('aborted', 'AbortError'))\n            return\n          }\n\n          // 2.\n          responsePromise.resolve(response)\n        }\n      }))\n\n      // 5.8\n      responsePromises.push(responsePromise.promise)\n    }\n\n    // 6.\n    const p = Promise.all(responsePromises)\n\n    // 7.\n    const responses = await p\n\n    // 7.1\n    const operations = []\n\n    // 7.2\n    let index = 0\n\n    // 7.3\n    for (const response of responses) {\n      // 7.3.1\n      /** @type {CacheBatchOperation} */\n      const operation = {\n        type: 'put', // 7.3.2\n        request: requestList[index], // 7.3.3\n        response // 7.3.4\n      }\n\n      operations.push(operation) // 7.3.5\n\n      index++ // 7.3.6\n    }\n\n    // 7.5\n    const cacheJobPromise = createDeferredPromise()\n\n    // 7.6.1\n    let errorData = null\n\n    // 7.6.2\n    try {\n      this.#batchCacheOperations(operations)\n    } catch (e) {\n      errorData = e\n    }\n\n    // 7.6.3\n    queueMicrotask(() => {\n      // 7.6.3.1\n      if (errorData === null) {\n        cacheJobPromise.resolve(undefined)\n      } else {\n        // 7.6.3.2\n        cacheJobPromise.reject(errorData)\n      }\n    })\n\n    // 7.7\n    return cacheJobPromise.promise\n  }\n\n  async put (request, response) {\n    webidl.brandCheck(this, Cache)\n    webidl.argumentLengthCheck(arguments, 2, { header: 'Cache.put' })\n\n    request = webidl.converters.RequestInfo(request)\n    response = webidl.converters.Response(response)\n\n    // 1.\n    let innerRequest = null\n\n    // 2.\n    if (request instanceof Request) {\n      innerRequest = request[kState]\n    } else { // 3.\n      innerRequest = new Request(request)[kState]\n    }\n\n    // 4.\n    if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== 'GET') {\n      throw webidl.errors.exception({\n        header: 'Cache.put',\n        message: 'Expected an http/s scheme when method is not GET'\n      })\n    }\n\n    // 5.\n    const innerResponse = response[kState]\n\n    // 6.\n    if (innerResponse.status === 206) {\n      throw webidl.errors.exception({\n        header: 'Cache.put',\n        message: 'Got 206 status'\n      })\n    }\n\n    // 7.\n    if (innerResponse.headersList.contains('vary')) {\n      // 7.1.\n      const fieldValues = getFieldValues(innerResponse.headersList.get('vary'))\n\n      // 7.2.\n      for (const fieldValue of fieldValues) {\n        // 7.2.1\n        if (fieldValue === '*') {\n          throw webidl.errors.exception({\n            header: 'Cache.put',\n            message: 'Got * vary field value'\n          })\n        }\n      }\n    }\n\n    // 8.\n    if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {\n      throw webidl.errors.exception({\n        header: 'Cache.put',\n        message: 'Response body is locked or disturbed'\n      })\n    }\n\n    // 9.\n    const clonedResponse = cloneResponse(innerResponse)\n\n    // 10.\n    const bodyReadPromise = createDeferredPromise()\n\n    // 11.\n    if (innerResponse.body != null) {\n      // 11.1\n      const stream = innerResponse.body.stream\n\n      // 11.2\n      const reader = stream.getReader()\n\n      // 11.3\n      readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject)\n    } else {\n      bodyReadPromise.resolve(undefined)\n    }\n\n    // 12.\n    /** @type {CacheBatchOperation[]} */\n    const operations = []\n\n    // 13.\n    /** @type {CacheBatchOperation} */\n    const operation = {\n      type: 'put', // 14.\n      request: innerRequest, // 15.\n      response: clonedResponse // 16.\n    }\n\n    // 17.\n    operations.push(operation)\n\n    // 19.\n    const bytes = await bodyReadPromise.promise\n\n    if (clonedResponse.body != null) {\n      clonedResponse.body.source = bytes\n    }\n\n    // 19.1\n    const cacheJobPromise = createDeferredPromise()\n\n    // 19.2.1\n    let errorData = null\n\n    // 19.2.2\n    try {\n      this.#batchCacheOperations(operations)\n    } catch (e) {\n      errorData = e\n    }\n\n    // 19.2.3\n    queueMicrotask(() => {\n      // 19.2.3.1\n      if (errorData === null) {\n        cacheJobPromise.resolve()\n      } else { // 19.2.3.2\n        cacheJobPromise.reject(errorData)\n      }\n    })\n\n    return cacheJobPromise.promise\n  }\n\n  async delete (request, options = {}) {\n    webidl.brandCheck(this, Cache)\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.delete' })\n\n    request = webidl.converters.RequestInfo(request)\n    options = webidl.converters.CacheQueryOptions(options)\n\n    /**\n     * @type {Request}\n     */\n    let r = null\n\n    if (request instanceof Request) {\n      r = request[kState]\n\n      if (r.method !== 'GET' && !options.ignoreMethod) {\n        return false\n      }\n    } else {\n      assert(typeof request === 'string')\n\n      r = new Request(request)[kState]\n    }\n\n    /** @type {CacheBatchOperation[]} */\n    const operations = []\n\n    /** @type {CacheBatchOperation} */\n    const operation = {\n      type: 'delete',\n      request: r,\n      options\n    }\n\n    operations.push(operation)\n\n    const cacheJobPromise = createDeferredPromise()\n\n    let errorData = null\n    let requestResponses\n\n    try {\n      requestResponses = this.#batchCacheOperations(operations)\n    } catch (e) {\n      errorData = e\n    }\n\n    queueMicrotask(() => {\n      if (errorData === null) {\n        cacheJobPromise.resolve(!!requestResponses?.length)\n      } else {\n        cacheJobPromise.reject(errorData)\n      }\n    })\n\n    return cacheJobPromise.promise\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys\n   * @param {any} request\n   * @param {import('../../types/cache').CacheQueryOptions} options\n   * @returns {readonly Request[]}\n   */\n  async keys (request = undefined, options = {}) {\n    webidl.brandCheck(this, Cache)\n\n    if (request !== undefined) request = webidl.converters.RequestInfo(request)\n    options = webidl.converters.CacheQueryOptions(options)\n\n    // 1.\n    let r = null\n\n    // 2.\n    if (request !== undefined) {\n      // 2.1\n      if (request instanceof Request) {\n        // 2.1.1\n        r = request[kState]\n\n        // 2.1.2\n        if (r.method !== 'GET' && !options.ignoreMethod) {\n          return []\n        }\n      } else if (typeof request === 'string') { // 2.2\n        r = new Request(request)[kState]\n      }\n    }\n\n    // 4.\n    const promise = createDeferredPromise()\n\n    // 5.\n    // 5.1\n    const requests = []\n\n    // 5.2\n    if (request === undefined) {\n      // 5.2.1\n      for (const requestResponse of this.#relevantRequestResponseList) {\n        // 5.2.1.1\n        requests.push(requestResponse[0])\n      }\n    } else { // 5.3\n      // 5.3.1\n      const requestResponses = this.#queryCache(r, options)\n\n      // 5.3.2\n      for (const requestResponse of requestResponses) {\n        // 5.3.2.1\n        requests.push(requestResponse[0])\n      }\n    }\n\n    // 5.4\n    queueMicrotask(() => {\n      // 5.4.1\n      const requestList = []\n\n      // 5.4.2\n      for (const request of requests) {\n        const requestObject = new Request('https://a')\n        requestObject[kState] = request\n        requestObject[kHeaders][kHeadersList] = request.headersList\n        requestObject[kHeaders][kGuard] = 'immutable'\n        requestObject[kRealm] = request.client\n\n        // 5.4.2.1\n        requestList.push(requestObject)\n      }\n\n      // 5.4.3\n      promise.resolve(Object.freeze(requestList))\n    })\n\n    return promise.promise\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm\n   * @param {CacheBatchOperation[]} operations\n   * @returns {requestResponseList}\n   */\n  #batchCacheOperations (operations) {\n    // 1.\n    const cache = this.#relevantRequestResponseList\n\n    // 2.\n    const backupCache = [...cache]\n\n    // 3.\n    const addedItems = []\n\n    // 4.1\n    const resultList = []\n\n    try {\n      // 4.2\n      for (const operation of operations) {\n        // 4.2.1\n        if (operation.type !== 'delete' && operation.type !== 'put') {\n          throw webidl.errors.exception({\n            header: 'Cache.#batchCacheOperations',\n            message: 'operation type does not match \"delete\" or \"put\"'\n          })\n        }\n\n        // 4.2.2\n        if (operation.type === 'delete' && operation.response != null) {\n          throw webidl.errors.exception({\n            header: 'Cache.#batchCacheOperations',\n            message: 'delete operation should not have an associated response'\n          })\n        }\n\n        // 4.2.3\n        if (this.#queryCache(operation.request, operation.options, addedItems).length) {\n          throw new DOMException('???', 'InvalidStateError')\n        }\n\n        // 4.2.4\n        let requestResponses\n\n        // 4.2.5\n        if (operation.type === 'delete') {\n          // 4.2.5.1\n          requestResponses = this.#queryCache(operation.request, operation.options)\n\n          // TODO: the spec is wrong, this is needed to pass WPTs\n          if (requestResponses.length === 0) {\n            return []\n          }\n\n          // 4.2.5.2\n          for (const requestResponse of requestResponses) {\n            const idx = cache.indexOf(requestResponse)\n            assert(idx !== -1)\n\n            // 4.2.5.2.1\n            cache.splice(idx, 1)\n          }\n        } else if (operation.type === 'put') { // 4.2.6\n          // 4.2.6.1\n          if (operation.response == null) {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'put operation should have an associated response'\n            })\n          }\n\n          // 4.2.6.2\n          const r = operation.request\n\n          // 4.2.6.3\n          if (!urlIsHttpHttpsScheme(r.url)) {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'expected http or https scheme'\n            })\n          }\n\n          // 4.2.6.4\n          if (r.method !== 'GET') {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'not get method'\n            })\n          }\n\n          // 4.2.6.5\n          if (operation.options != null) {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'options must not be defined'\n            })\n          }\n\n          // 4.2.6.6\n          requestResponses = this.#queryCache(operation.request)\n\n          // 4.2.6.7\n          for (const requestResponse of requestResponses) {\n            const idx = cache.indexOf(requestResponse)\n            assert(idx !== -1)\n\n            // 4.2.6.7.1\n            cache.splice(idx, 1)\n          }\n\n          // 4.2.6.8\n          cache.push([operation.request, operation.response])\n\n          // 4.2.6.10\n          addedItems.push([operation.request, operation.response])\n        }\n\n        // 4.2.7\n        resultList.push([operation.request, operation.response])\n      }\n\n      // 4.3\n      return resultList\n    } catch (e) { // 5.\n      // 5.1\n      this.#relevantRequestResponseList.length = 0\n\n      // 5.2\n      this.#relevantRequestResponseList = backupCache\n\n      // 5.3\n      throw e\n    }\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#query-cache\n   * @param {any} requestQuery\n   * @param {import('../../types/cache').CacheQueryOptions} options\n   * @param {requestResponseList} targetStorage\n   * @returns {requestResponseList}\n   */\n  #queryCache (requestQuery, options, targetStorage) {\n    /** @type {requestResponseList} */\n    const resultList = []\n\n    const storage = targetStorage ?? this.#relevantRequestResponseList\n\n    for (const requestResponse of storage) {\n      const [cachedRequest, cachedResponse] = requestResponse\n      if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {\n        resultList.push(requestResponse)\n      }\n    }\n\n    return resultList\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm\n   * @param {any} requestQuery\n   * @param {any} request\n   * @param {any | null} response\n   * @param {import('../../types/cache').CacheQueryOptions | undefined} options\n   * @returns {boolean}\n   */\n  #requestMatchesCachedItem (requestQuery, request, response = null, options) {\n    // if (options?.ignoreMethod === false && request.method === 'GET') {\n    //   return false\n    // }\n\n    const queryURL = new URL(requestQuery.url)\n\n    const cachedURL = new URL(request.url)\n\n    if (options?.ignoreSearch) {\n      cachedURL.search = ''\n\n      queryURL.search = ''\n    }\n\n    if (!urlEquals(queryURL, cachedURL, true)) {\n      return false\n    }\n\n    if (\n      response == null ||\n      options?.ignoreVary ||\n      !response.headersList.contains('vary')\n    ) {\n      return true\n    }\n\n    const fieldValues = getFieldValues(response.headersList.get('vary'))\n\n    for (const fieldValue of fieldValues) {\n      if (fieldValue === '*') {\n        return false\n      }\n\n      const requestValue = request.headersList.get(fieldValue)\n      const queryValue = requestQuery.headersList.get(fieldValue)\n\n      // If one has the header and the other doesn't, or one has\n      // a different value than the other, return false\n      if (requestValue !== queryValue) {\n        return false\n      }\n    }\n\n    return true\n  }\n}\n\nObject.defineProperties(Cache.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'Cache',\n    configurable: true\n  },\n  match: kEnumerableProperty,\n  matchAll: kEnumerableProperty,\n  add: kEnumerableProperty,\n  addAll: kEnumerableProperty,\n  put: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  keys: kEnumerableProperty\n})\n\nconst cacheQueryOptionConverters = [\n  {\n    key: 'ignoreSearch',\n    converter: webidl.converters.boolean,\n    defaultValue: false\n  },\n  {\n    key: 'ignoreMethod',\n    converter: webidl.converters.boolean,\n    defaultValue: false\n  },\n  {\n    key: 'ignoreVary',\n    converter: webidl.converters.boolean,\n    defaultValue: false\n  }\n]\n\nwebidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters)\n\nwebidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([\n  ...cacheQueryOptionConverters,\n  {\n    key: 'cacheName',\n    converter: webidl.converters.DOMString\n  }\n])\n\nwebidl.converters.Response = webidl.interfaceConverter(Response)\n\nwebidl.converters['sequence<RequestInfo>'] = webidl.sequenceConverter(\n  webidl.converters.RequestInfo\n)\n\nmodule.exports = {\n  Cache\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}