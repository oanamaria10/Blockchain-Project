{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VMTracer = void 0;\nconst ethereumjs_util_1 = require(\"@nomicfoundation/ethereumjs-util\");\nconst errors_1 = require(\"../../core/errors\");\nconst exit_1 = require(\"../provider/vm/exit\");\nconst message_trace_1 = require(\"./message-trace\");\n/* eslint-disable @nomicfoundation/hardhat-internal-rules/only-hardhat-error */\nconst DUMMY_RETURN_DATA = Buffer.from([]);\nconst DUMMY_GAS_USED = 0n;\nclass VMTracer {\n  constructor(_throwErrors = true) {\n    this._throwErrors = _throwErrors;\n    this.tracingSteps = [];\n    this._messageTraces = [];\n    // TODO: temporarily hardcoded to remove the need of using ethereumjs' common and evm here\n    this._maxPrecompileNumber = 10;\n  }\n  getLastTopLevelMessageTrace() {\n    return this._messageTraces[0];\n  }\n  getLastError() {\n    return this._lastError;\n  }\n  clearLastError() {\n    this._lastError = undefined;\n  }\n  _shouldKeepTracing() {\n    return this._throwErrors || this._lastError === undefined;\n  }\n  async addBeforeMessage(message) {\n    if (!this._shouldKeepTracing()) {\n      return;\n    }\n    try {\n      let trace;\n      if (message.depth === 0) {\n        this._messageTraces = [];\n        this.tracingSteps = [];\n      }\n      if (message.to === undefined) {\n        const createTrace = {\n          code: message.data,\n          steps: [],\n          value: message.value,\n          exit: new exit_1.Exit(exit_1.ExitCode.SUCCESS),\n          returnData: DUMMY_RETURN_DATA,\n          numberOfSubtraces: 0,\n          depth: message.depth,\n          deployedContract: undefined,\n          gasUsed: DUMMY_GAS_USED\n        };\n        trace = createTrace;\n      } else {\n        const toAsBigInt = (0, ethereumjs_util_1.bytesToBigInt)(message.to);\n        if (toAsBigInt > 0 && toAsBigInt <= this._maxPrecompileNumber) {\n          const precompileTrace = {\n            precompile: Number(toAsBigInt),\n            calldata: message.data,\n            value: message.value,\n            exit: new exit_1.Exit(exit_1.ExitCode.SUCCESS),\n            returnData: DUMMY_RETURN_DATA,\n            depth: message.depth,\n            gasUsed: DUMMY_GAS_USED\n          };\n          trace = precompileTrace;\n        } else {\n          const codeAddress = message.codeAddress;\n          // if we enter here, then `to` is not undefined, therefore\n          // `codeAddress` and `code` should be defined\n          (0, errors_1.assertHardhatInvariant)(codeAddress !== undefined, \"codeAddress should be defined\");\n          (0, errors_1.assertHardhatInvariant)(message.code !== undefined, \"code should be defined\");\n          const callTrace = {\n            code: message.code,\n            calldata: message.data,\n            steps: [],\n            value: message.value,\n            exit: new exit_1.Exit(exit_1.ExitCode.SUCCESS),\n            returnData: DUMMY_RETURN_DATA,\n            address: message.to,\n            numberOfSubtraces: 0,\n            depth: message.depth,\n            gasUsed: DUMMY_GAS_USED,\n            codeAddress\n          };\n          trace = callTrace;\n        }\n      }\n      if (this._messageTraces.length > 0) {\n        const parentTrace = this._messageTraces[this._messageTraces.length - 1];\n        if ((0, message_trace_1.isPrecompileTrace)(parentTrace)) {\n          throw new Error(\"This should not happen: message execution started while a precompile was executing\");\n        }\n        parentTrace.steps.push(trace);\n        parentTrace.numberOfSubtraces += 1;\n      }\n      this._messageTraces.push(trace);\n    } catch (error) {\n      if (this._throwErrors) {\n        throw error;\n      } else {\n        this._lastError = error;\n      }\n    }\n  }\n  async addStep(step) {\n    if (!this._shouldKeepTracing()) {\n      return;\n    }\n    this.tracingSteps.push(step);\n    try {\n      const trace = this._messageTraces[this._messageTraces.length - 1];\n      if ((0, message_trace_1.isPrecompileTrace)(trace)) {\n        throw new Error(\"This should not happen: step event fired while a precompile was executing\");\n      }\n      trace.steps.push({\n        pc: Number(step.pc)\n      });\n    } catch (error) {\n      if (this._throwErrors) {\n        throw error;\n      } else {\n        this._lastError = error;\n      }\n    }\n  }\n  async addAfterMessage(result, haltOverride) {\n    if (!this._shouldKeepTracing()) {\n      return;\n    }\n    try {\n      const trace = this._messageTraces[this._messageTraces.length - 1];\n      trace.gasUsed = result.result.gasUsed;\n      const executionResult = result.result;\n      if ((0, message_trace_1.isSuccessResult)(executionResult)) {\n        trace.exit = exit_1.Exit.fromEdrSuccessReason(executionResult.reason);\n        trace.returnData = executionResult.output.returnValue;\n        if ((0, message_trace_1.isCreateTrace)(trace)) {\n          trace.deployedContract = executionResult.output.address;\n        }\n      } else if ((0, message_trace_1.isHaltResult)(executionResult)) {\n        trace.exit = haltOverride ?? exit_1.Exit.fromEdrExceptionalHalt(executionResult.reason);\n        trace.returnData = Buffer.from([]);\n      } else {\n        trace.exit = new exit_1.Exit(exit_1.ExitCode.REVERT);\n        trace.returnData = executionResult.output;\n      }\n      if (this._messageTraces.length > 1) {\n        this._messageTraces.pop();\n      }\n    } catch (error) {\n      if (this._throwErrors) {\n        throw error;\n      } else {\n        this._lastError = error;\n      }\n    }\n  }\n}\nexports.VMTracer = VMTracer;","map":{"version":3,"names":["ethereumjs_util_1","require","errors_1","exit_1","message_trace_1","DUMMY_RETURN_DATA","Buffer","from","DUMMY_GAS_USED","VMTracer","constructor","_throwErrors","tracingSteps","_messageTraces","_maxPrecompileNumber","getLastTopLevelMessageTrace","getLastError","_lastError","clearLastError","undefined","_shouldKeepTracing","addBeforeMessage","message","trace","depth","to","createTrace","code","data","steps","value","exit","Exit","ExitCode","SUCCESS","returnData","numberOfSubtraces","deployedContract","gasUsed","toAsBigInt","bytesToBigInt","precompileTrace","precompile","Number","calldata","codeAddress","assertHardhatInvariant","callTrace","address","length","parentTrace","isPrecompileTrace","Error","push","error","addStep","step","pc","addAfterMessage","result","haltOverride","executionResult","isSuccessResult","fromEdrSuccessReason","reason","output","returnValue","isCreateTrace","isHaltResult","fromEdrExceptionalHalt","REVERT","pop","exports"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\internal\\hardhat-network\\stack-traces\\vm-tracer.ts"],"sourcesContent":["import {\n  CreateOutput,\n  ExecutionResult,\n  TracingMessage,\n  TracingStep,\n} from \"@nomicfoundation/edr\";\n\nimport { bytesToBigInt } from \"@nomicfoundation/ethereumjs-util\";\n\nimport { assertHardhatInvariant } from \"../../core/errors\";\nimport { Exit, ExitCode } from \"../provider/vm/exit\";\n\nimport {\n  CallMessageTrace,\n  CreateMessageTrace,\n  isCreateTrace,\n  isHaltResult,\n  isPrecompileTrace,\n  isSuccessResult,\n  MessageTrace,\n  PrecompileMessageTrace,\n} from \"./message-trace\";\n\n/* eslint-disable @nomicfoundation/hardhat-internal-rules/only-hardhat-error */\n\nconst DUMMY_RETURN_DATA = Buffer.from([]);\nconst DUMMY_GAS_USED = 0n;\n\nexport class VMTracer {\n  public tracingSteps: TracingStep[] = [];\n\n  private _messageTraces: MessageTrace[] = [];\n  private _lastError: Error | undefined;\n  private _maxPrecompileNumber;\n\n  constructor(private readonly _throwErrors = true) {\n    // TODO: temporarily hardcoded to remove the need of using ethereumjs' common and evm here\n    this._maxPrecompileNumber = 10;\n  }\n\n  public getLastTopLevelMessageTrace(): MessageTrace | undefined {\n    return this._messageTraces[0];\n  }\n\n  public getLastError(): Error | undefined {\n    return this._lastError;\n  }\n\n  public clearLastError() {\n    this._lastError = undefined;\n  }\n\n  private _shouldKeepTracing() {\n    return this._throwErrors || this._lastError === undefined;\n  }\n\n  public async addBeforeMessage(message: TracingMessage) {\n    if (!this._shouldKeepTracing()) {\n      return;\n    }\n\n    try {\n      let trace: MessageTrace;\n\n      if (message.depth === 0) {\n        this._messageTraces = [];\n        this.tracingSteps = [];\n      }\n\n      if (message.to === undefined) {\n        const createTrace: CreateMessageTrace = {\n          code: message.data,\n          steps: [],\n          value: message.value,\n          exit: new Exit(ExitCode.SUCCESS),\n          returnData: DUMMY_RETURN_DATA,\n          numberOfSubtraces: 0,\n          depth: message.depth,\n          deployedContract: undefined,\n          gasUsed: DUMMY_GAS_USED,\n        };\n\n        trace = createTrace;\n      } else {\n        const toAsBigInt = bytesToBigInt(message.to);\n\n        if (toAsBigInt > 0 && toAsBigInt <= this._maxPrecompileNumber) {\n          const precompileTrace: PrecompileMessageTrace = {\n            precompile: Number(toAsBigInt),\n            calldata: message.data,\n            value: message.value,\n            exit: new Exit(ExitCode.SUCCESS),\n            returnData: DUMMY_RETURN_DATA,\n            depth: message.depth,\n            gasUsed: DUMMY_GAS_USED,\n          };\n\n          trace = precompileTrace;\n        } else {\n          const codeAddress = message.codeAddress;\n\n          // if we enter here, then `to` is not undefined, therefore\n          // `codeAddress` and `code` should be defined\n          assertHardhatInvariant(\n            codeAddress !== undefined,\n            \"codeAddress should be defined\"\n          );\n          assertHardhatInvariant(\n            message.code !== undefined,\n            \"code should be defined\"\n          );\n\n          const callTrace: CallMessageTrace = {\n            code: message.code,\n            calldata: message.data,\n            steps: [],\n            value: message.value,\n            exit: new Exit(ExitCode.SUCCESS),\n            returnData: DUMMY_RETURN_DATA,\n            address: message.to,\n            numberOfSubtraces: 0,\n            depth: message.depth,\n            gasUsed: DUMMY_GAS_USED,\n            codeAddress,\n          };\n\n          trace = callTrace;\n        }\n      }\n\n      if (this._messageTraces.length > 0) {\n        const parentTrace = this._messageTraces[this._messageTraces.length - 1];\n\n        if (isPrecompileTrace(parentTrace)) {\n          throw new Error(\n            \"This should not happen: message execution started while a precompile was executing\"\n          );\n        }\n\n        parentTrace.steps.push(trace);\n        parentTrace.numberOfSubtraces += 1;\n      }\n\n      this._messageTraces.push(trace);\n    } catch (error) {\n      if (this._throwErrors) {\n        throw error;\n      } else {\n        this._lastError = error as Error;\n      }\n    }\n  }\n\n  public async addStep(step: TracingStep) {\n    if (!this._shouldKeepTracing()) {\n      return;\n    }\n\n    this.tracingSteps.push(step);\n\n    try {\n      const trace = this._messageTraces[this._messageTraces.length - 1];\n\n      if (isPrecompileTrace(trace)) {\n        throw new Error(\n          \"This should not happen: step event fired while a precompile was executing\"\n        );\n      }\n\n      trace.steps.push({ pc: Number(step.pc) });\n    } catch (error) {\n      if (this._throwErrors) {\n        throw error;\n      } else {\n        this._lastError = error as Error;\n      }\n    }\n  }\n\n  public async addAfterMessage(result: ExecutionResult, haltOverride?: Exit) {\n    if (!this._shouldKeepTracing()) {\n      return;\n    }\n\n    try {\n      const trace = this._messageTraces[this._messageTraces.length - 1];\n      trace.gasUsed = result.result.gasUsed;\n\n      const executionResult = result.result;\n      if (isSuccessResult(executionResult)) {\n        trace.exit = Exit.fromEdrSuccessReason(executionResult.reason);\n        trace.returnData = executionResult.output.returnValue;\n\n        if (isCreateTrace(trace)) {\n          trace.deployedContract = (\n            executionResult.output as CreateOutput\n          ).address;\n        }\n      } else if (isHaltResult(executionResult)) {\n        trace.exit =\n          haltOverride ?? Exit.fromEdrExceptionalHalt(executionResult.reason);\n\n        trace.returnData = Buffer.from([]);\n      } else {\n        trace.exit = new Exit(ExitCode.REVERT);\n\n        trace.returnData = executionResult.output;\n      }\n\n      if (this._messageTraces.length > 1) {\n        this._messageTraces.pop();\n      }\n    } catch (error) {\n      if (this._throwErrors) {\n        throw error;\n      } else {\n        this._lastError = error as Error;\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}