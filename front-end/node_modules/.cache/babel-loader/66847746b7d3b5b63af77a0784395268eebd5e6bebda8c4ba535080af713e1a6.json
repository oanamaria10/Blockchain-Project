{"ast":null,"code":"import * as API from \"./api.js\";\nconst utf8 = new TextEncoder();\nimport { murmur364 } from \"@multiformats/murmur3\";\n\n/**\n * @param {Uint8Array} bytes\n */\n/* c8 ignore next 2 */\nexport const hash64 = bytes => ( /** @type {Uint8Array} */murmur364.encode(bytes));\n\n/**\n * @param {Partial<API.Options<Uint8Array>>} options\n * @returns {API.Path<Uint8Array>}\n */\n/* c8 ignore next 25 */\nexport const configure = ({\n  bitWidth = 8,\n  hash = hash64\n} = {}) => {\n  const hashSize = hash(new Uint8Array()).byteLength;\n\n  /**\n   * @param {Uint8Array} path\n   * @param {number} depth\n   * @returns {API.Uint32}\n   */\n  const at = (path, depth) => {\n    const offset = depth * bitWidth;\n    if (offset > hashSize) {\n      throw new RangeError(`Out of bounds`);\n    }\n    return toInt(path, offset, bitWidth);\n  };\n\n  /**\n   * @param {string} key\n   * @returns {Uint8Array}\n   */\n  const from = key => hash(utf8.encode(key));\n  return {\n    from,\n    at,\n    size: Math.ceil(hashSize * 8 / bitWidth)\n  };\n};\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset - bit offset\n * @param {number} count - number of bits to consume\n */\nexport const toInt = (bytes, offset, count) => {\n  let byteOffset = offset / 8 | 0;\n  let bitOffset = offset % 8;\n  let desired = count;\n  let bits = 0;\n  while (desired > 0 && byteOffset < bytes.byteLength) {\n    const byte = bytes[byteOffset];\n    const available = 8 - bitOffset;\n    const taking = available < desired ? available : desired;\n    const bitsLeft = 8 - bitOffset - taking;\n    // mask to turn of bits before bitOffset\n    const mask = 0xff >> bitOffset;\n    // turn off offset bits and shift to drop remaining bit on the right\n    const value = (mask & byte) >> bitsLeft;\n    bits = (bits << taking) + value;\n    desired -= taking;\n    byteOffset++;\n    bitOffset = 0;\n  }\n  return bits;\n};","map":{"version":3,"names":["API","utf8","TextEncoder","murmur364","hash64","bytes","encode","configure","bitWidth","hash","hashSize","Uint8Array","byteLength","at","path","depth","offset","RangeError","toInt","from","key","size","Math","ceil","count","byteOffset","bitOffset","desired","bits","byte","available","taking","bitsLeft","mask","value"],"sources":["C:/FACULTATE/Proiect/node_modules/@perma/map/src/path/Uint8Array.js"],"sourcesContent":["import * as API from \"./api.js\"\nconst utf8 = new TextEncoder()\nimport { murmur364 } from \"@multiformats/murmur3\"\n\n/**\n * @param {Uint8Array} bytes\n */\n/* c8 ignore next 2 */\nexport const hash64 = bytes =>\n  /** @type {Uint8Array} */ (murmur364.encode(bytes))\n\n/**\n * @param {Partial<API.Options<Uint8Array>>} options\n * @returns {API.Path<Uint8Array>}\n */\n/* c8 ignore next 25 */\nexport const configure = ({ bitWidth = 8, hash = hash64 } = {}) => {\n  const hashSize = hash(new Uint8Array()).byteLength\n\n  /**\n   * @param {Uint8Array} path\n   * @param {number} depth\n   * @returns {API.Uint32}\n   */\n  const at = (path, depth) => {\n    const offset = depth * bitWidth\n    if (offset > hashSize) {\n      throw new RangeError(`Out of bounds`)\n    }\n\n    return toInt(path, offset, bitWidth)\n  }\n\n  /**\n   * @param {string} key\n   * @returns {Uint8Array}\n   */\n  const from = key => hash(utf8.encode(key))\n\n  return { from, at, size: Math.ceil((hashSize * 8) / bitWidth) }\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset - bit offset\n * @param {number} count - number of bits to consume\n */\nexport const toInt = (bytes, offset, count) => {\n  let byteOffset = (offset / 8) | 0\n  let bitOffset = offset % 8\n  let desired = count\n  let bits = 0\n  while (desired > 0 && byteOffset < bytes.byteLength) {\n    const byte = bytes[byteOffset]\n    const available = 8 - bitOffset\n\n    const taking = available < desired ? available : desired\n    const bitsLeft = 8 - bitOffset - taking\n    // mask to turn of bits before bitOffset\n    const mask = 0xff >> bitOffset\n    // turn off offset bits and shift to drop remaining bit on the right\n    const value = (mask & byte) >> bitsLeft\n    bits = (bits << taking) + value\n\n    desired -= taking\n    byteOffset++\n    bitOffset = 0\n  }\n\n  return bits\n}\n"],"mappings":"AAAA,OAAO,KAAKA,GAAG,MAAM,UAAU;AAC/B,MAAMC,IAAI,GAAG,IAAIC,WAAW,CAAC,CAAC;AAC9B,SAASC,SAAS,QAAQ,uBAAuB;;AAEjD;AACA;AACA;AACA;AACA,OAAO,MAAMC,MAAM,GAAGC,KAAK,MACzB,yBAA2BF,SAAS,CAACG,MAAM,CAACD,KAAK,CAAC,CAAC;;AAErD;AACA;AACA;AACA;AACA;AACA,OAAO,MAAME,SAAS,GAAGA,CAAC;EAAEC,QAAQ,GAAG,CAAC;EAAEC,IAAI,GAAGL;AAAO,CAAC,GAAG,CAAC,CAAC,KAAK;EACjE,MAAMM,QAAQ,GAAGD,IAAI,CAAC,IAAIE,UAAU,CAAC,CAAC,CAAC,CAACC,UAAU;;EAElD;AACF;AACA;AACA;AACA;EACE,MAAMC,EAAE,GAAGA,CAACC,IAAI,EAAEC,KAAK,KAAK;IAC1B,MAAMC,MAAM,GAAGD,KAAK,GAAGP,QAAQ;IAC/B,IAAIQ,MAAM,GAAGN,QAAQ,EAAE;MACrB,MAAM,IAAIO,UAAU,CAAE,eAAc,CAAC;IACvC;IAEA,OAAOC,KAAK,CAACJ,IAAI,EAAEE,MAAM,EAAER,QAAQ,CAAC;EACtC,CAAC;;EAED;AACF;AACA;AACA;EACE,MAAMW,IAAI,GAAGC,GAAG,IAAIX,IAAI,CAACR,IAAI,CAACK,MAAM,CAACc,GAAG,CAAC,CAAC;EAE1C,OAAO;IAAED,IAAI;IAAEN,EAAE;IAAEQ,IAAI,EAAEC,IAAI,CAACC,IAAI,CAAEb,QAAQ,GAAG,CAAC,GAAIF,QAAQ;EAAE,CAAC;AACjE,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMU,KAAK,GAAGA,CAACb,KAAK,EAAEW,MAAM,EAAEQ,KAAK,KAAK;EAC7C,IAAIC,UAAU,GAAIT,MAAM,GAAG,CAAC,GAAI,CAAC;EACjC,IAAIU,SAAS,GAAGV,MAAM,GAAG,CAAC;EAC1B,IAAIW,OAAO,GAAGH,KAAK;EACnB,IAAII,IAAI,GAAG,CAAC;EACZ,OAAOD,OAAO,GAAG,CAAC,IAAIF,UAAU,GAAGpB,KAAK,CAACO,UAAU,EAAE;IACnD,MAAMiB,IAAI,GAAGxB,KAAK,CAACoB,UAAU,CAAC;IAC9B,MAAMK,SAAS,GAAG,CAAC,GAAGJ,SAAS;IAE/B,MAAMK,MAAM,GAAGD,SAAS,GAAGH,OAAO,GAAGG,SAAS,GAAGH,OAAO;IACxD,MAAMK,QAAQ,GAAG,CAAC,GAAGN,SAAS,GAAGK,MAAM;IACvC;IACA,MAAME,IAAI,GAAG,IAAI,IAAIP,SAAS;IAC9B;IACA,MAAMQ,KAAK,GAAG,CAACD,IAAI,GAAGJ,IAAI,KAAKG,QAAQ;IACvCJ,IAAI,GAAG,CAACA,IAAI,IAAIG,MAAM,IAAIG,KAAK;IAE/BP,OAAO,IAAII,MAAM;IACjBN,UAAU,EAAE;IACZC,SAAS,GAAG,CAAC;EACf;EAEA,OAAOE,IAAI;AACb,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}