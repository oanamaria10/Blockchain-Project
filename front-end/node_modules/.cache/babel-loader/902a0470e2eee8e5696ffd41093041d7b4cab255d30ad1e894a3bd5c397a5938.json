{"ast":null,"code":"import { RLP } from '@nomicfoundation/ethereumjs-rlp';\nimport { keccak256 } from 'ethereum-cryptography/keccak.js';\nimport { privateKeyVerify, publicKeyConvert, publicKeyCreate, publicKeyVerify } from 'ethereum-cryptography/secp256k1';\nimport { bigIntToUnpaddedBytes, bytesToBigInt, bytesToHex, concatBytes, equalsBytes, hexToBytes, toBytes, utf8ToBytes, zeros } from './bytes.js';\nimport { BIGINT_0, KECCAK256_NULL, KECCAK256_RLP } from './constants.js';\nimport { assertIsBytes, assertIsHexString, assertIsString } from './helpers.js';\nimport { stripHexPrefix } from './internal.js';\nexport class Account {\n  /**\n   * This constructor assigns and validates the values.\n   * Use the static factory methods to assist in creating an Account from varying data types.\n   */\n  constructor(nonce = BIGINT_0, balance = BIGINT_0, storageRoot = KECCAK256_RLP, codeHash = KECCAK256_NULL) {\n    this.nonce = nonce;\n    this.balance = balance;\n    this.storageRoot = storageRoot;\n    this.codeHash = codeHash;\n    this._validate();\n  }\n  static fromAccountData(accountData) {\n    const {\n      nonce,\n      balance,\n      storageRoot,\n      codeHash\n    } = accountData;\n    return new Account(nonce !== undefined ? bytesToBigInt(toBytes(nonce)) : undefined, balance !== undefined ? bytesToBigInt(toBytes(balance)) : undefined, storageRoot !== undefined ? toBytes(storageRoot) : undefined, codeHash !== undefined ? toBytes(codeHash) : undefined);\n  }\n  static fromRlpSerializedAccount(serialized) {\n    const values = RLP.decode(serialized);\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized account input. Must be array');\n    }\n    return this.fromValuesArray(values);\n  }\n  static fromValuesArray(values) {\n    const [nonce, balance, storageRoot, codeHash] = values;\n    return new Account(bytesToBigInt(nonce), bytesToBigInt(balance), storageRoot, codeHash);\n  }\n  _validate() {\n    if (this.nonce < BIGINT_0) {\n      throw new Error('nonce must be greater than zero');\n    }\n    if (this.balance < BIGINT_0) {\n      throw new Error('balance must be greater than zero');\n    }\n    if (this.storageRoot.length !== 32) {\n      throw new Error('storageRoot must have a length of 32');\n    }\n    if (this.codeHash.length !== 32) {\n      throw new Error('codeHash must have a length of 32');\n    }\n  }\n  /**\n   * Returns an array of Uint8Arrays of the raw bytes for the account, in order.\n   */\n  raw() {\n    return [bigIntToUnpaddedBytes(this.nonce), bigIntToUnpaddedBytes(this.balance), this.storageRoot, this.codeHash];\n  }\n  /**\n   * Returns the RLP serialization of the account as a `Uint8Array`.\n   */\n  serialize() {\n    return RLP.encode(this.raw());\n  }\n  /**\n   * Returns a `Boolean` determining if the account is a contract.\n   */\n  isContract() {\n    return !equalsBytes(this.codeHash, KECCAK256_NULL);\n  }\n  /**\n   * Returns a `Boolean` determining if the account is empty complying to the definition of\n   * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n   * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n   */\n  isEmpty() {\n    return this.balance === BIGINT_0 && this.nonce === BIGINT_0 && equalsBytes(this.codeHash, KECCAK256_NULL);\n  }\n}\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nexport const isValidAddress = function (hexAddress) {\n  try {\n    assertIsString(hexAddress);\n  } catch (e) {\n    return false;\n  }\n  return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\n/**\n * Returns a checksummed address.\n *\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\n * backwards compatible to the original widely adopted checksum format standard introduced in\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\n */\nexport const toChecksumAddress = function (hexAddress, eip1191ChainId) {\n  assertIsHexString(hexAddress);\n  const address = stripHexPrefix(hexAddress).toLowerCase();\n  let prefix = '';\n  if (eip1191ChainId !== undefined) {\n    const chainId = bytesToBigInt(toBytes(eip1191ChainId));\n    prefix = chainId.toString() + '0x';\n  }\n  const bytes = utf8ToBytes(prefix + address);\n  const hash = bytesToHex(keccak256(Buffer.from(bytes))).slice(2);\n  let ret = '0x';\n  for (let i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase();\n    } else {\n      ret += address[i];\n    }\n  }\n  return ret;\n};\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\nexport const isValidChecksumAddress = function (hexAddress, eip1191ChainId) {\n  return isValidAddress(hexAddress) && toChecksumAddress(hexAddress, eip1191ChainId) === hexAddress;\n};\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nexport const generateAddress = function (from, nonce) {\n  assertIsBytes(from);\n  assertIsBytes(nonce);\n  if (bytesToBigInt(nonce) === BIGINT_0) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    return keccak256(Buffer.from(RLP.encode([from, Uint8Array.from([])]))).subarray(-20);\n  }\n  // Only take the lower 160bits of the hash\n  return keccak256(Buffer.from(RLP.encode([from, nonce]))).subarray(-20);\n};\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nexport const generateAddress2 = function (from, salt, initCode) {\n  assertIsBytes(from);\n  assertIsBytes(salt);\n  assertIsBytes(initCode);\n  if (from.length !== 20) {\n    throw new Error('Expected from to be of length 20');\n  }\n  if (salt.length !== 32) {\n    throw new Error('Expected salt to be of length 32');\n  }\n  const address = keccak256(Buffer.from(concatBytes(hexToBytes('0xff'), from, salt, keccak256(Buffer.from(initCode)))));\n  return address.subarray(-20);\n};\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nexport const isValidPrivate = function (privateKey) {\n  try {\n    return privateKeyVerify(privateKey);\n  } catch {\n    return false;\n  }\n};\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexport const isValidPublic = function (publicKey, sanitize = false) {\n  assertIsBytes(publicKey);\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    return publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));\n  }\n  if (!sanitize) {\n    return false;\n  }\n  return publicKeyVerify(publicKey);\n};\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexport const pubToAddress = function (pubKey, sanitize = false) {\n  assertIsBytes(pubKey);\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = Buffer.from(publicKeyConvert(pubKey, false).slice(1));\n  }\n  if (pubKey.length !== 64) {\n    throw new Error('Expected pubKey to be of length 64');\n  }\n  // Only take the lower 160bits of the hash\n  return Buffer.from(keccak256(Buffer.from(pubKey))).slice(-20);\n};\nexport const publicToAddress = pubToAddress;\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexport const privateToPublic = function (privateKey) {\n  assertIsBytes(privateKey);\n  // skip the type flag and use the X, Y points\n  return Buffer.from(publicKeyCreate(privateKey, false)).slice(1);\n};\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexport const privateToAddress = function (privateKey) {\n  return publicToAddress(privateToPublic(privateKey));\n};\n/**\n * Converts a public key to the Ethereum format.\n */\nexport const importPublic = function (publicKey) {\n  assertIsBytes(publicKey);\n  if (publicKey.length !== 64) {\n    publicKey = Buffer.from(publicKeyConvert(publicKey, false).slice(1));\n  }\n  return publicKey;\n};\n/**\n * Returns the zero address.\n */\nexport const zeroAddress = function () {\n  const addressLength = 20;\n  const addr = zeros(addressLength);\n  return bytesToHex(addr);\n};\n/**\n * Checks if a given address is the zero address.\n */\nexport const isZeroAddress = function (hexAddress) {\n  try {\n    assertIsString(hexAddress);\n  } catch (e) {\n    return false;\n  }\n  const zeroAddr = zeroAddress();\n  return zeroAddr === hexAddress;\n};\nexport function accountBodyFromSlim(body) {\n  const [nonce, balance, storageRoot, codeHash] = body;\n  return [nonce, balance, storageRoot.length === 0 ? KECCAK256_RLP : storageRoot, codeHash.length === 0 ? KECCAK256_NULL : codeHash];\n}\nconst emptyUint8Arr = new Uint8Array(0);\nexport function accountBodyToSlim(body) {\n  const [nonce, balance, storageRoot, codeHash] = body;\n  return [nonce, balance, equalsBytes(storageRoot, KECCAK256_RLP) ? emptyUint8Arr : storageRoot, equalsBytes(codeHash, KECCAK256_NULL) ? emptyUint8Arr : codeHash];\n}\n/**\n * Converts a slim account (per snap protocol spec) to the RLP encoded version of the account\n * @param body Array of 4 Uint8Array-like items to represent the account\n * @returns RLP encoded version of the account\n */\nexport function accountBodyToRLP(body, couldBeSlim = true) {\n  const accountBody = couldBeSlim ? accountBodyFromSlim(body) : body;\n  return RLP.encode(accountBody);\n}","map":{"version":3,"names":["RLP","keccak256","privateKeyVerify","publicKeyConvert","publicKeyCreate","publicKeyVerify","bigIntToUnpaddedBytes","bytesToBigInt","bytesToHex","concatBytes","equalsBytes","hexToBytes","toBytes","utf8ToBytes","zeros","BIGINT_0","KECCAK256_NULL","KECCAK256_RLP","assertIsBytes","assertIsHexString","assertIsString","stripHexPrefix","Account","constructor","nonce","balance","storageRoot","codeHash","_validate","fromAccountData","accountData","undefined","fromRlpSerializedAccount","serialized","values","decode","Array","isArray","Error","fromValuesArray","length","raw","serialize","encode","isContract","isEmpty","isValidAddress","hexAddress","e","test","toChecksumAddress","eip1191ChainId","address","toLowerCase","prefix","chainId","toString","bytes","hash","Buffer","from","slice","ret","i","parseInt","toUpperCase","isValidChecksumAddress","generateAddress","Uint8Array","subarray","generateAddress2","salt","initCode","isValidPrivate","privateKey","isValidPublic","publicKey","sanitize","concat","pubToAddress","pubKey","publicToAddress","privateToPublic","privateToAddress","importPublic","zeroAddress","addressLength","addr","isZeroAddress","zeroAddr","accountBodyFromSlim","body","emptyUint8Arr","accountBodyToSlim","accountBodyToRLP","couldBeSlim","accountBody"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\@nomicfoundation\\ethereumjs-util\\src\\account.ts"],"sourcesContent":["import { RLP } from '@nomicfoundation/ethereumjs-rlp'\nimport { keccak256 } from 'ethereum-cryptography/keccak.js'\nimport {\n  privateKeyVerify,\n  publicKeyConvert,\n  publicKeyCreate,\n  publicKeyVerify,\n} from 'ethereum-cryptography/secp256k1'\n\nimport {\n  bigIntToUnpaddedBytes,\n  bytesToBigInt,\n  bytesToHex,\n  concatBytes,\n  equalsBytes,\n  hexToBytes,\n  toBytes,\n  utf8ToBytes,\n  zeros,\n} from './bytes.js'\nimport { BIGINT_0, KECCAK256_NULL, KECCAK256_RLP } from './constants.js'\nimport { assertIsBytes, assertIsHexString, assertIsString } from './helpers.js'\nimport { stripHexPrefix } from './internal.js'\n\nimport type { BigIntLike, BytesLike } from './types.js'\n\nexport interface AccountData {\n  nonce?: BigIntLike\n  balance?: BigIntLike\n  storageRoot?: BytesLike\n  codeHash?: BytesLike\n}\n\nexport type AccountBodyBytes = [Uint8Array, Uint8Array, Uint8Array, Uint8Array]\n\nexport class Account {\n  nonce: bigint\n  balance: bigint\n  storageRoot: Uint8Array\n  codeHash: Uint8Array\n\n  static fromAccountData(accountData: AccountData) {\n    const { nonce, balance, storageRoot, codeHash } = accountData\n\n    return new Account(\n      nonce !== undefined ? bytesToBigInt(toBytes(nonce)) : undefined,\n      balance !== undefined ? bytesToBigInt(toBytes(balance)) : undefined,\n      storageRoot !== undefined ? toBytes(storageRoot) : undefined,\n      codeHash !== undefined ? toBytes(codeHash) : undefined\n    )\n  }\n\n  public static fromRlpSerializedAccount(serialized: Uint8Array) {\n    const values = RLP.decode(serialized) as Uint8Array[]\n\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized account input. Must be array')\n    }\n\n    return this.fromValuesArray(values)\n  }\n\n  public static fromValuesArray(values: Uint8Array[]) {\n    const [nonce, balance, storageRoot, codeHash] = values\n\n    return new Account(bytesToBigInt(nonce), bytesToBigInt(balance), storageRoot, codeHash)\n  }\n\n  /**\n   * This constructor assigns and validates the values.\n   * Use the static factory methods to assist in creating an Account from varying data types.\n   */\n  constructor(\n    nonce = BIGINT_0,\n    balance = BIGINT_0,\n    storageRoot = KECCAK256_RLP,\n    codeHash = KECCAK256_NULL\n  ) {\n    this.nonce = nonce\n    this.balance = balance\n    this.storageRoot = storageRoot\n    this.codeHash = codeHash\n\n    this._validate()\n  }\n\n  private _validate() {\n    if (this.nonce < BIGINT_0) {\n      throw new Error('nonce must be greater than zero')\n    }\n    if (this.balance < BIGINT_0) {\n      throw new Error('balance must be greater than zero')\n    }\n    if (this.storageRoot.length !== 32) {\n      throw new Error('storageRoot must have a length of 32')\n    }\n    if (this.codeHash.length !== 32) {\n      throw new Error('codeHash must have a length of 32')\n    }\n  }\n\n  /**\n   * Returns an array of Uint8Arrays of the raw bytes for the account, in order.\n   */\n  raw(): Uint8Array[] {\n    return [\n      bigIntToUnpaddedBytes(this.nonce),\n      bigIntToUnpaddedBytes(this.balance),\n      this.storageRoot,\n      this.codeHash,\n    ]\n  }\n\n  /**\n   * Returns the RLP serialization of the account as a `Uint8Array`.\n   */\n  serialize(): Uint8Array {\n    return RLP.encode(this.raw())\n  }\n\n  /**\n   * Returns a `Boolean` determining if the account is a contract.\n   */\n  isContract(): boolean {\n    return !equalsBytes(this.codeHash, KECCAK256_NULL)\n  }\n\n  /**\n   * Returns a `Boolean` determining if the account is empty complying to the definition of\n   * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n   * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n   */\n  isEmpty(): boolean {\n    return (\n      this.balance === BIGINT_0 &&\n      this.nonce === BIGINT_0 &&\n      equalsBytes(this.codeHash, KECCAK256_NULL)\n    )\n  }\n}\n\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nexport const isValidAddress = function (hexAddress: string): boolean {\n  try {\n    assertIsString(hexAddress)\n  } catch (e: any) {\n    return false\n  }\n\n  return /^0x[0-9a-fA-F]{40}$/.test(hexAddress)\n}\n\n/**\n * Returns a checksummed address.\n *\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\n * backwards compatible to the original widely adopted checksum format standard introduced in\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\n */\nexport const toChecksumAddress = function (\n  hexAddress: string,\n  eip1191ChainId?: BigIntLike\n): string {\n  assertIsHexString(hexAddress)\n  const address = stripHexPrefix(hexAddress).toLowerCase()\n\n  let prefix = ''\n  if (eip1191ChainId !== undefined) {\n    const chainId = bytesToBigInt(toBytes(eip1191ChainId))\n    prefix = chainId.toString() + '0x'\n  }\n\n  const bytes = utf8ToBytes(prefix + address)\n  const hash = bytesToHex(keccak256(Buffer.from(bytes))).slice(2)\n  let ret = '0x'\n\n  for (let i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase()\n    } else {\n      ret += address[i]\n    }\n  }\n\n  return ret\n}\n\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\nexport const isValidChecksumAddress = function (\n  hexAddress: string,\n  eip1191ChainId?: BigIntLike\n): boolean {\n  return isValidAddress(hexAddress) && toChecksumAddress(hexAddress, eip1191ChainId) === hexAddress\n}\n\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nexport const generateAddress = function (from: Uint8Array, nonce: Uint8Array): Uint8Array {\n  assertIsBytes(from)\n  assertIsBytes(nonce)\n\n  if (bytesToBigInt(nonce) === BIGINT_0) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    return keccak256(Buffer.from(RLP.encode([from, Uint8Array.from([])]))).subarray(-20)\n  }\n\n  // Only take the lower 160bits of the hash\n  return keccak256(Buffer.from(RLP.encode([from, nonce]))).subarray(-20)\n}\n\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nexport const generateAddress2 = function (\n  from: Uint8Array,\n  salt: Uint8Array,\n  initCode: Uint8Array\n): Uint8Array {\n  assertIsBytes(from)\n  assertIsBytes(salt)\n  assertIsBytes(initCode)\n\n  if (from.length !== 20) {\n    throw new Error('Expected from to be of length 20')\n  }\n  if (salt.length !== 32) {\n    throw new Error('Expected salt to be of length 32')\n  }\n\n  const address = keccak256(\n    Buffer.from(concatBytes(hexToBytes('0xff'), from, salt, keccak256(Buffer.from(initCode))))\n  )\n\n  return address.subarray(-20)\n}\n\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nexport const isValidPrivate = function (privateKey: Uint8Array): boolean {\n  try {\n    return privateKeyVerify(privateKey)\n  } catch {\n    return false\n  }\n}\n\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexport const isValidPublic = function (publicKey: Uint8Array, sanitize: boolean = false): boolean {\n  assertIsBytes(publicKey)\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    return publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]))\n  }\n\n  if (!sanitize) {\n    return false\n  }\n\n  return publicKeyVerify(publicKey)\n}\n\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexport const pubToAddress = function (pubKey: Uint8Array, sanitize: boolean = false): Uint8Array {\n  assertIsBytes(pubKey)\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = Buffer.from(publicKeyConvert(pubKey, false).slice(1))\n  }\n  if (pubKey.length !== 64) {\n    throw new Error('Expected pubKey to be of length 64')\n  }\n  // Only take the lower 160bits of the hash\n  return Buffer.from(keccak256(Buffer.from(pubKey))).slice(-20)\n}\nexport const publicToAddress = pubToAddress\n\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexport const privateToPublic = function (privateKey: Uint8Array): Uint8Array {\n  assertIsBytes(privateKey)\n  // skip the type flag and use the X, Y points\n  return Buffer.from(publicKeyCreate(privateKey, false)).slice(1)\n}\n\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexport const privateToAddress = function (privateKey: Uint8Array): Uint8Array {\n  return publicToAddress(privateToPublic(privateKey))\n}\n\n/**\n * Converts a public key to the Ethereum format.\n */\nexport const importPublic = function (publicKey: Uint8Array): Uint8Array {\n  assertIsBytes(publicKey)\n  if (publicKey.length !== 64) {\n    publicKey = Buffer.from(publicKeyConvert(publicKey, false).slice(1))\n  }\n  return publicKey\n}\n\n/**\n * Returns the zero address.\n */\nexport const zeroAddress = function (): string {\n  const addressLength = 20\n  const addr = zeros(addressLength)\n  return bytesToHex(addr)\n}\n\n/**\n * Checks if a given address is the zero address.\n */\nexport const isZeroAddress = function (hexAddress: string): boolean {\n  try {\n    assertIsString(hexAddress)\n  } catch (e: any) {\n    return false\n  }\n\n  const zeroAddr = zeroAddress()\n  return zeroAddr === hexAddress\n}\n\nexport function accountBodyFromSlim(body: AccountBodyBytes) {\n  const [nonce, balance, storageRoot, codeHash] = body\n  return [\n    nonce,\n    balance,\n    storageRoot.length === 0 ? KECCAK256_RLP : storageRoot,\n    codeHash.length === 0 ? KECCAK256_NULL : codeHash,\n  ]\n}\n\nconst emptyUint8Arr = new Uint8Array(0)\nexport function accountBodyToSlim(body: AccountBodyBytes) {\n  const [nonce, balance, storageRoot, codeHash] = body\n  return [\n    nonce,\n    balance,\n    equalsBytes(storageRoot, KECCAK256_RLP) ? emptyUint8Arr : storageRoot,\n    equalsBytes(codeHash, KECCAK256_NULL) ? emptyUint8Arr : codeHash,\n  ]\n}\n\n/**\n * Converts a slim account (per snap protocol spec) to the RLP encoded version of the account\n * @param body Array of 4 Uint8Array-like items to represent the account\n * @returns RLP encoded version of the account\n */\nexport function accountBodyToRLP(body: AccountBodyBytes, couldBeSlim = true) {\n  const accountBody = couldBeSlim ? accountBodyFromSlim(body) : body\n  return RLP.encode(accountBody)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}