{"ast":null,"code":"import { addSpacesFromDelegations, Agent as AccessAgent } from './agent.js';\nimport * as Access from '@web3-storage/capabilities/access';\nimport { bytesToDelegations } from './encoding.js';\nimport { Provider, Plan } from '@web3-storage/capabilities';\nimport * as w3caps from '@web3-storage/capabilities';\nimport { Schema, delegate } from '@ucanto/core';\nimport { AgentData, isSessionProof } from './agent-data.js';\nimport * as DidMailto from '@web3-storage/did-mailto';\nimport * as API from './types.js';\nconst DIDWeb = Schema.DID.match({\n  method: 'web'\n});\n/**\n * Request access by a session allowing this agent to issue UCANs\n * signed by the account.\n *\n * @param {AccessAgent} access\n * @param {API.Principal<API.AccountDID>} account\n * @param {Iterable<{ can: API.Ability }>} capabilities\n */\nexport async function requestAccess(access, account, capabilities) {\n  const res = await access.invokeAndExecute(Access.authorize, {\n    audience: access.connection.id,\n    with: access.issuer.did(),\n    nb: {\n      iss: account.did(),\n      att: [...capabilities]\n    }\n  });\n  if (res?.out.error) {\n    throw res.out.error;\n  }\n}\n/**\n * claim delegations delegated to an audience\n *\n * @param {AccessAgent} access\n * @param {API.DID} [audienceOfClaimedDelegations] - audience of claimed delegations. defaults to access.connection.id.did()\n * @param {object} opts\n * @param {string} [opts.nonce] - nonce to use for the claim\n * @param {boolean} [opts.addProofs] - whether to addProof to access agent\n */\nexport async function claimAccess(access, audienceOfClaimedDelegations = access.connection.id.did(), {\n  addProofs = false,\n  nonce\n} = {}) {\n  const res = await access.invokeAndExecute(Access.claim, {\n    audience: access.connection.id,\n    with: audienceOfClaimedDelegations,\n    nonce\n  });\n  if (res.out.error) {\n    throw res.out.error;\n  }\n  const delegations = Object.values(res.out.ok.delegations).flatMap(bytes => bytesToDelegations(bytes));\n  if (addProofs) {\n    for (const d of delegations) {\n      await access.addProof(d);\n    }\n    await addSpacesFromDelegations(access, delegations);\n  }\n  return delegations;\n}\n/**\n * @param {object} opts\n * @param {AccessAgent} opts.access\n * @param {API.SpaceDID} opts.space\n * @param {API.Principal<API.AccountDID>} opts.account\n * @param {API.ProviderDID} opts.provider - e.g. 'did:web:staging.web3.storage'\n */\nexport async function addProvider({\n  access,\n  space,\n  account,\n  provider\n}) {\n  const result = await access.invokeAndExecute(Provider.add, {\n    audience: access.connection.id,\n    with: account.did(),\n    nb: {\n      provider,\n      consumer: space\n    }\n  });\n  if (result.out.error) {\n    throw result.out.error;\n  }\n}\n/**\n * @typedef {(delegations: API.Delegation[]) => boolean} DelegationsChecker\n */\n/**\n * @type DelegationsChecker\n */\nexport function delegationsIncludeSessionProof(delegations) {\n  return delegations.some(d => isSessionProof(d));\n}\n/**\n * @param {DelegationsChecker} delegationsMatch\n * @param {AccessAgent} access\n * @param {API.DID} delegee\n * @param {object} [opts]\n * @param {number} [opts.interval]\n * @param {AbortSignal} [opts.signal]\n * @returns {Promise<Iterable<API.Delegation>>}\n */\nexport async function pollAccessClaimUntil(delegationsMatch, access, delegee, opts) {\n  const interval = opts?.interval || 250;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (opts?.signal?.aborted) throw opts.signal.reason ?? new Error('operation aborted');\n    const res = await access.invokeAndExecute(w3caps.Access.claim, {\n      with: delegee\n    });\n    if (res.out.error) throw res.out.error;\n    const claims = Object.values(res.out.ok.delegations).flatMap(d => bytesToDelegations(d));\n    if (delegationsMatch(claims)) return claims;\n    await new Promise(resolve => setTimeout(resolve, interval));\n  }\n}\n/**\n * @template [T={}]\n * @typedef {{ signal?: AbortSignal } & T} AuthorizationWaiterOpts\n */\n/**\n * @template [U={}]\n * @typedef {(accessAgent: AccessAgent, opts: AuthorizationWaiterOpts<U>) => Promise<Iterable<API.Delegation>>} AuthorizationWaiter\n */\n/**\n * Wait for authorization process to complete by polling executions of the\n * `access/claim` capability and waiting for the result to include\n * a session delegation.\n *\n * @type AuthorizationWaiter<{interval?: number}>\n */\nexport async function waitForAuthorizationByPolling(access, opts = {}) {\n  const claimed = await pollAccessClaimUntil(delegationsIncludeSessionProof, access, access.issuer.did(), {\n    signal: opts?.signal,\n    interval: opts?.interval\n  });\n  return [...claimed];\n}\n/**\n * Request authorization of a session allowing this agent to issue UCANs\n * signed by the passed email address.\n *\n * @param {AccessAgent} access\n * @param {`${string}@${string}`} email\n * @param {object} [opts]\n * @param {AbortSignal} [opts.signal]\n * @param {boolean} [opts.dontAddProofs] - whether to skip adding proofs to the agent\n * @param {Iterable<{ can: API.Ability }>} [opts.capabilities]\n * @param {AuthorizationWaiter} [opts.expectAuthorization] - function that will resolve once account has confirmed the authorization request\n */\nexport async function authorizeAndWait(access, email, opts = {}) {\n  const expectAuthorization = opts.expectAuthorization || waitForAuthorizationByPolling;\n  const account = {\n    did: () => DidMailto.fromEmail(email)\n  };\n  await requestAccess(access, account, opts?.capabilities || [{\n    can: 'space/*'\n  }, {\n    can: 'store/*'\n  }, {\n    can: 'provider/add'\n  }, {\n    can: 'subscription/list'\n  }, {\n    can: 'upload/*'\n  }, {\n    can: 'ucan/*'\n  }, {\n    can: 'plan/*'\n  }, {\n    can: 'usage/*'\n  }, {\n    can: 'w3up/*'\n  }]);\n  const sessionDelegations = [...(await expectAuthorization(access, opts))];\n  if (!opts?.dontAddProofs) {\n    await Promise.all(sessionDelegations.map(async d => access.addProof(d)));\n  }\n}\n/**\n * Request authorization of a session allowing this agent to issue UCANs\n * signed by the passed email address.\n *\n * @param {AccessAgent} accessAgent\n * @param {`${string}@${string}`} email\n * @param {object} [opts]\n * @param {AbortSignal} [opts.signal]\n * @param {Iterable<{ can: API.Ability }>} [opts.capabilities]\n * @param {boolean} [opts.addProofs]\n * @param {AuthorizationWaiter} [opts.expectAuthorization] - function that will resolve once account has confirmed the authorization request\n */\nexport async function authorizeWaitAndClaim(accessAgent, email, opts) {\n  await authorizeAndWait(accessAgent, email, opts);\n  await claimAccess(accessAgent, accessAgent.issuer.did(), {\n    addProofs: opts?.addProofs ?? true\n  });\n}\n/**\n * Provisions space with the specified account and sets up a recovery with the\n * same account.\n *\n * @param {AccessAgent} access\n * @param {AgentData} agentData\n * @param {string} email\n * @param {object} [opts]\n * @param {AbortSignal} [opts.signal]\n * @param {API.DID<'key'>} [opts.space]\n * @param {API.ProviderDID} [opts.provider] - provider to register - defaults to this.connection.id\n */\nexport async function addProviderAndDelegateToAccount(access, agentData, email, opts) {\n  const space = opts?.space || access.currentSpace();\n  const spaceMeta = space ? agentData.spaces.get(space) : undefined;\n  const provider = opts?.provider || (() => {\n    const service = access.connection.id.did();\n    if (DIDWeb.is(service)) {\n      // connection.id did is a valid provider value. Try using that.\n      return service;\n    }\n    throw new Error(`unable to determine provider to use to addProviderAndDelegateToAccount using access.connection.id did ${service}. expected a did:web:`);\n  })();\n  if (!space || !spaceMeta) {\n    throw new Error('No space selected');\n  }\n  if (spaceMeta) {\n    throw new Error('Space already registered with web3.storage.');\n  }\n  const account = {\n    did: () => DidMailto.fromEmail(DidMailto.email(email))\n  };\n  await addProvider({\n    access,\n    space,\n    account,\n    provider\n  });\n  const delegateSpaceAccessResult = await delegateSpaceAccessToAccount(access, space, account);\n  if (delegateSpaceAccessResult.out.error) {\n    throw delegateSpaceAccessResult.out.error;\n  }\n  await agentData.addSpace(space, spaceMeta);\n}\n/**\n * @param {AccessAgent} access\n * @param {API.SpaceDID} space\n * @param {API.Principal<API.AccountDID>} account\n */\nasync function delegateSpaceAccessToAccount(access, space, account) {\n  const issuerSaysAccountCanAdminSpace = await createIssuerSaysAccountCanAdminSpace(access.issuer, space, account, undefined, access.proofs([{\n    with: space,\n    can: '*'\n  }]),\n  // we want to sign over control of this space forever\n  Infinity);\n  return access.invokeAndExecute(Access.delegate, {\n    audience: access.connection.id,\n    with: space,\n    expiration: Infinity,\n    nb: {\n      delegations: {\n        [issuerSaysAccountCanAdminSpace.cid.toString()]: issuerSaysAccountCanAdminSpace.cid\n      }\n    },\n    proofs: [\n    // must be embedded here because it's referenced by cid in .nb.delegations\n    issuerSaysAccountCanAdminSpace]\n  });\n}\n/**\n * @param {API.Signer<API.DIDKey>} issuer\n * @param {API.SpaceDID} space\n * @param {API.Principal<API.AccountDID>} account\n * @param {API.Capabilities} capabilities\n * @param {API.Delegation[]} proofs\n * @param {number} expiration\n * @returns\n */\nasync function createIssuerSaysAccountCanAdminSpace(issuer, space, account, capabilities = [{\n  can: '*',\n  with: space\n}], proofs = [], expiration) {\n  return delegate({\n    issuer,\n    audience: account,\n    capabilities,\n    proofs,\n    expiration\n  });\n}\n/**\n *\n * @param {AccessAgent} agent\n * @param {API.AccountDID} account\n */\nexport async function getAccountPlan(agent, account) {\n  const receipt = await agent.invokeAndExecute(Plan.get, {\n    with: account\n  });\n  return receipt.out;\n}","map":{"version":3,"names":["addSpacesFromDelegations","Agent","AccessAgent","Access","bytesToDelegations","Provider","Plan","w3caps","Schema","delegate","AgentData","isSessionProof","DidMailto","API","DIDWeb","DID","match","method","requestAccess","access","account","capabilities","res","invokeAndExecute","authorize","audience","connection","id","with","issuer","did","nb","iss","att","out","error","claimAccess","audienceOfClaimedDelegations","addProofs","nonce","claim","delegations","Object","values","ok","flatMap","bytes","d","addProof","addProvider","space","provider","result","add","consumer","delegationsIncludeSessionProof","some","pollAccessClaimUntil","delegationsMatch","delegee","opts","interval","signal","aborted","reason","Error","claims","Promise","resolve","setTimeout","waitForAuthorizationByPolling","claimed","authorizeAndWait","email","expectAuthorization","fromEmail","can","sessionDelegations","dontAddProofs","all","map","authorizeWaitAndClaim","accessAgent","addProviderAndDelegateToAccount","agentData","currentSpace","spaceMeta","spaces","get","undefined","service","is","delegateSpaceAccessResult","delegateSpaceAccessToAccount","addSpace","issuerSaysAccountCanAdminSpace","createIssuerSaysAccountCanAdminSpace","proofs","Infinity","expiration","cid","toString","getAccountPlan","agent","receipt"],"sources":["../../src/agent-use-cases.js"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}