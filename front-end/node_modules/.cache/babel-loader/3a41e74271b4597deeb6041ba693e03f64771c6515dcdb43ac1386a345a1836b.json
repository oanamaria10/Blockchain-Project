{"ast":null,"code":"import * as Layout from \"./api.js\";\nimport * as Chunker from \"./../chunker/api.js\";\n\n/**\n * Type representing a state of the balanced tree. First row hold leaves coming\n * into a builder, once number of leaves in the stack reaches `maxChildren` they\n * are moved into `RootNode` instance which is pushed into the next row of nodes.\n * If next row now contains `maxChildren` nodes from there are again moved into\n * a new `RootNode` and pushed into next row etc...\n *\n * For illustration let's assume we have `maxChildren: 3`, after 3 leafs were\n * added tree will have following layout\n *\n * ```\n *           (root1)\n *              |\n *    ----------------------\n *    |         |          |\n * (leaf1)   (leaf2)    (leaf3)\n * ```\n *\n * Which in our model before flushing is represented as follows:\n *\n * ```js\n * {\n *    width: 3\n *    leafIndex: [leaf1, leaf2, leaf3]\n *    nodeIndex: []\n *    nodes: []\n * }\n * ```\n *\n * After flushing 3 leaves (which is width) are moved into a `RootNode` that\n * is added to `nodes` array (and returned so that caller can create a block).\n * Additionally position of the added node is captured in the `index` at an\n * appropriate depth `0` (that is because we don't count leaves into depth).\n *\n * ```js\n * {\n *    width: 3\n *    leafIndex: []\n *    nodeIndex: [[0]]\n *    nodes: [new RootNode([leaf1, leaf2, leaf3])]\n * }\n * ```\n *\n * Increasing number of leaves to 10 would produce following tree layout\n *\n *```\n *                                                         (root7)\n *                                                           |\n *                                    ------------------------------------------\n *                                    |                                        |\n *                                 (root4)                                  (root6)\n *                                    |                                        |\n *            -------------------------------------------------                |\n *            |                       |                       |                |\n *         (root1)                 (root2)                 (root3)          (root5)\n *            |                       |                       |                |\n *    --------|--------       --------|--------       --------|--------        |\n *    |       |       |       |       |       |       |       |       |        |\n * (leaf1) (leaf2) (leaf3) (leaf4) (leaf5) (leaf6) (leaf7) (leaf8) (leaf9) (leaf10)\n * ```\n *\n * Which in our model will look as follows (note we do not have root5 - root7\n * in model because they are build once width is reached or once builder is\n * closed)\n *\n * ```js\n * {\n *    width: 3\n *    leafIndex: [leaf10]\n *    nodeIndex: [\n *      [0, 1, 2], // [r1, r2, r3]\n *      [3]        // [r4]\n *     ]\n *    nodes: [\n *      new Node([leaf1, leaf2, leaf3]), // r1\n *      new Node([leaf4, leaf5, leaf6]), // r2\n *      new Node([leaf7, leaf8, leaf9]), // r3\n *      new Node([ // r4\n *         new Node([leaf1, leaf2, leaf3]), // r1\n *         new Node([leaf4, leaf5, leaf6]), // r2\n *         new Node([leaf7, leaf8, leaf9]), // r3\n *      ])\n *    ]\n * }\n * ```\n *\n * @typedef {{\n * width: number\n * head: Chunker.Chunk | null\n * leafIndex: number[]\n * nodeIndex: number[][]\n * lastID: number\n * }} Balanced\n */\n\nclass Node {\n  /**\n   *\n   * @param {number} id\n   * @param {number[]} children\n   * @param {Layout.Metadata} [metadata]\n   */\n  constructor(id, children, metadata) {\n    this.id = id;\n    this.children = children;\n    this.metadata = metadata;\n  }\n}\n\n/**\n * @typedef Options\n * @property {number} width - Max children per node.\n *\n * @param {number} width\n * @returns {Layout.LayoutEngine<Balanced>}\n */\nexport const withWidth = width => ({\n  open: () => open({\n    width\n  }),\n  write,\n  close\n});\nexport const defaults = {\n  width: 174\n};\n\n/**\n * @param {Options} options\n * @returns {Balanced}\n */\nexport const open = ({\n  width\n} = defaults) => ({\n  width,\n  head: null,\n  leafIndex: [],\n  nodeIndex: [],\n  lastID: 0\n});\n\n/**\n *\n * @param {Balanced} layout\n * @param {Chunker.Chunk[]} chunks\n * @returns {Layout.WriteResult<Balanced>}\n */\nexport const write = (layout, chunks) => {\n  if (chunks.length === 0) {\n    return {\n      layout,\n      nodes: EMPTY,\n      leaves: EMPTY\n    };\n  } else {\n    let {\n      lastID\n    } = layout;\n    // We need to hold on to the first chunk until we either get a second chunk\n    // (at which point we know our layout will have branches) or until we close\n    // (at which point our layout will be single leaf or node depneding on\n    // metadata)\n    const [head, slices] = layout.head ?\n    // If we had a head we have more then two chunks (we already checked\n    // chunks weren't empty) so we process head along with other chunks.\n    [null, (chunks.unshift(layout.head), chunks)] :\n    // If we have no head no leaves and got only one chunk we have to save it\n    // until we can decide what to do with it.\n    chunks.length === 1 && layout.leafIndex.length === 0 ? [chunks[0], EMPTY] :\n    // Otherwise we have no head but got enough chunks to know we'll have a\n    // node.\n    [null, chunks];\n    if (slices.length === 0) {\n      return {\n        layout: {\n          ...layout,\n          head\n        },\n        nodes: EMPTY,\n        leaves: EMPTY\n      };\n    } else {\n      const leafIndex = [...layout.leafIndex];\n      const leaves = [];\n      for (const chunk of slices) {\n        const leaf = {\n          id: ++lastID,\n          content: chunk\n        };\n        leaves.push(leaf);\n        leafIndex.push(leaf.id);\n      }\n      if (leafIndex.length > layout.width) {\n        return flush({\n          ...layout,\n          leafIndex,\n          head,\n          lastID\n        }, leaves);\n      } else {\n        return {\n          layout: {\n            ...layout,\n            head,\n            leafIndex,\n            lastID\n          },\n          leaves,\n          nodes: EMPTY\n        };\n      }\n    }\n  }\n};\n\n/**\n * @param {Balanced} state\n * @param {Layout.Leaf[]} leaves\n * @param {Layout.Branch[]} [nodes]\n * @param {boolean} [close]\n * @returns {Layout.WriteResult<Balanced>}\n */\nexport const flush = (state, leaves = EMPTY, nodes = [], close = false) => {\n  let {\n    lastID\n  } = state;\n  const nodeIndex = state.nodeIndex.map(row => [...row]);\n  const leafIndex = [...state.leafIndex];\n  const {\n    width\n  } = state;\n\n  // Move leaves into nodes\n  while (leafIndex.length > width || leafIndex.length > 0 && close) {\n    grow(nodeIndex, 1);\n    const node = new Node(++lastID, leafIndex.splice(0, width));\n    nodeIndex[0].push(node.id);\n    nodes.push(node);\n  }\n  let depth = 0;\n  while (depth < nodeIndex.length) {\n    const row = nodeIndex[depth];\n    depth++;\n    while (row.length > width || row.length > 0 && close && depth < nodeIndex.length) {\n      const node = new Node(++lastID, row.splice(0, width));\n      grow(nodeIndex, depth + 1);\n      nodeIndex[depth].push(node.id);\n      nodes.push(node);\n    }\n  }\n  return {\n    layout: {\n      ...state,\n      lastID,\n      leafIndex,\n      nodeIndex\n    },\n    leaves,\n    nodes\n  };\n};\n\n/**\n * @param {Balanced} layout\n * @param {Layout.Metadata} [metadata]\n * @returns {Layout.CloseResult}\n */\nexport const close = (layout, metadata) => {\n  const state = layout;\n  if (layout.head) {\n    return {\n      root: {\n        id: 1,\n        content: layout.head,\n        metadata\n      },\n      leaves: EMPTY,\n      nodes: EMPTY\n    };\n  } else if (layout.leafIndex.length === 0) {\n    return {\n      root: {\n        id: 1,\n        metadata\n      },\n      leaves: EMPTY,\n      nodes: EMPTY\n    };\n  } else {\n    // Flush with width 1 so all the items will be propagate up the tree\n    // and height of `depth-1` so we propagate nodes all but from the top\n    // most level\n    const {\n      nodes,\n      layout\n    } = flush(state, EMPTY, [], true);\n    const {\n      nodeIndex\n    } = layout;\n    const height = nodeIndex.length - 1;\n    const top = nodeIndex[height];\n    if (top.length === 1) {\n      const root = nodes[nodes.length - 1];\n      nodes.length = nodes.length - 1;\n      return {\n        root,\n        nodes,\n        leaves: EMPTY\n      };\n    } else {\n      const root = new Node(layout.lastID + 1, top, metadata);\n      return {\n        root,\n        nodes,\n        leaves: EMPTY\n      };\n    }\n  }\n};\n\n/**\n * @template T\n * @param {T[][]} index\n * @param {number} length\n */\nconst grow = (index, length) => {\n  while (index.length < length) {\n    index.push([]);\n  }\n  return index;\n};\n\n/** @type {never[]} */\nconst EMPTY = [];","map":{"version":3,"names":["Layout","Chunker","Node","constructor","id","children","metadata","withWidth","width","open","write","close","defaults","head","leafIndex","nodeIndex","lastID","layout","chunks","length","nodes","EMPTY","leaves","slices","unshift","chunk","leaf","content","push","flush","state","map","row","grow","node","splice","depth","root","height","top","index"],"sources":["C:/FACULTATE/Proiect/node_modules/@ipld/unixfs/src/file/layout/balanced.js"],"sourcesContent":["import * as Layout from \"./api.js\"\nimport * as Chunker from \"./../chunker/api.js\"\n\n/**\n * Type representing a state of the balanced tree. First row hold leaves coming\n * into a builder, once number of leaves in the stack reaches `maxChildren` they\n * are moved into `RootNode` instance which is pushed into the next row of nodes.\n * If next row now contains `maxChildren` nodes from there are again moved into\n * a new `RootNode` and pushed into next row etc...\n *\n * For illustration let's assume we have `maxChildren: 3`, after 3 leafs were\n * added tree will have following layout\n *\n * ```\n *           (root1)\n *              |\n *    ----------------------\n *    |         |          |\n * (leaf1)   (leaf2)    (leaf3)\n * ```\n *\n * Which in our model before flushing is represented as follows:\n *\n * ```js\n * {\n *    width: 3\n *    leafIndex: [leaf1, leaf2, leaf3]\n *    nodeIndex: []\n *    nodes: []\n * }\n * ```\n *\n * After flushing 3 leaves (which is width) are moved into a `RootNode` that\n * is added to `nodes` array (and returned so that caller can create a block).\n * Additionally position of the added node is captured in the `index` at an\n * appropriate depth `0` (that is because we don't count leaves into depth).\n *\n * ```js\n * {\n *    width: 3\n *    leafIndex: []\n *    nodeIndex: [[0]]\n *    nodes: [new RootNode([leaf1, leaf2, leaf3])]\n * }\n * ```\n *\n * Increasing number of leaves to 10 would produce following tree layout\n *\n *```\n *                                                         (root7)\n *                                                           |\n *                                    ------------------------------------------\n *                                    |                                        |\n *                                 (root4)                                  (root6)\n *                                    |                                        |\n *            -------------------------------------------------                |\n *            |                       |                       |                |\n *         (root1)                 (root2)                 (root3)          (root5)\n *            |                       |                       |                |\n *    --------|--------       --------|--------       --------|--------        |\n *    |       |       |       |       |       |       |       |       |        |\n * (leaf1) (leaf2) (leaf3) (leaf4) (leaf5) (leaf6) (leaf7) (leaf8) (leaf9) (leaf10)\n * ```\n *\n * Which in our model will look as follows (note we do not have root5 - root7\n * in model because they are build once width is reached or once builder is\n * closed)\n *\n * ```js\n * {\n *    width: 3\n *    leafIndex: [leaf10]\n *    nodeIndex: [\n *      [0, 1, 2], // [r1, r2, r3]\n *      [3]        // [r4]\n *     ]\n *    nodes: [\n *      new Node([leaf1, leaf2, leaf3]), // r1\n *      new Node([leaf4, leaf5, leaf6]), // r2\n *      new Node([leaf7, leaf8, leaf9]), // r3\n *      new Node([ // r4\n *         new Node([leaf1, leaf2, leaf3]), // r1\n *         new Node([leaf4, leaf5, leaf6]), // r2\n *         new Node([leaf7, leaf8, leaf9]), // r3\n *      ])\n *    ]\n * }\n * ```\n *\n * @typedef {{\n * width: number\n * head: Chunker.Chunk | null\n * leafIndex: number[]\n * nodeIndex: number[][]\n * lastID: number\n * }} Balanced\n */\n\nclass Node {\n  /**\n   *\n   * @param {number} id\n   * @param {number[]} children\n   * @param {Layout.Metadata} [metadata]\n   */\n  constructor(id, children, metadata) {\n    this.id = id\n    this.children = children\n    this.metadata = metadata\n  }\n}\n\n/**\n * @typedef Options\n * @property {number} width - Max children per node.\n *\n * @param {number} width\n * @returns {Layout.LayoutEngine<Balanced>}\n */\nexport const withWidth = width => ({\n  open: () => open({ width }),\n  write,\n  close,\n})\n\nexport const defaults = { width: 174 }\n\n/**\n * @param {Options} options\n * @returns {Balanced}\n */\nexport const open = ({ width } = defaults) => ({\n  width,\n\n  head: null,\n  leafIndex: [],\n  nodeIndex: [],\n  lastID: 0,\n})\n\n/**\n *\n * @param {Balanced} layout\n * @param {Chunker.Chunk[]} chunks\n * @returns {Layout.WriteResult<Balanced>}\n */\nexport const write = (layout, chunks) => {\n  if (chunks.length === 0) {\n    return { layout, nodes: EMPTY, leaves: EMPTY }\n  } else {\n    let { lastID } = layout\n    // We need to hold on to the first chunk until we either get a second chunk\n    // (at which point we know our layout will have branches) or until we close\n    // (at which point our layout will be single leaf or node depneding on\n    // metadata)\n    const [head, slices] = layout.head\n      ? // If we had a head we have more then two chunks (we already checked\n        // chunks weren't empty) so we process head along with other chunks.\n        [null, (chunks.unshift(layout.head), chunks)]\n      : // If we have no head no leaves and got only one chunk we have to save it\n      // until we can decide what to do with it.\n      chunks.length === 1 && layout.leafIndex.length === 0\n      ? [chunks[0], EMPTY]\n      : // Otherwise we have no head but got enough chunks to know we'll have a\n        // node.\n        [null, chunks]\n\n    if (slices.length === 0) {\n      return { layout: { ...layout, head }, nodes: EMPTY, leaves: EMPTY }\n    } else {\n      const leafIndex = [...layout.leafIndex]\n      const leaves = []\n      for (const chunk of slices) {\n        const leaf = { id: ++lastID, content: chunk }\n        leaves.push(leaf)\n        leafIndex.push(leaf.id)\n      }\n\n      if (leafIndex.length > layout.width) {\n        return flush({ ...layout, leafIndex, head, lastID }, leaves)\n      } else {\n        return {\n          layout: { ...layout, head, leafIndex, lastID },\n          leaves,\n          nodes: EMPTY,\n        }\n      }\n    }\n  }\n}\n\n/**\n * @param {Balanced} state\n * @param {Layout.Leaf[]} leaves\n * @param {Layout.Branch[]} [nodes]\n * @param {boolean} [close]\n * @returns {Layout.WriteResult<Balanced>}\n */\nexport const flush = (state, leaves = EMPTY, nodes = [], close = false) => {\n  let { lastID } = state\n  const nodeIndex = state.nodeIndex.map(row => [...row])\n  const leafIndex = [...state.leafIndex]\n  const { width } = state\n\n  // Move leaves into nodes\n  while (leafIndex.length > width || (leafIndex.length > 0 && close)) {\n    grow(nodeIndex, 1)\n    const node = new Node(++lastID, leafIndex.splice(0, width))\n    nodeIndex[0].push(node.id)\n    nodes.push(node)\n  }\n\n  let depth = 0\n  while (depth < nodeIndex.length) {\n    const row = nodeIndex[depth]\n    depth++\n\n    while (\n      row.length > width ||\n      (row.length > 0 && close && depth < nodeIndex.length)\n    ) {\n      const node = new Node(++lastID, row.splice(0, width))\n      grow(nodeIndex, depth + 1)\n      nodeIndex[depth].push(node.id)\n      nodes.push(node)\n    }\n  }\n\n  return { layout: { ...state, lastID, leafIndex, nodeIndex }, leaves, nodes }\n}\n\n/**\n * @param {Balanced} layout\n * @param {Layout.Metadata} [metadata]\n * @returns {Layout.CloseResult}\n */\nexport const close = (layout, metadata) => {\n  const state = layout\n  if (layout.head) {\n    return {\n      root: { id: 1, content: layout.head, metadata },\n      leaves: EMPTY,\n      nodes: EMPTY,\n    }\n  } else if (layout.leafIndex.length === 0) {\n    return {\n      root: { id: 1, metadata },\n      leaves: EMPTY,\n      nodes: EMPTY,\n    }\n  } else {\n    // Flush with width 1 so all the items will be propagate up the tree\n    // and height of `depth-1` so we propagate nodes all but from the top\n    // most level\n    const { nodes, layout } = flush(state, EMPTY, [], true)\n\n    const { nodeIndex } = layout\n    const height = nodeIndex.length - 1\n\n    const top = nodeIndex[height]\n    if (top.length === 1) {\n      const root = nodes[nodes.length - 1]\n      nodes.length = nodes.length - 1\n      return { root, nodes, leaves: EMPTY }\n    } else {\n      const root = new Node(layout.lastID + 1, top, metadata)\n      return { root, nodes, leaves: EMPTY }\n    }\n  }\n}\n\n/**\n * @template T\n * @param {T[][]} index\n * @param {number} length\n */\nconst grow = (index, length) => {\n  while (index.length < length) {\n    index.push([])\n  }\n  return index\n}\n\n/** @type {never[]} */\nconst EMPTY = []\n"],"mappings":"AAAA,OAAO,KAAKA,MAAM,MAAM,UAAU;AAClC,OAAO,KAAKC,OAAO,MAAM,qBAAqB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,IAAI,CAAC;EACT;AACF;AACA;AACA;AACA;AACA;EACEC,WAAWA,CAACC,EAAE,EAAEC,QAAQ,EAAEC,QAAQ,EAAE;IAClC,IAAI,CAACF,EAAE,GAAGA,EAAE;IACZ,IAAI,CAACC,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,QAAQ,GAAGA,QAAQ;EAC1B;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,SAAS,GAAGC,KAAK,KAAK;EACjCC,IAAI,EAAEA,CAAA,KAAMA,IAAI,CAAC;IAAED;EAAM,CAAC,CAAC;EAC3BE,KAAK;EACLC;AACF,CAAC,CAAC;AAEF,OAAO,MAAMC,QAAQ,GAAG;EAAEJ,KAAK,EAAE;AAAI,CAAC;;AAEtC;AACA;AACA;AACA;AACA,OAAO,MAAMC,IAAI,GAAGA,CAAC;EAAED;AAAM,CAAC,GAAGI,QAAQ,MAAM;EAC7CJ,KAAK;EAELK,IAAI,EAAE,IAAI;EACVC,SAAS,EAAE,EAAE;EACbC,SAAS,EAAE,EAAE;EACbC,MAAM,EAAE;AACV,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,M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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}