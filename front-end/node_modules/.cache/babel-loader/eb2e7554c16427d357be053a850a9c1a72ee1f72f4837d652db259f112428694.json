{"ast":null,"code":"import * as API from '@ucanto/interface';\nimport { create, createLegacy, isLink, parse, base32 } from '../link.js';\nimport * as Schema from './schema.js';\nexport { create, createLegacy, isLink, parse };\n\n/**\n * @template {number} [Code=number]\n * @template {number} [Alg=number]\n * @template {1|0} [Version=0|1]\n * @typedef {{\n * code?:Code,\n * version?:Version\n * multihash?: {code?: Alg, digest?: Uint8Array}\n * }} Settings\n */\n\n/**\n * @template {number} Code\n * @template {number} Alg\n * @template {1|0} Version\n * @extends {Schema.API<API.Link<unknown, Code, Alg, Version>, unknown, Settings<Code, Alg, Version>>}\n */\nclass LinkSchema extends Schema.API {\n  /**\n   *\n   * @param {unknown} cid\n   * @param {Settings<Code, Alg, Version>} settings\n   * @returns {Schema.ReadResult<API.Link<unknown, Code, Alg, Version>>}\n   */\n  readWith(cid, {\n    code,\n    multihash = {},\n    version\n  }) {\n    if (cid == null) {\n      return Schema.error(`Expected link but got ${cid} instead`);\n    } else {\n      if (!isLink(cid)) {\n        return Schema.error(`Expected link to be a CID instead of ${cid}`);\n      } else {\n        if (code != null && cid.code !== code) {\n          return Schema.error(`Expected link to be CID with 0x${code.toString(16)} codec`);\n        }\n        if (multihash.code != null && cid.multihash.code !== multihash.code) return Schema.error(`Expected link to be CID with 0x${multihash.code.toString(16)} hashing algorithm`);\n        if (version != null && cid.version !== version) {\n          return Schema.error(`Expected link to be CID version ${version} instead of ${cid.version}`);\n        }\n        const [expectDigest, actualDigest] = multihash.digest != null ? [base32.baseEncode(multihash.digest), base32.baseEncode(cid.multihash.digest)] : ['', ''];\n        if (expectDigest !== actualDigest) {\n          return Schema.error(`Expected link with \"${expectDigest}\" hash digest instead of \"${actualDigest}\"`);\n        }\n        return {\n          ok: ( /** @type {API.Link<unknown, any, any, any>} */cid)\n        };\n      }\n    }\n  }\n}\n\n/** @type {Schema.Schema<API.Link<unknown, number, number, 0|1>, unknown>}  */\nexport const schema = new LinkSchema({});\nexport const link = () => schema;\n\n/**\n * @template {number} Code\n * @template {number} Alg\n * @template {1|0} Version\n * @param {Settings<Code, Alg, Version>} options\n * @returns {Schema.Schema<API.Link<unknown, Code, Alg, Version>>}\n */\nexport const match = (options = {}) => new LinkSchema(options);\n\n/**\n * @param {unknown} input\n */\nexport const read = input => schema.read(input);\nexport const optional = () => schema.optional();","map":{"version":3,"names":["API","create","createLegacy","isLink","parse","base32","Schema","LinkSchema","readWith","cid","code","multihash","version","error","toString","expectDigest","actualDigest","digest","baseEncode","ok","schema","link","match","options","read","input","optional"],"sources":["C:/FACULTATE/Proiect/node_modules/@ucanto/core/src/schema/link.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport { create, createLegacy, isLink, parse, base32 } from '../link.js'\nimport * as Schema from './schema.js'\n\nexport { create, createLegacy, isLink, parse }\n\n/**\n * @template {number} [Code=number]\n * @template {number} [Alg=number]\n * @template {1|0} [Version=0|1]\n * @typedef {{\n * code?:Code,\n * version?:Version\n * multihash?: {code?: Alg, digest?: Uint8Array}\n * }} Settings\n */\n\n/**\n * @template {number} Code\n * @template {number} Alg\n * @template {1|0} Version\n * @extends {Schema.API<API.Link<unknown, Code, Alg, Version>, unknown, Settings<Code, Alg, Version>>}\n */\nclass LinkSchema extends Schema.API {\n  /**\n   *\n   * @param {unknown} cid\n   * @param {Settings<Code, Alg, Version>} settings\n   * @returns {Schema.ReadResult<API.Link<unknown, Code, Alg, Version>>}\n   */\n  readWith(cid, { code, multihash = {}, version }) {\n    if (cid == null) {\n      return Schema.error(`Expected link but got ${cid} instead`)\n    } else {\n      if (!isLink(cid)) {\n        return Schema.error(`Expected link to be a CID instead of ${cid}`)\n      } else {\n        if (code != null && cid.code !== code) {\n          return Schema.error(\n            `Expected link to be CID with 0x${code.toString(16)} codec`\n          )\n        }\n\n        if (multihash.code != null && cid.multihash.code !== multihash.code)\n          return Schema.error(\n            `Expected link to be CID with 0x${multihash.code.toString(\n              16\n            )} hashing algorithm`\n          )\n\n        if (version != null && cid.version !== version) {\n          return Schema.error(\n            `Expected link to be CID version ${version} instead of ${cid.version}`\n          )\n        }\n\n        const [expectDigest, actualDigest] =\n          multihash.digest != null\n            ? [\n                base32.baseEncode(multihash.digest),\n                base32.baseEncode(cid.multihash.digest),\n              ]\n            : ['', '']\n\n        if (expectDigest !== actualDigest) {\n          return Schema.error(\n            `Expected link with \"${expectDigest}\" hash digest instead of \"${actualDigest}\"`\n          )\n        }\n\n        return {\n          ok: /** @type {API.Link<unknown, any, any, any>} */ (cid),\n        }\n      }\n    }\n  }\n}\n\n/** @type {Schema.Schema<API.Link<unknown, number, number, 0|1>, unknown>}  */\nexport const schema = new LinkSchema({})\n\nexport const link = () => schema\n\n/**\n * @template {number} Code\n * @template {number} Alg\n * @template {1|0} Version\n * @param {Settings<Code, Alg, Version>} options\n * @returns {Schema.Schema<API.Link<unknown, Code, Alg, Version>>}\n */\nexport const match = (options = {}) => new LinkSchema(options)\n\n/**\n * @param {unknown} input\n */\nexport const read = input => schema.read(input)\n\nexport const optional = () => schema.optional()\n"],"mappings":"AAAA,OAAO,KAAKA,GAAG,MAAM,mBAAmB;AACxC,SAASC,MAAM,EAAEC,YAAY,EAAEC,MAAM,EAAEC,KAAK,EAAEC,MAAM,QAAQ,YAAY;AACxE,OAAO,KAAKC,MAAM,MAAM,aAAa;AAErC,SAASL,MAAM,EAAEC,YAAY,EAAEC,MAAM,EAAEC,KAAK;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMG,UAAU,SAASD,MAAM,CAACN,GAAG,CAAC;EAClC;AACF;AACA;AACA;AACA;AACA;EACEQ,QAAQA,CAACC,GAAG,EAAE;IAAEC,IAAI;IAAEC,SAAS,GAAG,CAAC,CAAC;IAAEC;EAAQ,CAAC,EAAE;IAC/C,IAAIH,GAAG,IAAI,IAAI,EAAE;MACf,OAAOH,MAAM,CAACO,KAAK,CAAE,yBAAwBJ,GAAI,UAAS,CAAC;IAC7D,CAAC,MAAM;MACL,IAAI,CAACN,MAAM,CAACM,GAAG,CAAC,EAAE;QAChB,OAAOH,MAAM,CAACO,KAAK,CAAE,wCAAuCJ,GAAI,EAAC,CAAC;MACpE,CAAC,MAAM;QACL,IAAIC,IAAI,IAAI,IAAI,IAAID,GAAG,CAACC,IAAI,KAAKA,IAAI,EAAE;UACrC,OAAOJ,MAAM,CAACO,KAAK,CAChB,kCAAiCH,IAAI,CAACI,QAAQ,CAAC,EAAE,CAAE,QACtD,CAAC;QACH;QAEA,IAAIH,SAAS,CAACD,IAAI,IAAI,IAAI,IAAID,GAAG,CAACE,SAAS,CAACD,IAAI,KAAKC,SAAS,CAACD,IAAI,EACjE,OAAOJ,MAAM,CAACO,KAAK,CAChB,kCAAiCF,SAAS,CAACD,IAAI,CAACI,QAAQ,CACvD,EACF,CAAE,oBACJ,CAAC;QAEH,IAAIF,OAAO,IAAI,IAAI,IAAIH,GAAG,CAACG,OAAO,KAAKA,OAAO,EAAE;UAC9C,OAAON,MAAM,CAACO,KAAK,CAChB,mCAAkCD,OAAQ,eAAcH,GAAG,CAACG,OAAQ,EACvE,CAAC;QACH;QAEA,MAAM,CAACG,YAAY,EAAEC,YAAY,CAAC,GAChCL,SAAS,CAACM,MAAM,IAAI,IAAI,GACpB,CACEZ,MAAM,CAACa,UAAU,CAACP,SAAS,CAACM,MAAM,CAAC,EACnCZ,MAAM,CAACa,UAAU,CAACT,GAAG,CAACE,SAAS,CAACM,MAAM,CAAC,CACxC,GACD,CAAC,EAAE,EAAE,EAAE,CAAC;QAEd,IAAIF,YAAY,KAAKC,YAAY,EAAE;UACjC,OAAOV,MAAM,CAACO,KAAK,CAChB,uBAAsBE,YAAa,6BAA4BC,YAAa,GAC/E,CAAC;QACH;QAEA,OAAO;UACLG,EAAE,IAAE,+CAAiDV,GAAG;QAC1D,CAAC;MACH;IACF;EACF;AACF;;AAEA;AACA,OAAO,MAAMW,MAAM,GAAG,IAAIb,UAAU,CAAC,CAAC,CAAC,CAAC;AAExC,OAAO,MAAMc,IAAI,GAAGA,CAAA,KAAMD,MAAM;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAME,KAAK,GAAGA,CAACC,OAAO,GAAG,CAAC,CAAC,KAAK,IAAIhB,UAAU,CAACgB,OAAO,CAAC;;AAE9D;AACA;AACA;AACA,OAAO,MAAMC,IAAI,GAAGC,KAAK,IAAIL,MAAM,CAACI,IAAI,CAACC,KAAK,CAAC;AAE/C,OAAO,MAAMC,QAAQ,GAAGA,CAAA,KAAMN,MAAM,CAACM,QAAQ,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}