{"ast":null,"code":"'use strict';\n\nconst {\n  InvalidArgumentError,\n  NotSupportedError\n} = require('./errors');\nconst assert = require('assert');\nconst {\n  kHTTP2BuildRequest,\n  kHTTP2CopyHeaders,\n  kHTTP1BuildRequest\n} = require('./symbols');\nconst util = require('./util');\n\n// tokenRegExp and headerCharRegex have been lifted from\n// https://github.com/nodejs/node/blob/main/lib/_http_common.js\n\n/**\n * Verifies that the given val is a valid HTTP token\n * per the rules defined in RFC 7230\n * See https://tools.ietf.org/html/rfc7230#section-3.2.6\n */\nconst tokenRegExp = /^[\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]+$/;\n\n/**\n * Matches if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n */\nconst headerCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\n\n// Verifies that a given path is valid does not contain control chars \\x00 to \\x20\nconst invalidPathRegex = /[^\\u0021-\\u00ff]/;\nconst kHandler = Symbol('handler');\nconst channels = {};\nlet extractBody;\ntry {\n  const diagnosticsChannel = require('diagnostics_channel');\n  channels.create = diagnosticsChannel.channel('undici:request:create');\n  channels.bodySent = diagnosticsChannel.channel('undici:request:bodySent');\n  channels.headers = diagnosticsChannel.channel('undici:request:headers');\n  channels.trailers = diagnosticsChannel.channel('undici:request:trailers');\n  channels.error = diagnosticsChannel.channel('undici:request:error');\n} catch {\n  channels.create = {\n    hasSubscribers: false\n  };\n  channels.bodySent = {\n    hasSubscribers: false\n  };\n  channels.headers = {\n    hasSubscribers: false\n  };\n  channels.trailers = {\n    hasSubscribers: false\n  };\n  channels.error = {\n    hasSubscribers: false\n  };\n}\nclass Request {\n  constructor(origin, {\n    path,\n    method,\n    body,\n    headers,\n    query,\n    idempotent,\n    blocking,\n    upgrade,\n    headersTimeout,\n    bodyTimeout,\n    reset,\n    throwOnError,\n    expectContinue\n  }, handler) {\n    if (typeof path !== 'string') {\n      throw new InvalidArgumentError('path must be a string');\n    } else if (path[0] !== '/' && !(path.startsWith('http://') || path.startsWith('https://')) && method !== 'CONNECT') {\n      throw new InvalidArgumentError('path must be an absolute URL or start with a slash');\n    } else if (invalidPathRegex.exec(path) !== null) {\n      throw new InvalidArgumentError('invalid request path');\n    }\n    if (typeof method !== 'string') {\n      throw new InvalidArgumentError('method must be a string');\n    } else if (tokenRegExp.exec(method) === null) {\n      throw new InvalidArgumentError('invalid request method');\n    }\n    if (upgrade && typeof upgrade !== 'string') {\n      throw new InvalidArgumentError('upgrade must be a string');\n    }\n    if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('invalid headersTimeout');\n    }\n    if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('invalid bodyTimeout');\n    }\n    if (reset != null && typeof reset !== 'boolean') {\n      throw new InvalidArgumentError('invalid reset');\n    }\n    if (expectContinue != null && typeof expectContinue !== 'boolean') {\n      throw new InvalidArgumentError('invalid expectContinue');\n    }\n    this.headersTimeout = headersTimeout;\n    this.bodyTimeout = bodyTimeout;\n    this.throwOnError = throwOnError === true;\n    this.method = method;\n    this.abort = null;\n    if (body == null) {\n      this.body = null;\n    } else if (util.isStream(body)) {\n      this.body = body;\n      const rState = this.body._readableState;\n      if (!rState || !rState.autoDestroy) {\n        this.endHandler = function autoDestroy() {\n          util.destroy(this);\n        };\n        this.body.on('end', this.endHandler);\n      }\n      this.errorHandler = err => {\n        if (this.abort) {\n          this.abort(err);\n        } else {\n          this.error = err;\n        }\n      };\n      this.body.on('error', this.errorHandler);\n    } else if (util.isBuffer(body)) {\n      this.body = body.byteLength ? body : null;\n    } else if (ArrayBuffer.isView(body)) {\n      this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;\n    } else if (body instanceof ArrayBuffer) {\n      this.body = body.byteLength ? Buffer.from(body) : null;\n    } else if (typeof body === 'string') {\n      this.body = body.length ? Buffer.from(body) : null;\n    } else if (util.isFormDataLike(body) || util.isIterable(body) || util.isBlobLike(body)) {\n      this.body = body;\n    } else {\n      throw new InvalidArgumentError('body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable');\n    }\n    this.completed = false;\n    this.aborted = false;\n    this.upgrade = upgrade || null;\n    this.path = query ? util.buildURL(path, query) : path;\n    this.origin = origin;\n    this.idempotent = idempotent == null ? method === 'HEAD' || method === 'GET' : idempotent;\n    this.blocking = blocking == null ? false : blocking;\n    this.reset = reset == null ? null : reset;\n    this.host = null;\n    this.contentLength = null;\n    this.contentType = null;\n    this.headers = '';\n\n    // Only for H2\n    this.expectContinue = expectContinue != null ? expectContinue : false;\n    if (Array.isArray(headers)) {\n      if (headers.length % 2 !== 0) {\n        throw new InvalidArgumentError('headers array must be even');\n      }\n      for (let i = 0; i < headers.length; i += 2) {\n        processHeader(this, headers[i], headers[i + 1]);\n      }\n    } else if (headers && typeof headers === 'object') {\n      const keys = Object.keys(headers);\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        processHeader(this, key, headers[key]);\n      }\n    } else if (headers != null) {\n      throw new InvalidArgumentError('headers must be an object or an array');\n    }\n    if (util.isFormDataLike(this.body)) {\n      if (util.nodeMajor < 16 || util.nodeMajor === 16 && util.nodeMinor < 8) {\n        throw new InvalidArgumentError('Form-Data bodies are only supported in node v16.8 and newer.');\n      }\n      if (!extractBody) {\n        extractBody = require('../fetch/body.js').extractBody;\n      }\n      const [bodyStream, contentType] = extractBody(body);\n      if (this.contentType == null) {\n        this.contentType = contentType;\n        this.headers += `content-type: ${contentType}\\r\\n`;\n      }\n      this.body = bodyStream.stream;\n      this.contentLength = bodyStream.length;\n    } else if (util.isBlobLike(body) && this.contentType == null && body.type) {\n      this.contentType = body.type;\n      this.headers += `content-type: ${body.type}\\r\\n`;\n    }\n    util.validateHandler(handler, method, upgrade);\n    this.servername = util.getServerName(this.host);\n    this[kHandler] = handler;\n    if (channels.create.hasSubscribers) {\n      channels.create.publish({\n        request: this\n      });\n    }\n  }\n  onBodySent(chunk) {\n    if (this[kHandler].onBodySent) {\n      try {\n        return this[kHandler].onBodySent(chunk);\n      } catch (err) {\n        this.abort(err);\n      }\n    }\n  }\n  onRequestSent() {\n    if (channels.bodySent.hasSubscribers) {\n      channels.bodySent.publish({\n        request: this\n      });\n    }\n    if (this[kHandler].onRequestSent) {\n      try {\n        return this[kHandler].onRequestSent();\n      } catch (err) {\n        this.abort(err);\n      }\n    }\n  }\n  onConnect(abort) {\n    assert(!this.aborted);\n    assert(!this.completed);\n    if (this.error) {\n      abort(this.error);\n    } else {\n      this.abort = abort;\n      return this[kHandler].onConnect(abort);\n    }\n  }\n  onHeaders(statusCode, headers, resume, statusText) {\n    assert(!this.aborted);\n    assert(!this.completed);\n    if (channels.headers.hasSubscribers) {\n      channels.headers.publish({\n        request: this,\n        response: {\n          statusCode,\n          headers,\n          statusText\n        }\n      });\n    }\n    try {\n      return this[kHandler].onHeaders(statusCode, headers, resume, statusText);\n    } catch (err) {\n      this.abort(err);\n    }\n  }\n  onData(chunk) {\n    assert(!this.aborted);\n    assert(!this.completed);\n    try {\n      return this[kHandler].onData(chunk);\n    } catch (err) {\n      this.abort(err);\n      return false;\n    }\n  }\n  onUpgrade(statusCode, headers, socket) {\n    assert(!this.aborted);\n    assert(!this.completed);\n    return this[kHandler].onUpgrade(statusCode, headers, socket);\n  }\n  onComplete(trailers) {\n    this.onFinally();\n    assert(!this.aborted);\n    this.completed = true;\n    if (channels.trailers.hasSubscribers) {\n      channels.trailers.publish({\n        request: this,\n        trailers\n      });\n    }\n    try {\n      return this[kHandler].onComplete(trailers);\n    } catch (err) {\n      // TODO (fix): This might be a bad idea?\n      this.onError(err);\n    }\n  }\n  onError(error) {\n    this.onFinally();\n    if (channels.error.hasSubscribers) {\n      channels.error.publish({\n        request: this,\n        error\n      });\n    }\n    if (this.aborted) {\n      return;\n    }\n    this.aborted = true;\n    return this[kHandler].onError(error);\n  }\n  onFinally() {\n    if (this.errorHandler) {\n      this.body.off('error', this.errorHandler);\n      this.errorHandler = null;\n    }\n    if (this.endHandler) {\n      this.body.off('end', this.endHandler);\n      this.endHandler = null;\n    }\n  }\n\n  // TODO: adjust to support H2\n  addHeader(key, value) {\n    processHeader(this, key, value);\n    return this;\n  }\n  static [kHTTP1BuildRequest](origin, opts, handler) {\n    // TODO: Migrate header parsing here, to make Requests\n    // HTTP agnostic\n    return new Request(origin, opts, handler);\n  }\n  static [kHTTP2BuildRequest](origin, opts, handler) {\n    const headers = opts.headers;\n    opts = {\n      ...opts,\n      headers: null\n    };\n    const request = new Request(origin, opts, handler);\n    request.headers = {};\n    if (Array.isArray(headers)) {\n      if (headers.length % 2 !== 0) {\n        throw new InvalidArgumentError('headers array must be even');\n      }\n      for (let i = 0; i < headers.length; i += 2) {\n        processHeader(request, headers[i], headers[i + 1], true);\n      }\n    } else if (headers && typeof headers === 'object') {\n      const keys = Object.keys(headers);\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        processHeader(request, key, headers[key], true);\n      }\n    } else if (headers != null) {\n      throw new InvalidArgumentError('headers must be an object or an array');\n    }\n    return request;\n  }\n  static [kHTTP2CopyHeaders](raw) {\n    const rawHeaders = raw.split('\\r\\n');\n    const headers = {};\n    for (const header of rawHeaders) {\n      const [key, value] = header.split(': ');\n      if (value == null || value.length === 0) continue;\n      if (headers[key]) headers[key] += `,${value}`;else headers[key] = value;\n    }\n    return headers;\n  }\n}\nfunction processHeaderValue(key, val, skipAppend) {\n  if (val && typeof val === 'object') {\n    throw new InvalidArgumentError(`invalid ${key} header`);\n  }\n  val = val != null ? `${val}` : '';\n  if (headerCharRegex.exec(val) !== null) {\n    throw new InvalidArgumentError(`invalid ${key} header`);\n  }\n  return skipAppend ? val : `${key}: ${val}\\r\\n`;\n}\nfunction processHeader(request, key, val, skipAppend = false) {\n  if (val && typeof val === 'object' && !Array.isArray(val)) {\n    throw new InvalidArgumentError(`invalid ${key} header`);\n  } else if (val === undefined) {\n    return;\n  }\n  if (request.host === null && key.length === 4 && key.toLowerCase() === 'host') {\n    if (headerCharRegex.exec(val) !== null) {\n      throw new InvalidArgumentError(`invalid ${key} header`);\n    }\n    // Consumed by Client\n    request.host = val;\n  } else if (request.contentLength === null && key.length === 14 && key.toLowerCase() === 'content-length') {\n    request.contentLength = parseInt(val, 10);\n    if (!Number.isFinite(request.contentLength)) {\n      throw new InvalidArgumentError('invalid content-length header');\n    }\n  } else if (request.contentType === null && key.length === 12 && key.toLowerCase() === 'content-type') {\n    request.contentType = val;\n    if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);else request.headers += processHeaderValue(key, val);\n  } else if (key.length === 17 && key.toLowerCase() === 'transfer-encoding') {\n    throw new InvalidArgumentError('invalid transfer-encoding header');\n  } else if (key.length === 10 && key.toLowerCase() === 'connection') {\n    const value = typeof val === 'string' ? val.toLowerCase() : null;\n    if (value !== 'close' && value !== 'keep-alive') {\n      throw new InvalidArgumentError('invalid connection header');\n    } else if (value === 'close') {\n      request.reset = true;\n    }\n  } else if (key.length === 10 && key.toLowerCase() === 'keep-alive') {\n    throw new InvalidArgumentError('invalid keep-alive header');\n  } else if (key.length === 7 && key.toLowerCase() === 'upgrade') {\n    throw new InvalidArgumentError('invalid upgrade header');\n  } else if (key.length === 6 && key.toLowerCase() === 'expect') {\n    throw new NotSupportedError('expect header not supported');\n  } else if (tokenRegExp.exec(key) === null) {\n    throw new InvalidArgumentError('invalid header key');\n  } else {\n    if (Array.isArray(val)) {\n      for (let i = 0; i < val.length; i++) {\n        if (skipAppend) {\n          if (request.headers[key]) request.headers[key] += `,${processHeaderValue(key, val[i], skipAppend)}`;else request.headers[key] = processHeaderValue(key, val[i], skipAppend);\n        } else {\n          request.headers += processHeaderValue(key, val[i]);\n        }\n      }\n    } else {\n      if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);else request.headers += processHeaderValue(key, val);\n    }\n  }\n}\nmodule.exports = Request;","map":{"version":3,"names":["InvalidArgumentError","NotSupportedError","require","assert","kHTTP2BuildRequest","kHTTP2CopyHeaders","kHTTP1BuildRequest","util","tokenRegExp","headerCharRegex","invalidPathRegex","kHandler","Symbol","channels","extractBody","diagnosticsChannel","create","channel","bodySent","headers","trailers","error","hasSubscribers","Request","constructor","origin","path","method","body","query","idempotent","blocking","upgrade","headersTimeout","bodyTimeout","reset","throwOnError","expectContinue","handler","startsWith","exec","Number","isFinite","abort","isStream","rState","_readableState","autoDestroy","endHandler","destroy","on","errorHandler","err","isBuffer","byteLength","ArrayBuffer","isView","buffer","Buffer","from","byteOffset","length","isFormDataLike","isIterable","isBlobLike","completed","aborted","buildURL","host","contentLength","contentType","Array","isArray","i","processHeader","keys","Object","key","nodeMajor","nodeMinor","bodyStream","stream","type","validateHandler","servername","getServerName","publish","request","onBodySent","chunk","onRequestSent","onConnect","onHeaders","statusCode","resume","statusText","response","onData","onUpgrade","socket","onComplete","onFinally","onError","off","addHeader","value","opts","raw","rawHeaders","split","header","processHeaderValue","val","skipAppend","undefined","toLowerCase","parseInt","module","exports"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/undici/lib/core/request.js"],"sourcesContent":["'use strict'\n\nconst {\n  InvalidArgumentError,\n  NotSupportedError\n} = require('./errors')\nconst assert = require('assert')\nconst { kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = require('./symbols')\nconst util = require('./util')\n\n// tokenRegExp and headerCharRegex have been lifted from\n// https://github.com/nodejs/node/blob/main/lib/_http_common.js\n\n/**\n * Verifies that the given val is a valid HTTP token\n * per the rules defined in RFC 7230\n * See https://tools.ietf.org/html/rfc7230#section-3.2.6\n */\nconst tokenRegExp = /^[\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]+$/\n\n/**\n * Matches if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n */\nconst headerCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/\n\n// Verifies that a given path is valid does not contain control chars \\x00 to \\x20\nconst invalidPathRegex = /[^\\u0021-\\u00ff]/\n\nconst kHandler = Symbol('handler')\n\nconst channels = {}\n\nlet extractBody\n\ntry {\n  const diagnosticsChannel = require('diagnostics_channel')\n  channels.create = diagnosticsChannel.channel('undici:request:create')\n  channels.bodySent = diagnosticsChannel.channel('undici:request:bodySent')\n  channels.headers = diagnosticsChannel.channel('undici:request:headers')\n  channels.trailers = diagnosticsChannel.channel('undici:request:trailers')\n  channels.error = diagnosticsChannel.channel('undici:request:error')\n} catch {\n  channels.create = { hasSubscribers: false }\n  channels.bodySent = { hasSubscribers: false }\n  channels.headers = { hasSubscribers: false }\n  channels.trailers = { hasSubscribers: false }\n  channels.error = { hasSubscribers: false }\n}\n\nclass Request {\n  constructor (origin, {\n    path,\n    method,\n    body,\n    headers,\n    query,\n    idempotent,\n    blocking,\n    upgrade,\n    headersTimeout,\n    bodyTimeout,\n    reset,\n    throwOnError,\n    expectContinue\n  }, handler) {\n    if (typeof path !== 'string') {\n      throw new InvalidArgumentError('path must be a string')\n    } else if (\n      path[0] !== '/' &&\n      !(path.startsWith('http://') || path.startsWith('https://')) &&\n      method !== 'CONNECT'\n    ) {\n      throw new InvalidArgumentError('path must be an absolute URL or start with a slash')\n    } else if (invalidPathRegex.exec(path) !== null) {\n      throw new InvalidArgumentError('invalid request path')\n    }\n\n    if (typeof method !== 'string') {\n      throw new InvalidArgumentError('method must be a string')\n    } else if (tokenRegExp.exec(method) === null) {\n      throw new InvalidArgumentError('invalid request method')\n    }\n\n    if (upgrade && typeof upgrade !== 'string') {\n      throw new InvalidArgumentError('upgrade must be a string')\n    }\n\n    if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('invalid headersTimeout')\n    }\n\n    if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('invalid bodyTimeout')\n    }\n\n    if (reset != null && typeof reset !== 'boolean') {\n      throw new InvalidArgumentError('invalid reset')\n    }\n\n    if (expectContinue != null && typeof expectContinue !== 'boolean') {\n      throw new InvalidArgumentError('invalid expectContinue')\n    }\n\n    this.headersTimeout = headersTimeout\n\n    this.bodyTimeout = bodyTimeout\n\n    this.throwOnError = throwOnError === true\n\n    this.method = method\n\n    this.abort = null\n\n    if (body == null) {\n      this.body = null\n    } else if (util.isStream(body)) {\n      this.body = body\n\n      const rState = this.body._readableState\n      if (!rState || !rState.autoDestroy) {\n        this.endHandler = function autoDestroy () {\n          util.destroy(this)\n        }\n        this.body.on('end', this.endHandler)\n      }\n\n      this.errorHandler = err => {\n        if (this.abort) {\n          this.abort(err)\n        } else {\n          this.error = err\n        }\n      }\n      this.body.on('error', this.errorHandler)\n    } else if (util.isBuffer(body)) {\n      this.body = body.byteLength ? body : null\n    } else if (ArrayBuffer.isView(body)) {\n      this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null\n    } else if (body instanceof ArrayBuffer) {\n      this.body = body.byteLength ? Buffer.from(body) : null\n    } else if (typeof body === 'string') {\n      this.body = body.length ? Buffer.from(body) : null\n    } else if (util.isFormDataLike(body) || util.isIterable(body) || util.isBlobLike(body)) {\n      this.body = body\n    } else {\n      throw new InvalidArgumentError('body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable')\n    }\n\n    this.completed = false\n\n    this.aborted = false\n\n    this.upgrade = upgrade || null\n\n    this.path = query ? util.buildURL(path, query) : path\n\n    this.origin = origin\n\n    this.idempotent = idempotent == null\n      ? method === 'HEAD' || method === 'GET'\n      : idempotent\n\n    this.blocking = blocking == null ? false : blocking\n\n    this.reset = reset == null ? null : reset\n\n    this.host = null\n\n    this.contentLength = null\n\n    this.contentType = null\n\n    this.headers = ''\n\n    // Only for H2\n    this.expectContinue = expectContinue != null ? expectContinue : false\n\n    if (Array.isArray(headers)) {\n      if (headers.length % 2 !== 0) {\n        throw new InvalidArgumentError('headers array must be even')\n      }\n      for (let i = 0; i < headers.length; i += 2) {\n        processHeader(this, headers[i], headers[i + 1])\n      }\n    } else if (headers && typeof headers === 'object') {\n      const keys = Object.keys(headers)\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i]\n        processHeader(this, key, headers[key])\n      }\n    } else if (headers != null) {\n      throw new InvalidArgumentError('headers must be an object or an array')\n    }\n\n    if (util.isFormDataLike(this.body)) {\n      if (util.nodeMajor < 16 || (util.nodeMajor === 16 && util.nodeMinor < 8)) {\n        throw new InvalidArgumentError('Form-Data bodies are only supported in node v16.8 and newer.')\n      }\n\n      if (!extractBody) {\n        extractBody = require('../fetch/body.js').extractBody\n      }\n\n      const [bodyStream, contentType] = extractBody(body)\n      if (this.contentType == null) {\n        this.contentType = contentType\n        this.headers += `content-type: ${contentType}\\r\\n`\n      }\n      this.body = bodyStream.stream\n      this.contentLength = bodyStream.length\n    } else if (util.isBlobLike(body) && this.contentType == null && body.type) {\n      this.contentType = body.type\n      this.headers += `content-type: ${body.type}\\r\\n`\n    }\n\n    util.validateHandler(handler, method, upgrade)\n\n    this.servername = util.getServerName(this.host)\n\n    this[kHandler] = handler\n\n    if (channels.create.hasSubscribers) {\n      channels.create.publish({ request: this })\n    }\n  }\n\n  onBodySent (chunk) {\n    if (this[kHandler].onBodySent) {\n      try {\n        return this[kHandler].onBodySent(chunk)\n      } catch (err) {\n        this.abort(err)\n      }\n    }\n  }\n\n  onRequestSent () {\n    if (channels.bodySent.hasSubscribers) {\n      channels.bodySent.publish({ request: this })\n    }\n\n    if (this[kHandler].onRequestSent) {\n      try {\n        return this[kHandler].onRequestSent()\n      } catch (err) {\n        this.abort(err)\n      }\n    }\n  }\n\n  onConnect (abort) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    if (this.error) {\n      abort(this.error)\n    } else {\n      this.abort = abort\n      return this[kHandler].onConnect(abort)\n    }\n  }\n\n  onHeaders (statusCode, headers, resume, statusText) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    if (channels.headers.hasSubscribers) {\n      channels.headers.publish({ request: this, response: { statusCode, headers, statusText } })\n    }\n\n    try {\n      return this[kHandler].onHeaders(statusCode, headers, resume, statusText)\n    } catch (err) {\n      this.abort(err)\n    }\n  }\n\n  onData (chunk) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    try {\n      return this[kHandler].onData(chunk)\n    } catch (err) {\n      this.abort(err)\n      return false\n    }\n  }\n\n  onUpgrade (statusCode, headers, socket) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    return this[kHandler].onUpgrade(statusCode, headers, socket)\n  }\n\n  onComplete (trailers) {\n    this.onFinally()\n\n    assert(!this.aborted)\n\n    this.completed = true\n    if (channels.trailers.hasSubscribers) {\n      channels.trailers.publish({ request: this, trailers })\n    }\n\n    try {\n      return this[kHandler].onComplete(trailers)\n    } catch (err) {\n      // TODO (fix): This might be a bad idea?\n      this.onError(err)\n    }\n  }\n\n  onError (error) {\n    this.onFinally()\n\n    if (channels.error.hasSubscribers) {\n      channels.error.publish({ request: this, error })\n    }\n\n    if (this.aborted) {\n      return\n    }\n    this.aborted = true\n\n    return this[kHandler].onError(error)\n  }\n\n  onFinally () {\n    if (this.errorHandler) {\n      this.body.off('error', this.errorHandler)\n      this.errorHandler = null\n    }\n\n    if (this.endHandler) {\n      this.body.off('end', this.endHandler)\n      this.endHandler = null\n    }\n  }\n\n  // TODO: adjust to support H2\n  addHeader (key, value) {\n    processHeader(this, key, value)\n    return this\n  }\n\n  static [kHTTP1BuildRequest] (origin, opts, handler) {\n    // TODO: Migrate header parsing here, to make Requests\n    // HTTP agnostic\n    return new Request(origin, opts, handler)\n  }\n\n  static [kHTTP2BuildRequest] (origin, opts, handler) {\n    const headers = opts.headers\n    opts = { ...opts, headers: null }\n\n    const request = new Request(origin, opts, handler)\n\n    request.headers = {}\n\n    if (Array.isArray(headers)) {\n      if (headers.length % 2 !== 0) {\n        throw new InvalidArgumentError('headers array must be even')\n      }\n      for (let i = 0; i < headers.length; i += 2) {\n        processHeader(request, headers[i], headers[i + 1], true)\n      }\n    } else if (headers && typeof headers === 'object') {\n      const keys = Object.keys(headers)\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i]\n        processHeader(request, key, headers[key], true)\n      }\n    } else if (headers != null) {\n      throw new InvalidArgumentError('headers must be an object or an array')\n    }\n\n    return request\n  }\n\n  static [kHTTP2CopyHeaders] (raw) {\n    const rawHeaders = raw.split('\\r\\n')\n    const headers = {}\n\n    for (const header of rawHeaders) {\n      const [key, value] = header.split(': ')\n\n      if (value == null || value.length === 0) continue\n\n      if (headers[key]) headers[key] += `,${value}`\n      else headers[key] = value\n    }\n\n    return headers\n  }\n}\n\nfunction processHeaderValue (key, val, skipAppend) {\n  if (val && typeof val === 'object') {\n    throw new InvalidArgumentError(`invalid ${key} header`)\n  }\n\n  val = val != null ? `${val}` : ''\n\n  if (headerCharRegex.exec(val) !== null) {\n    throw new InvalidArgumentError(`invalid ${key} header`)\n  }\n\n  return skipAppend ? val : `${key}: ${val}\\r\\n`\n}\n\nfunction processHeader (request, key, val, skipAppend = false) {\n  if (val && (typeof val === 'object' && !Array.isArray(val))) {\n    throw new InvalidArgumentError(`invalid ${key} header`)\n  } else if (val === undefined) {\n    return\n  }\n\n  if (\n    request.host === null &&\n    key.length === 4 &&\n    key.toLowerCase() === 'host'\n  ) {\n    if (headerCharRegex.exec(val) !== null) {\n      throw new InvalidArgumentError(`invalid ${key} header`)\n    }\n    // Consumed by Client\n    request.host = val\n  } else if (\n    request.contentLength === null &&\n    key.length === 14 &&\n    key.toLowerCase() === 'content-length'\n  ) {\n    request.contentLength = parseInt(val, 10)\n    if (!Number.isFinite(request.contentLength)) {\n      throw new InvalidArgumentError('invalid content-length header')\n    }\n  } else if (\n    request.contentType === null &&\n    key.length === 12 &&\n    key.toLowerCase() === 'content-type'\n  ) {\n    request.contentType = val\n    if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend)\n    else request.headers += processHeaderValue(key, val)\n  } else if (\n    key.length === 17 &&\n    key.toLowerCase() === 'transfer-encoding'\n  ) {\n    throw new InvalidArgumentError('invalid transfer-encoding header')\n  } else if (\n    key.length === 10 &&\n    key.toLowerCase() === 'connection'\n  ) {\n    const value = typeof val === 'string' ? val.toLowerCase() : null\n    if (value !== 'close' && value !== 'keep-alive') {\n      throw new InvalidArgumentError('invalid connection header')\n    } else if (value === 'close') {\n      request.reset = true\n    }\n  } else if (\n    key.length === 10 &&\n    key.toLowerCase() === 'keep-alive'\n  ) {\n    throw new InvalidArgumentError('invalid keep-alive header')\n  } else if (\n    key.length === 7 &&\n    key.toLowerCase() === 'upgrade'\n  ) {\n    throw new InvalidArgumentError('invalid upgrade header')\n  } else if (\n    key.length === 6 &&\n    key.toLowerCase() === 'expect'\n  ) {\n    throw new NotSupportedError('expect header not supported')\n  } else if (tokenRegExp.exec(key) === null) {\n    throw new InvalidArgumentError('invalid header key')\n  } else {\n    if (Array.isArray(val)) {\n      for (let i = 0; i < val.length; i++) {\n        if (skipAppend) {\n          if (request.headers[key]) request.headers[key] += `,${processHeaderValue(key, val[i], skipAppend)}`\n          else request.headers[key] = processHeaderValue(key, val[i], skipAppend)\n        } else {\n          request.headers += processHeaderValue(key, val[i])\n        }\n      }\n    } else {\n      if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend)\n      else request.headers += processHeaderValue(key, val)\n    }\n  }\n}\n\nmodule.exports = Request\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}