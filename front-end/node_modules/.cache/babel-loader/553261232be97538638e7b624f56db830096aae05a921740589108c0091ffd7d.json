{"ast":null,"code":"import { sha256 } from 'ethereum-cryptography/sha256.js';\nimport { utf8ToBytes } from './bytes.js';\nimport { kzg } from './kzg.js';\n/**\n * These utilities for constructing blobs are borrowed from https://github.com/Inphi/eip4844-interop.git\n */\nconst BYTES_PER_FIELD_ELEMENT = 32;\nconst FIELD_ELEMENTS_PER_BLOB = 4096;\nconst USEFUL_BYTES_PER_BLOB = 32 * FIELD_ELEMENTS_PER_BLOB;\nconst MAX_BLOBS_PER_TX = 2;\nconst MAX_USEFUL_BYTES_PER_TX = USEFUL_BYTES_PER_BLOB * MAX_BLOBS_PER_TX - 1;\nconst BLOB_SIZE = BYTES_PER_FIELD_ELEMENT * FIELD_ELEMENTS_PER_BLOB;\nfunction get_padded(data, blobs_len) {\n  const pdata = new Uint8Array(blobs_len * USEFUL_BYTES_PER_BLOB).fill(0);\n  pdata.set(data);\n  pdata[data.byteLength] = 0x80;\n  return pdata;\n}\nfunction get_blob(data) {\n  const blob = new Uint8Array(BLOB_SIZE);\n  for (let i = 0; i < FIELD_ELEMENTS_PER_BLOB; i++) {\n    const chunk = new Uint8Array(32);\n    chunk.set(data.subarray(i * 31, (i + 1) * 31), 0);\n    blob.set(chunk, i * 32);\n  }\n  return blob;\n}\nexport const getBlobs = input => {\n  const data = utf8ToBytes(input);\n  const len = data.byteLength;\n  if (len === 0) {\n    throw Error('invalid blob data');\n  }\n  if (len > MAX_USEFUL_BYTES_PER_TX) {\n    throw Error('blob data is too large');\n  }\n  const blobs_len = Math.ceil(len / USEFUL_BYTES_PER_BLOB);\n  const pdata = get_padded(data, blobs_len);\n  const blobs = [];\n  for (let i = 0; i < blobs_len; i++) {\n    const chunk = pdata.subarray(i * USEFUL_BYTES_PER_BLOB, (i + 1) * USEFUL_BYTES_PER_BLOB);\n    const blob = get_blob(chunk);\n    blobs.push(blob);\n  }\n  return blobs;\n};\nexport const blobsToCommitments = blobs => {\n  const commitments = [];\n  for (const blob of blobs) {\n    commitments.push(kzg.blobToKzgCommitment(blob));\n  }\n  return commitments;\n};\nexport const blobsToProofs = (blobs, commitments) => {\n  const proofs = blobs.map((blob, ctx) => kzg.computeBlobKzgProof(blob, commitments[ctx]));\n  return proofs;\n};\n/**\n * Converts a vector commitment for a given data blob to its versioned hash.  For 4844, this version\n * number will be 0x01 for KZG vector commitments but could be different if future vector commitment\n * types are introduced\n * @param commitment a vector commitment to a blob\n * @param blobCommitmentVersion the version number corresponding to the type of vector commitment\n * @returns a versioned hash corresponding to a given blob vector commitment\n */\nexport const computeVersionedHash = (commitment, blobCommitmentVersion) => {\n  const computedVersionedHash = new Uint8Array(32);\n  computedVersionedHash.set([blobCommitmentVersion], 0);\n  computedVersionedHash.set(sha256(Buffer.from(commitment)).subarray(1), 1);\n  return computedVersionedHash;\n};\n/**\n * Generate an array of versioned hashes from corresponding kzg commitments\n * @param commitments array of kzg commitments\n * @returns array of versioned hashes\n * Note: assumes KZG commitments (version 1 version hashes)\n */\nexport const commitmentsToVersionedHashes = commitments => {\n  const hashes = [];\n  for (const commitment of commitments) {\n    hashes.push(computeVersionedHash(commitment, 0x01));\n  }\n  return hashes;\n};","map":{"version":3,"names":["sha256","utf8ToBytes","kzg","BYTES_PER_FIELD_ELEMENT","FIELD_ELEMENTS_PER_BLOB","USEFUL_BYTES_PER_BLOB","MAX_BLOBS_PER_TX","MAX_USEFUL_BYTES_PER_TX","BLOB_SIZE","get_padded","data","blobs_len","pdata","Uint8Array","fill","set","byteLength","get_blob","blob","i","chunk","subarray","getBlobs","input","len","Error","Math","ceil","blobs","push","blobsToCommitments","commitments","blobToKzgCommitment","blobsToProofs","proofs","map","ctx","computeBlobKzgProof","computeVersionedHash","commitment","blobCommitmentVersion","computedVersionedHash","Buffer","from","commitmentsToVersionedHashes","hashes"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\@nomicfoundation\\ethereumjs-util\\src\\blobs.ts"],"sourcesContent":["import { sha256 } from 'ethereum-cryptography/sha256.js'\n\nimport { utf8ToBytes } from './bytes.js'\nimport { kzg } from './kzg.js'\n\n/**\n * These utilities for constructing blobs are borrowed from https://github.com/Inphi/eip4844-interop.git\n */\nconst BYTES_PER_FIELD_ELEMENT = 32\nconst FIELD_ELEMENTS_PER_BLOB = 4096\nconst USEFUL_BYTES_PER_BLOB = 32 * FIELD_ELEMENTS_PER_BLOB\nconst MAX_BLOBS_PER_TX = 2\nconst MAX_USEFUL_BYTES_PER_TX = USEFUL_BYTES_PER_BLOB * MAX_BLOBS_PER_TX - 1\nconst BLOB_SIZE = BYTES_PER_FIELD_ELEMENT * FIELD_ELEMENTS_PER_BLOB\n\nfunction get_padded(data: Uint8Array, blobs_len: number): Uint8Array {\n  const pdata = new Uint8Array(blobs_len * USEFUL_BYTES_PER_BLOB).fill(0)\n  pdata.set(data)\n  pdata[data.byteLength] = 0x80\n  return pdata\n}\n\nfunction get_blob(data: Uint8Array): Uint8Array {\n  const blob = new Uint8Array(BLOB_SIZE)\n  for (let i = 0; i < FIELD_ELEMENTS_PER_BLOB; i++) {\n    const chunk = new Uint8Array(32)\n    chunk.set(data.subarray(i * 31, (i + 1) * 31), 0)\n    blob.set(chunk, i * 32)\n  }\n\n  return blob\n}\n\nexport const getBlobs = (input: string) => {\n  const data = utf8ToBytes(input)\n  const len = data.byteLength\n  if (len === 0) {\n    throw Error('invalid blob data')\n  }\n  if (len > MAX_USEFUL_BYTES_PER_TX) {\n    throw Error('blob data is too large')\n  }\n\n  const blobs_len = Math.ceil(len / USEFUL_BYTES_PER_BLOB)\n\n  const pdata = get_padded(data, blobs_len)\n\n  const blobs: Uint8Array[] = []\n  for (let i = 0; i < blobs_len; i++) {\n    const chunk = pdata.subarray(i * USEFUL_BYTES_PER_BLOB, (i + 1) * USEFUL_BYTES_PER_BLOB)\n    const blob = get_blob(chunk)\n    blobs.push(blob)\n  }\n\n  return blobs\n}\n\nexport const blobsToCommitments = (blobs: Uint8Array[]) => {\n  const commitments: Uint8Array[] = []\n  for (const blob of blobs) {\n    commitments.push(kzg.blobToKzgCommitment(blob))\n  }\n  return commitments\n}\n\nexport const blobsToProofs = (blobs: Uint8Array[], commitments: Uint8Array[]) => {\n  const proofs = blobs.map((blob, ctx) => kzg.computeBlobKzgProof(blob, commitments[ctx]))\n\n  return proofs\n}\n\n/**\n * Converts a vector commitment for a given data blob to its versioned hash.  For 4844, this version\n * number will be 0x01 for KZG vector commitments but could be different if future vector commitment\n * types are introduced\n * @param commitment a vector commitment to a blob\n * @param blobCommitmentVersion the version number corresponding to the type of vector commitment\n * @returns a versioned hash corresponding to a given blob vector commitment\n */\nexport const computeVersionedHash = (commitment: Uint8Array, blobCommitmentVersion: number) => {\n  const computedVersionedHash = new Uint8Array(32)\n  computedVersionedHash.set([blobCommitmentVersion], 0)\n  computedVersionedHash.set(sha256(Buffer.from(commitment)).subarray(1), 1)\n  return computedVersionedHash\n}\n\n/**\n * Generate an array of versioned hashes from corresponding kzg commitments\n * @param commitments array of kzg commitments\n * @returns array of versioned hashes\n * Note: assumes KZG commitments (version 1 version hashes)\n */\nexport const commitmentsToVersionedHashes = (commitments: Uint8Array[]) => {\n  const hashes: Uint8Array[] = []\n  for (const commitment of commitments) {\n    hashes.push(computeVersionedHash(commitment, 0x01))\n  }\n  return hashes\n}\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,iCAAiC;AAExD,SAASC,WAAW,QAAQ,YAAY;AACxC,SAASC,GAAG,QAAQ,UAAU;AAE9B;;;AAGA,MAAMC,uBAAuB,GAAG,EAAE;AAClC,MAAMC,uBAAuB,GAAG,IAAI;AACpC,MAAMC,qBAAqB,GAAG,EAAE,GAAGD,uBAAuB;AAC1D,MAAME,gBAAgB,GAAG,CAAC;AAC1B,MAAMC,uBAAuB,GAAGF,qBAAqB,GAAGC,gBAAgB,GAAG,CAAC;AAC5E,MAAME,SAAS,GAAGL,uBAAuB,GAAGC,uBAAuB;AAEnE,SAASK,UAAUA,CAACC,IAAgB,EAAEC,SAAiB;EACrD,MAAMC,KAAK,GAAG,IAAIC,UAAU,CAACF,SAAS,GAAGN,qBAAqB,CAAC,CAACS,IAAI,CAAC,CAAC,CAAC;EACvEF,KAAK,CAACG,GAAG,CAACL,IAAI,CAAC;EACfE,KAAK,CAACF,IAAI,CAACM,UAAU,CAAC,GAAG,IAAI;EAC7B,OAAOJ,KAAK;AACd;AAEA,SAASK,QAAQA,CAACP,IAAgB;EAChC,MAAMQ,IAAI,GAAG,IAAIL,UAAU,CAACL,SAAS,CAAC;EACtC,KAAK,IAAIW,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGf,uBAAuB,EAAEe,CAAC,EAAE,EAAE;IAChD,MAAMC,KAAK,GAAG,IAAIP,UAAU,CAAC,EAAE,CAAC;IAChCO,KAAK,CAACL,GAAG,CAACL,IAAI,CAACW,QAAQ,CAACF,CAAC,GAAG,EAAE,EAAE,CAACA,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC;IACjDD,IAAI,CAACH,GAAG,CAACK,KAAK,EAAED,CAAC,GAAG,EAAE,CAAC;;EAGzB,OAAOD,IAAI;AACb;AAEA,OAAO,MAAMI,QAAQ,GAAIC,KAAa,IAAI;EACxC,MAAMb,IAAI,GAAGT,WAAW,CAACsB,KAAK,CAAC;EAC/B,MAAMC,GAAG,GAAGd,IAAI,CAACM,UAAU;EAC3B,IAAIQ,GAAG,KAAK,CAAC,EAAE;IACb,MAAMC,KAAK,CAAC,mBAAmB,CAAC;;EAElC,IAAID,GAAG,GAAGjB,uBAAuB,EAAE;IACjC,MAAMkB,KAAK,CAAC,wBAAwB,CAAC;;EAGvC,MAAMd,SAAS,GAAGe,IAAI,CAACC,IAAI,CAACH,GAAG,GAAGnB,qBAAqB,CAAC;EAExD,MAAMO,KAAK,GAAGH,UAAU,CAACC,IAAI,EAAEC,SAAS,CAAC;EAEzC,MAAMiB,KAAK,GAAiB,EAAE;EAC9B,KAAK,IAAIT,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,SAAS,EAAEQ,CAAC,EAAE,EAAE;IAClC,MAAMC,KAAK,GAAGR,KAAK,CAACS,QAAQ,CAACF,CAAC,GAAGd,qBAAqB,EAAE,CAACc,CAAC,GAAG,CAAC,IAAId,qBAAqB,CAAC;IACxF,MAAMa,IAAI,GAAGD,QAAQ,CAACG,KAAK,CAAC;IAC5BQ,KAAK,CAACC,IAAI,CAACX,IAAI,CAAC;;EAGlB,OAAOU,KAAK;AACd,CAAC;AAED,OAAO,MAAME,kBAAkB,GAAIF,KAAmB,IAAI;EACxD,MAAMG,WAAW,GAAiB,EAAE;EACpC,KAAK,MAAMb,IAAI,IAAIU,KAAK,EAAE;IACxBG,WAAW,CAACF,IAAI,CAAC3B,GAAG,CAAC8B,mBAAmB,CAACd,IAAI,CAAC,CAAC;;EAEjD,OAAOa,WAAW;AACpB,CAAC;AAED,OAAO,MAAME,aAAa,GAAGA,CAACL,KAAmB,EAAEG,WAAyB,KAAI;EAC9E,MAAMG,MAAM,GAAGN,KAAK,CAACO,GAAG,CAAC,CAACjB,IAAI,EAAEkB,GAAG,KAAKlC,GAAG,CAACmC,mBAAmB,CAACnB,IAAI,EAAEa,WAAW,CAACK,GAAG,CAAC,CAAC,CAAC;EAExF,OAAOF,MAAM;AACf,CAAC;AAED;;;;;;;;AAQA,OAAO,MAAMI,oBAAoB,GAAGA,CAACC,UAAsB,EAAEC,qBAA6B,KAAI;EAC5F,MAAMC,qBAAqB,GAAG,IAAI5B,UAAU,CAAC,EAAE,CAAC;EAChD4B,qBAAqB,CAAC1B,GAAG,CAAC,CAACyB,qBAAqB,CAAC,EAAE,CAAC,CAAC;EACrDC,qBAAqB,CAAC1B,GAAG,CAACf,MAAM,CAAC0C,MAAM,CAACC,IAAI,CAACJ,UAAU,CAAC,CAAC,CAAClB,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;EACzE,OAAOoB,qBAAqB;AAC9B,CAAC;AAED;;;;;;AAMA,OAAO,MAAMG,4BAA4B,GAAIb,WAAyB,IAAI;EACxE,MAAMc,MAAM,GAAiB,EAAE;EAC/B,KAAK,MAAMN,UAAU,IAAIR,WAAW,EAAE;IACpCc,MAAM,CAAChB,IAAI,CAACS,oBAAoB,CAACC,UAAU,EAAE,IAAI,CAAC,CAAC;;EAErD,OAAOM,MAAM;AACf,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}