{"ast":null,"code":"import { BIGINT_0, TypeOutput, bytesToHex, concatBytes, hexToBytes, intToBytes, toType } from '@nomicfoundation/ethereumjs-util';\nimport { EventEmitter } from 'events';\nimport { chains as CHAIN_SPECS } from './chains.js';\nimport { crc32 } from './crc.js';\nimport { EIPs } from './eips.js';\nimport { Chain, CustomChain, Hardfork } from './enums.js';\nimport { hardforks as HARDFORK_SPECS } from './hardforks.js';\nimport { parseGethGenesis } from './utils.js';\n/**\n * Common class to access chain and hardfork parameters and to provide\n * a unified and shared view on the network and hardfork state.\n *\n * Use the {@link Common.custom} static constructor for creating simple\n * custom chain {@link Common} objects (more complete custom chain setups\n * can be created via the main constructor and the {@link CommonOpts.customChains} parameter).\n */\nexport class Common {\n  constructor(opts) {\n    this._eips = [];\n    this._paramsCache = {};\n    this._activatedEIPsCache = [];\n    this.events = new EventEmitter();\n    this._customChains = opts.customChains ?? [];\n    this._chainParams = this.setChain(opts.chain);\n    this.DEFAULT_HARDFORK = this._chainParams.defaultHardfork ?? Hardfork.Shanghai;\n    // Assign hardfork changes in the sequence of the applied hardforks\n    this.HARDFORK_CHANGES = this.hardforks().map(hf => [hf.name, HARDFORK_SPECS[hf.name]]);\n    this._hardfork = this.DEFAULT_HARDFORK;\n    if (opts.hardfork !== undefined) {\n      this.setHardfork(opts.hardfork);\n    }\n    if (opts.eips) {\n      this.setEIPs(opts.eips);\n    }\n    this.customCrypto = opts.customCrypto ?? {};\n    if (Object.keys(this._paramsCache).length === 0) {\n      this._buildParamsCache();\n      this._buildActivatedEIPsCache();\n    }\n  }\n  /**\n   * Creates a {@link Common} object for a custom chain, based on a standard one.\n   *\n   * It uses all the {@link Chain} parameters from the {@link baseChain} option except the ones overridden\n   * in a provided {@link chainParamsOrName} dictionary. Some usage example:\n   *\n   * ```javascript\n   * Common.custom({chainId: 123})\n   * ```\n   *\n   * There are also selected supported custom chains which can be initialized by using one of the\n   * {@link CustomChains} for {@link chainParamsOrName}, e.g.:\n   *\n   * ```javascript\n   * Common.custom(CustomChains.MaticMumbai)\n   * ```\n   *\n   * Note that these supported custom chains only provide some base parameters (usually the chain and\n   * network ID and a name) and can only be used for selected use cases (e.g. sending a tx with\n   * the `@ethereumjs/tx` library to a Layer-2 chain).\n   *\n   * @param chainParamsOrName Custom parameter dict (`name` will default to `custom-chain`) or string with name of a supported custom chain\n   * @param opts Custom chain options to set the {@link CustomCommonOpts.baseChain}, selected {@link CustomCommonOpts.hardfork} and others\n   */\n  static custom(chainParamsOrName, opts = {}) {\n    const baseChain = opts.baseChain ?? 'mainnet';\n    const standardChainParams = {\n      ...Common._getChainParams(baseChain)\n    };\n    standardChainParams['name'] = 'custom-chain';\n    if (typeof chainParamsOrName !== 'string') {\n      return new Common({\n        chain: {\n          ...standardChainParams,\n          ...chainParamsOrName\n        },\n        ...opts\n      });\n    } else {\n      if (chainParamsOrName === CustomChain.PolygonMainnet) {\n        return Common.custom({\n          name: CustomChain.PolygonMainnet,\n          chainId: 137,\n          networkId: 137\n        }, opts);\n      }\n      if (chainParamsOrName === CustomChain.PolygonMumbai) {\n        return Common.custom({\n          name: CustomChain.PolygonMumbai,\n          chainId: 80001,\n          networkId: 80001\n        }, opts);\n      }\n      if (chainParamsOrName === CustomChain.ArbitrumOne) {\n        return Common.custom({\n          name: CustomChain.ArbitrumOne,\n          chainId: 42161,\n          networkId: 42161\n        }, opts);\n      }\n      if (chainParamsOrName === CustomChain.xDaiChain) {\n        return Common.custom({\n          name: CustomChain.xDaiChain,\n          chainId: 100,\n          networkId: 100\n        }, opts);\n      }\n      if (chainParamsOrName === CustomChain.OptimisticKovan) {\n        return Common.custom({\n          name: CustomChain.OptimisticKovan,\n          chainId: 69,\n          networkId: 69\n        },\n        // Optimism has not implemented the London hardfork yet (targeting Q1.22)\n        {\n          hardfork: Hardfork.Berlin,\n          ...opts\n        });\n      }\n      if (chainParamsOrName === CustomChain.OptimisticEthereum) {\n        return Common.custom({\n          name: CustomChain.OptimisticEthereum,\n          chainId: 10,\n          networkId: 10\n        },\n        // Optimism has not implemented the London hardfork yet (targeting Q1.22)\n        {\n          hardfork: Hardfork.Berlin,\n          ...opts\n        });\n      }\n      throw new Error(`Custom chain ${chainParamsOrName} not supported`);\n    }\n  }\n  /**\n   * Static method to load and set common from a geth genesis json\n   * @param genesisJson json of geth configuration\n   * @param { chain, eips, genesisHash, hardfork, mergeForkIdPostMerge } to further configure the common instance\n   * @returns Common\n   */\n  static fromGethGenesis(genesisJson, {\n    chain,\n    eips,\n    genesisHash,\n    hardfork,\n    mergeForkIdPostMerge\n  }) {\n    const genesisParams = parseGethGenesis(genesisJson, chain, mergeForkIdPostMerge);\n    const common = new Common({\n      chain: genesisParams.name ?? 'custom',\n      customChains: [genesisParams],\n      eips,\n      hardfork: hardfork ?? genesisParams.hardfork\n    });\n    if (genesisHash !== undefined) {\n      common.setForkHashes(genesisHash);\n    }\n    return common;\n  }\n  /**\n   * Static method to determine if a {@link chainId} is supported as a standard chain\n   * @param chainId bigint id (`1`) of a standard chain\n   * @returns boolean\n   */\n  static isSupportedChainId(chainId) {\n    const initializedChains = this.getInitializedChains();\n    return Boolean(initializedChains['names'][chainId.toString()]);\n  }\n  static _getChainParams(chain, customChains) {\n    const initializedChains = this.getInitializedChains(customChains);\n    if (typeof chain === 'number' || typeof chain === 'bigint') {\n      chain = chain.toString();\n      if (initializedChains['names'][chain]) {\n        const name = initializedChains['names'][chain];\n        return initializedChains[name];\n      }\n      throw new Error(`Chain with ID ${chain} not supported`);\n    }\n    if (initializedChains[chain] !== undefined) {\n      return initializedChains[chain];\n    }\n    throw new Error(`Chain with name ${chain} not supported`);\n  }\n  /**\n   * Sets the chain\n   * @param chain String ('mainnet') or Number (1) chain representation.\n   *              Or, a Dictionary of chain parameters for a private network.\n   * @returns The dictionary with parameters set as chain\n   */\n  setChain(chain) {\n    if (typeof chain === 'number' || typeof chain === 'bigint' || typeof chain === 'string') {\n      this._chainParams = Common._getChainParams(chain, this._customChains);\n    } else if (typeof chain === 'object') {\n      if (this._customChains.length > 0) {\n        throw new Error('Chain must be a string, number, or bigint when initialized with customChains passed in');\n      }\n      const required = ['networkId', 'genesis', 'hardforks', 'bootstrapNodes'];\n      for (const param of required) {\n        if (!(param in chain)) {\n          throw new Error(`Missing required chain parameter: ${param}`);\n        }\n      }\n      this._chainParams = chain;\n    } else {\n      throw new Error('Wrong input format');\n    }\n    for (const hf of this.hardforks()) {\n      if (hf.block === undefined) {\n        throw new Error(`Hardfork cannot have undefined block number`);\n      }\n    }\n    return this._chainParams;\n  }\n  /**\n   * Sets the hardfork to get params for\n   * @param hardfork String identifier (e.g. 'byzantium') or {@link Hardfork} enum\n   */\n  setHardfork(hardfork) {\n    let existing = false;\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if (hfChanges[0] === hardfork) {\n        if (this._hardfork !== hardfork) {\n          this._hardfork = hardfork;\n          this._buildParamsCache();\n          this._buildActivatedEIPsCache();\n          this.events.emit('hardforkChanged', hardfork);\n        }\n        existing = true;\n      }\n    }\n    if (!existing) {\n      throw new Error(`Hardfork with name ${hardfork} not supported`);\n    }\n  }\n  /**\n   * Returns the hardfork either based on block numer (older HFs) or\n   * timestamp (Shanghai upwards).\n   *\n   * An optional TD takes precedence in case the corresponding HF block\n   * is set to `null` or otherwise needs to match (if not an error\n   * will be thrown).\n   *\n   * @param Opts Block number, timestamp or TD (all optional)\n   * @returns The name of the HF\n   */\n  getHardforkBy(opts) {\n    let {\n      blockNumber,\n      timestamp,\n      td\n    } = opts;\n    blockNumber = toType(blockNumber, TypeOutput.BigInt);\n    td = toType(td, TypeOutput.BigInt);\n    timestamp = toType(timestamp, TypeOutput.BigInt);\n    // Filter out hardforks with no block number, no ttd or no timestamp (i.e. unapplied hardforks)\n    const hfs = this.hardforks().filter(hf => hf.block !== null || hf.ttd !== null && hf.ttd !== undefined || hf.timestamp !== undefined);\n    const mergeIndex = hfs.findIndex(hf => hf.ttd !== null && hf.ttd !== undefined);\n    const doubleTTDHF = hfs.slice(mergeIndex + 1).findIndex(hf => hf.ttd !== null && hf.ttd !== undefined);\n    if (doubleTTDHF >= 0) {\n      throw Error(`More than one merge hardforks found with ttd specified`);\n    }\n    // Find the first hardfork that has a block number greater than `blockNumber`\n    // (skips the merge hardfork since it cannot have a block number specified).\n    // If timestamp is not provided, it also skips timestamps hardforks to continue\n    // discovering/checking number hardforks.\n    let hfIndex = hfs.findIndex(hf => blockNumber !== undefined && hf.block !== null && BigInt(hf.block) > blockNumber || timestamp !== undefined && hf.timestamp !== undefined && hf.timestamp > timestamp);\n    if (hfIndex === -1) {\n      // all hardforks apply, set hfIndex to the last one as that's the candidate\n      hfIndex = hfs.length;\n    } else if (hfIndex === 0) {\n      // cannot have a case where a block number is before all applied hardforks\n      // since the chain has to start with a hardfork\n      throw Error('Must have at least one hardfork at block 0');\n    }\n    // If timestamp is not provided, we need to rollback to the last hf with block or ttd\n    if (timestamp === undefined) {\n      const stepBack = hfs.slice(0, hfIndex).reverse().findIndex(hf => hf.block !== null || hf.ttd !== undefined);\n      hfIndex = hfIndex - stepBack;\n    }\n    // Move hfIndex one back to arrive at candidate hardfork\n    hfIndex = hfIndex - 1;\n    // If the timestamp was not provided, we could have skipped timestamp hardforks to look for number\n    // hardforks. so it will now be needed to rollback\n    if (hfs[hfIndex].block === null && hfs[hfIndex].timestamp === undefined) {\n      // We're on the merge hardfork.  Let's check the TTD\n      if (td === undefined || td === null || BigInt(hfs[hfIndex].ttd) > td) {\n        // Merge ttd greater than current td so we're on hardfork before merge\n        hfIndex -= 1;\n      }\n    } else {\n      if (mergeIndex >= 0 && td !== undefined && td !== null) {\n        if (hfIndex >= mergeIndex && BigInt(hfs[mergeIndex].ttd) > td) {\n          throw Error('Maximum HF determined by total difficulty is lower than the block number HF');\n        } else if (hfIndex < mergeIndex && BigInt(hfs[mergeIndex].ttd) < td) {\n          throw Error('HF determined by block number is lower than the minimum total difficulty HF');\n        }\n      }\n    }\n    const hfStartIndex = hfIndex;\n    // Move the hfIndex to the end of the hardforks that might be scheduled on the same block/timestamp\n    // This won't anyway be the case with Merge hfs\n    for (; hfIndex < hfs.length - 1; hfIndex++) {\n      // break out if hfIndex + 1 is not scheduled at hfIndex\n      if (hfs[hfIndex].block !== hfs[hfIndex + 1].block || hfs[hfIndex].timestamp !== hfs[hfIndex + 1].timestamp) {\n        break;\n      }\n    }\n    if (timestamp !== undefined) {\n      const minTimeStamp = hfs.slice(0, hfStartIndex).reduce((acc, hf) => Math.max(Number(hf.timestamp ?? '0'), acc), 0);\n      if (minTimeStamp > timestamp) {\n        throw Error(`Maximum HF determined by timestamp is lower than the block number/ttd HF`);\n      }\n      const maxTimeStamp = hfs.slice(hfIndex + 1).reduce((acc, hf) => Math.min(Number(hf.timestamp ?? timestamp), acc), Number(timestamp));\n      if (maxTimeStamp < timestamp) {\n        throw Error(`Maximum HF determined by block number/ttd is lower than timestamp HF`);\n      }\n    }\n    const hardfork = hfs[hfIndex];\n    return hardfork.name;\n  }\n  /**\n   * Sets a new hardfork either based on block numer (older HFs) or\n   * timestamp (Shanghai upwards).\n   *\n   * An optional TD takes precedence in case the corresponding HF block\n   * is set to `null` or otherwise needs to match (if not an error\n   * will be thrown).\n   *\n   * @param Opts Block number, timestamp or TD (all optional)\n   * @returns The name of the HF set\n   */\n  setHardforkBy(opts) {\n    const hardfork = this.getHardforkBy(opts);\n    this.setHardfork(hardfork);\n    return hardfork;\n  }\n  /**\n   * Internal helper function, returns the params for the given hardfork for the chain set\n   * @param hardfork Hardfork name\n   * @returns Dictionary with hardfork params or null if hardfork not on chain\n   */\n  _getHardfork(hardfork) {\n    const hfs = this.hardforks();\n    for (const hf of hfs) {\n      if (hf['name'] === hardfork) return hf;\n    }\n    return null;\n  }\n  /**\n   * Sets the active EIPs\n   * @param eips\n   */\n  setEIPs(eips = []) {\n    for (const eip of eips) {\n      if (!(eip in EIPs)) {\n        throw new Error(`${eip} not supported`);\n      }\n      const minHF = this.gteHardfork(EIPs[eip]['minimumHardfork']);\n      if (!minHF) {\n        throw new Error(`${eip} cannot be activated on hardfork ${this.hardfork()}, minimumHardfork: ${minHF}`);\n      }\n    }\n    this._eips = eips;\n    this._buildParamsCache();\n    this._buildActivatedEIPsCache();\n    for (const eip of eips) {\n      if (EIPs[eip].requiredEIPs !== undefined) {\n        for (const elem of EIPs[eip].requiredEIPs) {\n          if (!(eips.includes(elem) || this.isActivatedEIP(elem))) {\n            throw new Error(`${eip} requires EIP ${elem}, but is not included in the EIP list`);\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Internal helper for _buildParamsCache()\n   */\n  _mergeWithParamsCache(params) {\n    this._paramsCache['gasConfig'] = {\n      ...this._paramsCache['gasConfig'],\n      ...params['gasConfig']\n    };\n    this._paramsCache['gasPrices'] = {\n      ...this._paramsCache['gasPrices'],\n      ...params['gasPrices']\n    };\n    this._paramsCache['pow'] = {\n      ...this._paramsCache['pow'],\n      ...params['pow']\n    };\n    this._paramsCache['sharding'] = {\n      ...this._paramsCache['sharding'],\n      ...params['sharding']\n    };\n    this._paramsCache['vm'] = {\n      ...this._paramsCache['vm'],\n      ...params['vm']\n    };\n  }\n  /**\n   * Build up a cache for all parameter values for the current HF and all activated EIPs\n   */\n  _buildParamsCache() {\n    this._paramsCache = {};\n    // Iterate through all hardforks up to hardfork set\n    const hardfork = this.hardfork();\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      // EIP-referencing HF config (e.g. for berlin)\n      if ('eips' in hfChanges[1]) {\n        const hfEIPs = hfChanges[1]['eips'];\n        for (const eip of hfEIPs) {\n          if (!(eip in EIPs)) {\n            throw new Error(`${eip} not supported`);\n          }\n          this._mergeWithParamsCache(EIPs[eip]);\n        }\n        // Parameter-inlining HF config (e.g. for istanbul)\n      } else {\n        this._mergeWithParamsCache(hfChanges[1]);\n      }\n      if (hfChanges[0] === hardfork) break;\n    }\n    // Iterate through all additionally activated EIPs\n    for (const eip of this._eips) {\n      if (!(eip in EIPs)) {\n        throw new Error(`${eip} not supported`);\n      }\n      this._mergeWithParamsCache(EIPs[eip]);\n    }\n  }\n  _buildActivatedEIPsCache() {\n    this._activatedEIPsCache = [];\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      const hf = hfChanges[1];\n      if (this.gteHardfork(hf['name']) && 'eips' in hf) {\n        this._activatedEIPsCache = this._activatedEIPsCache.concat(hf['eips']);\n      }\n    }\n    this._activatedEIPsCache = this._activatedEIPsCache.concat(this._eips);\n  }\n  /**\n   * Returns a parameter for the current chain setup\n   *\n   * If the parameter is present in an EIP, the EIP always takes precedence.\n   * Otherwise the parameter is taken from the latest applied HF with\n   * a change on the respective parameter.\n   *\n   * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')\n   * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)\n   * @returns The value requested or `BigInt(0)` if not found\n   */\n  param(topic, name) {\n    // TODO: consider the case that different active EIPs\n    // can change the same parameter\n    let value = null;\n    if (this._paramsCache[topic] !== undefined && this._paramsCache[topic][name] !== undefined) {\n      value = this._paramsCache[topic][name].v;\n    }\n    return BigInt(value ?? 0);\n  }\n  /**\n   * Returns the parameter corresponding to a hardfork\n   * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')\n   * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)\n   * @param hardfork Hardfork name\n   * @returns The value requested or `BigInt(0)` if not found\n   */\n  paramByHardfork(topic, name, hardfork) {\n    let value = null;\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      // EIP-referencing HF config (e.g. for berlin)\n      if ('eips' in hfChanges[1]) {\n        const hfEIPs = hfChanges[1]['eips'];\n        for (const eip of hfEIPs) {\n          const valueEIP = this.paramByEIP(topic, name, eip);\n          value = typeof valueEIP === 'bigint' ? valueEIP : value;\n        }\n        // Parameter-inlining HF config (e.g. for istanbul)\n      } else {\n        if (hfChanges[1][topic] !== undefined && hfChanges[1][topic][name] !== undefined) {\n          value = hfChanges[1][topic][name].v;\n        }\n      }\n      if (hfChanges[0] === hardfork) break;\n    }\n    return BigInt(value ?? 0);\n  }\n  /**\n   * Returns a parameter corresponding to an EIP\n   * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')\n   * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)\n   * @param eip Number of the EIP\n   * @returns The value requested or `undefined` if not found\n   */\n  paramByEIP(topic, name, eip) {\n    if (!(eip in EIPs)) {\n      throw new Error(`${eip} not supported`);\n    }\n    const eipParams = EIPs[eip];\n    if (!(topic in eipParams)) {\n      return undefined;\n    }\n    if (eipParams[topic][name] === undefined) {\n      return undefined;\n    }\n    const value = eipParams[topic][name].v;\n    return BigInt(value);\n  }\n  /**\n   * Returns a parameter for the hardfork active on block number or\n   * optional provided total difficulty (Merge HF)\n   * @param topic Parameter topic\n   * @param name Parameter name\n   * @param blockNumber Block number\n   * @param td Total difficulty\n   *    * @returns The value requested or `BigInt(0)` if not found\n   */\n  paramByBlock(topic, name, blockNumber, td, timestamp) {\n    const hardfork = this.getHardforkBy({\n      blockNumber,\n      td,\n      timestamp\n    });\n    return this.paramByHardfork(topic, name, hardfork);\n  }\n  /**\n   * Checks if an EIP is activated by either being included in the EIPs\n   * manually passed in with the {@link CommonOpts.eips} or in a\n   * hardfork currently being active\n   *\n   * Note: this method only works for EIPs being supported\n   * by the {@link CommonOpts.eips} constructor option\n   * @param eip\n   */\n  isActivatedEIP(eip) {\n    if (this._activatedEIPsCache.includes(eip)) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Checks if set or provided hardfork is active on block number\n   * @param hardfork Hardfork name or null (for HF set)\n   * @param blockNumber\n   * @returns True if HF is active on block number\n   */\n  hardforkIsActiveOnBlock(hardfork, blockNumber) {\n    blockNumber = toType(blockNumber, TypeOutput.BigInt);\n    hardfork = hardfork ?? this._hardfork;\n    const hfBlock = this.hardforkBlock(hardfork);\n    if (typeof hfBlock === 'bigint' && hfBlock !== BIGINT_0 && blockNumber >= hfBlock) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Alias to hardforkIsActiveOnBlock when hardfork is set\n   * @param blockNumber\n   * @returns True if HF is active on block number\n   */\n  activeOnBlock(blockNumber) {\n    return this.hardforkIsActiveOnBlock(null, blockNumber);\n  }\n  /**\n   * Sequence based check if given or set HF1 is greater than or equal HF2\n   * @param hardfork1 Hardfork name or null (if set)\n   * @param hardfork2 Hardfork name\n   * @param opts Hardfork options\n   * @returns True if HF1 gte HF2\n   */\n  hardforkGteHardfork(hardfork1, hardfork2) {\n    hardfork1 = hardfork1 ?? this._hardfork;\n    const hardforks = this.hardforks();\n    let posHf1 = -1,\n      posHf2 = -1;\n    let index = 0;\n    for (const hf of hardforks) {\n      if (hf['name'] === hardfork1) posHf1 = index;\n      if (hf['name'] === hardfork2) posHf2 = index;\n      index += 1;\n    }\n    return posHf1 >= posHf2 && posHf2 !== -1;\n  }\n  /**\n   * Alias to hardforkGteHardfork when hardfork is set\n   * @param hardfork Hardfork name\n   * @returns True if hardfork set is greater than hardfork provided\n   */\n  gteHardfork(hardfork) {\n    return this.hardforkGteHardfork(null, hardfork);\n  }\n  /**\n   * Returns the hardfork change block for hardfork provided or set\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns Block number or null if unscheduled\n   */\n  hardforkBlock(hardfork) {\n    hardfork = hardfork ?? this._hardfork;\n    const block = this._getHardfork(hardfork)?.['block'];\n    if (block === undefined || block === null) {\n      return null;\n    }\n    return BigInt(block);\n  }\n  hardforkTimestamp(hardfork) {\n    hardfork = hardfork ?? this._hardfork;\n    const timestamp = this._getHardfork(hardfork)?.['timestamp'];\n    if (timestamp === undefined || timestamp === null) {\n      return null;\n    }\n    return BigInt(timestamp);\n  }\n  /**\n   * Returns the hardfork change block for eip\n   * @param eip EIP number\n   * @returns Block number or null if unscheduled\n   */\n  eipBlock(eip) {\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      const hf = hfChanges[1];\n      if ('eips' in hf) {\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        if (hf['eips'].includes(eip)) {\n          return this.hardforkBlock(hfChanges[0]);\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Returns the hardfork change total difficulty (Merge HF) for hardfork provided or set\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns Total difficulty or null if no set\n   */\n  hardforkTTD(hardfork) {\n    hardfork = hardfork ?? this._hardfork;\n    const ttd = this._getHardfork(hardfork)?.['ttd'];\n    if (ttd === undefined || ttd === null) {\n      return null;\n    }\n    return BigInt(ttd);\n  }\n  /**\n   * Returns the change block for the next hardfork after the hardfork provided or set\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns Block timestamp, number or null if not available\n   */\n  nextHardforkBlockOrTimestamp(hardfork) {\n    hardfork = hardfork ?? this._hardfork;\n    const hfs = this.hardforks();\n    let hfIndex = hfs.findIndex(hf => hf.name === hardfork);\n    // If the current hardfork is merge, go one behind as merge hf is not part of these\n    // calcs even if the merge hf block is set\n    if (hardfork === Hardfork.Paris) {\n      hfIndex -= 1;\n    }\n    // Hardfork not found\n    if (hfIndex < 0) {\n      return null;\n    }\n    let currHfTimeOrBlock = hfs[hfIndex].timestamp ?? hfs[hfIndex].block;\n    currHfTimeOrBlock = currHfTimeOrBlock !== null && currHfTimeOrBlock !== undefined ? Number(currHfTimeOrBlock) : null;\n    const nextHf = hfs.slice(hfIndex + 1).find(hf => {\n      let hfTimeOrBlock = hf.timestamp ?? hf.block;\n      hfTimeOrBlock = hfTimeOrBlock !== null && hfTimeOrBlock !== undefined ? Number(hfTimeOrBlock) : null;\n      return hf.name !== Hardfork.Paris && hfTimeOrBlock !== null && hfTimeOrBlock !== undefined && hfTimeOrBlock !== currHfTimeOrBlock;\n    });\n    // If no next hf found with valid block or timestamp return null\n    if (nextHf === undefined) {\n      return null;\n    }\n    const nextHfBlock = nextHf.timestamp ?? nextHf.block;\n    if (nextHfBlock === null || nextHfBlock === undefined) {\n      return null;\n    }\n    return BigInt(nextHfBlock);\n  }\n  /**\n   * Internal helper function to calculate a fork hash\n   * @param hardfork Hardfork name\n   * @param genesisHash Genesis block hash of the chain\n   * @returns Fork hash as hex string\n   */\n  _calcForkHash(hardfork, genesisHash) {\n    let hfBytes = new Uint8Array(0);\n    let prevBlockOrTime = 0;\n    for (const hf of this.hardforks()) {\n      const {\n        block,\n        timestamp,\n        name\n      } = hf;\n      // Timestamp to be used for timestamp based hfs even if we may bundle\n      // block number with them retrospectively\n      let blockOrTime = timestamp ?? block;\n      blockOrTime = blockOrTime !== null ? Number(blockOrTime) : null;\n      // Skip for chainstart (0), not applied HFs (null) and\n      // when already applied on same blockOrTime HFs\n      // and on the merge since forkhash doesn't change on merge hf\n      if (typeof blockOrTime === 'number' && blockOrTime !== 0 && blockOrTime !== prevBlockOrTime && name !== Hardfork.Paris) {\n        const hfBlockBytes = hexToBytes('0x' + blockOrTime.toString(16).padStart(16, '0'));\n        hfBytes = concatBytes(hfBytes, hfBlockBytes);\n        prevBlockOrTime = blockOrTime;\n      }\n      if (hf.name === hardfork) break;\n    }\n    const inputBytes = concatBytes(genesisHash, hfBytes);\n    // CRC32 delivers result as signed (negative) 32-bit integer,\n    // convert to hex string\n    const forkhash = bytesToHex(intToBytes(crc32(inputBytes) >>> 0));\n    return forkhash;\n  }\n  /**\n   * Returns an eth/64 compliant fork hash (EIP-2124)\n   * @param hardfork Hardfork name, optional if HF set\n   * @param genesisHash Genesis block hash of the chain, optional if already defined and not needed to be calculated\n   */\n  forkHash(hardfork, genesisHash) {\n    hardfork = hardfork ?? this._hardfork;\n    const data = this._getHardfork(hardfork);\n    if (data === null || data?.block === null && data?.timestamp === undefined && data?.ttd === undefined) {\n      const msg = 'No fork hash calculation possible for future hardfork';\n      throw new Error(msg);\n    }\n    if (data?.forkHash !== null && data?.forkHash !== undefined) {\n      return data.forkHash;\n    }\n    if (!genesisHash) throw new Error('genesisHash required for forkHash calculation');\n    return this._calcForkHash(hardfork, genesisHash);\n  }\n  /**\n   *\n   * @param forkHash Fork hash as a hex string\n   * @returns Array with hardfork data (name, block, forkHash)\n   */\n  hardforkForForkHash(forkHash) {\n    const resArray = this.hardforks().filter(hf => {\n      return hf.forkHash === forkHash;\n    });\n    return resArray.length >= 1 ? resArray[resArray.length - 1] : null;\n  }\n  /**\n   * Sets any missing forkHashes on the passed-in {@link Common} instance\n   * @param common The {@link Common} to set the forkHashes for\n   * @param genesisHash The genesis block hash\n   */\n  setForkHashes(genesisHash) {\n    for (const hf of this.hardforks()) {\n      const blockOrTime = hf.timestamp ?? hf.block;\n      if ((hf.forkHash === null || hf.forkHash === undefined) && (blockOrTime !== null && blockOrTime !== undefined || typeof hf.ttd !== 'undefined')) {\n        hf.forkHash = this.forkHash(hf.name, genesisHash);\n      }\n    }\n  }\n  /**\n   * Returns the Genesis parameters of the current chain\n   * @returns Genesis dictionary\n   */\n  genesis() {\n    return this._chainParams.genesis;\n  }\n  /**\n   * Returns the hardforks for current chain\n   * @returns {Array} Array with arrays of hardforks\n   */\n  hardforks() {\n    return this._chainParams.hardforks;\n  }\n  /**\n   * Returns bootstrap nodes for the current chain\n   * @returns {Dictionary} Dict with bootstrap nodes\n   */\n  bootstrapNodes() {\n    return this._chainParams.bootstrapNodes;\n  }\n  /**\n   * Returns DNS networks for the current chain\n   * @returns {String[]} Array of DNS ENR urls\n   */\n  dnsNetworks() {\n    return this._chainParams.dnsNetworks;\n  }\n  /**\n   * Returns the hardfork set\n   * @returns Hardfork name\n   */\n  hardfork() {\n    return this._hardfork;\n  }\n  /**\n   * Returns the Id of current chain\n   * @returns chain Id\n   */\n  chainId() {\n    return BigInt(this._chainParams.chainId);\n  }\n  /**\n   * Returns the name of current chain\n   * @returns chain name (lower case)\n   */\n  chainName() {\n    return this._chainParams.name;\n  }\n  /**\n   * Returns the Id of current network\n   * @returns network Id\n   */\n  networkId() {\n    return BigInt(this._chainParams.networkId);\n  }\n  /**\n   * Returns the additionally activated EIPs\n   * (by using the `eips` constructor option)\n   * @returns List of EIPs\n   */\n  eips() {\n    return this._eips;\n  }\n  /**\n   * Returns the consensus type of the network\n   * Possible values: \"pow\"|\"poa\"|\"pos\"\n   *\n   * Note: This value can update along a Hardfork.\n   */\n  consensusType() {\n    const hardfork = this.hardfork();\n    let value;\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if ('consensus' in hfChanges[1]) {\n        value = hfChanges[1]['consensus']['type'];\n      }\n      if (hfChanges[0] === hardfork) break;\n    }\n    return value ?? this._chainParams['consensus']['type'];\n  }\n  /**\n   * Returns the concrete consensus implementation\n   * algorithm or protocol for the network\n   * e.g. \"ethash\" for \"pow\" consensus type,\n   * \"clique\" for \"poa\" consensus type or\n   * \"casper\" for \"pos\" consensus type.\n   *\n   * Note: This value can update along a Hardfork.\n   */\n  consensusAlgorithm() {\n    const hardfork = this.hardfork();\n    let value;\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if ('consensus' in hfChanges[1]) {\n        value = hfChanges[1]['consensus']['algorithm'];\n      }\n      if (hfChanges[0] === hardfork) break;\n    }\n    return value ?? this._chainParams['consensus']['algorithm'];\n  }\n  /**\n   * Returns a dictionary with consensus configuration\n   * parameters based on the consensus algorithm\n   *\n   * Expected returns (parameters must be present in\n   * the respective chain json files):\n   *\n   * ethash: empty object\n   * clique: period, epoch\n   * casper: empty object\n   *\n   * Note: This value can update along a Hardfork.\n   */\n  consensusConfig() {\n    const hardfork = this.hardfork();\n    let value;\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if ('consensus' in hfChanges[1]) {\n        // The config parameter is named after the respective consensus algorithm\n        const config = hfChanges[1];\n        const algorithm = config['consensus']['algorithm'];\n        value = config['consensus'][algorithm];\n      }\n      if (hfChanges[0] === hardfork) break;\n    }\n    return value ?? this._chainParams['consensus'][this.consensusAlgorithm()] ?? {};\n  }\n  /**\n   * Returns a deep copy of this {@link Common} instance.\n   */\n  copy() {\n    const copy = Object.assign(Object.create(Object.getPrototypeOf(this)), this);\n    copy.events = new EventEmitter();\n    return copy;\n  }\n  static getInitializedChains(customChains) {\n    const names = {};\n    for (const [name, id] of Object.entries(Chain)) {\n      names[id] = name.toLowerCase();\n    }\n    const chains = {\n      ...CHAIN_SPECS\n    };\n    if (customChains) {\n      for (const chain of customChains) {\n        const {\n          name\n        } = chain;\n        names[chain.chainId.toString()] = name;\n        chains[name] = chain;\n      }\n    }\n    chains.names = names;\n    return chains;\n  }\n}","map":{"version":3,"names":["BIGINT_0","TypeOutput","bytesToHex","concatBytes","hexToBytes","intToBytes","toType","EventEmitter","chains","CHAIN_SPECS","crc32","EIPs","Chain","CustomChain","Hardfork","hardforks","HARDFORK_SPECS","parseGethGenesis","Common","constructor","opts","_eips","_paramsCache","_activatedEIPsCache","events","_customChains","customChains","_chainParams","setChain","chain","DEFAULT_HARDFORK","defaultHardfork","Shanghai","HARDFORK_CHANGES","map","hf","name","_hardfork","hardfork","undefined","setHardfork","eips","setEIPs","customCrypto","Object","keys","length","_buildParamsCache","_buildActivatedEIPsCache","custom","chainParamsOrName","baseChain","standardChainParams","_getChainParams","PolygonMainnet","chainId","networkId","PolygonMumbai","ArbitrumOne","xDaiChain","OptimisticKovan","Berlin","OptimisticEthereum","Error","fromGethGenesis","genesisJson","genesisHash","mergeForkIdPostMerge","genesisParams","common","setForkHashes","isSupportedChainId","initializedChains","getInitializedChains","Boolean","toString","required","param","block","existing","hfChanges","emit","getHardforkBy","blockNumber","timestamp","td","BigInt","hfs","filter","ttd","mergeIndex","findIndex","doubleTTDHF","slice","hfIndex","stepBack","reverse","hfStartIndex","minTimeStamp","reduce","acc","Math","max","Number","maxTimeStamp","min","setHardforkBy","_getHardfork","eip","minHF","gteHardfork","requiredEIPs","elem","includes","isActivatedEIP","_mergeWithParamsCache","params","hfEIPs","concat","topic","value","v","paramByHardfork","valueEIP","paramByEIP","eipParams","paramByBlock","hardforkIsActiveOnBlock","hfBlock","hardforkBlock","activeOnBlock","hardforkGteHardfork","hardfork1","hardfork2","posHf1","posHf2","index","hardforkTimestamp","eipBlock","hardforkTTD","nextHardforkBlockOrTimestamp","Paris","currHfTimeOrBlock","nextHf","find","hfTimeOrBlock","nextHfBlock","_calcForkHash","hfBytes","Uint8Array","prevBlockOrTime","blockOrTime","hfBlockBytes","padStart","inputBytes","forkhash","forkHash","data","msg","hardforkForForkHash","resArray","genesis","bootstrapNodes","dnsNetworks","chainName","consensusType","consensusAlgorithm","consensusConfig","config","algorithm","copy","assign","create","getPrototypeOf","names","id","entries","toLowerCase"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\@nomicfoundation\\ethereumjs-common\\src\\common.ts"],"sourcesContent":["import {\n  BIGINT_0,\n  TypeOutput,\n  bytesToHex,\n  concatBytes,\n  hexToBytes,\n  intToBytes,\n  toType,\n} from '@nomicfoundation/ethereumjs-util'\nimport { EventEmitter } from 'events'\n\nimport { chains as CHAIN_SPECS } from './chains.js'\nimport { crc32 } from './crc.js'\nimport { EIPs } from './eips.js'\nimport { Chain, CustomChain, Hardfork } from './enums.js'\nimport { hardforks as HARDFORK_SPECS } from './hardforks.js'\nimport { parseGethGenesis } from './utils.js'\n\nimport type { ConsensusAlgorithm, ConsensusType } from './enums.js'\nimport type {\n  BootstrapNodeConfig,\n  CasperConfig,\n  ChainConfig,\n  ChainName,\n  ChainsConfig,\n  CliqueConfig,\n  CommonOpts,\n  CustomCommonOpts,\n  CustomCrypto,\n  EIPConfig,\n  EIPOrHFConfig,\n  EthashConfig,\n  GenesisBlockConfig,\n  GethConfigOpts,\n  HardforkByOpts,\n  HardforkConfig,\n  HardforkTransitionConfig,\n} from './types.js'\nimport type { BigIntLike, PrefixedHexString } from '@nomicfoundation/ethereumjs-util'\n\ntype HardforkSpecKeys = string // keyof typeof HARDFORK_SPECS\ntype HardforkSpecValues = typeof HARDFORK_SPECS[HardforkSpecKeys]\n\ntype ParamsCacheConfig = Omit<EIPOrHFConfig, 'comment' | 'url' | 'status'>\n\n/**\n * Common class to access chain and hardfork parameters and to provide\n * a unified and shared view on the network and hardfork state.\n *\n * Use the {@link Common.custom} static constructor for creating simple\n * custom chain {@link Common} objects (more complete custom chain setups\n * can be created via the main constructor and the {@link CommonOpts.customChains} parameter).\n */\nexport class Common {\n  readonly DEFAULT_HARDFORK: string | Hardfork\n\n  protected _chainParams: ChainConfig\n  protected _hardfork: string | Hardfork\n  protected _eips: number[] = []\n  protected _customChains: ChainConfig[]\n\n  public readonly customCrypto: CustomCrypto\n\n  protected _paramsCache: ParamsCacheConfig = {}\n  protected _activatedEIPsCache: number[] = []\n\n  protected HARDFORK_CHANGES: [HardforkSpecKeys, HardforkSpecValues][]\n\n  public events: EventEmitter\n\n  /**\n   * Creates a {@link Common} object for a custom chain, based on a standard one.\n   *\n   * It uses all the {@link Chain} parameters from the {@link baseChain} option except the ones overridden\n   * in a provided {@link chainParamsOrName} dictionary. Some usage example:\n   *\n   * ```javascript\n   * Common.custom({chainId: 123})\n   * ```\n   *\n   * There are also selected supported custom chains which can be initialized by using one of the\n   * {@link CustomChains} for {@link chainParamsOrName}, e.g.:\n   *\n   * ```javascript\n   * Common.custom(CustomChains.MaticMumbai)\n   * ```\n   *\n   * Note that these supported custom chains only provide some base parameters (usually the chain and\n   * network ID and a name) and can only be used for selected use cases (e.g. sending a tx with\n   * the `@ethereumjs/tx` library to a Layer-2 chain).\n   *\n   * @param chainParamsOrName Custom parameter dict (`name` will default to `custom-chain`) or string with name of a supported custom chain\n   * @param opts Custom chain options to set the {@link CustomCommonOpts.baseChain}, selected {@link CustomCommonOpts.hardfork} and others\n   */\n  static custom(\n    chainParamsOrName: Partial<ChainConfig> | CustomChain,\n    opts: CustomCommonOpts = {}\n  ): Common {\n    const baseChain = opts.baseChain ?? 'mainnet'\n    const standardChainParams = { ...Common._getChainParams(baseChain) }\n    standardChainParams['name'] = 'custom-chain'\n\n    if (typeof chainParamsOrName !== 'string') {\n      return new Common({\n        chain: {\n          ...standardChainParams,\n          ...chainParamsOrName,\n        },\n        ...opts,\n      })\n    } else {\n      if (chainParamsOrName === CustomChain.PolygonMainnet) {\n        return Common.custom(\n          {\n            name: CustomChain.PolygonMainnet,\n            chainId: 137,\n            networkId: 137,\n          },\n          opts\n        )\n      }\n      if (chainParamsOrName === CustomChain.PolygonMumbai) {\n        return Common.custom(\n          {\n            name: CustomChain.PolygonMumbai,\n            chainId: 80001,\n            networkId: 80001,\n          },\n          opts\n        )\n      }\n      if (chainParamsOrName === CustomChain.ArbitrumOne) {\n        return Common.custom(\n          {\n            name: CustomChain.ArbitrumOne,\n            chainId: 42161,\n            networkId: 42161,\n          },\n          opts\n        )\n      }\n      if (chainParamsOrName === CustomChain.xDaiChain) {\n        return Common.custom(\n          {\n            name: CustomChain.xDaiChain,\n            chainId: 100,\n            networkId: 100,\n          },\n          opts\n        )\n      }\n\n      if (chainParamsOrName === CustomChain.OptimisticKovan) {\n        return Common.custom(\n          {\n            name: CustomChain.OptimisticKovan,\n            chainId: 69,\n            networkId: 69,\n          },\n          // Optimism has not implemented the London hardfork yet (targeting Q1.22)\n          { hardfork: Hardfork.Berlin, ...opts }\n        )\n      }\n\n      if (chainParamsOrName === CustomChain.OptimisticEthereum) {\n        return Common.custom(\n          {\n            name: CustomChain.OptimisticEthereum,\n            chainId: 10,\n            networkId: 10,\n          },\n          // Optimism has not implemented the London hardfork yet (targeting Q1.22)\n          { hardfork: Hardfork.Berlin, ...opts }\n        )\n      }\n      throw new Error(`Custom chain ${chainParamsOrName} not supported`)\n    }\n  }\n\n  /**\n   * Static method to load and set common from a geth genesis json\n   * @param genesisJson json of geth configuration\n   * @param { chain, eips, genesisHash, hardfork, mergeForkIdPostMerge } to further configure the common instance\n   * @returns Common\n   */\n  static fromGethGenesis(\n    genesisJson: any,\n    { chain, eips, genesisHash, hardfork, mergeForkIdPostMerge }: GethConfigOpts\n  ): Common {\n    const genesisParams = parseGethGenesis(genesisJson, chain, mergeForkIdPostMerge)\n    const common = new Common({\n      chain: genesisParams.name ?? 'custom',\n      customChains: [genesisParams],\n      eips,\n      hardfork: hardfork ?? genesisParams.hardfork,\n    })\n    if (genesisHash !== undefined) {\n      common.setForkHashes(genesisHash)\n    }\n    return common\n  }\n\n  /**\n   * Static method to determine if a {@link chainId} is supported as a standard chain\n   * @param chainId bigint id (`1`) of a standard chain\n   * @returns boolean\n   */\n  static isSupportedChainId(chainId: bigint): boolean {\n    const initializedChains = this.getInitializedChains()\n    return Boolean((initializedChains['names'] as ChainName)[chainId.toString()])\n  }\n\n  protected static _getChainParams(\n    chain: string | number | Chain | bigint,\n    customChains?: ChainConfig[]\n  ): ChainConfig {\n    const initializedChains = this.getInitializedChains(customChains)\n    if (typeof chain === 'number' || typeof chain === 'bigint') {\n      chain = chain.toString()\n\n      if ((initializedChains['names'] as ChainName)[chain]) {\n        const name: string = (initializedChains['names'] as ChainName)[chain]\n        return initializedChains[name] as ChainConfig\n      }\n\n      throw new Error(`Chain with ID ${chain} not supported`)\n    }\n\n    if (initializedChains[chain] !== undefined) {\n      return initializedChains[chain] as ChainConfig\n    }\n\n    throw new Error(`Chain with name ${chain} not supported`)\n  }\n\n  constructor(opts: CommonOpts) {\n    this.events = new EventEmitter()\n\n    this._customChains = opts.customChains ?? []\n    this._chainParams = this.setChain(opts.chain)\n    this.DEFAULT_HARDFORK = this._chainParams.defaultHardfork ?? Hardfork.Shanghai\n    // Assign hardfork changes in the sequence of the applied hardforks\n    this.HARDFORK_CHANGES = this.hardforks().map((hf) => [\n      hf.name as HardforkSpecKeys,\n      HARDFORK_SPECS[hf.name as HardforkSpecKeys],\n    ])\n    this._hardfork = this.DEFAULT_HARDFORK\n    if (opts.hardfork !== undefined) {\n      this.setHardfork(opts.hardfork)\n    }\n    if (opts.eips) {\n      this.setEIPs(opts.eips)\n    }\n    this.customCrypto = opts.customCrypto ?? {}\n\n    if (Object.keys(this._paramsCache).length === 0) {\n      this._buildParamsCache()\n      this._buildActivatedEIPsCache()\n    }\n  }\n\n  /**\n   * Sets the chain\n   * @param chain String ('mainnet') or Number (1) chain representation.\n   *              Or, a Dictionary of chain parameters for a private network.\n   * @returns The dictionary with parameters set as chain\n   */\n  setChain(chain: string | number | Chain | bigint | object): ChainConfig {\n    if (typeof chain === 'number' || typeof chain === 'bigint' || typeof chain === 'string') {\n      this._chainParams = Common._getChainParams(chain, this._customChains)\n    } else if (typeof chain === 'object') {\n      if (this._customChains.length > 0) {\n        throw new Error(\n          'Chain must be a string, number, or bigint when initialized with customChains passed in'\n        )\n      }\n      const required = ['networkId', 'genesis', 'hardforks', 'bootstrapNodes']\n      for (const param of required) {\n        if (!(param in chain)) {\n          throw new Error(`Missing required chain parameter: ${param}`)\n        }\n      }\n      this._chainParams = chain as ChainConfig\n    } else {\n      throw new Error('Wrong input format')\n    }\n    for (const hf of this.hardforks()) {\n      if (hf.block === undefined) {\n        throw new Error(`Hardfork cannot have undefined block number`)\n      }\n    }\n    return this._chainParams\n  }\n\n  /**\n   * Sets the hardfork to get params for\n   * @param hardfork String identifier (e.g. 'byzantium') or {@link Hardfork} enum\n   */\n  setHardfork(hardfork: string | Hardfork): void {\n    let existing = false\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if (hfChanges[0] === hardfork) {\n        if (this._hardfork !== hardfork) {\n          this._hardfork = hardfork\n          this._buildParamsCache()\n          this._buildActivatedEIPsCache()\n          this.events.emit('hardforkChanged', hardfork)\n        }\n        existing = true\n      }\n    }\n    if (!existing) {\n      throw new Error(`Hardfork with name ${hardfork} not supported`)\n    }\n  }\n\n  /**\n   * Returns the hardfork either based on block numer (older HFs) or\n   * timestamp (Shanghai upwards).\n   *\n   * An optional TD takes precedence in case the corresponding HF block\n   * is set to `null` or otherwise needs to match (if not an error\n   * will be thrown).\n   *\n   * @param Opts Block number, timestamp or TD (all optional)\n   * @returns The name of the HF\n   */\n  getHardforkBy(opts: HardforkByOpts): string {\n    let { blockNumber, timestamp, td } = opts\n\n    blockNumber = toType(blockNumber, TypeOutput.BigInt)\n    td = toType(td, TypeOutput.BigInt)\n    timestamp = toType(timestamp, TypeOutput.BigInt)\n\n    // Filter out hardforks with no block number, no ttd or no timestamp (i.e. unapplied hardforks)\n    const hfs = this.hardforks().filter(\n      (hf) =>\n        hf.block !== null || (hf.ttd !== null && hf.ttd !== undefined) || hf.timestamp !== undefined\n    )\n    const mergeIndex = hfs.findIndex((hf) => hf.ttd !== null && hf.ttd !== undefined)\n    const doubleTTDHF = hfs\n      .slice(mergeIndex + 1)\n      .findIndex((hf) => hf.ttd !== null && hf.ttd !== undefined)\n    if (doubleTTDHF >= 0) {\n      throw Error(`More than one merge hardforks found with ttd specified`)\n    }\n\n    // Find the first hardfork that has a block number greater than `blockNumber`\n    // (skips the merge hardfork since it cannot have a block number specified).\n    // If timestamp is not provided, it also skips timestamps hardforks to continue\n    // discovering/checking number hardforks.\n    let hfIndex = hfs.findIndex(\n      (hf) =>\n        (blockNumber !== undefined &&\n          hf.block !== null &&\n          BigInt(hf.block) > (blockNumber as bigint)) ||\n        (timestamp !== undefined && hf.timestamp !== undefined && hf.timestamp > timestamp)\n    )\n\n    if (hfIndex === -1) {\n      // all hardforks apply, set hfIndex to the last one as that's the candidate\n      hfIndex = hfs.length\n    } else if (hfIndex === 0) {\n      // cannot have a case where a block number is before all applied hardforks\n      // since the chain has to start with a hardfork\n      throw Error('Must have at least one hardfork at block 0')\n    }\n\n    // If timestamp is not provided, we need to rollback to the last hf with block or ttd\n    if (timestamp === undefined) {\n      const stepBack = hfs\n        .slice(0, hfIndex)\n        .reverse()\n        .findIndex((hf) => hf.block !== null || hf.ttd !== undefined)\n      hfIndex = hfIndex - stepBack\n    }\n    // Move hfIndex one back to arrive at candidate hardfork\n    hfIndex = hfIndex - 1\n\n    // If the timestamp was not provided, we could have skipped timestamp hardforks to look for number\n    // hardforks. so it will now be needed to rollback\n    if (hfs[hfIndex].block === null && hfs[hfIndex].timestamp === undefined) {\n      // We're on the merge hardfork.  Let's check the TTD\n      if (td === undefined || td === null || BigInt(hfs[hfIndex].ttd!) > td) {\n        // Merge ttd greater than current td so we're on hardfork before merge\n        hfIndex -= 1\n      }\n    } else {\n      if (mergeIndex >= 0 && td !== undefined && td !== null) {\n        if (hfIndex >= mergeIndex && BigInt(hfs[mergeIndex].ttd!) > td) {\n          throw Error('Maximum HF determined by total difficulty is lower than the block number HF')\n        } else if (hfIndex < mergeIndex && BigInt(hfs[mergeIndex].ttd!) < td) {\n          throw Error('HF determined by block number is lower than the minimum total difficulty HF')\n        }\n      }\n    }\n\n    const hfStartIndex = hfIndex\n    // Move the hfIndex to the end of the hardforks that might be scheduled on the same block/timestamp\n    // This won't anyway be the case with Merge hfs\n    for (; hfIndex < hfs.length - 1; hfIndex++) {\n      // break out if hfIndex + 1 is not scheduled at hfIndex\n      if (\n        hfs[hfIndex].block !== hfs[hfIndex + 1].block ||\n        hfs[hfIndex].timestamp !== hfs[hfIndex + 1].timestamp\n      ) {\n        break\n      }\n    }\n\n    if (timestamp !== undefined) {\n      const minTimeStamp = hfs\n        .slice(0, hfStartIndex)\n        .reduce(\n          (acc: number, hf: HardforkTransitionConfig) => Math.max(Number(hf.timestamp ?? '0'), acc),\n          0\n        )\n      if (minTimeStamp > timestamp) {\n        throw Error(`Maximum HF determined by timestamp is lower than the block number/ttd HF`)\n      }\n\n      const maxTimeStamp = hfs\n        .slice(hfIndex + 1)\n        .reduce(\n          (acc: number, hf: HardforkTransitionConfig) =>\n            Math.min(Number(hf.timestamp ?? timestamp), acc),\n          Number(timestamp)\n        )\n      if (maxTimeStamp < timestamp) {\n        throw Error(`Maximum HF determined by block number/ttd is lower than timestamp HF`)\n      }\n    }\n    const hardfork = hfs[hfIndex]\n    return hardfork.name\n  }\n\n  /**\n   * Sets a new hardfork either based on block numer (older HFs) or\n   * timestamp (Shanghai upwards).\n   *\n   * An optional TD takes precedence in case the corresponding HF block\n   * is set to `null` or otherwise needs to match (if not an error\n   * will be thrown).\n   *\n   * @param Opts Block number, timestamp or TD (all optional)\n   * @returns The name of the HF set\n   */\n  setHardforkBy(opts: HardforkByOpts): string {\n    const hardfork = this.getHardforkBy(opts)\n    this.setHardfork(hardfork)\n    return hardfork\n  }\n\n  /**\n   * Internal helper function, returns the params for the given hardfork for the chain set\n   * @param hardfork Hardfork name\n   * @returns Dictionary with hardfork params or null if hardfork not on chain\n   */\n  protected _getHardfork(hardfork: string | Hardfork): HardforkTransitionConfig | null {\n    const hfs = this.hardforks()\n    for (const hf of hfs) {\n      if (hf['name'] === hardfork) return hf\n    }\n    return null\n  }\n\n  /**\n   * Sets the active EIPs\n   * @param eips\n   */\n  setEIPs(eips: number[] = []) {\n    for (const eip of eips) {\n      if (!(eip in EIPs)) {\n        throw new Error(`${eip} not supported`)\n      }\n      const minHF = this.gteHardfork((EIPs as any)[eip]['minimumHardfork'])\n      if (!minHF) {\n        throw new Error(\n          `${eip} cannot be activated on hardfork ${this.hardfork()}, minimumHardfork: ${minHF}`\n        )\n      }\n    }\n    this._eips = eips\n    this._buildParamsCache()\n    this._buildActivatedEIPsCache()\n\n    for (const eip of eips) {\n      if ((EIPs as any)[eip].requiredEIPs !== undefined) {\n        for (const elem of (EIPs as any)[eip].requiredEIPs) {\n          if (!(eips.includes(elem) || this.isActivatedEIP(elem))) {\n            throw new Error(`${eip} requires EIP ${elem}, but is not included in the EIP list`)\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Internal helper for _buildParamsCache()\n   */\n  protected _mergeWithParamsCache(params: HardforkConfig | EIPConfig) {\n    this._paramsCache['gasConfig'] = {\n      ...this._paramsCache['gasConfig'],\n      ...params['gasConfig'],\n    }\n    this._paramsCache['gasPrices'] = {\n      ...this._paramsCache['gasPrices'],\n      ...params['gasPrices'],\n    }\n    this._paramsCache['pow'] = {\n      ...this._paramsCache['pow'],\n      ...params['pow'],\n    }\n    this._paramsCache['sharding'] = {\n      ...this._paramsCache['sharding'],\n      ...params['sharding'],\n    }\n    this._paramsCache['vm'] = {\n      ...this._paramsCache['vm'],\n      ...params['vm'],\n    }\n  }\n\n  /**\n   * Build up a cache for all parameter values for the current HF and all activated EIPs\n   */\n  protected _buildParamsCache() {\n    this._paramsCache = {}\n    // Iterate through all hardforks up to hardfork set\n    const hardfork = this.hardfork()\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      // EIP-referencing HF config (e.g. for berlin)\n      if ('eips' in hfChanges[1]) {\n        const hfEIPs = hfChanges[1]['eips']\n        for (const eip of hfEIPs!) {\n          if (!(eip in EIPs)) {\n            throw new Error(`${eip} not supported`)\n          }\n\n          this._mergeWithParamsCache(EIPs[eip])\n        }\n        // Parameter-inlining HF config (e.g. for istanbul)\n      } else {\n        this._mergeWithParamsCache(hfChanges[1])\n      }\n      if (hfChanges[0] === hardfork) break\n    }\n    // Iterate through all additionally activated EIPs\n    for (const eip of this._eips) {\n      if (!(eip in EIPs)) {\n        throw new Error(`${eip} not supported`)\n      }\n\n      this._mergeWithParamsCache(EIPs[eip])\n    }\n  }\n\n  protected _buildActivatedEIPsCache() {\n    this._activatedEIPsCache = []\n\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      const hf = hfChanges[1]\n      if (this.gteHardfork(hf['name']) && 'eips' in hf) {\n        this._activatedEIPsCache = this._activatedEIPsCache.concat(hf['eips'] as number[])\n      }\n    }\n    this._activatedEIPsCache = this._activatedEIPsCache.concat(this._eips)\n  }\n\n  /**\n   * Returns a parameter for the current chain setup\n   *\n   * If the parameter is present in an EIP, the EIP always takes precedence.\n   * Otherwise the parameter is taken from the latest applied HF with\n   * a change on the respective parameter.\n   *\n   * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')\n   * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)\n   * @returns The value requested or `BigInt(0)` if not found\n   */\n  param(topic: string, name: string): bigint {\n    // TODO: consider the case that different active EIPs\n    // can change the same parameter\n    let value = null\n    if (\n      (this._paramsCache as any)[topic] !== undefined &&\n      (this._paramsCache as any)[topic][name] !== undefined\n    ) {\n      value = (this._paramsCache as any)[topic][name].v\n    }\n    return BigInt(value ?? 0)\n  }\n\n  /**\n   * Returns the parameter corresponding to a hardfork\n   * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')\n   * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)\n   * @param hardfork Hardfork name\n   * @returns The value requested or `BigInt(0)` if not found\n   */\n  paramByHardfork(topic: string, name: string, hardfork: string | Hardfork): bigint {\n    let value = null\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      // EIP-referencing HF config (e.g. for berlin)\n      if ('eips' in hfChanges[1]) {\n        const hfEIPs = hfChanges[1]['eips']\n        for (const eip of hfEIPs!) {\n          const valueEIP = this.paramByEIP(topic, name, eip)\n          value = typeof valueEIP === 'bigint' ? valueEIP : value\n        }\n        // Parameter-inlining HF config (e.g. for istanbul)\n      } else {\n        if (\n          (hfChanges[1] as any)[topic] !== undefined &&\n          (hfChanges[1] as any)[topic][name] !== undefined\n        ) {\n          value = (hfChanges[1] as any)[topic][name].v\n        }\n      }\n      if (hfChanges[0] === hardfork) break\n    }\n    return BigInt(value ?? 0)\n  }\n\n  /**\n   * Returns a parameter corresponding to an EIP\n   * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')\n   * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)\n   * @param eip Number of the EIP\n   * @returns The value requested or `undefined` if not found\n   */\n  paramByEIP(topic: string, name: string, eip: number): bigint | undefined {\n    if (!(eip in EIPs)) {\n      throw new Error(`${eip} not supported`)\n    }\n\n    const eipParams = (EIPs as any)[eip]\n    if (!(topic in eipParams)) {\n      return undefined\n    }\n    if (eipParams[topic][name] === undefined) {\n      return undefined\n    }\n    const value = eipParams[topic][name].v\n    return BigInt(value)\n  }\n\n  /**\n   * Returns a parameter for the hardfork active on block number or\n   * optional provided total difficulty (Merge HF)\n   * @param topic Parameter topic\n   * @param name Parameter name\n   * @param blockNumber Block number\n   * @param td Total difficulty\n   *    * @returns The value requested or `BigInt(0)` if not found\n   */\n  paramByBlock(\n    topic: string,\n    name: string,\n    blockNumber: BigIntLike,\n    td?: BigIntLike,\n    timestamp?: BigIntLike\n  ): bigint {\n    const hardfork = this.getHardforkBy({ blockNumber, td, timestamp })\n    return this.paramByHardfork(topic, name, hardfork)\n  }\n\n  /**\n   * Checks if an EIP is activated by either being included in the EIPs\n   * manually passed in with the {@link CommonOpts.eips} or in a\n   * hardfork currently being active\n   *\n   * Note: this method only works for EIPs being supported\n   * by the {@link CommonOpts.eips} constructor option\n   * @param eip\n   */\n  isActivatedEIP(eip: number): boolean {\n    if (this._activatedEIPsCache.includes(eip)) {\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Checks if set or provided hardfork is active on block number\n   * @param hardfork Hardfork name or null (for HF set)\n   * @param blockNumber\n   * @returns True if HF is active on block number\n   */\n  hardforkIsActiveOnBlock(hardfork: string | Hardfork | null, blockNumber: BigIntLike): boolean {\n    blockNumber = toType(blockNumber, TypeOutput.BigInt)\n    hardfork = hardfork ?? this._hardfork\n    const hfBlock = this.hardforkBlock(hardfork)\n    if (typeof hfBlock === 'bigint' && hfBlock !== BIGINT_0 && blockNumber >= hfBlock) {\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Alias to hardforkIsActiveOnBlock when hardfork is set\n   * @param blockNumber\n   * @returns True if HF is active on block number\n   */\n  activeOnBlock(blockNumber: BigIntLike): boolean {\n    return this.hardforkIsActiveOnBlock(null, blockNumber)\n  }\n\n  /**\n   * Sequence based check if given or set HF1 is greater than or equal HF2\n   * @param hardfork1 Hardfork name or null (if set)\n   * @param hardfork2 Hardfork name\n   * @param opts Hardfork options\n   * @returns True if HF1 gte HF2\n   */\n  hardforkGteHardfork(hardfork1: string | Hardfork | null, hardfork2: string | Hardfork): boolean {\n    hardfork1 = hardfork1 ?? this._hardfork\n    const hardforks = this.hardforks()\n\n    let posHf1 = -1,\n      posHf2 = -1\n    let index = 0\n    for (const hf of hardforks) {\n      if (hf['name'] === hardfork1) posHf1 = index\n      if (hf['name'] === hardfork2) posHf2 = index\n      index += 1\n    }\n    return posHf1 >= posHf2 && posHf2 !== -1\n  }\n\n  /**\n   * Alias to hardforkGteHardfork when hardfork is set\n   * @param hardfork Hardfork name\n   * @returns True if hardfork set is greater than hardfork provided\n   */\n  gteHardfork(hardfork: string | Hardfork): boolean {\n    return this.hardforkGteHardfork(null, hardfork)\n  }\n\n  /**\n   * Returns the hardfork change block for hardfork provided or set\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns Block number or null if unscheduled\n   */\n  hardforkBlock(hardfork?: string | Hardfork): bigint | null {\n    hardfork = hardfork ?? this._hardfork\n    const block = this._getHardfork(hardfork)?.['block']\n    if (block === undefined || block === null) {\n      return null\n    }\n    return BigInt(block)\n  }\n\n  hardforkTimestamp(hardfork?: string | Hardfork): bigint | null {\n    hardfork = hardfork ?? this._hardfork\n    const timestamp = this._getHardfork(hardfork)?.['timestamp']\n    if (timestamp === undefined || timestamp === null) {\n      return null\n    }\n    return BigInt(timestamp)\n  }\n\n  /**\n   * Returns the hardfork change block for eip\n   * @param eip EIP number\n   * @returns Block number or null if unscheduled\n   */\n  eipBlock(eip: number): bigint | null {\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      const hf = hfChanges[1]\n      if ('eips' in hf) {\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        if ((hf['eips'] as any).includes(eip)) {\n          return this.hardforkBlock(hfChanges[0])\n        }\n      }\n    }\n    return null\n  }\n\n  /**\n   * Returns the hardfork change total difficulty (Merge HF) for hardfork provided or set\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns Total difficulty or null if no set\n   */\n  hardforkTTD(hardfork?: string | Hardfork): bigint | null {\n    hardfork = hardfork ?? this._hardfork\n    const ttd = this._getHardfork(hardfork)?.['ttd']\n    if (ttd === undefined || ttd === null) {\n      return null\n    }\n    return BigInt(ttd)\n  }\n\n  /**\n   * Returns the change block for the next hardfork after the hardfork provided or set\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns Block timestamp, number or null if not available\n   */\n  nextHardforkBlockOrTimestamp(hardfork?: string | Hardfork): bigint | null {\n    hardfork = hardfork ?? this._hardfork\n    const hfs = this.hardforks()\n    let hfIndex = hfs.findIndex((hf) => hf.name === hardfork)\n    // If the current hardfork is merge, go one behind as merge hf is not part of these\n    // calcs even if the merge hf block is set\n    if (hardfork === Hardfork.Paris) {\n      hfIndex -= 1\n    }\n    // Hardfork not found\n    if (hfIndex < 0) {\n      return null\n    }\n\n    let currHfTimeOrBlock = hfs[hfIndex].timestamp ?? hfs[hfIndex].block\n    currHfTimeOrBlock =\n      currHfTimeOrBlock !== null && currHfTimeOrBlock !== undefined\n        ? Number(currHfTimeOrBlock)\n        : null\n\n    const nextHf = hfs.slice(hfIndex + 1).find((hf) => {\n      let hfTimeOrBlock = hf.timestamp ?? hf.block\n      hfTimeOrBlock =\n        hfTimeOrBlock !== null && hfTimeOrBlock !== undefined ? Number(hfTimeOrBlock) : null\n      return (\n        hf.name !== Hardfork.Paris &&\n        hfTimeOrBlock !== null &&\n        hfTimeOrBlock !== undefined &&\n        hfTimeOrBlock !== currHfTimeOrBlock\n      )\n    })\n    // If no next hf found with valid block or timestamp return null\n    if (nextHf === undefined) {\n      return null\n    }\n\n    const nextHfBlock = nextHf.timestamp ?? nextHf.block\n    if (nextHfBlock === null || nextHfBlock === undefined) {\n      return null\n    }\n\n    return BigInt(nextHfBlock)\n  }\n\n  /**\n   * Internal helper function to calculate a fork hash\n   * @param hardfork Hardfork name\n   * @param genesisHash Genesis block hash of the chain\n   * @returns Fork hash as hex string\n   */\n  protected _calcForkHash(hardfork: string | Hardfork, genesisHash: Uint8Array): PrefixedHexString {\n    let hfBytes = new Uint8Array(0)\n    let prevBlockOrTime = 0\n    for (const hf of this.hardforks()) {\n      const { block, timestamp, name } = hf\n      // Timestamp to be used for timestamp based hfs even if we may bundle\n      // block number with them retrospectively\n      let blockOrTime = timestamp ?? block\n      blockOrTime = blockOrTime !== null ? Number(blockOrTime) : null\n\n      // Skip for chainstart (0), not applied HFs (null) and\n      // when already applied on same blockOrTime HFs\n      // and on the merge since forkhash doesn't change on merge hf\n      if (\n        typeof blockOrTime === 'number' &&\n        blockOrTime !== 0 &&\n        blockOrTime !== prevBlockOrTime &&\n        name !== Hardfork.Paris\n      ) {\n        const hfBlockBytes = hexToBytes('0x' + blockOrTime.toString(16).padStart(16, '0'))\n        hfBytes = concatBytes(hfBytes, hfBlockBytes)\n        prevBlockOrTime = blockOrTime\n      }\n\n      if (hf.name === hardfork) break\n    }\n    const inputBytes = concatBytes(genesisHash, hfBytes)\n\n    // CRC32 delivers result as signed (negative) 32-bit integer,\n    // convert to hex string\n    const forkhash = bytesToHex(intToBytes(crc32(inputBytes) >>> 0))\n    return forkhash\n  }\n\n  /**\n   * Returns an eth/64 compliant fork hash (EIP-2124)\n   * @param hardfork Hardfork name, optional if HF set\n   * @param genesisHash Genesis block hash of the chain, optional if already defined and not needed to be calculated\n   */\n  forkHash(hardfork?: string | Hardfork, genesisHash?: Uint8Array): PrefixedHexString {\n    hardfork = hardfork ?? this._hardfork\n    const data = this._getHardfork(hardfork)\n    if (\n      data === null ||\n      (data?.block === null && data?.timestamp === undefined && data?.ttd === undefined)\n    ) {\n      const msg = 'No fork hash calculation possible for future hardfork'\n      throw new Error(msg)\n    }\n    if (data?.forkHash !== null && data?.forkHash !== undefined) {\n      return data.forkHash\n    }\n    if (!genesisHash) throw new Error('genesisHash required for forkHash calculation')\n    return this._calcForkHash(hardfork, genesisHash)\n  }\n\n  /**\n   *\n   * @param forkHash Fork hash as a hex string\n   * @returns Array with hardfork data (name, block, forkHash)\n   */\n  hardforkForForkHash(forkHash: string): HardforkTransitionConfig | null {\n    const resArray = this.hardforks().filter((hf: HardforkTransitionConfig) => {\n      return hf.forkHash === forkHash\n    })\n    return resArray.length >= 1 ? resArray[resArray.length - 1] : null\n  }\n\n  /**\n   * Sets any missing forkHashes on the passed-in {@link Common} instance\n   * @param common The {@link Common} to set the forkHashes for\n   * @param genesisHash The genesis block hash\n   */\n  setForkHashes(genesisHash: Uint8Array) {\n    for (const hf of this.hardforks()) {\n      const blockOrTime = hf.timestamp ?? hf.block\n      if (\n        (hf.forkHash === null || hf.forkHash === undefined) &&\n        ((blockOrTime !== null && blockOrTime !== undefined) || typeof hf.ttd !== 'undefined')\n      ) {\n        hf.forkHash = this.forkHash(hf.name, genesisHash)\n      }\n    }\n  }\n\n  /**\n   * Returns the Genesis parameters of the current chain\n   * @returns Genesis dictionary\n   */\n  genesis(): GenesisBlockConfig {\n    return this._chainParams.genesis\n  }\n\n  /**\n   * Returns the hardforks for current chain\n   * @returns {Array} Array with arrays of hardforks\n   */\n  hardforks(): HardforkTransitionConfig[] {\n    return this._chainParams.hardforks\n  }\n\n  /**\n   * Returns bootstrap nodes for the current chain\n   * @returns {Dictionary} Dict with bootstrap nodes\n   */\n  bootstrapNodes(): BootstrapNodeConfig[] {\n    return this._chainParams.bootstrapNodes\n  }\n\n  /**\n   * Returns DNS networks for the current chain\n   * @returns {String[]} Array of DNS ENR urls\n   */\n  dnsNetworks(): string[] {\n    return this._chainParams.dnsNetworks!\n  }\n\n  /**\n   * Returns the hardfork set\n   * @returns Hardfork name\n   */\n  hardfork(): string | Hardfork {\n    return this._hardfork\n  }\n\n  /**\n   * Returns the Id of current chain\n   * @returns chain Id\n   */\n  chainId(): bigint {\n    return BigInt(this._chainParams.chainId)\n  }\n\n  /**\n   * Returns the name of current chain\n   * @returns chain name (lower case)\n   */\n  chainName(): string {\n    return this._chainParams.name\n  }\n\n  /**\n   * Returns the Id of current network\n   * @returns network Id\n   */\n  networkId(): bigint {\n    return BigInt(this._chainParams.networkId)\n  }\n\n  /**\n   * Returns the additionally activated EIPs\n   * (by using the `eips` constructor option)\n   * @returns List of EIPs\n   */\n  eips(): number[] {\n    return this._eips\n  }\n\n  /**\n   * Returns the consensus type of the network\n   * Possible values: \"pow\"|\"poa\"|\"pos\"\n   *\n   * Note: This value can update along a Hardfork.\n   */\n  consensusType(): string | ConsensusType {\n    const hardfork = this.hardfork()\n\n    let value\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if ('consensus' in hfChanges[1]) {\n        value = (hfChanges[1] as any)['consensus']['type']\n      }\n      if (hfChanges[0] === hardfork) break\n    }\n    return value ?? this._chainParams['consensus']['type']\n  }\n\n  /**\n   * Returns the concrete consensus implementation\n   * algorithm or protocol for the network\n   * e.g. \"ethash\" for \"pow\" consensus type,\n   * \"clique\" for \"poa\" consensus type or\n   * \"casper\" for \"pos\" consensus type.\n   *\n   * Note: This value can update along a Hardfork.\n   */\n  consensusAlgorithm(): string | ConsensusAlgorithm {\n    const hardfork = this.hardfork()\n\n    let value\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if ('consensus' in hfChanges[1]) {\n        value = hfChanges[1]['consensus']!['algorithm']\n      }\n      if (hfChanges[0] === hardfork) break\n    }\n    return value ?? (this._chainParams['consensus']['algorithm'] as ConsensusAlgorithm)\n  }\n\n  /**\n   * Returns a dictionary with consensus configuration\n   * parameters based on the consensus algorithm\n   *\n   * Expected returns (parameters must be present in\n   * the respective chain json files):\n   *\n   * ethash: empty object\n   * clique: period, epoch\n   * casper: empty object\n   *\n   * Note: This value can update along a Hardfork.\n   */\n  consensusConfig(): { [key: string]: CliqueConfig | EthashConfig | CasperConfig } {\n    const hardfork = this.hardfork()\n\n    let value\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if ('consensus' in hfChanges[1]) {\n        // The config parameter is named after the respective consensus algorithm\n        const config = hfChanges[1]\n        const algorithm = config['consensus']!['algorithm']\n        value = (config['consensus'] as any)[algorithm]\n      }\n      if (hfChanges[0] === hardfork) break\n    }\n    return (\n      value ?? this._chainParams['consensus'][this.consensusAlgorithm() as ConsensusAlgorithm] ?? {}\n    )\n  }\n\n  /**\n   * Returns a deep copy of this {@link Common} instance.\n   */\n  copy(): Common {\n    const copy = Object.assign(Object.create(Object.getPrototypeOf(this)), this)\n    copy.events = new EventEmitter()\n    return copy\n  }\n\n  static getInitializedChains(customChains?: ChainConfig[]): ChainsConfig {\n    const names: ChainName = {}\n    for (const [name, id] of Object.entries(Chain)) {\n      names[id] = name.toLowerCase()\n    }\n    const chains = { ...CHAIN_SPECS } as ChainsConfig\n    if (customChains) {\n      for (const chain of customChains) {\n        const { name } = chain\n        names[chain.chainId.toString()] = name\n        chains[name] = chain\n      }\n    }\n    chains.names = names\n    return chains\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}