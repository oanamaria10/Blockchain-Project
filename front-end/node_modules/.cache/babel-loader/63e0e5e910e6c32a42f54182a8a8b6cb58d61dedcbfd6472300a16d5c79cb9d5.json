{"ast":null,"code":"import { bitCount, popcount as popcount32 } from \"./Uint32.js\";\nimport * as API from \"./api.js\";\n\n/**\n * @param {number} size\n */\nexport const empty = (size = 256) => {\n  if (size % 8 !== 0) {\n    throw new Error(`Must be multiple of 8`);\n  }\n  return new Uint8Array(size / 8);\n};\n\n/**\n * Creates bitfield with specific bits set.\n *\n * @param {number[]} bits\n * @param {number} [size]\n * @returns {Uint8Array}\n */\nexport const from = (bits, size) => {\n  let bitfield = empty(size);\n  for (const index of bits) {\n    const {\n      byte,\n      byteOffset,\n      bitOffset\n    } = at(bitfield, index);\n    bitfield[byteOffset] = byte | 1 << bitOffset;\n  }\n  return bitfield;\n};\n\n/**\n * @param {Uint8Array} bitfield\n */\nexport const size = bitfield => bitfield.byteLength * 8;\n\n/**\n * Compute offset for the given index\n *\n * @param {Uint8Array} bitfield\n * @param {number} index\n */\nconst at = (bitfield, index) => {\n  const byteOffset = bitfield.byteLength - 1 - (index / 8 | 0);\n  const bitOffset = index % 8;\n  const byte = bitfield[byteOffset];\n  return {\n    byte,\n    byteOffset,\n    bitOffset\n  };\n};\n\n/**\n * Set a particular bit.\n *\n * @param {Uint8Array} bytes\n * @param {number} index\n * @param {number} byte\n * @returns {Uint8Array}\n */\nconst setByte = (bytes, index, byte) => {\n  if (bytes[index] !== byte) {\n    const result = bytes.slice(0);\n    result[index] = byte;\n    return result;\n  }\n  return bytes;\n};\n\n/**\n * Set a particular bit.\n *\n * @param {Uint8Array} bitfield\n * @param {number} index\n * @returns {Uint8Array}\n */\nexport const set = (bitfield, index) => {\n  const {\n    byte,\n    byteOffset,\n    bitOffset\n  } = at(bitfield, index);\n  return setByte(bitfield, byteOffset, byte | 1 << bitOffset);\n};\n\n/**\n * Unsets a particular bit.\n\n * @param {Uint8Array} bitfield\n * @param {number} index\n * @returns {Uint8Array}\n */\nexport const unset = (bitfield, index) => {\n  const {\n    byte,\n    byteOffset,\n    bitOffset\n  } = at(bitfield, index);\n  return setByte(bitfield, byteOffset, byte & (0xff ^ 1 << bitOffset));\n};\n\n/**\n * Returns `true` if bit at given index is set.\n *\n * @param {Uint8Array} bitfield\n * @param {number} index\n */\nexport const get = (bitfield, index) => {\n  var {\n    byte,\n    bitOffset\n  } = at(bitfield, index);\n  return (byte >> bitOffset & 0x1) !== 0;\n};\n\n/**\n * @param {Uint8Array} bitfield\n */\nexport const toBytes = bitfield => bitfield;\n\n/**\n * @param {Uint8Array} bytes\n */\nexport const fromBytes = bytes => bytes;\n\n/**\n * @param {Uint8Array} bitfield\n * @param {number} index\n */\nexport const popcount = (bitfield, index = bitfield.byteLength * 8) => {\n  const {\n    byteOffset,\n    bitOffset,\n    byte\n  } = at(bitfield, index);\n  let count = popcount32(byte, bitOffset);\n  let offset = bitfield.byteLength - 1;\n  while (offset > byteOffset) {\n    const byte = bitfield[offset];\n    count += bitCount(byte);\n    offset--;\n  }\n  return count;\n};\n\n/**\n * @param {Uint8Array} left\n * @param {Uint8Array} right\n */\nexport const or = (left, right) => {\n  const result = left.slice();\n  let offset = 0;\n  while (offset < left.length) {\n    result[offset] |= right[offset];\n    offset++;\n  }\n  return result;\n};\n\n/**\n * @param {Uint8Array} left\n * @param {Uint8Array} right\n */\nexport const and = (left, right) => {\n  const result = left.slice();\n  let offset = 0;\n  while (offset < left.length) {\n    result[offset] &= right[offset];\n    offset++;\n  }\n  return result;\n};\nexport { API };","map":{"version":3,"names":["bitCount","popcount","popcount32","API","empty","size","Error","Uint8Array","from","bits","bitfield","index","byte","byteOffset","bitOffset","at","byteLength","setByte","bytes","result","slice","set","unset","get","toBytes","fromBytes","count","offset","or","left","right","length","and"],"sources":["C:/FACULTATE/Proiect/node_modules/@perma/map/src/bitfield/Uint8Array.js"],"sourcesContent":["import { bitCount, popcount as popcount32 } from \"./Uint32.js\"\nimport * as API from \"./api.js\"\n\n/**\n * @param {number} size\n */\nexport const empty = (size = 256) => {\n  if (size % 8 !== 0) {\n    throw new Error(`Must be multiple of 8`)\n  }\n\n  return new Uint8Array(size / 8)\n}\n\n/**\n * Creates bitfield with specific bits set.\n *\n * @param {number[]} bits\n * @param {number} [size]\n * @returns {Uint8Array}\n */\nexport const from = (bits, size) => {\n  let bitfield = empty(size)\n  for (const index of bits) {\n    const { byte, byteOffset, bitOffset } = at(bitfield, index)\n    bitfield[byteOffset] = byte | (1 << bitOffset)\n  }\n  return bitfield\n}\n\n/**\n * @param {Uint8Array} bitfield\n */\nexport const size = bitfield => bitfield.byteLength * 8\n\n/**\n * Compute offset for the given index\n *\n * @param {Uint8Array} bitfield\n * @param {number} index\n */\nconst at = (bitfield, index) => {\n  const byteOffset = bitfield.byteLength - 1 - ((index / 8) | 0)\n  const bitOffset = index % 8\n  const byte = bitfield[byteOffset]\n\n  return { byte, byteOffset, bitOffset }\n}\n\n/**\n * Set a particular bit.\n *\n * @param {Uint8Array} bytes\n * @param {number} index\n * @param {number} byte\n * @returns {Uint8Array}\n */\nconst setByte = (bytes, index, byte) => {\n  if (bytes[index] !== byte) {\n    const result = bytes.slice(0)\n    result[index] = byte\n    return result\n  }\n  return bytes\n}\n\n/**\n * Set a particular bit.\n *\n * @param {Uint8Array} bitfield\n * @param {number} index\n * @returns {Uint8Array}\n */\nexport const set = (bitfield, index) => {\n  const { byte, byteOffset, bitOffset } = at(bitfield, index)\n  return setByte(bitfield, byteOffset, byte | (1 << bitOffset))\n}\n\n/**\n * Unsets a particular bit.\n\n * @param {Uint8Array} bitfield\n * @param {number} index\n * @returns {Uint8Array}\n */\nexport const unset = (bitfield, index) => {\n  const { byte, byteOffset, bitOffset } = at(bitfield, index)\n  return setByte(bitfield, byteOffset, byte & (0xff ^ (1 << bitOffset)))\n}\n\n/**\n * Returns `true` if bit at given index is set.\n *\n * @param {Uint8Array} bitfield\n * @param {number} index\n */\nexport const get = (bitfield, index) => {\n  var { byte, bitOffset } = at(bitfield, index)\n  return ((byte >> bitOffset) & 0x1) !== 0\n}\n\n/**\n * @param {Uint8Array} bitfield\n */\nexport const toBytes = bitfield => bitfield\n\n/**\n * @param {Uint8Array} bytes\n */\nexport const fromBytes = bytes => bytes\n\n/**\n * @param {Uint8Array} bitfield\n * @param {number} index\n */\nexport const popcount = (bitfield, index = bitfield.byteLength * 8) => {\n  const { byteOffset, bitOffset, byte } = at(bitfield, index)\n\n  let count = popcount32(byte, bitOffset)\n  let offset = bitfield.byteLength - 1\n  while (offset > byteOffset) {\n    const byte = bitfield[offset]\n    count += bitCount(byte)\n    offset--\n  }\n\n  return count\n}\n\n/**\n * @param {Uint8Array} left\n * @param {Uint8Array} right\n */\nexport const or = (left, right) => {\n  const result = left.slice()\n  let offset = 0\n  while (offset < left.length) {\n    result[offset] |= right[offset]\n    offset++\n  }\n  return result\n}\n\n/**\n * @param {Uint8Array} left\n * @param {Uint8Array} right\n */\nexport const and = (left, right) => {\n  const result = left.slice()\n  let offset = 0\n  while (offset < left.length) {\n    result[offset] &= right[offset]\n    offset++\n  }\n  return result\n}\n\nexport { API }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}