{"ast":null,"code":"import * as UCAN from \"./ucan.js\";\nimport * as CBOR from \"./codec/cbor.js\";\nimport * as JWT from \"./codec/jwt.js\";\nimport * as UTF8 from \"./utf8.js\";\nimport { readPayload } from \"./schema.js\";\nimport { parse as parseDID } from \"./did.js\";\nimport { parse as parseJWT } from \"./parser.js\";\nimport { formatSignPayload } from \"./formatter.js\";\nimport { sha256 } from \"multiformats/hashes/sha2\";\nimport { create as createLink } from \"multiformats/link\";\nimport { format as formatDID } from \"./did.js\";\nexport * from \"./ucan.js\";\nexport const VERSION = \"0.9.1\";\nexport const name = \"dag-ucan\";\nexport const code = /** @type {UCAN.Code} */CBOR.code;\n\n/**\n * We cast sha256 to workaround typescripts limited inference problem when using\n * sha256 as default. If hasher is omitted type `A` should match sha256.code\n * but TS fails to deduce that.\n * @type {UCAN.MultihashHasher<any>}\n */\nconst defaultHasher = sha256;\n\n/**\n * Encodes given UCAN (in either IPLD or JWT representation) and encodes it into\n * corresponding bytes representation. UCAN in IPLD representation is encoded as\n * DAG-CBOR which JWT representation is encoded as raw bytes of JWT string.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.UCAN<C>} ucan\n * @returns {UCAN.ByteView<UCAN.UCAN<C>>}\n */\nexport const encode = ucan => ucan.jwt ? JWT.encode(ucan) : CBOR.encode(ucan);\n\n/**\n * Decodes binary encoded UCAN. It assumes UCAN is in primary IPLD\n * representation and attempts to decode it with DAG-CBOR, if that\n * fails it falls back to secondary representation and parses it as\n * a JWT.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.ByteView<UCAN.UCAN<C>>} bytes\n * @returns {UCAN.View<C>}\n */\nexport const decode = bytes => {\n  try {\n    return CBOR.decode(bytes);\n  } catch (_) {\n    return JWT.decode( /** @type {UCAN.ByteView<UCAN.FromJWT<C>>} */bytes);\n  }\n};\n\n/**\n * Convenience function to create a CID for the given UCAN. If UCAN is\n * in JWT representation get CID with RAW multicodec, while UCANs in IPLD\n * representation get UCAN multicodec code.\n *\n * @template {UCAN.Capabilities} C\n * @template {number} [A=typeof sha256.code] - Multihash code\n * @param {UCAN.View<C>} ucan\n * @param {{hasher?: UCAN.MultihashHasher<A>}} [options]\n */\nexport const link = async (ucan, options) => {\n  const {\n    cid\n  } = await write(ucan, options);\n  return cid;\n};\n\n/**\n * @template {UCAN.Capabilities} C\n * @template {number} [A=typeof sha256.code] - Multihash code\n * @param {UCAN.UCAN<C>} ucan\n * @param {{hasher?: UCAN.MultihashHasher<A>}} options\n * @returns {Promise<UCAN.Block<C, UCAN.Code, A>>}\n */\nexport const write = async (ucan, {\n  hasher = defaultHasher\n} = {}) => {\n  const [code, bytes] = ucan.jwt ? [JWT.code, JWT.encode(ucan)] : [CBOR.code, CBOR.encode(ucan)];\n  const digest = await hasher.digest(bytes);\n  return {\n    bytes,\n    cid: createLink(code, digest),\n    data: ucan\n  };\n};\n\n/**\n * Parses UCAN formatted as JWT string. Returns UCAN view in IPLD representation\n * when serializing it back would produce original string, otherwise returns UCAN\n * view in secondary JWT representation which is not as compact, but it retains\n * key order and whitespaces so it could be formatted back to same JWT string.\n * View will have `type` field with either `\"IPLD\"` or `\"JWT\"` value telling\n * in which representation UCAN is.\n *\n * Note: Parsing does not perform validation of capabilities or semantics of the\n * UCAN, it only ensures structure is spec compliant and throws `ParseError`\n * if it is not.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.JWT<C>|string} jwt\n * @returns {UCAN.View<C>}\n */\nexport const parse = jwt => {\n  const model = parseJWT(jwt);\n\n  // If formatting UCAN produces same jwt string we can use IPLD representation\n  // otherwise we need to fallback to raw representation. This decision will\n  // affect how we `encode` the UCAN.\n  return CBOR.format(model) === jwt ? CBOR.from(model) : JWT.from({\n    ...model,\n    jwt: ( /** @type {UCAN.JWT<C>} */jwt)\n  });\n};\n\n/**\n * Takes UCAN object and formats it into JWT string.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.UCAN<C>} ucan\n * @returns {UCAN.JWT<C>}\n */\nexport const format = ucan => ucan.jwt ? JWT.format(ucan) : CBOR.format(ucan);\n\n/**\n * Creates a new signed token with a given `options.issuer`. If expiration is\n * not set it defaults to 30 seconds from now. Returns UCAN in primary - IPLD\n * representation.\n *\n * @template {number} A\n * @template {UCAN.Capabilities} C\n * @param {UCAN.UCANOptions<C, A>} options\n * @returns {Promise<UCAN.View<C>>}\n */\nexport const issue = async ({\n  issuer,\n  audience,\n  capabilities,\n  lifetimeInSeconds = 30,\n  expiration = now() + lifetimeInSeconds,\n  notBefore,\n  facts = [],\n  proofs = [],\n  nonce\n}) => {\n  const v = VERSION;\n  const data = readPayload({\n    iss: parseDID(issuer.did()),\n    aud: parseDID(audience.did()),\n    att: capabilities,\n    fct: facts,\n    exp: expiration,\n    nbf: notBefore,\n    prf: proofs,\n    nnc: nonce\n  });\n  const payload = encodeSignaturePayload(data, v, issuer.signatureAlgorithm);\n  return CBOR.from({\n    ...data,\n    v,\n    s: await issuer.sign(payload)\n  });\n};\n\n/**\n *\n * @param {UCAN.Payload} payload\n * @param {UCAN.Version} version\n * @param {string} algorithm\n * @returns\n */\nconst encodeSignaturePayload = (payload, version, algorithm) => UTF8.encode(formatSignPayload(payload, version, algorithm));\n\n/**\n * Verifies UCAN signature.\n *\n * @param {UCAN.View} ucan\n * @param {UCAN.Verifier} verifier\n */\nexport const verifySignature = (ucan, verifier) => formatDID(ucan.issuer) === verifier.did() && verifier.verify(encodeSignaturePayload(ucan.model, ucan.model.v, ucan.signature.algorithm), ucan.signature);\n\n/**\n * Check if a UCAN is expired.\n *\n * @param {UCAN.View} ucan\n */\nexport const isExpired = ucan => ucan.expiration <= now();\n\n/**\n * Check if a UCAN is not active yet.\n * @param {UCAN.View} ucan\n */\nexport const isTooEarly = ucan => ucan.notBefore != null && now() <= ucan.notBefore;\n\n/**\n * Returns UTC Unix timestamp for comparing it against time window of the UCAN.\n */\nexport const now = () => Math.floor(Date.now() / 1000);","map":{"version":3,"names":["UCAN","CBOR","JWT","UTF8","readPayload","parse","parseDID","parseJWT","formatSignPayload","sha256","create","createLink","format","formatDID","VERSION","name","code","defaultHasher","encode","ucan","jwt","decode","bytes","_","link","options","cid","write","hasher","digest","data","model","from","issue","issuer","audience","capabilities","lifetimeInSeconds","expiration","now","notBefore","facts","proofs","nonce","v","iss","did","aud","att","fct","exp","nbf","prf","nnc","payload","encodeSignaturePayload","signatureAlgorithm","s","sign","version","algorithm","verifySignature","verifier","verify","signature","isExpired","isTooEarly","Math","floor","Date"],"sources":["C:/FACULTATE/Proiect/node_modules/@ipld/dag-ucan/src/lib.js"],"sourcesContent":["import * as UCAN from \"./ucan.js\"\nimport * as CBOR from \"./codec/cbor.js\"\nimport * as JWT from \"./codec/jwt.js\"\nimport * as UTF8 from \"./utf8.js\"\nimport { readPayload } from \"./schema.js\"\nimport { parse as parseDID } from \"./did.js\"\nimport { parse as parseJWT } from \"./parser.js\"\nimport { formatSignPayload } from \"./formatter.js\"\nimport { sha256 } from \"multiformats/hashes/sha2\"\nimport { create as createLink } from \"multiformats/link\"\nimport { format as formatDID } from \"./did.js\"\n\nexport * from \"./ucan.js\"\n\nexport const VERSION = \"0.9.1\"\nexport const name = \"dag-ucan\"\nexport const code = /** @type {UCAN.Code} */ (CBOR.code)\n\n/**\n * We cast sha256 to workaround typescripts limited inference problem when using\n * sha256 as default. If hasher is omitted type `A` should match sha256.code\n * but TS fails to deduce that.\n * @type {UCAN.MultihashHasher<any>}\n */\nconst defaultHasher = sha256\n\n/**\n * Encodes given UCAN (in either IPLD or JWT representation) and encodes it into\n * corresponding bytes representation. UCAN in IPLD representation is encoded as\n * DAG-CBOR which JWT representation is encoded as raw bytes of JWT string.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.UCAN<C>} ucan\n * @returns {UCAN.ByteView<UCAN.UCAN<C>>}\n */\nexport const encode = ucan => (ucan.jwt ? JWT.encode(ucan) : CBOR.encode(ucan))\n\n/**\n * Decodes binary encoded UCAN. It assumes UCAN is in primary IPLD\n * representation and attempts to decode it with DAG-CBOR, if that\n * fails it falls back to secondary representation and parses it as\n * a JWT.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.ByteView<UCAN.UCAN<C>>} bytes\n * @returns {UCAN.View<C>}\n */\nexport const decode = bytes => {\n  try {\n    return CBOR.decode(bytes)\n  } catch (_) {\n    return JWT.decode(/** @type {UCAN.ByteView<UCAN.FromJWT<C>>} */ (bytes))\n  }\n}\n\n/**\n * Convenience function to create a CID for the given UCAN. If UCAN is\n * in JWT representation get CID with RAW multicodec, while UCANs in IPLD\n * representation get UCAN multicodec code.\n *\n * @template {UCAN.Capabilities} C\n * @template {number} [A=typeof sha256.code] - Multihash code\n * @param {UCAN.View<C>} ucan\n * @param {{hasher?: UCAN.MultihashHasher<A>}} [options]\n */\nexport const link = async (ucan, options) => {\n  const { cid } = await write(ucan, options)\n  return cid\n}\n\n/**\n * @template {UCAN.Capabilities} C\n * @template {number} [A=typeof sha256.code] - Multihash code\n * @param {UCAN.UCAN<C>} ucan\n * @param {{hasher?: UCAN.MultihashHasher<A>}} options\n * @returns {Promise<UCAN.Block<C, UCAN.Code, A>>}\n */\nexport const write = async (ucan, { hasher = defaultHasher } = {}) => {\n  const [code, bytes] = ucan.jwt\n    ? [JWT.code, JWT.encode(ucan)]\n    : [CBOR.code, CBOR.encode(ucan)]\n  const digest = await hasher.digest(bytes)\n\n  return {\n    bytes,\n    cid: createLink(code, digest),\n    data: ucan,\n  }\n}\n\n/**\n * Parses UCAN formatted as JWT string. Returns UCAN view in IPLD representation\n * when serializing it back would produce original string, otherwise returns UCAN\n * view in secondary JWT representation which is not as compact, but it retains\n * key order and whitespaces so it could be formatted back to same JWT string.\n * View will have `type` field with either `\"IPLD\"` or `\"JWT\"` value telling\n * in which representation UCAN is.\n *\n * Note: Parsing does not perform validation of capabilities or semantics of the\n * UCAN, it only ensures structure is spec compliant and throws `ParseError`\n * if it is not.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.JWT<C>|string} jwt\n * @returns {UCAN.View<C>}\n */\nexport const parse = jwt => {\n  const model = parseJWT(jwt)\n\n  // If formatting UCAN produces same jwt string we can use IPLD representation\n  // otherwise we need to fallback to raw representation. This decision will\n  // affect how we `encode` the UCAN.\n  return CBOR.format(model) === jwt\n    ? CBOR.from(model)\n    : JWT.from({ ...model, jwt: /** @type {UCAN.JWT<C>} */ (jwt) })\n}\n\n/**\n * Takes UCAN object and formats it into JWT string.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.UCAN<C>} ucan\n * @returns {UCAN.JWT<C>}\n */\nexport const format = ucan => (ucan.jwt ? JWT.format(ucan) : CBOR.format(ucan))\n\n/**\n * Creates a new signed token with a given `options.issuer`. If expiration is\n * not set it defaults to 30 seconds from now. Returns UCAN in primary - IPLD\n * representation.\n *\n * @template {number} A\n * @template {UCAN.Capabilities} C\n * @param {UCAN.UCANOptions<C, A>} options\n * @returns {Promise<UCAN.View<C>>}\n */\nexport const issue = async ({\n  issuer,\n  audience,\n  capabilities,\n  lifetimeInSeconds = 30,\n  expiration = now() + lifetimeInSeconds,\n  notBefore,\n  facts = [],\n  proofs = [],\n  nonce,\n}) => {\n  const v = VERSION\n  const data = readPayload({\n    iss: parseDID(issuer.did()),\n    aud: parseDID(audience.did()),\n    att: capabilities,\n    fct: facts,\n    exp: expiration,\n    nbf: notBefore,\n    prf: proofs,\n    nnc: nonce,\n  })\n  const payload = encodeSignaturePayload(data, v, issuer.signatureAlgorithm)\n\n  return CBOR.from({\n    ...data,\n    v,\n    s: await issuer.sign(payload),\n  })\n}\n\n/**\n *\n * @param {UCAN.Payload} payload\n * @param {UCAN.Version} version\n * @param {string} algorithm\n * @returns\n */\nconst encodeSignaturePayload = (payload, version, algorithm) =>\n  UTF8.encode(formatSignPayload(payload, version, algorithm))\n\n/**\n * Verifies UCAN signature.\n *\n * @param {UCAN.View} ucan\n * @param {UCAN.Verifier} verifier\n */\nexport const verifySignature = (ucan, verifier) =>\n  formatDID(ucan.issuer) === verifier.did() &&\n  verifier.verify(\n    encodeSignaturePayload(ucan.model, ucan.model.v, ucan.signature.algorithm),\n    ucan.signature\n  )\n\n/**\n * Check if a UCAN is expired.\n *\n * @param {UCAN.View} ucan\n */\nexport const isExpired = ucan => ucan.expiration <= now()\n\n/**\n * Check if a UCAN is not active yet.\n * @param {UCAN.View} ucan\n */\nexport const isTooEarly = ucan =>\n  ucan.notBefore != null && now() <= ucan.notBefore\n\n/**\n * Returns UTC Unix timestamp for comparing it against time window of the UCAN.\n */\nexport const now = () => Math.floor(Date.now() / 1000)\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}