{"ast":null,"code":"import * as API from '@ucanto/interface';\nimport { isDelegation, UCAN, ok, fail } from '@ucanto/core';\nimport { capability } from './capability.js';\nimport * as Schema from '@ucanto/core/schema';\nimport * as Authorization from './authorization.js';\nimport { UnavailableProof, Unauthorized, PrincipalAlignmentError, Expired, Revoked, NotValidBefore, InvalidSignature, SessionEscalation, DelegationError, Failure, MalformedCapability, DIDKeyResolutionError, li } from './error.js';\nexport { capability } from './capability.js';\nexport * from '@ucanto/core/schema';\nexport { Schema, Authorization, Failure, fail, ok, Revoked, UnavailableProof, Unauthorized, MalformedCapability, DIDKeyResolutionError as DIDResolutionError };\n\n/**\n * @param {UCAN.Link} proof\n * @returns {{error:API.UnavailableProof}}\n */\nconst unavailable = proof => ({\n  error: new UnavailableProof(proof)\n});\n\n/**\n *\n * @param {UCAN.DID} did\n * @returns {{error:API.DIDKeyResolutionError}}\n */\nconst failDIDKeyResolution = did => ({\n  error: new DIDKeyResolutionError(did)\n});\n\n/**\n * @param {Required<API.ClaimOptions>} config\n * @param {API.Match<unknown, API.Match>} match\n */\n\nconst resolveMatch = async (match, config) => {\n  const promises = [];\n  const includes = new Set();\n  for (const source of match.source) {\n    const id = source.delegation.cid.toString();\n    if (!includes.has(id)) {\n      promises.push(await resolveSources(source, config));\n    }\n  }\n  const groups = await Promise.all(promises);\n  const sources = [];\n  const errors = [];\n  for (const group of groups) {\n    sources.push(...group.sources);\n    errors.push(...group.errors);\n  }\n  return {\n    sources,\n    errors\n  };\n};\n\n/**\n * Takes `proofs` from the delegation which may contain `Delegation` or a link\n * to one and attempts to resolve links by side loading them. Returns set of\n * resolved `Delegation`s and errors for the proofs that could not be resolved.\n *\n * @param {API.Proof[]} proofs\n * @param {Required<API.ProofResolver>} config\n */\nconst resolveProofs = async (proofs, config) => {\n  /** @type {API.Delegation[]} */\n  const delegations = [];\n  /** @type {API.UnavailableProof[]} */\n  const errors = [];\n  const promises = [];\n  for (const proof of proofs) {\n    // If it is a delegation we can just add it to the resolved set.\n    if (isDelegation(proof)) {\n      delegations.push(proof);\n    }\n    // otherwise we attempt to resolve the link asynchronously. To avoid doing\n    // sequential requests we create promise for each link and then wait for\n    // all of them at the end.\n    else {\n      promises.push(new Promise(async resolve => {\n        // config.resolve is not supposed to throw, but we catch it just in\n        // case it does and consider proof resolution failed.\n        try {\n          const result = await config.resolve(proof);\n          if (result.error) {\n            errors.push(result.error);\n          } else {\n            delegations.push(result.ok);\n          }\n        } catch (error) {\n          errors.push(new UnavailableProof(proof, /** @type {Error} */error));\n        }\n\n        // we don't care about the result, we just need to signal that we are\n        // done with this promise.\n        resolve(null);\n      }));\n    }\n  }\n\n  // Wait for all the promises to resolve. At this point we have collected all\n  // the resolved delegations and errors.\n  await Promise.all(promises);\n  return {\n    delegations,\n    errors\n  };\n};\n\n/**\n * Takes a delegation source and attempts to resolve all the linked proofs.\n *\n * @param {API.Source} from\n * @param {Required<API.ClaimOptions>} config\n * @return {Promise<{sources:API.Source[], errors:ProofError[]}>}\n */\nconst resolveSources = async ({\n  delegation\n}, config) => {\n  const errors = [];\n  const sources = [];\n  const proofs = [];\n  // First we attempt to resolve all the linked proofs.\n  const {\n    delegations,\n    errors: failedProofs\n  } = await resolveProofs(delegation.proofs, config);\n\n  // All the proofs that failed to resolve are saved as proof errors.\n  for (const error of failedProofs) {\n    errors.push(new ProofError(error.link, error));\n  }\n\n  // All the proofs that resolved are checked for principal alignment. Ones that\n  // do not align are saved as proof errors.\n  for (const proof of delegations) {\n    // If proof does not delegate to a matching audience save an proof error.\n    if (delegation.issuer.did() !== proof.audience.did()) {\n      errors.push(new ProofError(proof.cid, new PrincipalAlignmentError(delegation.issuer, proof)));\n    } else {\n      proofs.push(proof);\n    }\n  }\n  // In the second pass we attempt to proofs that were resolved and are aligned.\n  for (const proof of proofs) {\n    // If proof is not valid (expired, not active yet or has incorrect\n    // signature) save a corresponding proof error.\n    const validation = await validate(proof, proofs, config);\n    if (validation.error) {\n      errors.push(new ProofError(proof.cid, validation.error));\n    } else {\n      // otherwise create source objects for it's capabilities, so we could\n      // track which proof in which capability the are from.\n      for (const capability of proof.capabilities) {\n        sources.push( /** @type {API.Source} */{\n          capability,\n          delegation: proof\n        });\n      }\n    }\n  }\n  return {\n    sources,\n    errors\n  };\n};\n\n/**\n * @param {API.ParsedCapability} capability\n * @param {API.DID} issuer\n */\nconst isSelfIssued = (capability, issuer) => capability.with === issuer;\n\n/**\n * Finds a valid path in a proof chain of the given `invocation` by exploring\n * every possible option. On success an `Authorization` object is returned that\n * illustrates the valid path. If no valid path is found `Unauthorized` error\n * is returned detailing all explored paths and where they proved to fail.\n *\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {R} URI\n * @template {API.Caveats} C\n * @param {API.Invocation<API.Capability<A, URI, C>>} invocation\n * @param {API.ValidationOptions<API.ParsedCapability<A, R, C>>} options\n * @returns {Promise<API.Result<API.Authorization<API.ParsedCapability<A, R, C>>, API.Unauthorized>>}\n */\nexport const access = async (invocation, {\n  capability,\n  ...config\n}) => claim(capability, [invocation], config);\n\n/**\n * Attempts to find a valid proof chain for the claimed `capability` given set\n * of `proofs`. On success an `Authorization` object with detailed proof chain\n * is returned and on failure `Unauthorized` error is returned with details on\n * paths explored and why they have failed.\n *\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @param {API.CapabilityParser<API.Match<API.ParsedCapability<A, R, C>>>} capability\n * @param {API.Proof[]} proofs\n * @param {API.ClaimOptions} config\n * @returns {Promise<API.Result<API.Authorization<API.ParsedCapability<A, R, C>>, API.Unauthorized>>}\n */\nexport const claim = async (capability, proofs, {\n  authority,\n  principal,\n  validateAuthorization,\n  resolveDIDKey = failDIDKeyResolution,\n  canIssue = isSelfIssued,\n  resolve = unavailable\n}) => {\n  const config = {\n    canIssue,\n    resolve,\n    principal,\n    capability,\n    authority,\n    validateAuthorization,\n    resolveDIDKey\n  };\n  const invalidProofs = [];\n\n  /** @type {API.Source[]} */\n  const sources = [];\n  const {\n    delegations,\n    errors\n  } = await resolveProofs(proofs, config);\n  invalidProofs.push(...errors);\n  for (const proof of delegations) {\n    // Validate each proof if valid add ech capability to the list of sources.\n    // otherwise collect the error.\n    const validation = await validate(proof, delegations, config);\n    if (validation.ok) {\n      for (const capability of validation.ok.capabilities.values()) {\n        sources.push( /** @type {API.Source} */{\n          capability,\n          delegation: validation.ok\n        });\n      }\n    } else {\n      invalidProofs.push(validation.error);\n    }\n  }\n  // look for the matching capability\n  const selection = capability.select(sources);\n  const {\n    errors: delegationErrors,\n    unknown: unknownCapabilities\n  } = selection;\n  const failedProofs = [];\n  for (const matched of selection.matches) {\n    const selector = matched.prune(config);\n    if (selector == null) {\n      const authorization = Authorization.create(matched, []);\n      const result = await validateAuthorization(authorization);\n      if (result.error) {\n        invalidProofs.push(result.error);\n      } else {\n        return {\n          ok: authorization\n        };\n      }\n    } else {\n      const result = await authorize(selector, config);\n      if (result.error) {\n        failedProofs.push(result.error);\n      } else {\n        const authorization = Authorization.create(matched, [result.ok]);\n        const approval = await validateAuthorization(authorization);\n        if (approval.error) {\n          invalidProofs.push(approval.error);\n        } else {\n          return {\n            ok: authorization\n          };\n        }\n      }\n    }\n  }\n  return {\n    error: new Unauthorized({\n      capability,\n      delegationErrors,\n      unknownCapabilities,\n      invalidProofs,\n      failedProofs\n    })\n  };\n};\n\n/**\n * Verifies whether any of the delegated proofs grant give capability.\n *\n * @template {API.Match} Match\n * @param {Match} match\n * @param {Required<API.ClaimOptions>} config\n * @returns {Promise<API.Result<API.Authorization<API.ParsedCapability>, API.InvalidClaim>>}\n */\n\nexport const authorize = async (match, config) => {\n  // load proofs from all delegations\n  const {\n    sources,\n    errors: invalidProofs\n  } = await resolveMatch(match, config);\n  const selection = match.select(sources);\n  const {\n    errors: delegationErrors,\n    unknown: unknownCapabilities\n  } = selection;\n  const failedProofs = [];\n  for (const matched of selection.matches) {\n    const selector = matched.prune(config);\n    if (selector == null) {\n      return {\n        ok: Authorization.create(\n        // @ts-expect-error - it may not be a parsed capability but rather a\n        // group of capabilities but we can deal with that in the future.\n        matched, [])\n      };\n    } else {\n      const result = await authorize(selector, config);\n      if (result.error) {\n        failedProofs.push(result.error);\n      } else {\n        return {\n          ok: Authorization.create(\n          // @ts-expect-error - it may not be a parsed capability but rather a\n          // group of capabilities but we can deal with that in the future.\n          matched, [result.ok])\n        };\n      }\n    }\n  }\n  return {\n    error: new InvalidClaim({\n      match,\n      delegationErrors,\n      unknownCapabilities,\n      invalidProofs,\n      failedProofs\n    })\n  };\n};\nclass ProofError extends Failure {\n  /**\n   * @param {API.UCANLink} proof\n   * @param {API.Failure} cause\n   */\n  constructor(proof, cause) {\n    super();\n    this.name = 'ProofError';\n    this.proof = proof;\n    this.cause = cause;\n  }\n  describe() {\n    return [`Capability can not be derived from prf:${this.proof} because:`, li(this.cause.message)].join(`\\n`);\n  }\n}\n\n/**\n * @implements {API.InvalidClaim}\n */\nclass InvalidClaim extends Failure {\n  /**\n   * @param {{\n   * match: API.Match\n   * delegationErrors: API.DelegationError[]\n   * unknownCapabilities: API.Capability[]\n   * invalidProofs: ProofError[]\n   * failedProofs: API.InvalidClaim[]\n   * }} info\n   */\n  constructor(info) {\n    super();\n    this.info = info;\n    /** @type {\"InvalidClaim\"} */\n    this.name = 'InvalidClaim';\n  }\n  get issuer() {\n    return this.delegation.issuer;\n  }\n  get delegation() {\n    return this.info.match.source[0].delegation;\n  }\n  describe() {\n    const errors = [...this.info.failedProofs.map(error => li(error.message)), ...this.info.delegationErrors.map(error => li(error.message)), ...this.info.invalidProofs.map(error => li(error.message))];\n    const unknown = this.info.unknownCapabilities.map(c => li(JSON.stringify(c)));\n    return [`Capability ${this.info.match} is not authorized because:`, li(`Capability can not be (self) issued by '${this.issuer.did()}'`), ...(errors.length > 0 ? errors : [li(`Delegated capability not found`)]), ...(unknown.length > 0 ? [li(`Encountered unknown capabilities\\n${unknown.join('\\n')}`)] : [])].join('\\n');\n  }\n}\n\n/**\n * Validate a delegation to check it is within the time bound and that it is\n * authorized by the issuer.\n *\n * @template {API.Delegation} T\n * @param {T} delegation\n * @param {API.Delegation[]} proofs\n * @param {Required<API.ClaimOptions>} config\n * @returns {Promise<API.Result<T, API.InvalidProof|API.SessionEscalation|API.DIDKeyResolutionError>>}\n */\nconst validate = async (delegation, proofs, config) => {\n  if (UCAN.isExpired(delegation.data)) {\n    return {\n      error: new Expired( /** @type {API.Delegation & {expiration: number}} */delegation)\n    };\n  }\n  if (UCAN.isTooEarly(delegation.data)) {\n    return {\n      error: new NotValidBefore( /** @type {API.Delegation & {notBefore: number}} */delegation)\n    };\n  }\n  return await verifyAuthorization(delegation, proofs, config);\n};\n\n/**\n * Verifies that delegation has been authorized by the issuer. If issued by the\n * did:key principal checks that the signature is valid. If issued by the root\n * authority checks that the signature is valid. If issued by the principal\n * identified by other DID method attempts to resolve a valid `ucan/attest`\n * attestation from the authority, if attestation is not found falls back to\n * resolving did:key for the issuer and verifying its signature.\n *\n * @template {API.Delegation} T\n * @param {T} delegation\n * @param {API.Delegation[]} proofs\n * @param {Required<API.ClaimOptions>} config\n * @returns {Promise<API.Result<T, API.InvalidSignature|API.SessionEscalation|API.DIDKeyResolutionError>>}\n */\nconst verifyAuthorization = async (delegation, proofs, config) => {\n  const issuer = delegation.issuer.did();\n  // If the issuer is a did:key we just verify a signature\n  if (issuer.startsWith('did:key:')) {\n    return verifySignature(delegation, config.principal.parse(issuer));\n  }\n  // If the issuer is the root authority we use authority itself to verify\n  else if (issuer === config.authority.did()) {\n    return verifySignature(delegation, config.authority);\n  } else {\n    // If issuer is not a did:key principal nor configured authority, we\n    // attempt to resolve embedded authorization session from the authority.\n    const session = await verifySession(delegation, proofs, config);\n    // If we have valid session we consider authorization valid\n    if (session.ok) {\n      return {\n        ok: delegation\n      };\n    } else if (session.error.failedProofs.length > 0) {\n      return {\n        error: new SessionEscalation({\n          delegation,\n          cause: session.error\n        })\n      };\n    }\n    // Otherwise we try to resolve did:key from the DID instead\n    // and use that to verify the signature\n    else {\n      const verifier = await config.resolveDIDKey(issuer);\n      if (verifier.error) {\n        return verifier;\n      } else {\n        return verifySignature(delegation, config.principal.parse(verifier.ok).withDID(issuer));\n      }\n    }\n  }\n};\n\n/**\n * @template {API.Delegation} T\n * @param {T} delegation\n * @param {API.Verifier} verifier\n * @returns {Promise<API.Result<T, API.InvalidSignature|API.DIDKeyResolutionError>>}\n */\nconst verifySignature = async (delegation, verifier) => {\n  const valid = await UCAN.verifySignature(delegation.data, verifier);\n  return valid ? {\n    ok: delegation\n  } : {\n    error: new InvalidSignature(delegation, verifier)\n  };\n};\n\n/**\n * Attempts to find an authorization session - an `ucan/attest` capability\n * delegation where `with` matches `config.authority` and `nb.proof`\n * matches given delegation.\n * @see https://github.com/web3-storage/specs/blob/feat/auth+account/w3-session.md#authorization-session\n *\n * @param {API.Delegation} delegation\n * @param {API.Delegation[]} proofs\n * @param {Required<API.ClaimOptions>} config\n */\nconst verifySession = async (delegation, proofs, config) => {\n  // Create a schema that will match an authorization for this exact delegation\n  const attestation = capability({\n    with: Schema.literal(config.authority.did()),\n    can: 'ucan/attest',\n    nb: Schema.struct({\n      proof: Schema.link(delegation.cid)\n    })\n  });\n  return await claim(attestation,\n  // We only consider attestations otherwise we will end up doing an\n  // exponential scan if there are other proofs that require attestations.\n  proofs.filter(isAttestation), config);\n};\n\n/**\n * Checks if the delegation is an attestation.\n *\n * @param {API.Delegation} proof\n */\nconst isAttestation = proof => proof.capabilities[0]?.can === 'ucan/attest';","map":{"version":3,"names":["API","isDelegation","UCAN","ok","fail","capability","Schema","Authorization","UnavailableProof","Unauthorized","PrincipalAlignmentError","Expired","Revoked","NotValidBefore","InvalidSignature","SessionEscalation","DelegationError","Failure","MalformedCapability","DIDKeyResolutionError","li","DIDResolutionError","unavailable","proof","error","failDIDKeyResolution","did","resolveMatch","match","config","promises","includes","Set","source","id","delegation","cid","toString","has","push","resolveSources","groups","Promise","all","sources","errors","group","resolveProofs","proofs","delegations","resolve","result","failedProofs","ProofError","link","issuer","audience","validation","validate","capabilities","isSelfIssued","with","access","invocation","claim","authority","principal","validateAuthorization","resolveDIDKey","canIssue","invalidProofs","values","selection","select","delegationErrors","unknown","unknownCapabilities","matched","matches","selector","prune","authorization","create","authorize","approval","InvalidClaim","constructor","cause","name","describe","message","join","info","map","c","JSON","stringify","length","isExpired","data","isTooEarly","verifyAuthorization","startsWith","verifySignature","parse","session","verifySession","verifier","withDID","valid","attestation","literal","can","nb","struct","filter","isAttestation"],"sources":["C:/FACULTATE/Proiect/node_modules/@ucanto/validator/src/lib.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport { isDelegation, UCAN, ok, fail } from '@ucanto/core'\nimport { capability } from './capability.js'\nimport * as Schema from '@ucanto/core/schema'\nimport * as Authorization from './authorization.js'\nimport {\n  UnavailableProof,\n  Unauthorized,\n  PrincipalAlignmentError,\n  Expired,\n  Revoked,\n  NotValidBefore,\n  InvalidSignature,\n  SessionEscalation,\n  DelegationError,\n  Failure,\n  MalformedCapability,\n  DIDKeyResolutionError,\n  li,\n} from './error.js'\n\nexport { capability } from './capability.js'\nexport * from '@ucanto/core/schema'\n\nexport {\n  Schema,\n  Authorization,\n  Failure,\n  fail,\n  ok,\n  Revoked,\n  UnavailableProof,\n  Unauthorized,\n  MalformedCapability,\n  DIDKeyResolutionError as DIDResolutionError,\n}\n\n/**\n * @param {UCAN.Link} proof\n * @returns {{error:API.UnavailableProof}}\n */\nconst unavailable = proof => ({ error: new UnavailableProof(proof) })\n\n/**\n *\n * @param {UCAN.DID} did\n * @returns {{error:API.DIDKeyResolutionError}}\n */\nconst failDIDKeyResolution = did => ({ error: new DIDKeyResolutionError(did) })\n\n/**\n * @param {Required<API.ClaimOptions>} config\n * @param {API.Match<unknown, API.Match>} match\n */\n\nconst resolveMatch = async (match, config) => {\n  const promises = []\n  const includes = new Set()\n  for (const source of match.source) {\n    const id = source.delegation.cid.toString()\n    if (!includes.has(id)) {\n      promises.push(await resolveSources(source, config))\n    }\n  }\n  const groups = await Promise.all(promises)\n  const sources = []\n  const errors = []\n  for (const group of groups) {\n    sources.push(...group.sources)\n    errors.push(...group.errors)\n  }\n\n  return { sources, errors }\n}\n\n/**\n * Takes `proofs` from the delegation which may contain `Delegation` or a link\n * to one and attempts to resolve links by side loading them. Returns set of\n * resolved `Delegation`s and errors for the proofs that could not be resolved.\n *\n * @param {API.Proof[]} proofs\n * @param {Required<API.ProofResolver>} config\n */\nconst resolveProofs = async (proofs, config) => {\n  /** @type {API.Delegation[]} */\n  const delegations = []\n  /** @type {API.UnavailableProof[]} */\n  const errors = []\n  const promises = []\n  for (const proof of proofs) {\n    // If it is a delegation we can just add it to the resolved set.\n    if (isDelegation(proof)) {\n      delegations.push(proof)\n    }\n    // otherwise we attempt to resolve the link asynchronously. To avoid doing\n    // sequential requests we create promise for each link and then wait for\n    // all of them at the end.\n    else {\n      promises.push(\n        new Promise(async resolve => {\n          // config.resolve is not supposed to throw, but we catch it just in\n          // case it does and consider proof resolution failed.\n          try {\n            const result = await config.resolve(proof)\n            if (result.error) {\n              errors.push(result.error)\n            } else {\n              delegations.push(result.ok)\n            }\n          } catch (error) {\n            errors.push(\n              new UnavailableProof(proof, /** @type {Error} */ (error))\n            )\n          }\n\n          // we don't care about the result, we just need to signal that we are\n          // done with this promise.\n          resolve(null)\n        })\n      )\n    }\n  }\n\n  // Wait for all the promises to resolve. At this point we have collected all\n  // the resolved delegations and errors.\n  await Promise.all(promises)\n  return { delegations, errors }\n}\n\n/**\n * Takes a delegation source and attempts to resolve all the linked proofs.\n *\n * @param {API.Source} from\n * @param {Required<API.ClaimOptions>} config\n * @return {Promise<{sources:API.Source[], errors:ProofError[]}>}\n */\nconst resolveSources = async ({ delegation }, config) => {\n  const errors = []\n  const sources = []\n  const proofs = []\n  // First we attempt to resolve all the linked proofs.\n  const { delegations, errors: failedProofs } = await resolveProofs(\n    delegation.proofs,\n    config\n  )\n\n  // All the proofs that failed to resolve are saved as proof errors.\n  for (const error of failedProofs) {\n    errors.push(new ProofError(error.link, error))\n  }\n\n  // All the proofs that resolved are checked for principal alignment. Ones that\n  // do not align are saved as proof errors.\n  for (const proof of delegations) {\n    // If proof does not delegate to a matching audience save an proof error.\n    if (delegation.issuer.did() !== proof.audience.did()) {\n      errors.push(\n        new ProofError(\n          proof.cid,\n          new PrincipalAlignmentError(delegation.issuer, proof)\n        )\n      )\n    } else {\n      proofs.push(proof)\n    }\n  }\n  // In the second pass we attempt to proofs that were resolved and are aligned.\n  for (const proof of proofs) {\n    // If proof is not valid (expired, not active yet or has incorrect\n    // signature) save a corresponding proof error.\n    const validation = await validate(proof, proofs, config)\n    if (validation.error) {\n      errors.push(new ProofError(proof.cid, validation.error))\n    } else {\n      // otherwise create source objects for it's capabilities, so we could\n      // track which proof in which capability the are from.\n      for (const capability of proof.capabilities) {\n        sources.push(\n          /** @type {API.Source} */ ({\n            capability,\n            delegation: proof,\n          })\n        )\n      }\n    }\n  }\n\n  return { sources, errors }\n}\n\n/**\n * @param {API.ParsedCapability} capability\n * @param {API.DID} issuer\n */\nconst isSelfIssued = (capability, issuer) => capability.with === issuer\n\n/**\n * Finds a valid path in a proof chain of the given `invocation` by exploring\n * every possible option. On success an `Authorization` object is returned that\n * illustrates the valid path. If no valid path is found `Unauthorized` error\n * is returned detailing all explored paths and where they proved to fail.\n *\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {R} URI\n * @template {API.Caveats} C\n * @param {API.Invocation<API.Capability<A, URI, C>>} invocation\n * @param {API.ValidationOptions<API.ParsedCapability<A, R, C>>} options\n * @returns {Promise<API.Result<API.Authorization<API.ParsedCapability<A, R, C>>, API.Unauthorized>>}\n */\nexport const access = async (invocation, { capability, ...config }) =>\n  claim(capability, [invocation], config)\n\n/**\n * Attempts to find a valid proof chain for the claimed `capability` given set\n * of `proofs`. On success an `Authorization` object with detailed proof chain\n * is returned and on failure `Unauthorized` error is returned with details on\n * paths explored and why they have failed.\n *\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @param {API.CapabilityParser<API.Match<API.ParsedCapability<A, R, C>>>} capability\n * @param {API.Proof[]} proofs\n * @param {API.ClaimOptions} config\n * @returns {Promise<API.Result<API.Authorization<API.ParsedCapability<A, R, C>>, API.Unauthorized>>}\n */\nexport const claim = async (\n  capability,\n  proofs,\n  {\n    authority,\n    principal,\n    validateAuthorization,\n    resolveDIDKey = failDIDKeyResolution,\n    canIssue = isSelfIssued,\n    resolve = unavailable,\n  }\n) => {\n  const config = {\n    canIssue,\n    resolve,\n    principal,\n    capability,\n    authority,\n    validateAuthorization,\n    resolveDIDKey,\n  }\n\n  const invalidProofs = []\n\n  /** @type {API.Source[]} */\n  const sources = []\n\n  const { delegations, errors } = await resolveProofs(proofs, config)\n  invalidProofs.push(...errors)\n\n  for (const proof of delegations) {\n    // Validate each proof if valid add ech capability to the list of sources.\n    // otherwise collect the error.\n    const validation = await validate(proof, delegations, config)\n    if (validation.ok) {\n      for (const capability of validation.ok.capabilities.values()) {\n        sources.push(\n          /** @type {API.Source} */ ({\n            capability,\n            delegation: validation.ok,\n          })\n        )\n      }\n    } else {\n      invalidProofs.push(validation.error)\n    }\n  }\n  // look for the matching capability\n  const selection = capability.select(sources)\n\n  const { errors: delegationErrors, unknown: unknownCapabilities } = selection\n  const failedProofs = []\n  for (const matched of selection.matches) {\n    const selector = matched.prune(config)\n    if (selector == null) {\n      const authorization = Authorization.create(matched, [])\n      const result = await validateAuthorization(authorization)\n      if (result.error) {\n        invalidProofs.push(result.error)\n      } else {\n        return { ok: authorization }\n      }\n    } else {\n      const result = await authorize(selector, config)\n      if (result.error) {\n        failedProofs.push(result.error)\n      } else {\n        const authorization = Authorization.create(matched, [result.ok])\n        const approval = await validateAuthorization(authorization)\n        if (approval.error) {\n          invalidProofs.push(approval.error)\n        } else {\n          return { ok: authorization }\n        }\n      }\n    }\n  }\n\n  return {\n    error: new Unauthorized({\n      capability,\n      delegationErrors,\n      unknownCapabilities,\n      invalidProofs,\n      failedProofs,\n    }),\n  }\n}\n\n/**\n * Verifies whether any of the delegated proofs grant give capability.\n *\n * @template {API.Match} Match\n * @param {Match} match\n * @param {Required<API.ClaimOptions>} config\n * @returns {Promise<API.Result<API.Authorization<API.ParsedCapability>, API.InvalidClaim>>}\n */\n\nexport const authorize = async (match, config) => {\n  // load proofs from all delegations\n  const { sources, errors: invalidProofs } = await resolveMatch(match, config)\n\n  const selection = match.select(sources)\n  const { errors: delegationErrors, unknown: unknownCapabilities } = selection\n\n  const failedProofs = []\n  for (const matched of selection.matches) {\n    const selector = matched.prune(config)\n    if (selector == null) {\n      return {\n        ok: Authorization.create(\n          // @ts-expect-error - it may not be a parsed capability but rather a\n          // group of capabilities but we can deal with that in the future.\n          matched,\n          []\n        ),\n      }\n    } else {\n      const result = await authorize(selector, config)\n      if (result.error) {\n        failedProofs.push(result.error)\n      } else {\n        return {\n          ok: Authorization.create(\n            // @ts-expect-error - it may not be a parsed capability but rather a\n            // group of capabilities but we can deal with that in the future.\n            matched,\n            [result.ok]\n          ),\n        }\n      }\n    }\n  }\n\n  return {\n    error: new InvalidClaim({\n      match,\n      delegationErrors,\n      unknownCapabilities,\n      invalidProofs,\n      failedProofs,\n    }),\n  }\n}\n\nclass ProofError extends Failure {\n  /**\n   * @param {API.UCANLink} proof\n   * @param {API.Failure} cause\n   */\n  constructor(proof, cause) {\n    super()\n    this.name = 'ProofError'\n    this.proof = proof\n    this.cause = cause\n  }\n  describe() {\n    return [\n      `Capability can not be derived from prf:${this.proof} because:`,\n      li(this.cause.message),\n    ].join(`\\n`)\n  }\n}\n\n/**\n * @implements {API.InvalidClaim}\n */\nclass InvalidClaim extends Failure {\n  /**\n   * @param {{\n   * match: API.Match\n   * delegationErrors: API.DelegationError[]\n   * unknownCapabilities: API.Capability[]\n   * invalidProofs: ProofError[]\n   * failedProofs: API.InvalidClaim[]\n   * }} info\n   */\n  constructor(info) {\n    super()\n    this.info = info\n    /** @type {\"InvalidClaim\"} */\n    this.name = 'InvalidClaim'\n  }\n  get issuer() {\n    return this.delegation.issuer\n  }\n  get delegation() {\n    return this.info.match.source[0].delegation\n  }\n  describe() {\n    const errors = [\n      ...this.info.failedProofs.map(error => li(error.message)),\n      ...this.info.delegationErrors.map(error => li(error.message)),\n      ...this.info.invalidProofs.map(error => li(error.message)),\n    ]\n\n    const unknown = this.info.unknownCapabilities.map(c =>\n      li(JSON.stringify(c))\n    )\n\n    return [\n      `Capability ${this.info.match} is not authorized because:`,\n      li(`Capability can not be (self) issued by '${this.issuer.did()}'`),\n      ...(errors.length > 0 ? errors : [li(`Delegated capability not found`)]),\n      ...(unknown.length > 0\n        ? [li(`Encountered unknown capabilities\\n${unknown.join('\\n')}`)]\n        : []),\n    ].join('\\n')\n  }\n}\n\n/**\n * Validate a delegation to check it is within the time bound and that it is\n * authorized by the issuer.\n *\n * @template {API.Delegation} T\n * @param {T} delegation\n * @param {API.Delegation[]} proofs\n * @param {Required<API.ClaimOptions>} config\n * @returns {Promise<API.Result<T, API.InvalidProof|API.SessionEscalation|API.DIDKeyResolutionError>>}\n */\nconst validate = async (delegation, proofs, config) => {\n  if (UCAN.isExpired(delegation.data)) {\n    return {\n      error: new Expired(\n        /** @type {API.Delegation & {expiration: number}} */ (delegation)\n      ),\n    }\n  }\n\n  if (UCAN.isTooEarly(delegation.data)) {\n    return {\n      error: new NotValidBefore(\n        /** @type {API.Delegation & {notBefore: number}} */ (delegation)\n      ),\n    }\n  }\n\n  return await verifyAuthorization(delegation, proofs, config)\n}\n\n/**\n * Verifies that delegation has been authorized by the issuer. If issued by the\n * did:key principal checks that the signature is valid. If issued by the root\n * authority checks that the signature is valid. If issued by the principal\n * identified by other DID method attempts to resolve a valid `ucan/attest`\n * attestation from the authority, if attestation is not found falls back to\n * resolving did:key for the issuer and verifying its signature.\n *\n * @template {API.Delegation} T\n * @param {T} delegation\n * @param {API.Delegation[]} proofs\n * @param {Required<API.ClaimOptions>} config\n * @returns {Promise<API.Result<T, API.InvalidSignature|API.SessionEscalation|API.DIDKeyResolutionError>>}\n */\nconst verifyAuthorization = async (delegation, proofs, config) => {\n  const issuer = delegation.issuer.did()\n  // If the issuer is a did:key we just verify a signature\n  if (issuer.startsWith('did:key:')) {\n    return verifySignature(delegation, config.principal.parse(issuer))\n  }\n  // If the issuer is the root authority we use authority itself to verify\n  else if (issuer === config.authority.did()) {\n    return verifySignature(delegation, config.authority)\n  } else {\n    // If issuer is not a did:key principal nor configured authority, we\n    // attempt to resolve embedded authorization session from the authority.\n    const session = await verifySession(delegation, proofs, config)\n    // If we have valid session we consider authorization valid\n    if (session.ok) {\n      return { ok: delegation }\n    } else if (session.error.failedProofs.length > 0) {\n      return {\n        error: new SessionEscalation({ delegation, cause: session.error }),\n      }\n    }\n    // Otherwise we try to resolve did:key from the DID instead\n    // and use that to verify the signature\n    else {\n      const verifier = await config.resolveDIDKey(issuer)\n      if (verifier.error) {\n        return verifier\n      } else {\n        return verifySignature(\n          delegation,\n          config.principal.parse(verifier.ok).withDID(issuer)\n        )\n      }\n    }\n  }\n}\n\n/**\n * @template {API.Delegation} T\n * @param {T} delegation\n * @param {API.Verifier} verifier\n * @returns {Promise<API.Result<T, API.InvalidSignature|API.DIDKeyResolutionError>>}\n */\nconst verifySignature = async (delegation, verifier) => {\n  const valid = await UCAN.verifySignature(delegation.data, verifier)\n  return valid\n    ? { ok: delegation }\n    : { error: new InvalidSignature(delegation, verifier) }\n}\n\n/**\n * Attempts to find an authorization session - an `ucan/attest` capability\n * delegation where `with` matches `config.authority` and `nb.proof`\n * matches given delegation.\n * @see https://github.com/web3-storage/specs/blob/feat/auth+account/w3-session.md#authorization-session\n *\n * @param {API.Delegation} delegation\n * @param {API.Delegation[]} proofs\n * @param {Required<API.ClaimOptions>} config\n */\nconst verifySession = async (delegation, proofs, config) => {\n  // Create a schema that will match an authorization for this exact delegation\n  const attestation = capability({\n    with: Schema.literal(config.authority.did()),\n    can: 'ucan/attest',\n    nb: Schema.struct({\n      proof: Schema.link(delegation.cid),\n    }),\n  })\n\n  return await claim(\n    attestation,\n    // We only consider attestations otherwise we will end up doing an\n    // exponential scan if there are other proofs that require attestations.\n    proofs.filter(isAttestation),\n    config\n  )\n}\n\n/**\n * Checks if the delegation is an attestation.\n *\n * @param {API.Delegation} proof\n */\nconst isAttestation = proof => proof.capabilities[0]?.can === 'ucan/attest'\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}