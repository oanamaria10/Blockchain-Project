{"ast":null,"code":"import { DID, Schema, fail, ok } from '@ucanto/validator';\n// eslint-disable-next-line no-unused-vars\nimport * as Types from '@ucanto/interface';\nimport { equals } from 'uint8arrays/equals';\n\n// e.g. did:web:web3.storage or did:web:staging.web3.storage\nexport const ProviderDID = DID.match({\n  method: 'web'\n});\nexport const SpaceDID = DID.match({\n  method: 'key'\n});\nexport const AccountDID = DID.match({\n  method: 'mailto'\n});\nexport const Await = Schema.struct({\n  'ucan/await': Schema.tuple([Schema.string(), Schema.link()])\n});\n\n/**\n * Check URI can be delegated.\n *\n * @param {string} [child]\n * @param {string} [parent]\n */\nexport function canDelegateURI(child, parent) {\n  if (parent === undefined) {\n    return ok({});\n  }\n  if (child !== undefined && parent.endsWith('*')) {\n    return child.startsWith(parent.slice(0, -1)) ? ok({}) : fail(`${child} does not match ${parent}`);\n  }\n  return child === parent ? ok({}) : fail(`${child} is different from ${parent}`);\n}\n\n/**\n * Checks that `with` on claimed capability is the same as `with`\n * in delegated capability. Note this will ignore `can` field.\n *\n * @param {Types.ParsedCapability} child\n * @param {Types.ParsedCapability} parent\n */\nexport function equalWith(child, parent) {\n  return child.with === parent.with ? ok({}) : fail(`Can not derive ${child.can} with ${child.with} from ${parent.with}`);\n}\n\n/**\n * @param {unknown} child\n * @param {unknown} parent\n * @param {string} constraint\n */\nexport function equal(child, parent, constraint) {\n  if (parent === undefined || parent === '*') {\n    return ok({});\n  } else if (String(child) === String(parent)) {\n    return ok({});\n  } else {\n    return fail(`Constrain violation: ${child} violates imposed ${constraint} constraint ${parent}`);\n  }\n}\n\n/**\n * @template {Types.ParsedCapability<\"store/add\"|\"store/get\"|\"store/remove\", Types.URI<'did:'>, {link?: Types.Link<unknown, number, number, 0|1>}>} T\n * @param {T} claimed\n * @param {T} delegated\n * @returns {Types.Result<{}, Types.Failure>}\n */\nexport const equalLink = (claimed, delegated) => {\n  if (claimed.with !== delegated.with) {\n    return fail(`Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`);\n  } else if (delegated.nb.link && `${delegated.nb.link}` !== `${claimed.nb.link}`) {\n    return fail(`Link ${claimed.nb.link ? `${claimed.nb.link}` : ''} violates imposed ${delegated.nb.link} constraint.`);\n  } else {\n    return ok({});\n  }\n};\n\n/**\n * @template {Types.ParsedCapability<\"space/blob/add\"|\"space/blob/remove\"|\"web3.storage/blob/allocate\"|\"web3.storage/blob/accept\", Types.URI<'did:'>, {blob: { digest: Uint8Array, size: number }}>} T\n * @param {T} claimed\n * @param {T} delegated\n * @returns {Types.Result<{}, Types.Failure>}\n */\nexport const equalBlob = (claimed, delegated) => {\n  if (claimed.with !== delegated.with) {\n    return fail(`Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`);\n  } else if (delegated.nb.blob.digest && !equals(delegated.nb.blob.digest, claimed.nb.blob.digest)) {\n    return fail(`Link ${claimed.nb.blob.digest ? `${claimed.nb.blob.digest}` : ''} violates imposed ${delegated.nb.blob.digest} constraint.`);\n  } else if (claimed.nb.blob.size !== undefined && delegated.nb.blob.size !== undefined) {\n    return claimed.nb.blob.size > delegated.nb.blob.size ? fail(`Size constraint violation: ${claimed.nb.blob.size} > ${delegated.nb.blob.size}`) : ok({});\n  } else {\n    return ok({});\n  }\n};\n\n/**\n * @template {Types.ParsedCapability<\"http/put\", Types.URI<'did:'>, {body: { digest: Uint8Array, size: number }}>} T\n * @param {T} claimed\n * @param {T} delegated\n * @returns {Types.Result<{}, Types.Failure>}\n */\nexport const equalBody = (claimed, delegated) => {\n  if (claimed.with !== delegated.with) {\n    return fail(`Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`);\n  } else if (delegated.nb.body.digest && !equals(delegated.nb.body.digest, claimed.nb.body.digest)) {\n    return fail(`Link ${claimed.nb.body.digest ? `${claimed.nb.body.digest}` : ''} violates imposed ${delegated.nb.body.digest} constraint.`);\n  } else if (claimed.nb.body.size !== undefined && delegated.nb.body.size !== undefined) {\n    return claimed.nb.body.size > delegated.nb.body.size ? fail(`Size constraint violation: ${claimed.nb.body.size} > ${delegated.nb.body.size}`) : ok({});\n  } else {\n    return ok({});\n  }\n};\n\n/**\n * @template {Types.ParsedCapability<\"blob/add\"|\"blob/remove\"|\"blob/allocate\"|\"blob/accept\"|\"http/put\", Types.URI<'did:'>, {content: Uint8Array}>} T\n * @param {T} claimed\n * @param {T} delegated\n * @returns {Types.Result<{}, Types.Failure>}\n */\nexport const equalContent = (claimed, delegated) => {\n  if (claimed.with !== delegated.with) {\n    return fail(`Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`);\n  } else if (delegated.nb.content && !equals(delegated.nb.content, claimed.nb.content)) {\n    return fail(`Link ${claimed.nb.content ? `${claimed.nb.content}` : ''} violates imposed ${delegated.nb.content} constraint.`);\n  } else {\n    return ok({});\n  }\n};\n\n/**\n * Checks that `claimed` {@link Types.Link} meets an `imposed` constraint.\n *\n * @param {Types.UnknownLink} claimed\n * @param {Types.UnknownLink|undefined} imposed\n * @param {string} at\n * @returns {Types.Result<{}, Types.Failure>}\n */\nexport const checkLink = (claimed, imposed, at) => {\n  return equal(String(claimed), imposed === undefined ? undefined : String(imposed), at);\n};\n\n/**\n * @template T\n * @param {Types.Result<T , Types.Failure>} result\n * @returns {{error: Types.Failure, ok?:undefined}|undefined}\n */\nexport const and = result => result.error ? result : undefined;\n\n/**\n *\n * @param {import('@ucanto/interface').Ability} ability\n */\nfunction parseAbility(ability) {\n  const [namespace, ...segments] = ability.split('/');\n  return {\n    namespace,\n    segments\n  };\n}\n\n/**\n *\n * TODO: needs to account for caps derived from different namespaces like 'account/info' can be derived from 'store/add'\n *\n * @param {import('@ucanto/interface').Ability} parent\n * @param {import('@ucanto/interface').Ability} child\n */\nexport function canDelegateAbility(parent, child) {\n  const parsedParent = parseAbility(parent);\n  const parsedChild = parseAbility(child);\n\n  // Parent is wildcard\n  if (parsedParent.namespace === '*' && parsedParent.segments.length === 0) {\n    return true;\n  }\n\n  // Child is wild card so it can not be delegated from anything\n  if (parsedChild.namespace === '*' && parsedChild.segments.length === 0) {\n    return false;\n  }\n\n  // namespaces don't match\n  if (parsedParent.namespace !== parsedChild.namespace) {\n    return false;\n  }\n\n  // given that namespaces match and parent first segment is wildcard\n  if (parsedParent.segments[0] === '*') {\n    return true;\n  }\n\n  // Array equality\n  if (parsedParent.segments.length !== parsedChild.segments.length) {\n    return false;\n  }\n\n  // all segments must match\n  return parsedParent.segments.reduce((acc, v, i) => acc && parsedChild.segments[i] === v, true);\n}","map":{"version":3,"names":["DID","Schema","fail","ok","Types","equals","ProviderDID","match","method","SpaceDID","AccountDID","Await","struct","tuple","string","link","canDelegateURI","child","parent","undefined","endsWith","startsWith","slice","equalWith","with","can","equal","constraint","String","equalLink","claimed","delegated","nb","equalBlob","blob","digest","size","equalBody","body","equalContent","content","checkLink","imposed","at","and","result","error","parseAbility","ability","namespace","segments","split","canDelegateAbility","parsedParent","parsedChild","length","reduce","acc","v","i"],"sources":["C:/FACULTATE/Proiect/node_modules/@web3-storage/capabilities/src/utils.js"],"sourcesContent":["import { DID, Schema, fail, ok } from '@ucanto/validator'\n// eslint-disable-next-line no-unused-vars\nimport * as Types from '@ucanto/interface'\n\nimport { equals } from 'uint8arrays/equals'\n\n// e.g. did:web:web3.storage or did:web:staging.web3.storage\nexport const ProviderDID = DID.match({ method: 'web' })\n\nexport const SpaceDID = DID.match({ method: 'key' })\n\nexport const AccountDID = DID.match({ method: 'mailto' })\n\nexport const Await = Schema.struct({\n  'ucan/await': Schema.tuple([Schema.string(), Schema.link()]),\n})\n\n/**\n * Check URI can be delegated.\n *\n * @param {string} [child]\n * @param {string} [parent]\n */\nexport function canDelegateURI(child, parent) {\n  if (parent === undefined) {\n    return ok({})\n  }\n  if (child !== undefined && parent.endsWith('*')) {\n    return child.startsWith(parent.slice(0, -1))\n      ? ok({})\n      : fail(`${child} does not match ${parent}`)\n  }\n\n  return child === parent\n    ? ok({})\n    : fail(`${child} is different from ${parent}`)\n}\n\n/**\n * Checks that `with` on claimed capability is the same as `with`\n * in delegated capability. Note this will ignore `can` field.\n *\n * @param {Types.ParsedCapability} child\n * @param {Types.ParsedCapability} parent\n */\nexport function equalWith(child, parent) {\n  return child.with === parent.with\n    ? ok({})\n    : fail(`Can not derive ${child.can} with ${child.with} from ${parent.with}`)\n}\n\n/**\n * @param {unknown} child\n * @param {unknown} parent\n * @param {string} constraint\n */\nexport function equal(child, parent, constraint) {\n  if (parent === undefined || parent === '*') {\n    return ok({})\n  } else if (String(child) === String(parent)) {\n    return ok({})\n  } else {\n    return fail(\n      `Constrain violation: ${child} violates imposed ${constraint} constraint ${parent}`\n    )\n  }\n}\n\n/**\n * @template {Types.ParsedCapability<\"store/add\"|\"store/get\"|\"store/remove\", Types.URI<'did:'>, {link?: Types.Link<unknown, number, number, 0|1>}>} T\n * @param {T} claimed\n * @param {T} delegated\n * @returns {Types.Result<{}, Types.Failure>}\n */\nexport const equalLink = (claimed, delegated) => {\n  if (claimed.with !== delegated.with) {\n    return fail(\n      `Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`\n    )\n  } else if (\n    delegated.nb.link &&\n    `${delegated.nb.link}` !== `${claimed.nb.link}`\n  ) {\n    return fail(\n      `Link ${claimed.nb.link ? `${claimed.nb.link}` : ''} violates imposed ${\n        delegated.nb.link\n      } constraint.`\n    )\n  } else {\n    return ok({})\n  }\n}\n\n/**\n * @template {Types.ParsedCapability<\"space/blob/add\"|\"space/blob/remove\"|\"web3.storage/blob/allocate\"|\"web3.storage/blob/accept\", Types.URI<'did:'>, {blob: { digest: Uint8Array, size: number }}>} T\n * @param {T} claimed\n * @param {T} delegated\n * @returns {Types.Result<{}, Types.Failure>}\n */\nexport const equalBlob = (claimed, delegated) => {\n  if (claimed.with !== delegated.with) {\n    return fail(\n      `Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`\n    )\n  } else if (\n    delegated.nb.blob.digest &&\n    !equals(delegated.nb.blob.digest, claimed.nb.blob.digest)\n  ) {\n    return fail(\n      `Link ${\n        claimed.nb.blob.digest ? `${claimed.nb.blob.digest}` : ''\n      } violates imposed ${delegated.nb.blob.digest} constraint.`\n    )\n  } else if (\n    claimed.nb.blob.size !== undefined &&\n    delegated.nb.blob.size !== undefined\n  ) {\n    return claimed.nb.blob.size > delegated.nb.blob.size\n      ? fail(\n          `Size constraint violation: ${claimed.nb.blob.size} > ${delegated.nb.blob.size}`\n        )\n      : ok({})\n  } else {\n    return ok({})\n  }\n}\n\n/**\n * @template {Types.ParsedCapability<\"http/put\", Types.URI<'did:'>, {body: { digest: Uint8Array, size: number }}>} T\n * @param {T} claimed\n * @param {T} delegated\n * @returns {Types.Result<{}, Types.Failure>}\n */\nexport const equalBody = (claimed, delegated) => {\n  if (claimed.with !== delegated.with) {\n    return fail(\n      `Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`\n    )\n  } else if (\n    delegated.nb.body.digest &&\n    !equals(delegated.nb.body.digest, claimed.nb.body.digest)\n  ) {\n    return fail(\n      `Link ${\n        claimed.nb.body.digest ? `${claimed.nb.body.digest}` : ''\n      } violates imposed ${delegated.nb.body.digest} constraint.`\n    )\n  } else if (\n    claimed.nb.body.size !== undefined &&\n    delegated.nb.body.size !== undefined\n  ) {\n    return claimed.nb.body.size > delegated.nb.body.size\n      ? fail(\n          `Size constraint violation: ${claimed.nb.body.size} > ${delegated.nb.body.size}`\n        )\n      : ok({})\n  } else {\n    return ok({})\n  }\n}\n\n/**\n * @template {Types.ParsedCapability<\"blob/add\"|\"blob/remove\"|\"blob/allocate\"|\"blob/accept\"|\"http/put\", Types.URI<'did:'>, {content: Uint8Array}>} T\n * @param {T} claimed\n * @param {T} delegated\n * @returns {Types.Result<{}, Types.Failure>}\n */\nexport const equalContent = (claimed, delegated) => {\n  if (claimed.with !== delegated.with) {\n    return fail(\n      `Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`\n    )\n  } else if (\n    delegated.nb.content &&\n    !equals(delegated.nb.content, claimed.nb.content)\n  ) {\n    return fail(\n      `Link ${\n        claimed.nb.content ? `${claimed.nb.content}` : ''\n      } violates imposed ${delegated.nb.content} constraint.`\n    )\n  } else {\n    return ok({})\n  }\n}\n\n/**\n * Checks that `claimed` {@link Types.Link} meets an `imposed` constraint.\n *\n * @param {Types.UnknownLink} claimed\n * @param {Types.UnknownLink|undefined} imposed\n * @param {string} at\n * @returns {Types.Result<{}, Types.Failure>}\n */\nexport const checkLink = (claimed, imposed, at) => {\n  return equal(\n    String(claimed),\n    imposed === undefined ? undefined : String(imposed),\n    at\n  )\n}\n\n/**\n * @template T\n * @param {Types.Result<T , Types.Failure>} result\n * @returns {{error: Types.Failure, ok?:undefined}|undefined}\n */\nexport const and = (result) => (result.error ? result : undefined)\n\n/**\n *\n * @param {import('@ucanto/interface').Ability} ability\n */\nfunction parseAbility(ability) {\n  const [namespace, ...segments] = ability.split('/')\n  return { namespace, segments }\n}\n\n/**\n *\n * TODO: needs to account for caps derived from different namespaces like 'account/info' can be derived from 'store/add'\n *\n * @param {import('@ucanto/interface').Ability} parent\n * @param {import('@ucanto/interface').Ability} child\n */\nexport function canDelegateAbility(parent, child) {\n  const parsedParent = parseAbility(parent)\n  const parsedChild = parseAbility(child)\n\n  // Parent is wildcard\n  if (parsedParent.namespace === '*' && parsedParent.segments.length === 0) {\n    return true\n  }\n\n  // Child is wild card so it can not be delegated from anything\n  if (parsedChild.namespace === '*' && parsedChild.segments.length === 0) {\n    return false\n  }\n\n  // namespaces don't match\n  if (parsedParent.namespace !== parsedChild.namespace) {\n    return false\n  }\n\n  // given that namespaces match and parent first segment is wildcard\n  if (parsedParent.segments[0] === '*') {\n    return true\n  }\n\n  // Array equality\n  if (parsedParent.segments.length !== parsedChild.segments.length) {\n    return false\n  }\n\n  // all segments must match\n  return parsedParent.segments.reduce(\n    (acc, v, i) => acc && parsedChild.segments[i] === v,\n    true\n  )\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}