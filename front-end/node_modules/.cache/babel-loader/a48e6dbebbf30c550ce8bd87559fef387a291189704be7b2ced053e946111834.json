{"ast":null,"code":"import * as API from '@ucanto/interface';\nimport * as DAG from './dag.js';\nimport { Invocation, panic } from './lib.js';\nimport * as Receipt from './receipt.js';\nimport * as Schema from './schema.js';\nexport const MessageSchema = Schema.variant({\n  'ucanto/message@7.0.0': Schema.struct({\n    execute: Schema.link().array().optional(),\n    delegate: Schema.dictionary({\n      key: Schema.string(),\n      value: ( /** @type {API.Reader<API.Link<API.ReceiptModel>>} */\n      Schema.link())\n    }).array().optional()\n  })\n});\n\n/**\n * @template {API.Tuple<API.IssuedInvocation>} I\n * @template {API.Tuple<API.Receipt>} R\n * @param {object} source\n * @param {I} [source.invocations]\n * @param {R} [source.receipts]\n * @returns {Promise<API.AgentMessage<{ In: API.InferInvocations<I>, Out: R }>>}\n */\nexport const build = ({\n  invocations,\n  receipts\n}) => new MessageBuilder({\n  invocations,\n  receipts\n}).buildIPLDView();\n\n/**\n * @template [E=never]\n * @param {object} source\n * @param {API.Link} source.root\n * @param {DAG.BlockStore} source.store\n * @param {E} [fallback]\n * @returns {API.AgentMessage|E}\n */\nexport const view = ({\n  root,\n  store\n}, fallback) => {\n  const block = DAG.get(root, store, null);\n  if (block === null) {\n    return fallback !== undefined ? fallback : DAG.notFound(root);\n  }\n  const data = DAG.CBOR.decode(block.bytes);\n  const [branch, value] = MessageSchema.match(data, fallback);\n  switch (branch) {\n    case 'ucanto/message@7.0.0':\n      return new Message({\n        root: {\n          ...block,\n          data\n        },\n        store\n      });\n    default:\n      return value;\n  }\n};\n\n/**\n * @template {API.Tuple<API.IssuedInvocation>} I\n * @template {API.Tuple<API.Receipt>} R\n * @implements {API.AgentMessageBuilder<{In: API.InferInvocations<I>, Out: R }>}\n *\n */\nclass MessageBuilder {\n  /**\n   * @param {object} source\n   * @param {I} [source.invocations]\n   * @param {R} [source.receipts]\n   */\n  constructor({\n    invocations,\n    receipts\n  }) {\n    this.invocations = invocations;\n    this.receipts = receipts;\n  }\n  /**\n   *\n   * @param {API.BuildOptions} [options]\n   * @returns {Promise<Message<{ In: API.InferInvocations<I>, Out: R }>>}\n   */\n  async buildIPLDView(options) {\n    const store = new Map();\n    const {\n      invocations,\n      ...executeField\n    } = await writeInvocations(this.invocations || [], store);\n    const {\n      receipts,\n      ...receiptsField\n    } = await writeReceipts(this.receipts || [], store);\n    const root = await DAG.writeInto( /** @type {API.AgentMessageModel<{ In: API.InferInvocations<I>, Out: R }>} */\n    {\n      'ucanto/message@7.0.0': {\n        ...executeField,\n        ...receiptsField\n      }\n    }, store, options);\n    return new Message({\n      root,\n      store\n    }, {\n      receipts,\n      invocations\n    });\n  }\n}\n\n/**\n *\n * @param {API.IssuedInvocation[]} run\n * @param {Map<string, API.Block>} store\n */\nconst writeInvocations = async (run, store) => {\n  const invocations = [];\n  const execute = [];\n  for (const invocation of run) {\n    const view = await invocation.buildIPLDView();\n    execute.push(view.link());\n    invocations.push(view);\n    for (const block of view.iterateIPLDBlocks()) {\n      store.set(`${block.cid}`, block);\n    }\n  }\n  return {\n    invocations,\n    ...(execute.length > 0 ? {\n      execute\n    } : {})\n  };\n};\n\n/**\n * @param {API.Receipt[]} source\n * @param {Map<string, API.Block>} store\n */\nconst writeReceipts = async (source, store) => {\n  if (source.length === 0) {\n    return {};\n  }\n  const receipts = new Map();\n  /** @type {Record<API.ToString<API.ReceiptModel['ocm']['ran']>, API.Link<API.ReceiptModel>>} */\n  const report = {};\n  for (const [n, receipt] of source.entries()) {\n    const view = await receipt.buildIPLDView();\n    for (const block of view.iterateIPLDBlocks()) {\n      store.set(`${block.cid}`, block);\n    }\n    const key = `${view.ran.link()}`;\n    if (!(key in report)) {\n      report[key] = view.root.cid;\n      receipts.set(key, view);\n    } else {\n      // In theory we could have gotten the same invocation twice and both\n      // should get same receipt. In legacy code we send tuple of results\n      // as opposed to a map keyed by invocation to keep old clients working\n      // we just stick the receipt in the map with a unique key so that when\n      // legacy encoder maps entries to array it will get both receipts in\n      // the right order.\n      receipts.set(`${key}@${n}`, view);\n    }\n  }\n  return {\n    receipts,\n    report\n  };\n};\n\n/**\n * @template {{ In: API.Invocation[], Out: API.Receipt[] }} T\n * @implements {API.AgentMessage<T>}\n */\nclass Message {\n  /**\n   * @param {object} source\n   * @param {Required<API.Block<API.AgentMessageModel<T>>>} source.root\n   * @param {DAG.BlockStore} source.store\n   * @param {object} build\n   * @param {API.Invocation[]} [build.invocations]\n   * @param {Map<string, API.Receipt>} [build.receipts]\n   */\n  constructor({\n    root,\n    store\n  }, {\n    invocations,\n    receipts\n  } = {}) {\n    this.root = root;\n    this.store = store;\n    this._invocations = invocations;\n    this._receipts = receipts;\n  }\n  *iterateIPLDBlocks() {\n    for (const invocation of this.invocations) {\n      yield* invocation.iterateIPLDBlocks();\n    }\n    for (const receipt of this.receipts.values()) {\n      yield* receipt.iterateIPLDBlocks();\n    }\n    yield this.root;\n  }\n  /**\n   * @template [E=never]\n   * @param {API.Link} link\n   * @param {E} [fallback]\n   * @returns {API.Receipt|E}\n   */\n  get(link, fallback) {\n    const receipts = this.root.data['ucanto/message@7.0.0'].report || {};\n    const receipt = receipts[`${link}`];\n    if (receipt) {\n      return Receipt.view({\n        root: receipt,\n        blocks: this.store\n      });\n    } else {\n      return fallback !== undefined ? fallback : panic(`Message does not include receipt for ${link}`);\n    }\n  }\n  get invocationLinks() {\n    return this.root.data['ucanto/message@7.0.0'].execute || [];\n  }\n  get invocations() {\n    let invocations = this._invocations;\n    if (!invocations) {\n      invocations = this.invocationLinks.map(link => {\n        return Invocation.view({\n          root: link,\n          blocks: this.store\n        });\n      });\n    }\n    return invocations;\n  }\n  get receipts() {\n    let receipts = this._receipts;\n    if (!receipts) {\n      receipts = new Map();\n      const report = this.root.data['ucanto/message@7.0.0'].report || {};\n      for (const [key, link] of Object.entries(report)) {\n        const receipt = Receipt.view({\n          root: link,\n          blocks: this.store\n        });\n        receipts.set(`${receipt.ran.link()}`, receipt);\n      }\n    }\n    return receipts;\n  }\n}","map":{"version":3,"names":["API","DAG","Invocation","panic","Receipt","Schema","MessageSchema","variant","struct","execute","link","array","optional","delegate","dictionary","key","string","value","build","invocations","receipts","MessageBuilder","buildIPLDView","view","root","store","fallback","block","get","undefined","notFound","data","CBOR","decode","bytes","branch","match","Message","constructor","options","Map","executeField","writeInvocations","receiptsField","writeReceipts","writeInto","run","invocation","push","iterateIPLDBlocks","set","cid","length","source","report","n","receipt","entries","ran","_invocations","_receipts","values","blocks","invocationLinks","map","Object"],"sources":["C:/FACULTATE/Proiect/node_modules/@ucanto/core/src/message.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport * as DAG from './dag.js'\nimport { Invocation, panic } from './lib.js'\nimport * as Receipt from './receipt.js'\nimport * as Schema from './schema.js'\n\nexport const MessageSchema = Schema.variant({\n  'ucanto/message@7.0.0': Schema.struct({\n    execute: Schema.link().array().optional(),\n    delegate: Schema.dictionary({\n      key: Schema.string(),\n      value: /** @type {API.Reader<API.Link<API.ReceiptModel>>} */ (\n        Schema.link()\n      ),\n    })\n      .array()\n      .optional(),\n  }),\n})\n\n/**\n * @template {API.Tuple<API.IssuedInvocation>} I\n * @template {API.Tuple<API.Receipt>} R\n * @param {object} source\n * @param {I} [source.invocations]\n * @param {R} [source.receipts]\n * @returns {Promise<API.AgentMessage<{ In: API.InferInvocations<I>, Out: R }>>}\n */\nexport const build = ({ invocations, receipts }) =>\n  new MessageBuilder({ invocations, receipts }).buildIPLDView()\n\n/**\n * @template [E=never]\n * @param {object} source\n * @param {API.Link} source.root\n * @param {DAG.BlockStore} source.store\n * @param {E} [fallback]\n * @returns {API.AgentMessage|E}\n */\nexport const view = ({ root, store }, fallback) => {\n  const block = DAG.get(root, store, null)\n  if (block === null) {\n    return fallback !== undefined ? fallback : DAG.notFound(root)\n  }\n  const data = DAG.CBOR.decode(block.bytes)\n  const [branch, value] = MessageSchema.match(data, fallback)\n  switch (branch) {\n    case 'ucanto/message@7.0.0':\n      return new Message({ root: { ...block, data }, store })\n    default:\n      return value\n  }\n}\n\n/**\n * @template {API.Tuple<API.IssuedInvocation>} I\n * @template {API.Tuple<API.Receipt>} R\n * @implements {API.AgentMessageBuilder<{In: API.InferInvocations<I>, Out: R }>}\n *\n */\nclass MessageBuilder {\n  /**\n   * @param {object} source\n   * @param {I} [source.invocations]\n   * @param {R} [source.receipts]\n   */\n  constructor({ invocations, receipts }) {\n    this.invocations = invocations\n    this.receipts = receipts\n  }\n  /**\n   *\n   * @param {API.BuildOptions} [options]\n   * @returns {Promise<Message<{ In: API.InferInvocations<I>, Out: R }>>}\n   */\n  async buildIPLDView(options) {\n    const store = new Map()\n\n    const { invocations, ...executeField } = await writeInvocations(\n      this.invocations || [],\n      store\n    )\n\n    const { receipts, ...receiptsField } = await writeReceipts(\n      this.receipts || [],\n      store\n    )\n\n    const root = await DAG.writeInto(\n      /** @type {API.AgentMessageModel<{ In: API.InferInvocations<I>, Out: R }>} */\n      ({\n        'ucanto/message@7.0.0': {\n          ...executeField,\n          ...receiptsField,\n        },\n      }),\n      store,\n      options\n    )\n\n    return new Message({ root, store }, { receipts, invocations })\n  }\n}\n\n/**\n *\n * @param {API.IssuedInvocation[]} run\n * @param {Map<string, API.Block>} store\n */\nconst writeInvocations = async (run, store) => {\n  const invocations = []\n  const execute = []\n  for (const invocation of run) {\n    const view = await invocation.buildIPLDView()\n    execute.push(view.link())\n    invocations.push(view)\n    for (const block of view.iterateIPLDBlocks()) {\n      store.set(`${block.cid}`, block)\n    }\n  }\n\n  return { invocations, ...(execute.length > 0 ? { execute } : {}) }\n}\n\n/**\n * @param {API.Receipt[]} source\n * @param {Map<string, API.Block>} store\n */\nconst writeReceipts = async (source, store) => {\n  if (source.length === 0) {\n    return {}\n  }\n\n  const receipts = new Map()\n  /** @type {Record<API.ToString<API.ReceiptModel['ocm']['ran']>, API.Link<API.ReceiptModel>>} */\n  const report = {}\n\n  for (const [n, receipt] of source.entries()) {\n    const view = await receipt.buildIPLDView()\n    for (const block of view.iterateIPLDBlocks()) {\n      store.set(`${block.cid}`, block)\n    }\n\n    const key = `${view.ran.link()}`\n    if (!(key in report)) {\n      report[key] = view.root.cid\n      receipts.set(key, view)\n    } else {\n      // In theory we could have gotten the same invocation twice and both\n      // should get same receipt. In legacy code we send tuple of results\n      // as opposed to a map keyed by invocation to keep old clients working\n      // we just stick the receipt in the map with a unique key so that when\n      // legacy encoder maps entries to array it will get both receipts in\n      // the right order.\n      receipts.set(`${key}@${n}`, view)\n    }\n  }\n\n  return { receipts, report }\n}\n\n/**\n * @template {{ In: API.Invocation[], Out: API.Receipt[] }} T\n * @implements {API.AgentMessage<T>}\n */\nclass Message {\n  /**\n   * @param {object} source\n   * @param {Required<API.Block<API.AgentMessageModel<T>>>} source.root\n   * @param {DAG.BlockStore} source.store\n   * @param {object} build\n   * @param {API.Invocation[]} [build.invocations]\n   * @param {Map<string, API.Receipt>} [build.receipts]\n   */\n  constructor({ root, store }, { invocations, receipts } = {}) {\n    this.root = root\n    this.store = store\n    this._invocations = invocations\n    this._receipts = receipts\n  }\n  *iterateIPLDBlocks() {\n    for (const invocation of this.invocations) {\n      yield* invocation.iterateIPLDBlocks()\n    }\n\n    for (const receipt of this.receipts.values()) {\n      yield* receipt.iterateIPLDBlocks()\n    }\n\n    yield this.root\n  }\n  /**\n   * @template [E=never]\n   * @param {API.Link} link\n   * @param {E} [fallback]\n   * @returns {API.Receipt|E}\n   */\n  get(link, fallback) {\n    const receipts = this.root.data['ucanto/message@7.0.0'].report || {}\n    const receipt = receipts[`${link}`]\n    if (receipt) {\n      return Receipt.view({ root: receipt, blocks: this.store })\n    } else {\n      return fallback !== undefined\n        ? fallback\n        : panic(`Message does not include receipt for ${link}`)\n    }\n  }\n\n  get invocationLinks() {\n    return this.root.data['ucanto/message@7.0.0'].execute || []\n  }\n\n  get invocations() {\n    let invocations = this._invocations\n    if (!invocations) {\n      invocations = this.invocationLinks.map(link => {\n        return Invocation.view({ root: link, blocks: this.store })\n      })\n    }\n\n    return invocations\n  }\n\n  get receipts() {\n    let receipts = this._receipts\n    if (!receipts) {\n      receipts = new Map()\n      const report = this.root.data['ucanto/message@7.0.0'].report || {}\n      for (const [key, link] of Object.entries(report)) {\n        const receipt = Receipt.view({ root: link, blocks: this.store })\n        receipts.set(`${receipt.ran.link()}`, receipt)\n      }\n    }\n\n    return receipts\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}