{"ast":null,"code":"/*istanbul ignore start*/\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = Diff;\n\n/*istanbul ignore end*/\nfunction Diff() {}\nDiff.prototype = {\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  diff: function diff(oldString, newString) {\n    /*istanbul ignore start*/\n    var /*istanbul ignore end*/\n    options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var callback = options.callback;\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    this.options = options;\n    var self = this;\n    function done(value) {\n      if (callback) {\n        setTimeout(function () {\n          callback(undefined, value);\n        }, 0);\n        return true;\n      } else {\n        return value;\n      }\n    } // Allow subclasses to massage the input prior to running\n\n    oldString = this.castInput(oldString);\n    newString = this.castInput(newString);\n    oldString = this.removeEmpty(this.tokenize(oldString));\n    newString = this.removeEmpty(this.tokenize(newString));\n    var newLen = newString.length,\n      oldLen = oldString.length;\n    var editLength = 1;\n    var maxEditLength = newLen + oldLen;\n    var bestPath = [{\n      newPos: -1,\n      components: []\n    }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      // Identity per the equality and tokenizer\n      return done([{\n        value: this.join(newString),\n        count: newString.length\n      }]);\n    } // Main worker method. checks all permutations of a given edit length for acceptance.\n\n    function execEditLength() {\n      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        var basePath = /*istanbul ignore start*/\n        void 0\n        /*istanbul ignore end*/;\n        var addPath = bestPath[diagonalPath - 1],\n          removePath = bestPath[diagonalPath + 1],\n          _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n        var canAdd = addPath && addPath.newPos + 1 < newLen,\n          canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        } // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n\n        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n          basePath = clonePath(removePath);\n          self.pushComponent(basePath.components, undefined, true);\n        } else {\n          basePath = addPath; // No need to clone, we've pulled it from the list\n\n          basePath.newPos++;\n          self.pushComponent(basePath.components, true, undefined);\n        }\n        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done\n\n        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\n          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath;\n        }\n      }\n      editLength++;\n    } // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced.\n\n    if (callback) {\n      (function exec() {\n        setTimeout(function () {\n          // This should not happen, but we want to be safe.\n\n          /* istanbul ignore next */\n          if (editLength > maxEditLength) {\n            return callback();\n          }\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      })();\n    } else {\n      while (editLength <= maxEditLength) {\n        var ret = execEditLength();\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  },\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  pushComponent: function pushComponent(components, added, removed) {\n    var last = components[components.length - 1];\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = {\n        count: last.count + 1,\n        added: added,\n        removed: removed\n      };\n    } else {\n      components.push({\n        count: 1,\n        added: added,\n        removed: removed\n      });\n    }\n  },\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n    var newLen = newString.length,\n      oldLen = oldString.length,\n      newPos = basePath.newPos,\n      oldPos = newPos - diagonalPath,\n      commonCount = 0;\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n    if (commonCount) {\n      basePath.components.push({\n        count: commonCount\n      });\n    }\n    basePath.newPos = newPos;\n    return oldPos;\n  },\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  equals: function equals(left, right) {\n    if (this.options.comparator) {\n      return this.options.comparator(left, right);\n    } else {\n      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n    }\n  },\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  removeEmpty: function removeEmpty(array) {\n    var ret = [];\n    for (var i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n    return ret;\n  },\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  castInput: function castInput(value) {\n    return value;\n  },\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  tokenize: function tokenize(value) {\n    return value.split('');\n  },\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  join: function join(chars) {\n    return chars.join('');\n  }\n};\nfunction buildValues(diff, components, newString, oldString, useLongestToken) {\n  var componentPos = 0,\n    componentLen = components.length,\n    newPos = 0,\n    oldPos = 0;\n  for (; componentPos < componentLen; componentPos++) {\n    var component = components[componentPos];\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        var value = newString.slice(newPos, newPos + component.count);\n        value = value.map(function (value, i) {\n          var oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n        component.value = diff.join(value);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n      }\n      newPos += component.count; // Common case\n\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n\n      if (componentPos && components[componentPos - 1].added) {\n        var tmp = components[componentPos - 1];\n        components[componentPos - 1] = components[componentPos];\n        components[componentPos] = tmp;\n      }\n    }\n  } // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n\n  var lastComponent = components[componentLen - 1];\n  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {\n    components[componentLen - 2].value += lastComponent.value;\n    components.pop();\n  }\n  return components;\n}\nfunction clonePath(path) {\n  return {\n    newPos: path.newPos,\n    components: path.components.slice(0)\n  };\n}","map":{"version":3,"names":["Diff","prototype","diff","oldString","newString","options","arguments","length","undefined","callback","self","done","value","setTimeout","castInput","removeEmpty","tokenize","newLen","oldLen","editLength","maxEditLength","bestPath","newPos","components","oldPos","extractCommon","join","count","execEditLength","diagonalPath","basePath","addPath","removePath","_oldPos","canAdd","canRemove","clonePath","pushComponent","buildValues","useLongestToken","exec","ret","added","removed","last","push","commonCount","equals","left","right","comparator","ignoreCase","toLowerCase","array","i","split","chars","componentPos","componentLen","component","slice","map","oldValue","tmp","lastComponent","pop","path"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\diff\\src\\diff\\base.js"],"sourcesContent":["export default function Diff() {}\n\nDiff.prototype = {\n  diff(oldString, newString, options = {}) {\n    let callback = options.callback;\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    this.options = options;\n\n    let self = this;\n\n    function done(value) {\n      if (callback) {\n        setTimeout(function() { callback(undefined, value); }, 0);\n        return true;\n      } else {\n        return value;\n      }\n    }\n\n    // Allow subclasses to massage the input prior to running\n    oldString = this.castInput(oldString);\n    newString = this.castInput(newString);\n\n    oldString = this.removeEmpty(this.tokenize(oldString));\n    newString = this.removeEmpty(this.tokenize(newString));\n\n    let newLen = newString.length, oldLen = oldString.length;\n    let editLength = 1;\n    let maxEditLength = newLen + oldLen;\n    let bestPath = [{ newPos: -1, components: [] }];\n\n    // Seed editLength = 0, i.e. the content starts with the same values\n    let oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      // Identity per the equality and tokenizer\n      return done([{value: this.join(newString), count: newString.length}]);\n    }\n\n    // Main worker method. checks all permutations of a given edit length for acceptance.\n    function execEditLength() {\n      for (let diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        let basePath;\n        let addPath = bestPath[diagonalPath - 1],\n            removePath = bestPath[diagonalPath + 1],\n            oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        let canAdd = addPath && addPath.newPos + 1 < newLen,\n            canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        }\n\n        // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n        if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {\n          basePath = clonePath(removePath);\n          self.pushComponent(basePath.components, undefined, true);\n        } else {\n          basePath = addPath; // No need to clone, we've pulled it from the list\n          basePath.newPos++;\n          self.pushComponent(basePath.components, true, undefined);\n        }\n\n        oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);\n\n        // If we have hit the end of both strings, then we are done\n        if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath;\n        }\n      }\n\n      editLength++;\n    }\n\n    // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced.\n    if (callback) {\n      (function exec() {\n        setTimeout(function() {\n          // This should not happen, but we want to be safe.\n          /* istanbul ignore next */\n          if (editLength > maxEditLength) {\n            return callback();\n          }\n\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      }());\n    } else {\n      while (editLength <= maxEditLength) {\n        let ret = execEditLength();\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  },\n\n  pushComponent(components, added, removed) {\n    let last = components[components.length - 1];\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = {count: last.count + 1, added: added, removed: removed };\n    } else {\n      components.push({count: 1, added: added, removed: removed });\n    }\n  },\n  extractCommon(basePath, newString, oldString, diagonalPath) {\n    let newLen = newString.length,\n        oldLen = oldString.length,\n        newPos = basePath.newPos,\n        oldPos = newPos - diagonalPath,\n\n        commonCount = 0;\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.components.push({count: commonCount});\n    }\n\n    basePath.newPos = newPos;\n    return oldPos;\n  },\n\n  equals(left, right) {\n    if (this.options.comparator) {\n      return this.options.comparator(left, right);\n    } else {\n      return left === right\n        || (this.options.ignoreCase && left.toLowerCase() === right.toLowerCase());\n    }\n  },\n  removeEmpty(array) {\n    let ret = [];\n    for (let i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n    return ret;\n  },\n  castInput(value) {\n    return value;\n  },\n  tokenize(value) {\n    return value.split('');\n  },\n  join(chars) {\n    return chars.join('');\n  }\n};\n\nfunction buildValues(diff, components, newString, oldString, useLongestToken) {\n  let componentPos = 0,\n      componentLen = components.length,\n      newPos = 0,\n      oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    let component = components[componentPos];\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        let value = newString.slice(newPos, newPos + component.count);\n        value = value.map(function(value, i) {\n          let oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n\n        component.value = diff.join(value);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n      }\n      newPos += component.count;\n\n      // Common case\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n      oldPos += component.count;\n\n      // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n      if (componentPos && components[componentPos - 1].added) {\n        let tmp = components[componentPos - 1];\n        components[componentPos - 1] = components[componentPos];\n        components[componentPos] = tmp;\n      }\n    }\n  }\n\n  // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n  let lastComponent = components[componentLen - 1];\n  if (componentLen > 1\n      && typeof lastComponent.value === 'string'\n      && (lastComponent.added || lastComponent.removed)\n      && diff.equals('', lastComponent.value)) {\n    components[componentLen - 2].value += lastComponent.value;\n    components.pop();\n  }\n\n  return components;\n}\n\nfunction clonePath(path) {\n  return { newPos: path.newPos, components: path.components.slice(0) };\n}\n"],"mappings":";;;;;;;;;AAAe,SAASA,IAATA,CAAA,EAAgB,CAAE;AAEjCA,IAAI,CAACC,SAAL,GAAiB;EAAA;;EAAA;EACfC,IADe,WAAAA,KACVC,SADU,EACCC,SADD,EAC0B;IAAA;IAAA;IAAdC,OAAc,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAJ,EAAI;IACvC,IAAIG,QAAQ,GAAGJ,OAAO,CAACI,QAAvB;IACA,IAAI,OAAOJ,OAAP,KAAmB,UAAvB,EAAmC;MACjCI,QAAQ,GAAGJ,OAAX;MACAA,OAAO,GAAG,EAAV;IACD;IACD,KAAKA,OAAL,GAAeA,OAAf;IAEA,IAAIK,IAAI,GAAG,IAAX;IAEA,SAASC,IAATA,CAAcC,KAAd,EAAqB;MACnB,IAAIH,QAAJ,EAAc;QACZI,UAAU,CAAC,YAAW;UAAEJ,QAAQ,CAACD,SAAD,EAAYI,KAAZ,CAAR;QAA6B,CAA3C,EAA6C,CAA7C,CAAV;QACA,OAAO,IAAP;MACD,CAHD,MAGO;QACL,OAAOA,KAAP;MACD;IACF,CAjBsC,CAmBvC;;IACAT,SAAS,GAAG,KAAKW,SAAL,CAAeX,SAAf,CAAZ;IACAC,SAAS,GAAG,KAAKU,SAAL,CAAeV,SAAf,CAAZ;IAEAD,SAAS,GAAG,KAAKY,WAAL,CAAiB,KAAKC,QAAL,CAAcb,SAAd,CAAjB,CAAZ;IACAC,SAAS,GAAG,KAAKW,WAAL,CAAiB,KAAKC,QAAL,CAAcZ,SAAd,CAAjB,CAAZ;IAEA,IAAIa,MAAM,GAAGb,SAAS,CAACG,MAAvB;MAA+BW,MAAM,GAAGf,SAAS,CAACI,MAAlD;IACA,IAAIY,UAAU,GAAG,CAAjB;IACA,IAAIC,aAAa,GAAGH,MAAM,GAAGC,MAA7B;IACA,IAAIG,QAAQ,GAAG,CAAC;MAAEC,MAAM,EAAE,CAAC,CAAX;MAAcC,UAAU,EAAE;IAA1B,CAAD,CAAf,CA7BuC,CA+BvC;;IACA,IAAIC,MAAM,GAAG,KAAKC,aAAL,CAAmBJ,QAAQ,CAAC,CAAD,CAA3B,EAAgCjB,SAAhC,EAA2CD,SAA3C,EAAsD,CAAtD,CAAb;IACA,IAAIkB,QAAQ,CAAC,CAAD,CAAR,CAAYC,MAAZ,GAAqB,CAArB,IAA0BL,MAA1B,IAAoCO,MAAM,GAAG,CAAT,IAAcN,MAAtD,EAA8D;MAC5D;MACA,OAAOP,IAAI,CAAC,CAAC;QAACC,KAAK,EAAE,KAAKc,IAAL,CAAUtB,SAAV,CAAR;QAA8BuB,KAAK,EAAEvB,SAAS,CAACG;MAA/C,CAAD,CAAD,CAAX;IACD,CApCsC,CAsCvC;;IACA,SAASqB,cAATA,CAAA,EAA0B;MACxB,KAAK,IAAIC,YAAY,GAAG,CAAC,CAAD,GAAKV,UAA7B,EAAyCU,YAAY,IAAIV,UAAzD,EAAqEU,YAAY,IAAI,CAArF,EAAwF;QACtF,IAAIC,QAAQ;QAAA;QAAZ;QACA,IAAIC,OAAO,GAAGV,QAAQ,CAACQ,YAAY,GAAG,CAAhB,CAAtB;UACIG,UAAU,GAAGX,QAAQ,CAACQ,YAAY,GAAG,CAAhB,CADzB;UAEII,OAAM,GAAG,CAACD,UAAU,GAAGA,UAAU,CAACV,MAAd,GAAuB,CAAlC,IAAuCO,YAFpD;QAGA,IAAIE,OAAJ,EAAa;UACX;UACAV,QAAQ,CAACQ,YAAY,GAAG,CAAhB,CAAR,GAA6BrB,SAA7B;QACD;QAED,IAAI0B,MAAM,GAAGH,OAAO,IAAIA,OAAO,CAACT,MAAR,GAAiB,CAAjB,GAAqBL,MAA7C;UACIkB,SAAS,GAAGH,UAAU,IAAI,KAAKC,OAAnB,IAA6BA,OAAM,GAAGf,MADtD;QAEA,IAAI,CAACgB,MAAD,IAAW,CAACC,SAAhB,EAA2B;UACzB;UACAd,QAAQ,CAACQ,YAAD,CAAR,GAAyBrB,SAAzB;UACA;QACD,CAhBqF,CAkBtF;QACA;QACA;;QACA,IAAI,CAAC0B,MAAD,IAAYC,SAAS,IAAIJ,OAAO,CAACT,MAAR,GAAiBU,UAAU,CAACV,MAAzD,EAAkE;UAChEQ,QAAQ,GAAGM,SAAS,CAACJ,UAAD,CAApB;UACAtB,IAAI,CAAC2B,aAAL,CAAmBP,QAAQ,CAACP,UAA5B,EAAwCf,SAAxC,EAAmD,IAAnD;QACD,CAHD,MAGO;UACLsB,QAAQ,GAAGC,OAAX,CADK,CACe;;UACpBD,QAAQ,CAACR,MAAT;UACAZ,IAAI,CAAC2B,aAAL,CAAmBP,QAAQ,CAACP,UAA5B,EAAwC,IAAxC,EAA8Cf,SAA9C;QACD;QAEDyB,OAAM,GAAGvB,IAAI,CAACe,aAAL,CAAmBK,QAAnB,EAA6B1B,SAA7B,EAAwCD,SAAxC,EAAmD0B,YAAnD,CAAT,CA9BsF,CAgCtF;;QACA,IAAIC,QAAQ,CAACR,MAAT,GAAkB,CAAlB,IAAuBL,MAAvB,IAAiCgB,OAAM,GAAG,CAAT,IAAcf,MAAnD,EAA2D;UACzD,OAAOP,IAAI,CAAC2B,WAAW,CAAC5B,IAAD,EAAOoB,QAAQ,CAACP,UAAhB,EAA4BnB,SAA5B,EAAuCD,SAAvC,EAAkDO,IAAI,CAAC6B,eAAvD,CAAZ,CAAX;QACD,CAFD,MAEO;UACL;UACAlB,QAAQ,CAACQ,YAAD,CAAR,GAAyBC,QAAzB;QACD;MACF;MAEDX,UAAU;IACX,CAlFsC,CAoFvC;IACA;IACA;;IACA,IAAIV,QAAJ,EAAc;MACX,UAAS+B,IAATA,CAAA,EAAgB;QACf3B,UAAU,CAAC,YAAW;UACpB;;UACA;UACA,IAAIM,UAAU,GAAGC,aAAjB,EAAgC;YAC9B,OAAOX,QAAQ,EAAf;UACD;UAED,IAAI,CAACmB,cAAc,EAAnB,EAAuB;YACrBY,IAAI;UACL;QACF,CAVS,EAUP,CAVO,CAAV;MAWD,CAZA,GAAD;IAaD,CAdD,MAcO;MACL,OAAOrB,UAAU,IAAIC,aAArB,EAAoC;QAClC,IAAIqB,GAAG,GAAGb,cAAc,EAAxB;QACA,IAAIa,GAAJ,EAAS;UACP,OAAOA,GAAP;QACD;MACF;IACF;EACF,CA9Gc;EAAA;;EAAA;EAgHfJ,aAhHe,WAAAA,cAgHDd,UAhHC,EAgHWmB,KAhHX,EAgHkBC,OAhHlB,EAgH2B;IACxC,IAAIC,IAAI,GAAGrB,UAAU,CAACA,UAAU,CAAChB,MAAX,GAAoB,CAArB,CAArB;IACA,IAAIqC,IAAI,IAAIA,IAAI,CAACF,KAAL,KAAeA,KAAvB,IAAgCE,IAAI,CAACD,OAAL,KAAiBA,OAArD,EAA8D;MAC5D;MACA;MACApB,UAAU,CAACA,UAAU,CAAChB,MAAX,GAAoB,CAArB,CAAV,GAAoC;QAACoB,KAAK,EAAEiB,IAAI,CAACjB,KAAL,GAAa,CAArB;QAAwBe,KAAK,EAAEA,KAA/B;QAAsCC,OAAO,EAAEA;MAA/C,CAApC;IACD,CAJD,MAIO;MACLpB,UAAU,CAACsB,IAAX,CAAgB;QAAClB,KAAK,EAAE,CAAR;QAAWe,KAAK,EAAEA,KAAlB;QAAyBC,OAAO,EAAEA;MAAlC,CAAhB;IACD;EACF,CAzHc;EAAA;;EAAA;EA0HflB,aA1He,WAAAA,cA0HDK,QA1HC,EA0HS1B,SA1HT,EA0HoBD,SA1HpB,EA0H+B0B,YA1H/B,EA0H6C;IAC1D,IAAIZ,MAAM,GAAGb,SAAS,CAACG,MAAvB;MACIW,MAAM,GAAGf,SAAS,CAACI,MADvB;MAEIe,MAAM,GAAGQ,QAAQ,CAACR,MAFtB;MAGIE,MAAM,GAAGF,MAAM,GAAGO,YAHtB;MAKIiB,WAAW,GAAG,CALlB;IAMA,OAAOxB,MAAM,GAAG,CAAT,GAAaL,MAAb,IAAuBO,MAAM,GAAG,CAAT,GAAaN,MAApC,IAA8C,KAAK6B,MAAL,CAAY3C,SAAS,CAACkB,MAAM,GAAG,CAAV,CAArB,EAAmCnB,SAAS,CAACqB,MAAM,GAAG,CAAV,CAA5C,CAArD,EAAgH;MAC9GF,MAAM;MACNE,MAAM;MACNsB,WAAW;IACZ;IAED,IAAIA,WAAJ,EAAiB;MACfhB,QAAQ,CAACP,UAAT,CAAoBsB,IAApB,CAAyB;QAAClB,KAAK,EAAEmB;MAAR,CAAzB;IACD;IAEDhB,QAAQ,CAACR,MAAT,GAAkBA,MAAlB;IACA,OAAOE,MAAP;EACD,CA7Ic;EAAA;;EAAA;EA+IfuB,MA/Ie,WAAAA,OA+IRC,IA/IQ,EA+IFC,KA/IE,EA+IK;IAClB,IAAI,KAAK5C,OAAL,CAAa6C,UAAjB,EAA6B;MAC3B,OAAO,KAAK7C,OAAL,CAAa6C,UAAb,CAAwBF,IAAxB,EAA8BC,KAA9B,CAAP;IACD,CAFD,MAEO;MACL,OAAOD,IAAI,KAAKC,KAAT,IACD,KAAK5C,OAAL,CAAa8C,UAAb,IAA2BH,IAAI,CAACI,WAAL,OAAuBH,KAAK,CAACG,WAAN,EADxD;IAED;EACF,CAtJc;EAAA;;EAAA;EAuJfrC,WAvJe,WAAAA,YAuJHsC,KAvJG,EAuJI;IACjB,IAAIZ,GAAG,GAAG,EAAV;IACA,KAAK,IAAIa,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAAC9C,MAA1B,EAAkC+C,CAAC,EAAnC,EAAuC;MACrC,IAAID,KAAK,CAACC,CAAD,CAAT,EAAc;QACZb,GAAG,CAACI,IAAJ,CAASQ,KAAK,CAACC,CAAD,CAAd;MACD;IACF;IACD,OAAOb,GAAP;EACD,CA/Jc;EAAA;;EAAA;EAgKf3B,SAhKe,WAAAA,UAgKLF,KAhKK,EAgKE;IACf,OAAOA,KAAP;EACD,CAlKc;EAAA;;EAAA;EAmKfI,QAnKe,WAAAA,SAmKNJ,KAnKM,EAmKC;IACd,OAAOA,KAAK,CAAC2C,KAAN,CAAY,EAAZ,CAAP;EACD,CArKc;EAAA;;EAAA;EAsKf7B,IAtKe,WAAAA,KAsKV8B,KAtKU,EAsKH;IACV,OAAOA,KAAK,CAAC9B,IAAN,CAAW,EAAX,CAAP;EACD;AAxKc,CAAjB;AA2KA,SAASY,WAATA,CAAqBpC,IAArB,EAA2BqB,UAA3B,EAAuCnB,SAAvC,EAAkDD,SAAlD,EAA6DoC,eAA7D,EAA8E;EAC5E,IAAIkB,YAAY,GAAG,CAAnB;IACIC,YAAY,GAAGnC,UAAU,CAAChB,MAD9B;IAEIe,MAAM,GAAG,CAFb;IAGIE,MAAM,GAAG,CAHb;EAKA,OAAOiC,YAAY,GAAGC,YAAtB,EAAoCD,YAAY,EAAhD,EAAoD;IAClD,IAAIE,SAAS,GAAGpC,UAAU,CAACkC,YAAD,CAA1B;IACA,IAAI,CAACE,SAAS,CAAChB,OAAf,EAAwB;MACtB,IAAI,CAACgB,SAAS,CAACjB,KAAX,IAAoBH,eAAxB,EAAyC;QACvC,IAAI3B,KAAK,GAAGR,SAAS,CAACwD,KAAV,CAAgBtC,MAAhB,EAAwBA,MAAM,GAAGqC,SAAS,CAAChC,KAA3C,CAAZ;QACAf,KAAK,GAAGA,KAAK,CAACiD,GAAN,CAAU,UAASjD,KAAT,EAAgB0C,CAAhB,EAAmB;UACnC,IAAIQ,QAAQ,GAAG3D,SAAS,CAACqB,MAAM,GAAG8B,CAAV,CAAxB;UACA,OAAOQ,QAAQ,CAACvD,MAAT,GAAkBK,KAAK,CAACL,MAAxB,GAAiCuD,QAAjC,GAA4ClD,KAAnD;QACD,CAHO,CAAR;QAKA+C,SAAS,CAAC/C,KAAV,GAAkBV,IAAI,CAACwB,IAAL,CAAUd,KAAV,CAAlB;MACD,CARD,MAQO;QACL+C,SAAS,CAAC/C,KAAV,GAAkBV,IAAI,CAACwB,IAAL,CAAUtB,SAAS,CAACwD,KAAV,CAAgBtC,MAAhB,EAAwBA,MAAM,GAAGqC,SAAS,CAAChC,KAA3C,CAAV,CAAlB;MACD;MACDL,MAAM,IAAIqC,SAAS,CAAChC,KAApB,CAZsB,CActB;;MACA,IAAI,CAACgC,SAAS,CAACjB,KAAf,EAAsB;QACpBlB,MAAM,IAAImC,SAAS,CAAChC,KAApB;MACD;IACF,CAlBD,MAkBO;MACLgC,SAAS,CAAC/C,KAAV,GAAkBV,IAAI,CAACwB,IAAL,CAAUvB,SAAS,CAACyD,KAAV,CAAgBpC,MAAhB,EAAwBA,MAAM,GAAGmC,SAAS,CAAChC,KAA3C,CAAV,CAAlB;MACAH,MAAM,IAAImC,SAAS,CAAChC,KAApB,CAFK,CAIL;MACA;MACA;;MACA,IAAI8B,YAAY,IAAIlC,UAAU,CAACkC,YAAY,GAAG,CAAhB,CAAV,CAA6Bf,KAAjD,EAAwD;QACtD,IAAIqB,GAAG,GAAGxC,UAAU,CAACkC,YAAY,GAAG,CAAhB,CAApB;QACAlC,UAAU,CAACkC,YAAY,GAAG,CAAhB,CAAV,GAA+BlC,UAAU,CAACkC,YAAD,CAAzC;QACAlC,UAAU,CAACkC,YAAD,CAAV,GAA2BM,GAA3B;MACD;IACF;EACF,CAvC2E,CAyC5E;EACA;EACA;;EACA,IAAIC,aAAa,GAAGzC,UAAU,CAACmC,YAAY,GAAG,CAAhB,CAA9B;EACA,IAAIA,YAAY,GAAG,CAAf,IACG,OAAOM,aAAa,CAACpD,KAArB,KAA+B,QADlC,KAEIoD,aAAa,CAACtB,KAAd,IAAuBsB,aAAa,CAACrB,OAFzC,KAGGzC,IAAI,CAAC6C,MAAL,CAAY,EAAZ,EAAgBiB,aAAa,CAACpD,KAA9B,CAHP,EAG6C;IAC3CW,UAAU,CAACmC,YAAY,GAAG,CAAhB,CAAV,CAA6B9C,KAA7B,IAAsCoD,aAAa,CAACpD,KAApD;IACAW,UAAU,CAAC0C,GAAX;EACD;EAED,OAAO1C,UAAP;AACD;AAED,SAASa,SAATA,CAAmB8B,IAAnB,EAAyB;EACvB,OAAO;IAAE5C,MAAM,EAAE4C,IAAI,CAAC5C,MAAf;IAAuBC,UAAU,EAAE2C,IAAI,CAAC3C,UAAL,CAAgBqC,KAAhB,CAAsB,CAAtB;EAAnC,CAAP;AACD","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}