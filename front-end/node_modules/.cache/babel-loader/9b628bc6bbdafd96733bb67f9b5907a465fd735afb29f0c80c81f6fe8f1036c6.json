{"ast":null,"code":"import * as DID from '@ipld/dag-ucan/did';\nimport * as ED25519 from '@noble/ed25519';\nimport { varint } from 'multiformats';\nimport * as API from './type.js';\nimport * as Signature from '@ipld/dag-ucan/signature';\nimport { base58btc } from 'multiformats/bases/base58';\nimport * as Verifier from '../verifier.js';\n\n/** @type {API.EdVerifier['code']} */\nexport const code = 0xed;\nexport const name = 'Ed25519';\n\n/** @type {API.SigAlg} */\nexport const signatureCode = Signature.EdDSA;\nexport const signatureAlgorithm = 'EdDSA';\nconst PUBLIC_TAG_SIZE = varint.encodingLength(code);\nconst SIZE = 32 + PUBLIC_TAG_SIZE;\n\n/**\n * @typedef {API.EdVerifier} EdVerifier\n */\n\n/**\n * Parses `did:key:` string as a VerifyingPrincipal.\n *\n * @param {API.DID|string} did\n * @returns {API.Verifier<API.DID, typeof signatureCode>}\n */\nexport const parse = did => decode(DID.parse(did));\n\n/**\n * Takes ed25519 public key tagged with `0xed` multiformat code and creates a\n * corresponding `Principal` that can be used to verify signatures.\n *\n * @param {Uint8Array} bytes\n * @returns {API.EdVerifier}\n */\nexport const decode = bytes => {\n  const [algorithm] = varint.decode(bytes);\n  if (algorithm !== code) {\n    throw new RangeError(`Unsupported key algorithm with multicode 0x${code.toString(16)}`);\n  } else if (bytes.byteLength !== SIZE) {\n    throw new RangeError(`Expected Uint8Array with byteLength ${SIZE}, instead got Uint8Array with byteLength ${bytes.byteLength}`);\n  } else {\n    return new Ed25519Verifier(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n  }\n};\n\n/**\n * Formats given Principal into `did:key:` format.\n *\n * @param {API.Principal<API.DID>} principal\n */\nexport const format = principal => DID.format(principal);\n\n/**\n * Encodes given Principal by tagging it's ed25519 public key with `0xed`\n * multiformat code.\n *\n * @param {API.Principal<API.DID<\"key\">>} principal\n */\nexport const encode = principal => DID.encode(principal);\n\n/**\n * @implements {API.EdVerifier}\n */\nclass Ed25519Verifier extends Uint8Array {\n  /** @type {typeof code} */\n  get code() {\n    return code;\n  }\n  /** @type {typeof signatureCode} */\n  get signatureCode() {\n    return signatureCode;\n  }\n  /** @type {typeof signatureAlgorithm} */\n  get signatureAlgorithm() {\n    return signatureAlgorithm;\n  }\n  /**\n   * Raw public key without a multiformat code.\n   *\n   * @readonly\n   */\n  get publicKey() {\n    const key = new Uint8Array(this.buffer, this.byteOffset + PUBLIC_TAG_SIZE);\n    Object.defineProperties(this, {\n      publicKey: {\n        value: key\n      }\n    });\n    return key;\n  }\n  /**\n   * DID of the Principal in `did:key` format.\n   * @returns {API.DID<\"key\">}\n   */\n  did() {\n    return `did:key:${base58btc.encode(this)}`;\n  }\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, Signature.EdDSA>} signature\n   * @returns {API.Await<boolean>}\n   */\n  verify(payload, signature) {\n    return signature.code === signatureCode && ED25519.verify(signature.raw, payload, this.publicKey);\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   * @returns {API.Verifier<ID, typeof signatureCode>}\n   */\n  withDID(id) {\n    return Verifier.withDID(this, id);\n  }\n  toDIDKey() {\n    return this.did();\n  }\n}\n\n/**\n * @param {API.PrincipalParser} other\n */\nexport const or = other => Verifier.or({\n  parse\n}, other);","map":{"version":3,"names":["DID","ED25519","varint","API","Signature","base58btc","Verifier","code","name","signatureCode","EdDSA","signatureAlgorithm","PUBLIC_TAG_SIZE","encodingLength","SIZE","parse","did","decode","bytes","algorithm","RangeError","toString","byteLength","Ed25519Verifier","buffer","byteOffset","format","principal","encode","Uint8Array","publicKey","key","Object","defineProperties","value","verify","payload","signature","raw","withDID","id","toDIDKey","or","other"],"sources":["C:/FACULTATE/Proiect/node_modules/@ucanto/principal/src/ed25519/verifier.js"],"sourcesContent":["import * as DID from '@ipld/dag-ucan/did'\nimport * as ED25519 from '@noble/ed25519'\nimport { varint } from 'multiformats'\nimport * as API from './type.js'\nimport * as Signature from '@ipld/dag-ucan/signature'\nimport { base58btc } from 'multiformats/bases/base58'\nimport * as Verifier from '../verifier.js'\n\n/** @type {API.EdVerifier['code']} */\nexport const code = 0xed\nexport const name = 'Ed25519'\n\n/** @type {API.SigAlg} */\nexport const signatureCode = Signature.EdDSA\nexport const signatureAlgorithm = 'EdDSA'\nconst PUBLIC_TAG_SIZE = varint.encodingLength(code)\nconst SIZE = 32 + PUBLIC_TAG_SIZE\n\n/**\n * @typedef {API.EdVerifier} EdVerifier\n */\n\n/**\n * Parses `did:key:` string as a VerifyingPrincipal.\n *\n * @param {API.DID|string} did\n * @returns {API.Verifier<API.DID, typeof signatureCode>}\n */\nexport const parse = did => decode(DID.parse(did))\n\n/**\n * Takes ed25519 public key tagged with `0xed` multiformat code and creates a\n * corresponding `Principal` that can be used to verify signatures.\n *\n * @param {Uint8Array} bytes\n * @returns {API.EdVerifier}\n */\nexport const decode = bytes => {\n  const [algorithm] = varint.decode(bytes)\n  if (algorithm !== code) {\n    throw new RangeError(\n      `Unsupported key algorithm with multicode 0x${code.toString(16)}`\n    )\n  } else if (bytes.byteLength !== SIZE) {\n    throw new RangeError(\n      `Expected Uint8Array with byteLength ${SIZE}, instead got Uint8Array with byteLength ${bytes.byteLength}`\n    )\n  } else {\n    return new Ed25519Verifier(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n  }\n}\n\n/**\n * Formats given Principal into `did:key:` format.\n *\n * @param {API.Principal<API.DID>} principal\n */\nexport const format = principal => DID.format(principal)\n\n/**\n * Encodes given Principal by tagging it's ed25519 public key with `0xed`\n * multiformat code.\n *\n * @param {API.Principal<API.DID<\"key\">>} principal\n */\nexport const encode = principal => DID.encode(principal)\n\n/**\n * @implements {API.EdVerifier}\n */\nclass Ed25519Verifier extends Uint8Array {\n  /** @type {typeof code} */\n  get code() {\n    return code\n  }\n  /** @type {typeof signatureCode} */\n  get signatureCode() {\n    return signatureCode\n  }\n  /** @type {typeof signatureAlgorithm} */\n  get signatureAlgorithm() {\n    return signatureAlgorithm\n  }\n  /**\n   * Raw public key without a multiformat code.\n   *\n   * @readonly\n   */\n  get publicKey() {\n    const key = new Uint8Array(this.buffer, this.byteOffset + PUBLIC_TAG_SIZE)\n    Object.defineProperties(this, {\n      publicKey: {\n        value: key,\n      },\n    })\n    return key\n  }\n  /**\n   * DID of the Principal in `did:key` format.\n   * @returns {API.DID<\"key\">}\n   */\n  did() {\n    return `did:key:${base58btc.encode(this)}`\n  }\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, Signature.EdDSA>} signature\n   * @returns {API.Await<boolean>}\n   */\n  verify(payload, signature) {\n    return (\n      signature.code === signatureCode &&\n      ED25519.verify(signature.raw, payload, this.publicKey)\n    )\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   * @returns {API.Verifier<ID, typeof signatureCode>}\n   */\n  withDID(id) {\n    return Verifier.withDID(this, id)\n  }\n\n  toDIDKey() {\n    return this.did()\n  }\n}\n\n/**\n * @param {API.PrincipalParser} other\n */\nexport const or = other => Verifier.or({ parse }, other)\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}