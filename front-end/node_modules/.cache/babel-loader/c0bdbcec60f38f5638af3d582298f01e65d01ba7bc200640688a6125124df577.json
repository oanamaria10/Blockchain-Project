{"ast":null,"code":"'use strict';\n\nconst {\n  kState,\n  kError,\n  kResult,\n  kAborted,\n  kLastProgressEventFired\n} = require('./symbols');\nconst {\n  ProgressEvent\n} = require('./progressevent');\nconst {\n  getEncoding\n} = require('./encoding');\nconst {\n  DOMException\n} = require('../fetch/constants');\nconst {\n  serializeAMimeType,\n  parseMIMEType\n} = require('../fetch/dataURL');\nconst {\n  types\n} = require('util');\nconst {\n  StringDecoder\n} = require('string_decoder');\nconst {\n  btoa\n} = require('buffer');\n\n/** @type {PropertyDescriptor} */\nconst staticPropertyDescriptors = {\n  enumerable: true,\n  writable: false,\n  configurable: false\n};\n\n/**\n * @see https://w3c.github.io/FileAPI/#readOperation\n * @param {import('./filereader').FileReader} fr\n * @param {import('buffer').Blob} blob\n * @param {string} type\n * @param {string?} encodingName\n */\nfunction readOperation(fr, blob, type, encodingName) {\n  // 1. If fr’s state is \"loading\", throw an InvalidStateError\n  //    DOMException.\n  if (fr[kState] === 'loading') {\n    throw new DOMException('Invalid state', 'InvalidStateError');\n  }\n\n  // 2. Set fr’s state to \"loading\".\n  fr[kState] = 'loading';\n\n  // 3. Set fr’s result to null.\n  fr[kResult] = null;\n\n  // 4. Set fr’s error to null.\n  fr[kError] = null;\n\n  // 5. Let stream be the result of calling get stream on blob.\n  /** @type {import('stream/web').ReadableStream} */\n  const stream = blob.stream();\n\n  // 6. Let reader be the result of getting a reader from stream.\n  const reader = stream.getReader();\n\n  // 7. Let bytes be an empty byte sequence.\n  /** @type {Uint8Array[]} */\n  const bytes = [];\n\n  // 8. Let chunkPromise be the result of reading a chunk from\n  //    stream with reader.\n  let chunkPromise = reader.read();\n\n  // 9. Let isFirstChunk be true.\n  let isFirstChunk = true\n\n  // 10. In parallel, while true:\n  // Note: \"In parallel\" just means non-blocking\n  // Note 2: readOperation itself cannot be async as double\n  // reading the body would then reject the promise, instead\n  // of throwing an error.\n  ;\n  (async () => {\n    while (!fr[kAborted]) {\n      // 1. Wait for chunkPromise to be fulfilled or rejected.\n      try {\n        const {\n          done,\n          value\n        } = await chunkPromise;\n\n        // 2. If chunkPromise is fulfilled, and isFirstChunk is\n        //    true, queue a task to fire a progress event called\n        //    loadstart at fr.\n        if (isFirstChunk && !fr[kAborted]) {\n          queueMicrotask(() => {\n            fireAProgressEvent('loadstart', fr);\n          });\n        }\n\n        // 3. Set isFirstChunk to false.\n        isFirstChunk = false;\n\n        // 4. If chunkPromise is fulfilled with an object whose\n        //    done property is false and whose value property is\n        //    a Uint8Array object, run these steps:\n        if (!done && types.isUint8Array(value)) {\n          // 1. Let bs be the byte sequence represented by the\n          //    Uint8Array object.\n\n          // 2. Append bs to bytes.\n          bytes.push(value);\n\n          // 3. If roughly 50ms have passed since these steps\n          //    were last invoked, queue a task to fire a\n          //    progress event called progress at fr.\n          if ((fr[kLastProgressEventFired] === undefined || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted]) {\n            fr[kLastProgressEventFired] = Date.now();\n            queueMicrotask(() => {\n              fireAProgressEvent('progress', fr);\n            });\n          }\n\n          // 4. Set chunkPromise to the result of reading a\n          //    chunk from stream with reader.\n          chunkPromise = reader.read();\n        } else if (done) {\n          // 5. Otherwise, if chunkPromise is fulfilled with an\n          //    object whose done property is true, queue a task\n          //    to run the following steps and abort this algorithm:\n          queueMicrotask(() => {\n            // 1. Set fr’s state to \"done\".\n            fr[kState] = 'done';\n\n            // 2. Let result be the result of package data given\n            //    bytes, type, blob’s type, and encodingName.\n            try {\n              const result = packageData(bytes, type, blob.type, encodingName);\n\n              // 4. Else:\n\n              if (fr[kAborted]) {\n                return;\n              }\n\n              // 1. Set fr’s result to result.\n              fr[kResult] = result;\n\n              // 2. Fire a progress event called load at the fr.\n              fireAProgressEvent('load', fr);\n            } catch (error) {\n              // 3. If package data threw an exception error:\n\n              // 1. Set fr’s error to error.\n              fr[kError] = error;\n\n              // 2. Fire a progress event called error at fr.\n              fireAProgressEvent('error', fr);\n            }\n\n            // 5. If fr’s state is not \"loading\", fire a progress\n            //    event called loadend at the fr.\n            if (fr[kState] !== 'loading') {\n              fireAProgressEvent('loadend', fr);\n            }\n          });\n          break;\n        }\n      } catch (error) {\n        if (fr[kAborted]) {\n          return;\n        }\n\n        // 6. Otherwise, if chunkPromise is rejected with an\n        //    error error, queue a task to run the following\n        //    steps and abort this algorithm:\n        queueMicrotask(() => {\n          // 1. Set fr’s state to \"done\".\n          fr[kState] = 'done';\n\n          // 2. Set fr’s error to error.\n          fr[kError] = error;\n\n          // 3. Fire a progress event called error at fr.\n          fireAProgressEvent('error', fr);\n\n          // 4. If fr’s state is not \"loading\", fire a progress\n          //    event called loadend at fr.\n          if (fr[kState] !== 'loading') {\n            fireAProgressEvent('loadend', fr);\n          }\n        });\n        break;\n      }\n    }\n  })();\n}\n\n/**\n * @see https://w3c.github.io/FileAPI/#fire-a-progress-event\n * @see https://dom.spec.whatwg.org/#concept-event-fire\n * @param {string} e The name of the event\n * @param {import('./filereader').FileReader} reader\n */\nfunction fireAProgressEvent(e, reader) {\n  // The progress event e does not bubble. e.bubbles must be false\n  // The progress event e is NOT cancelable. e.cancelable must be false\n  const event = new ProgressEvent(e, {\n    bubbles: false,\n    cancelable: false\n  });\n  reader.dispatchEvent(event);\n}\n\n/**\n * @see https://w3c.github.io/FileAPI/#blob-package-data\n * @param {Uint8Array[]} bytes\n * @param {string} type\n * @param {string?} mimeType\n * @param {string?} encodingName\n */\nfunction packageData(bytes, type, mimeType, encodingName) {\n  // 1. A Blob has an associated package data algorithm, given\n  //    bytes, a type, a optional mimeType, and a optional\n  //    encodingName, which switches on type and runs the\n  //    associated steps:\n\n  switch (type) {\n    case 'DataURL':\n      {\n        // 1. Return bytes as a DataURL [RFC2397] subject to\n        //    the considerations below:\n        //  * Use mimeType as part of the Data URL if it is\n        //    available in keeping with the Data URL\n        //    specification [RFC2397].\n        //  * If mimeType is not available return a Data URL\n        //    without a media-type. [RFC2397].\n\n        // https://datatracker.ietf.org/doc/html/rfc2397#section-3\n        // dataurl    := \"data:\" [ mediatype ] [ \";base64\" ] \",\" data\n        // mediatype  := [ type \"/\" subtype ] *( \";\" parameter )\n        // data       := *urlchar\n        // parameter  := attribute \"=\" value\n        let dataURL = 'data:';\n        const parsed = parseMIMEType(mimeType || 'application/octet-stream');\n        if (parsed !== 'failure') {\n          dataURL += serializeAMimeType(parsed);\n        }\n        dataURL += ';base64,';\n        const decoder = new StringDecoder('latin1');\n        for (const chunk of bytes) {\n          dataURL += btoa(decoder.write(chunk));\n        }\n        dataURL += btoa(decoder.end());\n        return dataURL;\n      }\n    case 'Text':\n      {\n        // 1. Let encoding be failure\n        let encoding = 'failure';\n\n        // 2. If the encodingName is present, set encoding to the\n        //    result of getting an encoding from encodingName.\n        if (encodingName) {\n          encoding = getEncoding(encodingName);\n        }\n\n        // 3. If encoding is failure, and mimeType is present:\n        if (encoding === 'failure' && mimeType) {\n          // 1. Let type be the result of parse a MIME type\n          //    given mimeType.\n          const type = parseMIMEType(mimeType);\n\n          // 2. If type is not failure, set encoding to the result\n          //    of getting an encoding from type’s parameters[\"charset\"].\n          if (type !== 'failure') {\n            encoding = getEncoding(type.parameters.get('charset'));\n          }\n        }\n\n        // 4. If encoding is failure, then set encoding to UTF-8.\n        if (encoding === 'failure') {\n          encoding = 'UTF-8';\n        }\n\n        // 5. Decode bytes using fallback encoding encoding, and\n        //    return the result.\n        return decode(bytes, encoding);\n      }\n    case 'ArrayBuffer':\n      {\n        // Return a new ArrayBuffer whose contents are bytes.\n        const sequence = combineByteSequences(bytes);\n        return sequence.buffer;\n      }\n    case 'BinaryString':\n      {\n        // Return bytes as a binary string, in which every byte\n        //  is represented by a code unit of equal value [0..255].\n        let binaryString = '';\n        const decoder = new StringDecoder('latin1');\n        for (const chunk of bytes) {\n          binaryString += decoder.write(chunk);\n        }\n        binaryString += decoder.end();\n        return binaryString;\n      }\n  }\n}\n\n/**\n * @see https://encoding.spec.whatwg.org/#decode\n * @param {Uint8Array[]} ioQueue\n * @param {string} encoding\n */\nfunction decode(ioQueue, encoding) {\n  const bytes = combineByteSequences(ioQueue);\n\n  // 1. Let BOMEncoding be the result of BOM sniffing ioQueue.\n  const BOMEncoding = BOMSniffing(bytes);\n  let slice = 0;\n\n  // 2. If BOMEncoding is non-null:\n  if (BOMEncoding !== null) {\n    // 1. Set encoding to BOMEncoding.\n    encoding = BOMEncoding;\n\n    // 2. Read three bytes from ioQueue, if BOMEncoding is\n    //    UTF-8; otherwise read two bytes.\n    //    (Do nothing with those bytes.)\n    slice = BOMEncoding === 'UTF-8' ? 3 : 2;\n  }\n\n  // 3. Process a queue with an instance of encoding’s\n  //    decoder, ioQueue, output, and \"replacement\".\n\n  // 4. Return output.\n\n  const sliced = bytes.slice(slice);\n  return new TextDecoder(encoding).decode(sliced);\n}\n\n/**\n * @see https://encoding.spec.whatwg.org/#bom-sniff\n * @param {Uint8Array} ioQueue\n */\nfunction BOMSniffing(ioQueue) {\n  // 1. Let BOM be the result of peeking 3 bytes from ioQueue,\n  //    converted to a byte sequence.\n  const [a, b, c] = ioQueue;\n\n  // 2. For each of the rows in the table below, starting with\n  //    the first one and going down, if BOM starts with the\n  //    bytes given in the first column, then return the\n  //    encoding given in the cell in the second column of that\n  //    row. Otherwise, return null.\n  if (a === 0xEF && b === 0xBB && c === 0xBF) {\n    return 'UTF-8';\n  } else if (a === 0xFE && b === 0xFF) {\n    return 'UTF-16BE';\n  } else if (a === 0xFF && b === 0xFE) {\n    return 'UTF-16LE';\n  }\n  return null;\n}\n\n/**\n * @param {Uint8Array[]} sequences\n */\nfunction combineByteSequences(sequences) {\n  const size = sequences.reduce((a, b) => {\n    return a + b.byteLength;\n  }, 0);\n  let offset = 0;\n  return sequences.reduce((a, b) => {\n    a.set(b, offset);\n    offset += b.byteLength;\n    return a;\n  }, new Uint8Array(size));\n}\nmodule.exports = {\n  staticPropertyDescriptors,\n  readOperation,\n  fireAProgressEvent\n};","map":{"version":3,"names":["kState","kError","kResult","kAborted","kLastProgressEventFired","require","ProgressEvent","getEncoding","DOMException","serializeAMimeType","parseMIMEType","types","StringDecoder","btoa","staticPropertyDescriptors","enumerable","writable","configurable","readOperation","fr","blob","type","encodingName","stream","reader","getReader","bytes","chunkPromise","read","isFirstChunk","done","value","queueMicrotask","fireAProgressEvent","isUint8Array","push","undefined","Date","now","result","packageData","error","e","event","bubbles","cancelable","dispatchEvent","mimeType","dataURL","parsed","decoder","chunk","write","end","encoding","parameters","get","decode","sequence","combineByteSequences","buffer","binaryString","ioQueue","BOMEncoding","BOMSniffing","slice","sliced","TextDecoder","a","b","c","sequences","size","reduce","byteLength","offset","set","Uint8Array","module","exports"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/undici/lib/fileapi/util.js"],"sourcesContent":["'use strict'\n\nconst {\n  kState,\n  kError,\n  kResult,\n  kAborted,\n  kLastProgressEventFired\n} = require('./symbols')\nconst { ProgressEvent } = require('./progressevent')\nconst { getEncoding } = require('./encoding')\nconst { DOMException } = require('../fetch/constants')\nconst { serializeAMimeType, parseMIMEType } = require('../fetch/dataURL')\nconst { types } = require('util')\nconst { StringDecoder } = require('string_decoder')\nconst { btoa } = require('buffer')\n\n/** @type {PropertyDescriptor} */\nconst staticPropertyDescriptors = {\n  enumerable: true,\n  writable: false,\n  configurable: false\n}\n\n/**\n * @see https://w3c.github.io/FileAPI/#readOperation\n * @param {import('./filereader').FileReader} fr\n * @param {import('buffer').Blob} blob\n * @param {string} type\n * @param {string?} encodingName\n */\nfunction readOperation (fr, blob, type, encodingName) {\n  // 1. If fr’s state is \"loading\", throw an InvalidStateError\n  //    DOMException.\n  if (fr[kState] === 'loading') {\n    throw new DOMException('Invalid state', 'InvalidStateError')\n  }\n\n  // 2. Set fr’s state to \"loading\".\n  fr[kState] = 'loading'\n\n  // 3. Set fr’s result to null.\n  fr[kResult] = null\n\n  // 4. Set fr’s error to null.\n  fr[kError] = null\n\n  // 5. Let stream be the result of calling get stream on blob.\n  /** @type {import('stream/web').ReadableStream} */\n  const stream = blob.stream()\n\n  // 6. Let reader be the result of getting a reader from stream.\n  const reader = stream.getReader()\n\n  // 7. Let bytes be an empty byte sequence.\n  /** @type {Uint8Array[]} */\n  const bytes = []\n\n  // 8. Let chunkPromise be the result of reading a chunk from\n  //    stream with reader.\n  let chunkPromise = reader.read()\n\n  // 9. Let isFirstChunk be true.\n  let isFirstChunk = true\n\n  // 10. In parallel, while true:\n  // Note: \"In parallel\" just means non-blocking\n  // Note 2: readOperation itself cannot be async as double\n  // reading the body would then reject the promise, instead\n  // of throwing an error.\n  ;(async () => {\n    while (!fr[kAborted]) {\n      // 1. Wait for chunkPromise to be fulfilled or rejected.\n      try {\n        const { done, value } = await chunkPromise\n\n        // 2. If chunkPromise is fulfilled, and isFirstChunk is\n        //    true, queue a task to fire a progress event called\n        //    loadstart at fr.\n        if (isFirstChunk && !fr[kAborted]) {\n          queueMicrotask(() => {\n            fireAProgressEvent('loadstart', fr)\n          })\n        }\n\n        // 3. Set isFirstChunk to false.\n        isFirstChunk = false\n\n        // 4. If chunkPromise is fulfilled with an object whose\n        //    done property is false and whose value property is\n        //    a Uint8Array object, run these steps:\n        if (!done && types.isUint8Array(value)) {\n          // 1. Let bs be the byte sequence represented by the\n          //    Uint8Array object.\n\n          // 2. Append bs to bytes.\n          bytes.push(value)\n\n          // 3. If roughly 50ms have passed since these steps\n          //    were last invoked, queue a task to fire a\n          //    progress event called progress at fr.\n          if (\n            (\n              fr[kLastProgressEventFired] === undefined ||\n              Date.now() - fr[kLastProgressEventFired] >= 50\n            ) &&\n            !fr[kAborted]\n          ) {\n            fr[kLastProgressEventFired] = Date.now()\n            queueMicrotask(() => {\n              fireAProgressEvent('progress', fr)\n            })\n          }\n\n          // 4. Set chunkPromise to the result of reading a\n          //    chunk from stream with reader.\n          chunkPromise = reader.read()\n        } else if (done) {\n          // 5. Otherwise, if chunkPromise is fulfilled with an\n          //    object whose done property is true, queue a task\n          //    to run the following steps and abort this algorithm:\n          queueMicrotask(() => {\n            // 1. Set fr’s state to \"done\".\n            fr[kState] = 'done'\n\n            // 2. Let result be the result of package data given\n            //    bytes, type, blob’s type, and encodingName.\n            try {\n              const result = packageData(bytes, type, blob.type, encodingName)\n\n              // 4. Else:\n\n              if (fr[kAborted]) {\n                return\n              }\n\n              // 1. Set fr’s result to result.\n              fr[kResult] = result\n\n              // 2. Fire a progress event called load at the fr.\n              fireAProgressEvent('load', fr)\n            } catch (error) {\n              // 3. If package data threw an exception error:\n\n              // 1. Set fr’s error to error.\n              fr[kError] = error\n\n              // 2. Fire a progress event called error at fr.\n              fireAProgressEvent('error', fr)\n            }\n\n            // 5. If fr’s state is not \"loading\", fire a progress\n            //    event called loadend at the fr.\n            if (fr[kState] !== 'loading') {\n              fireAProgressEvent('loadend', fr)\n            }\n          })\n\n          break\n        }\n      } catch (error) {\n        if (fr[kAborted]) {\n          return\n        }\n\n        // 6. Otherwise, if chunkPromise is rejected with an\n        //    error error, queue a task to run the following\n        //    steps and abort this algorithm:\n        queueMicrotask(() => {\n          // 1. Set fr’s state to \"done\".\n          fr[kState] = 'done'\n\n          // 2. Set fr’s error to error.\n          fr[kError] = error\n\n          // 3. Fire a progress event called error at fr.\n          fireAProgressEvent('error', fr)\n\n          // 4. If fr’s state is not \"loading\", fire a progress\n          //    event called loadend at fr.\n          if (fr[kState] !== 'loading') {\n            fireAProgressEvent('loadend', fr)\n          }\n        })\n\n        break\n      }\n    }\n  })()\n}\n\n/**\n * @see https://w3c.github.io/FileAPI/#fire-a-progress-event\n * @see https://dom.spec.whatwg.org/#concept-event-fire\n * @param {string} e The name of the event\n * @param {import('./filereader').FileReader} reader\n */\nfunction fireAProgressEvent (e, reader) {\n  // The progress event e does not bubble. e.bubbles must be false\n  // The progress event e is NOT cancelable. e.cancelable must be false\n  const event = new ProgressEvent(e, {\n    bubbles: false,\n    cancelable: false\n  })\n\n  reader.dispatchEvent(event)\n}\n\n/**\n * @see https://w3c.github.io/FileAPI/#blob-package-data\n * @param {Uint8Array[]} bytes\n * @param {string} type\n * @param {string?} mimeType\n * @param {string?} encodingName\n */\nfunction packageData (bytes, type, mimeType, encodingName) {\n  // 1. A Blob has an associated package data algorithm, given\n  //    bytes, a type, a optional mimeType, and a optional\n  //    encodingName, which switches on type and runs the\n  //    associated steps:\n\n  switch (type) {\n    case 'DataURL': {\n      // 1. Return bytes as a DataURL [RFC2397] subject to\n      //    the considerations below:\n      //  * Use mimeType as part of the Data URL if it is\n      //    available in keeping with the Data URL\n      //    specification [RFC2397].\n      //  * If mimeType is not available return a Data URL\n      //    without a media-type. [RFC2397].\n\n      // https://datatracker.ietf.org/doc/html/rfc2397#section-3\n      // dataurl    := \"data:\" [ mediatype ] [ \";base64\" ] \",\" data\n      // mediatype  := [ type \"/\" subtype ] *( \";\" parameter )\n      // data       := *urlchar\n      // parameter  := attribute \"=\" value\n      let dataURL = 'data:'\n\n      const parsed = parseMIMEType(mimeType || 'application/octet-stream')\n\n      if (parsed !== 'failure') {\n        dataURL += serializeAMimeType(parsed)\n      }\n\n      dataURL += ';base64,'\n\n      const decoder = new StringDecoder('latin1')\n\n      for (const chunk of bytes) {\n        dataURL += btoa(decoder.write(chunk))\n      }\n\n      dataURL += btoa(decoder.end())\n\n      return dataURL\n    }\n    case 'Text': {\n      // 1. Let encoding be failure\n      let encoding = 'failure'\n\n      // 2. If the encodingName is present, set encoding to the\n      //    result of getting an encoding from encodingName.\n      if (encodingName) {\n        encoding = getEncoding(encodingName)\n      }\n\n      // 3. If encoding is failure, and mimeType is present:\n      if (encoding === 'failure' && mimeType) {\n        // 1. Let type be the result of parse a MIME type\n        //    given mimeType.\n        const type = parseMIMEType(mimeType)\n\n        // 2. If type is not failure, set encoding to the result\n        //    of getting an encoding from type’s parameters[\"charset\"].\n        if (type !== 'failure') {\n          encoding = getEncoding(type.parameters.get('charset'))\n        }\n      }\n\n      // 4. If encoding is failure, then set encoding to UTF-8.\n      if (encoding === 'failure') {\n        encoding = 'UTF-8'\n      }\n\n      // 5. Decode bytes using fallback encoding encoding, and\n      //    return the result.\n      return decode(bytes, encoding)\n    }\n    case 'ArrayBuffer': {\n      // Return a new ArrayBuffer whose contents are bytes.\n      const sequence = combineByteSequences(bytes)\n\n      return sequence.buffer\n    }\n    case 'BinaryString': {\n      // Return bytes as a binary string, in which every byte\n      //  is represented by a code unit of equal value [0..255].\n      let binaryString = ''\n\n      const decoder = new StringDecoder('latin1')\n\n      for (const chunk of bytes) {\n        binaryString += decoder.write(chunk)\n      }\n\n      binaryString += decoder.end()\n\n      return binaryString\n    }\n  }\n}\n\n/**\n * @see https://encoding.spec.whatwg.org/#decode\n * @param {Uint8Array[]} ioQueue\n * @param {string} encoding\n */\nfunction decode (ioQueue, encoding) {\n  const bytes = combineByteSequences(ioQueue)\n\n  // 1. Let BOMEncoding be the result of BOM sniffing ioQueue.\n  const BOMEncoding = BOMSniffing(bytes)\n\n  let slice = 0\n\n  // 2. If BOMEncoding is non-null:\n  if (BOMEncoding !== null) {\n    // 1. Set encoding to BOMEncoding.\n    encoding = BOMEncoding\n\n    // 2. Read three bytes from ioQueue, if BOMEncoding is\n    //    UTF-8; otherwise read two bytes.\n    //    (Do nothing with those bytes.)\n    slice = BOMEncoding === 'UTF-8' ? 3 : 2\n  }\n\n  // 3. Process a queue with an instance of encoding’s\n  //    decoder, ioQueue, output, and \"replacement\".\n\n  // 4. Return output.\n\n  const sliced = bytes.slice(slice)\n  return new TextDecoder(encoding).decode(sliced)\n}\n\n/**\n * @see https://encoding.spec.whatwg.org/#bom-sniff\n * @param {Uint8Array} ioQueue\n */\nfunction BOMSniffing (ioQueue) {\n  // 1. Let BOM be the result of peeking 3 bytes from ioQueue,\n  //    converted to a byte sequence.\n  const [a, b, c] = ioQueue\n\n  // 2. For each of the rows in the table below, starting with\n  //    the first one and going down, if BOM starts with the\n  //    bytes given in the first column, then return the\n  //    encoding given in the cell in the second column of that\n  //    row. Otherwise, return null.\n  if (a === 0xEF && b === 0xBB && c === 0xBF) {\n    return 'UTF-8'\n  } else if (a === 0xFE && b === 0xFF) {\n    return 'UTF-16BE'\n  } else if (a === 0xFF && b === 0xFE) {\n    return 'UTF-16LE'\n  }\n\n  return null\n}\n\n/**\n * @param {Uint8Array[]} sequences\n */\nfunction combineByteSequences (sequences) {\n  const size = sequences.reduce((a, b) => {\n    return a + b.byteLength\n  }, 0)\n\n  let offset = 0\n\n  return sequences.reduce((a, b) => {\n    a.set(b, offset)\n    offset += b.byteLength\n    return a\n  }, new Uint8Array(size))\n}\n\nmodule.exports = {\n  staticPropertyDescriptors,\n  readOperation,\n  fireAProgressEvent\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}