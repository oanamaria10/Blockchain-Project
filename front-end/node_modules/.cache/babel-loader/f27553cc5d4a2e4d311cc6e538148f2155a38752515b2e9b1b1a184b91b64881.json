{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArgumentsParser = void 0;\nconst task_names_1 = require(\"../../builtin-tasks/task-names\");\nconst errors_1 = require(\"../core/errors\");\nconst errors_list_1 = require(\"../core/errors-list\");\nclass ArgumentsParser {\n  static paramNameToCLA(paramName) {\n    return ArgumentsParser.PARAM_PREFIX + paramName.split(/(?=[A-Z])/g).map(s => s.toLowerCase()).join(\"-\");\n  }\n  static cLAToParamName(cLA) {\n    if (cLA.toLowerCase() !== cLA) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.PARAM_NAME_INVALID_CASING, {\n        param: cLA\n      });\n    }\n    const parts = cLA.slice(ArgumentsParser.PARAM_PREFIX.length).split(\"-\").filter(x => x.length > 0);\n    return parts[0] + parts.slice(1).map(s => s[0].toUpperCase() + s.slice(1)).join(\"\");\n  }\n  parseHardhatArguments(hardhatParamDefinitions, envVariableArguments, rawCLAs) {\n    const hardhatArguments = {};\n    let scopeOrTaskName;\n    const allUnparsedCLAs = [];\n    for (let i = 0; i < rawCLAs.length; i++) {\n      const arg = rawCLAs[i];\n      if (scopeOrTaskName === undefined) {\n        if (!this._hasCLAParamNameFormat(arg)) {\n          scopeOrTaskName = arg;\n          allUnparsedCLAs.push(arg);\n          continue;\n        }\n        if (!this._isCLAParamName(arg, hardhatParamDefinitions)) {\n          throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_COMMAND_LINE_ARG, {\n            argument: arg\n          });\n        }\n        i = this._parseArgumentAt(rawCLAs, i, hardhatParamDefinitions, hardhatArguments, scopeOrTaskName);\n      } else {\n        if (!this._isCLAParamName(arg, hardhatParamDefinitions)) {\n          allUnparsedCLAs.push(arg);\n          continue;\n        }\n        i = this._parseArgumentAt(rawCLAs, i, hardhatParamDefinitions, hardhatArguments, scopeOrTaskName);\n      }\n    }\n    return {\n      hardhatArguments: this._addHardhatDefaultArguments(hardhatParamDefinitions, envVariableArguments, hardhatArguments),\n      scopeOrTaskName,\n      allUnparsedCLAs\n    };\n  }\n  parseScopeAndTaskNames(allUnparsedCLAs, taskDefinitions, scopeDefinitions) {\n    const [firstCLA, secondCLA] = allUnparsedCLAs;\n    if (allUnparsedCLAs.length === 0) {\n      return {\n        taskName: task_names_1.TASK_HELP,\n        unparsedCLAs: []\n      };\n    } else if (allUnparsedCLAs.length === 1) {\n      if (scopeDefinitions[firstCLA] !== undefined) {\n        // this is a bit of a hack, but it's the easiest way to print\n        // the help of a scope when no task is specified\n        return {\n          taskName: task_names_1.TASK_HELP,\n          unparsedCLAs: [firstCLA]\n        };\n      } else if (taskDefinitions[firstCLA] !== undefined) {\n        return {\n          taskName: firstCLA,\n          unparsedCLAs: allUnparsedCLAs.slice(1)\n        };\n      } else {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_TASK, {\n          task: firstCLA\n        });\n      }\n    } else {\n      const scopeDefinition = scopeDefinitions[firstCLA];\n      if (scopeDefinition !== undefined) {\n        if (scopeDefinition.tasks[secondCLA] !== undefined) {\n          return {\n            scopeName: firstCLA,\n            taskName: secondCLA,\n            unparsedCLAs: allUnparsedCLAs.slice(2)\n          };\n        } else {\n          throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_SCOPED_TASK, {\n            scope: firstCLA,\n            task: secondCLA\n          });\n        }\n      } else if (taskDefinitions[firstCLA] !== undefined) {\n        return {\n          taskName: firstCLA,\n          unparsedCLAs: allUnparsedCLAs.slice(1)\n        };\n      } else {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_TASK, {\n          task: firstCLA\n        });\n      }\n    }\n  }\n  parseTaskArguments(taskDefinition, rawCLAs) {\n    const {\n      paramArguments,\n      rawPositionalArguments\n    } = this._parseTaskParamArguments(taskDefinition, rawCLAs);\n    const positionalArguments = this._parsePositionalParamArgs(rawPositionalArguments, taskDefinition.positionalParamDefinitions);\n    return {\n      ...paramArguments,\n      ...positionalArguments\n    };\n  }\n  _parseTaskParamArguments(taskDefinition, rawCLAs) {\n    const paramArguments = {};\n    const rawPositionalArguments = [];\n    for (let i = 0; i < rawCLAs.length; i++) {\n      const arg = rawCLAs[i];\n      if (!this._hasCLAParamNameFormat(arg)) {\n        rawPositionalArguments.push(arg);\n        continue;\n      }\n      if (!this._isCLAParamName(arg, taskDefinition.paramDefinitions)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_PARAM_NAME, {\n          param: arg\n        });\n      }\n      i = this._parseArgumentAt(rawCLAs, i, taskDefinition.paramDefinitions, paramArguments, taskDefinition.name);\n    }\n    this._addTaskDefaultArguments(taskDefinition, paramArguments);\n    return {\n      paramArguments,\n      rawPositionalArguments\n    };\n  }\n  _addHardhatDefaultArguments(hardhatParamDefinitions, envVariableArguments, hardhatArguments) {\n    return {\n      ...envVariableArguments,\n      ...hardhatArguments\n    };\n  }\n  _addTaskDefaultArguments(taskDefinition, taskArguments) {\n    for (const paramName of Object.keys(taskDefinition.paramDefinitions)) {\n      const definition = taskDefinition.paramDefinitions[paramName];\n      if (taskArguments[paramName] !== undefined) {\n        continue;\n      }\n      if (!definition.isOptional) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n          param: ArgumentsParser.paramNameToCLA(paramName),\n          task: taskDefinition.name\n        });\n      }\n      taskArguments[paramName] = definition.defaultValue;\n    }\n  }\n  _isCLAParamName(str, paramDefinitions) {\n    if (!this._hasCLAParamNameFormat(str)) {\n      return false;\n    }\n    const name = ArgumentsParser.cLAToParamName(str);\n    return paramDefinitions[name] !== undefined;\n  }\n  _hasCLAParamNameFormat(str) {\n    return str.startsWith(ArgumentsParser.PARAM_PREFIX);\n  }\n  _parseArgumentAt(rawCLAs, index, paramDefinitions, parsedArguments, scopeOrTaskName) {\n    const claArg = rawCLAs[index];\n    const paramName = ArgumentsParser.cLAToParamName(claArg);\n    const definition = paramDefinitions[paramName];\n    if (parsedArguments[paramName] !== undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.REPEATED_PARAM, {\n        param: claArg\n      });\n    }\n    if (definition.isFlag) {\n      parsedArguments[paramName] = true;\n    } else {\n      index++;\n      const value = rawCLAs[index];\n      if (value === undefined) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n          param: ArgumentsParser.paramNameToCLA(paramName),\n          task: scopeOrTaskName ?? \"help\"\n        });\n      }\n      // We only parse the arguments of non-subtasks, and those only\n      // accept CLIArgumentTypes.\n      const type = definition.type;\n      parsedArguments[paramName] = type.parse(paramName, value);\n    }\n    return index;\n  }\n  _parsePositionalParamArgs(rawPositionalParamArgs, positionalParamDefinitions) {\n    const args = {};\n    for (let i = 0; i < positionalParamDefinitions.length; i++) {\n      const definition = positionalParamDefinitions[i];\n      // We only parse the arguments of non-subtasks, and those only\n      // accept CLIArgumentTypes.\n      const type = definition.type;\n      const rawArg = rawPositionalParamArgs[i];\n      if (rawArg === undefined) {\n        if (!definition.isOptional) {\n          throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.MISSING_POSITIONAL_ARG, {\n            param: definition.name\n          });\n        }\n        args[definition.name] = definition.defaultValue;\n      } else if (!definition.isVariadic) {\n        args[definition.name] = type.parse(definition.name, rawArg);\n      } else {\n        args[definition.name] = rawPositionalParamArgs.slice(i).map(raw => type.parse(definition.name, raw));\n      }\n    }\n    const lastDefinition = positionalParamDefinitions[positionalParamDefinitions.length - 1];\n    const hasVariadicParam = lastDefinition !== undefined && lastDefinition.isVariadic;\n    if (!hasVariadicParam && rawPositionalParamArgs.length > positionalParamDefinitions.length) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_POSITIONAL_ARG, {\n        argument: rawPositionalParamArgs[positionalParamDefinitions.length]\n      });\n    }\n    return args;\n  }\n}\nArgumentsParser.PARAM_PREFIX = \"--\";\nexports.ArgumentsParser = ArgumentsParser;","map":{"version":3,"names":["task_names_1","require","errors_1","errors_list_1","ArgumentsParser","paramNameToCLA","paramName","PARAM_PREFIX","split","map","s","toLowerCase","join","cLAToParamName","cLA","HardhatError","ERRORS","ARGUMENTS","PARAM_NAME_INVALID_CASING","param","parts","slice","length","filter","x","toUpperCase","parseHardhatArguments","hardhatParamDefinitions","envVariableArguments","rawCLAs","hardhatArguments","scopeOrTaskName","allUnparsedCLAs","i","arg","undefined","_hasCLAParamNameFormat","push","_isCLAParamName","UNRECOGNIZED_COMMAND_LINE_ARG","argument","_parseArgumentAt","_addHardhatDefaultArguments","parseScopeAndTaskNames","taskDefinitions","scopeDefinitions","firstCLA","secondCLA","taskName","TASK_HELP","unparsedCLAs","UNRECOGNIZED_TASK","task","scopeDefinition","tasks","scopeName","UNRECOGNIZED_SCOPED_TASK","scope","parseTaskArguments","taskDefinition","paramArguments","rawPositionalArguments","_parseTaskParamArguments","positionalArguments","_parsePositionalParamArgs","positionalParamDefinitions","paramDefinitions","UNRECOGNIZED_PARAM_NAME","name","_addTaskDefaultArguments","taskArguments","Object","keys","definition","isOptional","MISSING_TASK_ARGUMENT","defaultValue","str","startsWith","index","parsedArguments","claArg","REPEATED_PARAM","isFlag","value","type","parse","rawPositionalParamArgs","args","rawArg","MISSING_POSITIONAL_ARG","isVariadic","raw","lastDefinition","hasVariadicParam","UNRECOGNIZED_POSITIONAL_ARG","exports"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\internal\\cli\\ArgumentsParser.ts"],"sourcesContent":["import { TASK_HELP } from \"../../builtin-tasks/task-names\";\nimport {\n  CLIArgumentType,\n  HardhatArguments,\n  HardhatParamDefinitions,\n  ParamDefinition,\n  ParamDefinitionsMap,\n  ScopesMap,\n  TaskArguments,\n  TaskDefinition,\n  TasksMap,\n} from \"../../types\";\nimport { HardhatError } from \"../core/errors\";\nimport { ERRORS } from \"../core/errors-list\";\n\nexport class ArgumentsParser {\n  public static readonly PARAM_PREFIX = \"--\";\n\n  public static paramNameToCLA(paramName: string): string {\n    return (\n      ArgumentsParser.PARAM_PREFIX +\n      paramName\n        .split(/(?=[A-Z])/g)\n        .map((s) => s.toLowerCase())\n        .join(\"-\")\n    );\n  }\n\n  public static cLAToParamName(cLA: string): string {\n    if (cLA.toLowerCase() !== cLA) {\n      throw new HardhatError(ERRORS.ARGUMENTS.PARAM_NAME_INVALID_CASING, {\n        param: cLA,\n      });\n    }\n\n    const parts = cLA\n      .slice(ArgumentsParser.PARAM_PREFIX.length)\n      .split(\"-\")\n      .filter((x) => x.length > 0);\n\n    return (\n      parts[0] +\n      parts\n        .slice(1)\n        .map((s) => s[0].toUpperCase() + s.slice(1))\n        .join(\"\")\n    );\n  }\n\n  public parseHardhatArguments(\n    hardhatParamDefinitions: HardhatParamDefinitions,\n    envVariableArguments: HardhatArguments,\n    rawCLAs: string[]\n  ): {\n    hardhatArguments: HardhatArguments;\n    scopeOrTaskName: string | undefined;\n    allUnparsedCLAs: string[];\n  } {\n    const hardhatArguments: Partial<HardhatArguments> = {};\n    let scopeOrTaskName: string | undefined;\n    const allUnparsedCLAs: string[] = [];\n\n    for (let i = 0; i < rawCLAs.length; i++) {\n      const arg = rawCLAs[i];\n\n      if (scopeOrTaskName === undefined) {\n        if (!this._hasCLAParamNameFormat(arg)) {\n          scopeOrTaskName = arg;\n          allUnparsedCLAs.push(arg);\n          continue;\n        }\n\n        if (!this._isCLAParamName(arg, hardhatParamDefinitions)) {\n          throw new HardhatError(\n            ERRORS.ARGUMENTS.UNRECOGNIZED_COMMAND_LINE_ARG,\n            { argument: arg }\n          );\n        }\n\n        i = this._parseArgumentAt(\n          rawCLAs,\n          i,\n          hardhatParamDefinitions,\n          hardhatArguments,\n          scopeOrTaskName\n        );\n      } else {\n        if (!this._isCLAParamName(arg, hardhatParamDefinitions)) {\n          allUnparsedCLAs.push(arg);\n          continue;\n        }\n\n        i = this._parseArgumentAt(\n          rawCLAs,\n          i,\n          hardhatParamDefinitions,\n          hardhatArguments,\n          scopeOrTaskName\n        );\n      }\n    }\n\n    return {\n      hardhatArguments: this._addHardhatDefaultArguments(\n        hardhatParamDefinitions,\n        envVariableArguments,\n        hardhatArguments\n      ),\n      scopeOrTaskName,\n      allUnparsedCLAs,\n    };\n  }\n\n  public parseScopeAndTaskNames(\n    allUnparsedCLAs: string[],\n    taskDefinitions: TasksMap,\n    scopeDefinitions: ScopesMap\n  ): {\n    scopeName?: string;\n    taskName: string;\n    unparsedCLAs: string[];\n  } {\n    const [firstCLA, secondCLA] = allUnparsedCLAs;\n\n    if (allUnparsedCLAs.length === 0) {\n      return {\n        taskName: TASK_HELP,\n        unparsedCLAs: [],\n      };\n    } else if (allUnparsedCLAs.length === 1) {\n      if (scopeDefinitions[firstCLA] !== undefined) {\n        // this is a bit of a hack, but it's the easiest way to print\n        // the help of a scope when no task is specified\n        return {\n          taskName: TASK_HELP,\n          unparsedCLAs: [firstCLA],\n        };\n      } else if (taskDefinitions[firstCLA] !== undefined) {\n        return {\n          taskName: firstCLA,\n          unparsedCLAs: allUnparsedCLAs.slice(1),\n        };\n      } else {\n        throw new HardhatError(ERRORS.ARGUMENTS.UNRECOGNIZED_TASK, {\n          task: firstCLA,\n        });\n      }\n    } else {\n      const scopeDefinition = scopeDefinitions[firstCLA];\n      if (scopeDefinition !== undefined) {\n        if (scopeDefinition.tasks[secondCLA] !== undefined) {\n          return {\n            scopeName: firstCLA,\n            taskName: secondCLA,\n            unparsedCLAs: allUnparsedCLAs.slice(2),\n          };\n        } else {\n          throw new HardhatError(ERRORS.ARGUMENTS.UNRECOGNIZED_SCOPED_TASK, {\n            scope: firstCLA,\n            task: secondCLA,\n          });\n        }\n      } else if (taskDefinitions[firstCLA] !== undefined) {\n        return {\n          taskName: firstCLA,\n          unparsedCLAs: allUnparsedCLAs.slice(1),\n        };\n      } else {\n        throw new HardhatError(ERRORS.ARGUMENTS.UNRECOGNIZED_TASK, {\n          task: firstCLA,\n        });\n      }\n    }\n  }\n\n  public parseTaskArguments(\n    taskDefinition: TaskDefinition,\n    rawCLAs: string[]\n  ): TaskArguments {\n    const { paramArguments, rawPositionalArguments } =\n      this._parseTaskParamArguments(taskDefinition, rawCLAs);\n\n    const positionalArguments = this._parsePositionalParamArgs(\n      rawPositionalArguments,\n      taskDefinition.positionalParamDefinitions\n    );\n\n    return { ...paramArguments, ...positionalArguments };\n  }\n\n  private _parseTaskParamArguments(\n    taskDefinition: TaskDefinition,\n    rawCLAs: string[]\n  ) {\n    const paramArguments = {};\n    const rawPositionalArguments: string[] = [];\n\n    for (let i = 0; i < rawCLAs.length; i++) {\n      const arg = rawCLAs[i];\n\n      if (!this._hasCLAParamNameFormat(arg)) {\n        rawPositionalArguments.push(arg);\n        continue;\n      }\n\n      if (!this._isCLAParamName(arg, taskDefinition.paramDefinitions)) {\n        throw new HardhatError(ERRORS.ARGUMENTS.UNRECOGNIZED_PARAM_NAME, {\n          param: arg,\n        });\n      }\n\n      i = this._parseArgumentAt(\n        rawCLAs,\n        i,\n        taskDefinition.paramDefinitions,\n        paramArguments,\n        taskDefinition.name\n      );\n    }\n\n    this._addTaskDefaultArguments(taskDefinition, paramArguments);\n\n    return { paramArguments, rawPositionalArguments };\n  }\n\n  private _addHardhatDefaultArguments(\n    hardhatParamDefinitions: HardhatParamDefinitions,\n    envVariableArguments: HardhatArguments,\n    hardhatArguments: Partial<HardhatArguments>\n  ): HardhatArguments {\n    return {\n      ...envVariableArguments,\n      ...hardhatArguments,\n    };\n  }\n\n  private _addTaskDefaultArguments(\n    taskDefinition: TaskDefinition,\n    taskArguments: TaskArguments\n  ) {\n    for (const paramName of Object.keys(taskDefinition.paramDefinitions)) {\n      const definition = taskDefinition.paramDefinitions[paramName];\n\n      if (taskArguments[paramName] !== undefined) {\n        continue;\n      }\n      if (!definition.isOptional) {\n        throw new HardhatError(ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n          param: ArgumentsParser.paramNameToCLA(paramName),\n          task: taskDefinition.name,\n        });\n      }\n\n      taskArguments[paramName] = definition.defaultValue;\n    }\n  }\n\n  private _isCLAParamName(str: string, paramDefinitions: ParamDefinitionsMap) {\n    if (!this._hasCLAParamNameFormat(str)) {\n      return false;\n    }\n\n    const name = ArgumentsParser.cLAToParamName(str);\n    return paramDefinitions[name] !== undefined;\n  }\n\n  private _hasCLAParamNameFormat(str: string) {\n    return str.startsWith(ArgumentsParser.PARAM_PREFIX);\n  }\n\n  private _parseArgumentAt(\n    rawCLAs: string[],\n    index: number,\n    paramDefinitions: ParamDefinitionsMap,\n    parsedArguments: TaskArguments,\n    scopeOrTaskName?: string\n  ) {\n    const claArg = rawCLAs[index];\n    const paramName = ArgumentsParser.cLAToParamName(claArg);\n    const definition = paramDefinitions[paramName];\n\n    if (parsedArguments[paramName] !== undefined) {\n      throw new HardhatError(ERRORS.ARGUMENTS.REPEATED_PARAM, {\n        param: claArg,\n      });\n    }\n\n    if (definition.isFlag) {\n      parsedArguments[paramName] = true;\n    } else {\n      index++;\n      const value = rawCLAs[index];\n\n      if (value === undefined) {\n        throw new HardhatError(ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n          param: ArgumentsParser.paramNameToCLA(paramName),\n          task: scopeOrTaskName ?? \"help\",\n        });\n      }\n\n      // We only parse the arguments of non-subtasks, and those only\n      // accept CLIArgumentTypes.\n      const type = definition.type as CLIArgumentType<any>;\n      parsedArguments[paramName] = type.parse(paramName, value);\n    }\n\n    return index;\n  }\n\n  private _parsePositionalParamArgs(\n    rawPositionalParamArgs: string[],\n    positionalParamDefinitions: Array<ParamDefinition<any>>\n  ): TaskArguments {\n    const args: TaskArguments = {};\n\n    for (let i = 0; i < positionalParamDefinitions.length; i++) {\n      const definition = positionalParamDefinitions[i];\n      // We only parse the arguments of non-subtasks, and those only\n      // accept CLIArgumentTypes.\n      const type = definition.type as CLIArgumentType<any>;\n\n      const rawArg = rawPositionalParamArgs[i];\n\n      if (rawArg === undefined) {\n        if (!definition.isOptional) {\n          throw new HardhatError(ERRORS.ARGUMENTS.MISSING_POSITIONAL_ARG, {\n            param: definition.name,\n          });\n        }\n\n        args[definition.name] = definition.defaultValue;\n      } else if (!definition.isVariadic) {\n        args[definition.name] = type.parse(definition.name, rawArg);\n      } else {\n        args[definition.name] = rawPositionalParamArgs\n          .slice(i)\n          .map((raw) => type.parse(definition.name, raw));\n      }\n    }\n\n    const lastDefinition =\n      positionalParamDefinitions[positionalParamDefinitions.length - 1];\n\n    const hasVariadicParam =\n      lastDefinition !== undefined && lastDefinition.isVariadic;\n\n    if (\n      !hasVariadicParam &&\n      rawPositionalParamArgs.length > positionalParamDefinitions.length\n    ) {\n      throw new HardhatError(ERRORS.ARGUMENTS.UNRECOGNIZED_POSITIONAL_ARG, {\n        argument: rawPositionalParamArgs[positionalParamDefinitions.length],\n      });\n    }\n\n    return args;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}