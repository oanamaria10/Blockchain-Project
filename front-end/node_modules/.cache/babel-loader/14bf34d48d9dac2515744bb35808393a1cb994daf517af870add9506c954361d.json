{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createModelsAndDecodeBytecodes = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst library_utils_1 = require(\"./library-utils\");\nconst model_1 = require(\"./model\");\nconst source_maps_1 = require(\"./source-maps\");\nconst abi = require(\"ethereumjs-abi\");\nconst log = (0, debug_1.default)(\"hardhat:core:hardhat-network:compiler-to-model\");\nfunction createModelsAndDecodeBytecodes(solcVersion, compilerInput, compilerOutput) {\n  const fileIdToSourceFile = new Map();\n  const contractIdToContract = new Map();\n  createSourcesModelFromAst(compilerOutput, compilerInput, fileIdToSourceFile, contractIdToContract);\n  const bytecodes = decodeBytecodes(solcVersion, compilerOutput, fileIdToSourceFile, contractIdToContract);\n  correctSelectors(bytecodes, compilerOutput);\n  return bytecodes;\n}\nexports.createModelsAndDecodeBytecodes = createModelsAndDecodeBytecodes;\nfunction createSourcesModelFromAst(compilerOutput, compilerInput, fileIdToSourceFile, contractIdToContract) {\n  const contractIdToLinearizedBaseContractIds = new Map();\n  // Create a `sourceName => contract => abi` mapping\n  const sourceNameToContractToAbi = new Map();\n  for (const [sourceName, contracts] of Object.entries(compilerOutput.contracts)) {\n    const contractToAbi = new Map();\n    sourceNameToContractToAbi.set(sourceName, contractToAbi);\n    for (const [contractName, contract] of Object.entries(contracts)) {\n      contractToAbi.set(contractName, contract.abi);\n    }\n  }\n  for (const [sourceName, source] of Object.entries(compilerOutput.sources)) {\n    const contractToAbi = sourceNameToContractToAbi.get(sourceName);\n    const file = new model_1.SourceFile(sourceName, compilerInput.sources[sourceName].content);\n    fileIdToSourceFile.set(source.id, file);\n    for (const node of source.ast.nodes) {\n      if (node.nodeType === \"ContractDefinition\") {\n        const contractType = contractKindToContractType(node.contractKind);\n        if (contractType === undefined) {\n          continue;\n        }\n        const contractAbi = contractToAbi?.get(node.name);\n        processContractAstNode(file, node, fileIdToSourceFile, contractType, contractIdToContract, contractIdToLinearizedBaseContractIds, contractAbi);\n      }\n      // top-level functions\n      if (node.nodeType === \"FunctionDefinition\") {\n        processFunctionDefinitionAstNode(node, fileIdToSourceFile, undefined, file);\n      }\n    }\n  }\n  applyContractsInheritance(contractIdToContract, contractIdToLinearizedBaseContractIds);\n}\nfunction processContractAstNode(file, contractNode, fileIdToSourceFile, contractType, contractIdToContract, contractIdToLinearizedBaseContractIds, contractAbi) {\n  const contractLocation = astSrcToSourceLocation(contractNode.src, fileIdToSourceFile);\n  const contract = new model_1.Contract(contractNode.name, contractType, contractLocation);\n  contractIdToContract.set(contractNode.id, contract);\n  contractIdToLinearizedBaseContractIds.set(contractNode.id, contractNode.linearizedBaseContracts);\n  file.addContract(contract);\n  for (const node of contractNode.nodes) {\n    if (node.nodeType === \"FunctionDefinition\") {\n      const functionAbis = contractAbi?.filter(abiEntry => abiEntry.name === node.name);\n      processFunctionDefinitionAstNode(node, fileIdToSourceFile, contract, file, functionAbis);\n    } else if (node.nodeType === \"ModifierDefinition\") {\n      processModifierDefinitionAstNode(node, fileIdToSourceFile, contract, file);\n    } else if (node.nodeType === \"VariableDeclaration\") {\n      const getterAbi = contractAbi?.find(abiEntry => abiEntry.name === node.name);\n      processVariableDeclarationAstNode(node, fileIdToSourceFile, contract, file, getterAbi);\n    }\n  }\n}\nfunction processFunctionDefinitionAstNode(functionDefinitionNode, fileIdToSourceFile, contract, file, functionAbis) {\n  if (functionDefinitionNode.implemented === false) {\n    return;\n  }\n  const functionType = functionDefinitionKindToFunctionType(functionDefinitionNode.kind);\n  const functionLocation = astSrcToSourceLocation(functionDefinitionNode.src, fileIdToSourceFile);\n  const visibility = astVisibilityToVisibility(functionDefinitionNode.visibility);\n  let selector;\n  if (functionType === model_1.ContractFunctionType.FUNCTION && (visibility === model_1.ContractFunctionVisibility.EXTERNAL || visibility === model_1.ContractFunctionVisibility.PUBLIC)) {\n    selector = astFunctionDefinitionToSelector(functionDefinitionNode);\n  }\n  // function can be overloaded, match the abi by the selector\n  const matchingFunctionAbi = functionAbis?.find(functionAbi => {\n    if (functionAbi.name === undefined) {\n      return false;\n    }\n    const functionAbiSelector = abi.methodID(functionAbi.name, functionAbi.inputs?.map(input => input.type) ?? []);\n    if (selector === undefined || functionAbiSelector === undefined) {\n      return false;\n    }\n    return selector.equals(functionAbiSelector);\n  });\n  const paramTypes = matchingFunctionAbi?.inputs?.map(input => input.type);\n  const cf = new model_1.ContractFunction(functionDefinitionNode.name, functionType, functionLocation, contract, visibility, functionDefinitionNode.stateMutability === \"payable\", selector, paramTypes);\n  if (contract !== undefined) {\n    contract.addLocalFunction(cf);\n  }\n  file.addFunction(cf);\n}\nfunction processModifierDefinitionAstNode(modifierDefinitionNode, fileIdToSourceFile, contract, file) {\n  const functionLocation = astSrcToSourceLocation(modifierDefinitionNode.src, fileIdToSourceFile);\n  const cf = new model_1.ContractFunction(modifierDefinitionNode.name, model_1.ContractFunctionType.MODIFIER, functionLocation, contract);\n  contract.addLocalFunction(cf);\n  file.addFunction(cf);\n}\nfunction canonicalAbiTypeForElementaryOrUserDefinedTypes(keyType) {\n  if (isElementaryType(keyType)) {\n    return toCanonicalAbiType(keyType.name);\n  }\n  if (isEnumType(keyType)) {\n    return \"uint256\";\n  }\n  if (isContractType(keyType)) {\n    return \"address\";\n  }\n  return undefined;\n}\nfunction getPublicVariableSelectorFromDeclarationAstNode(variableDeclaration) {\n  if (variableDeclaration.functionSelector !== undefined) {\n    return Buffer.from(variableDeclaration.functionSelector, \"hex\");\n  }\n  const paramTypes = [];\n  // VariableDeclaration nodes for function parameters or state variables will always\n  // have their typeName fields defined.\n  let nextType = variableDeclaration.typeName;\n  while (true) {\n    if (nextType.nodeType === \"Mapping\") {\n      const canonicalType = canonicalAbiTypeForElementaryOrUserDefinedTypes(nextType.keyType);\n      paramTypes.push(canonicalType);\n      nextType = nextType.valueType;\n    } else {\n      if (nextType.nodeType === \"ArrayTypeName\") {\n        paramTypes.push(\"uint256\");\n      }\n      break;\n    }\n  }\n  return abi.methodID(variableDeclaration.name, paramTypes);\n}\nfunction processVariableDeclarationAstNode(variableDeclarationNode, fileIdToSourceFile, contract, file, getterAbi) {\n  const visibility = astVisibilityToVisibility(variableDeclarationNode.visibility);\n  // Variables can't be external\n  if (visibility !== model_1.ContractFunctionVisibility.PUBLIC) {\n    return;\n  }\n  const functionLocation = astSrcToSourceLocation(variableDeclarationNode.src, fileIdToSourceFile);\n  const paramTypes = getterAbi?.inputs?.map(input => input.type);\n  const cf = new model_1.ContractFunction(variableDeclarationNode.name, model_1.ContractFunctionType.GETTER, functionLocation, contract, visibility, false,\n  // Getters aren't payable\n  getPublicVariableSelectorFromDeclarationAstNode(variableDeclarationNode), paramTypes);\n  contract.addLocalFunction(cf);\n  file.addFunction(cf);\n}\nfunction applyContractsInheritance(contractIdToContract, contractIdToLinearizedBaseContractIds) {\n  for (const [cid, contract] of contractIdToContract.entries()) {\n    const inheritanceIds = contractIdToLinearizedBaseContractIds.get(cid);\n    for (const baseId of inheritanceIds) {\n      const baseContract = contractIdToContract.get(baseId);\n      if (baseContract === undefined) {\n        // This list includes interface, which we don't model\n        continue;\n      }\n      contract.addNextLinearizedBaseContract(baseContract);\n    }\n  }\n}\nfunction decodeBytecodes(solcVersion, compilerOutput, fileIdToSourceFile, contractIdToContract) {\n  const bytecodes = [];\n  for (const contract of contractIdToContract.values()) {\n    const contractFile = contract.location.file.sourceName;\n    const contractEvmOutput = compilerOutput.contracts[contractFile][contract.name].evm;\n    const contractAbiOutput = compilerOutput.contracts[contractFile][contract.name].abi;\n    for (const abiItem of contractAbiOutput) {\n      if (abiItem.type === \"error\") {\n        const customError = model_1.CustomError.fromABI(abiItem.name, abiItem.inputs);\n        if (customError !== undefined) {\n          contract.addCustomError(customError);\n        } else {\n          log(`Couldn't build CustomError for error '${abiItem.name}'`);\n        }\n      }\n    }\n    // This is an abstract contract\n    if (contractEvmOutput.bytecode.object === \"\") {\n      continue;\n    }\n    const deploymentBytecode = decodeEvmBytecode(contract, solcVersion, true, contractEvmOutput.bytecode, fileIdToSourceFile);\n    const runtimeBytecode = decodeEvmBytecode(contract, solcVersion, false, contractEvmOutput.deployedBytecode, fileIdToSourceFile);\n    bytecodes.push(deploymentBytecode);\n    bytecodes.push(runtimeBytecode);\n  }\n  return bytecodes;\n}\nfunction decodeEvmBytecode(contract, solcVersion, isDeployment, compilerBytecode, fileIdToSourceFile) {\n  const libraryAddressPositions = (0, library_utils_1.getLibraryAddressPositions)(compilerBytecode);\n  const immutableReferences = compilerBytecode.immutableReferences !== undefined ? Object.values(compilerBytecode.immutableReferences).reduce((previousValue, currentValue) => [...previousValue, ...currentValue], []) : [];\n  const normalizedCode = (0, library_utils_1.normalizeCompilerOutputBytecode)(compilerBytecode.object, libraryAddressPositions);\n  const instructions = (0, source_maps_1.decodeInstructions)(normalizedCode, compilerBytecode.sourceMap, fileIdToSourceFile, isDeployment);\n  return new model_1.Bytecode(contract, isDeployment, normalizedCode, instructions, libraryAddressPositions, immutableReferences, solcVersion);\n}\nfunction astSrcToSourceLocation(src, fileIdToSourceFile) {\n  const [offset, length, fileId] = src.split(\":\").map(p => +p);\n  const file = fileIdToSourceFile.get(fileId);\n  if (file === undefined) {\n    return undefined;\n  }\n  return new model_1.SourceLocation(file, offset, length);\n}\nfunction contractKindToContractType(contractKind) {\n  if (contractKind === \"library\") {\n    return model_1.ContractType.LIBRARY;\n  }\n  if (contractKind === \"contract\") {\n    return model_1.ContractType.CONTRACT;\n  }\n  return undefined;\n}\nfunction astVisibilityToVisibility(visibility) {\n  if (visibility === \"private\") {\n    return model_1.ContractFunctionVisibility.PRIVATE;\n  }\n  if (visibility === \"internal\") {\n    return model_1.ContractFunctionVisibility.INTERNAL;\n  }\n  if (visibility === \"public\") {\n    return model_1.ContractFunctionVisibility.PUBLIC;\n  }\n  return model_1.ContractFunctionVisibility.EXTERNAL;\n}\nfunction functionDefinitionKindToFunctionType(kind) {\n  if (kind === \"constructor\") {\n    return model_1.ContractFunctionType.CONSTRUCTOR;\n  }\n  if (kind === \"fallback\") {\n    return model_1.ContractFunctionType.FALLBACK;\n  }\n  if (kind === \"receive\") {\n    return model_1.ContractFunctionType.RECEIVE;\n  }\n  if (kind === \"freeFunction\") {\n    return model_1.ContractFunctionType.FREE_FUNCTION;\n  }\n  return model_1.ContractFunctionType.FUNCTION;\n}\nfunction astFunctionDefinitionToSelector(functionDefinition) {\n  const paramTypes = [];\n  // The function selector is available in solc versions >=0.6.0\n  if (functionDefinition.functionSelector !== undefined) {\n    return Buffer.from(functionDefinition.functionSelector, \"hex\");\n  }\n  for (const param of functionDefinition.parameters.parameters) {\n    if (isContractType(param)) {\n      paramTypes.push(\"address\");\n      continue;\n    }\n    // TODO: implement ABIv2 structs parsing\n    // This might mean we need to parse struct definitions before\n    // resolving types and trying to calculate function selectors.\n    // if (isStructType(param)) {\n    //   paramTypes.push(something);\n    //   continue;\n    // }\n    if (isEnumType(param)) {\n      // TODO: If the enum has >= 256 elements this will fail. It should be a uint16. This is\n      //  complicated, as enums can be inherited. Fortunately, if multiple parent contracts\n      //  define the same enum, solc fails to compile.\n      paramTypes.push(\"uint8\");\n      continue;\n    }\n    // The rest of the function parameters always have their typeName node defined\n    const typename = param.typeName;\n    if (typename.nodeType === \"ArrayTypeName\" || typename.nodeType === \"FunctionTypeName\" || typename.nodeType === \"Mapping\") {\n      paramTypes.push(typename.typeDescriptions.typeString);\n      continue;\n    }\n    paramTypes.push(toCanonicalAbiType(typename.name));\n  }\n  return abi.methodID(functionDefinition.name, paramTypes);\n}\nfunction isContractType(param) {\n  return (param.typeName?.nodeType === \"UserDefinedTypeName\" || param?.nodeType === \"UserDefinedTypeName\") && param.typeDescriptions?.typeString !== undefined && param.typeDescriptions.typeString.startsWith(\"contract \");\n}\nfunction isEnumType(param) {\n  return (param.typeName?.nodeType === \"UserDefinedTypeName\" || param?.nodeType === \"UserDefinedTypeName\") && param.typeDescriptions?.typeString !== undefined && param.typeDescriptions.typeString.startsWith(\"enum \");\n}\nfunction isElementaryType(param) {\n  return param.type === \"ElementaryTypeName\" || param.nodeType === \"ElementaryTypeName\";\n}\nfunction toCanonicalAbiType(type) {\n  if (type.startsWith(\"int[\")) {\n    return `int256${type.slice(3)}`;\n  }\n  if (type === \"int\") {\n    return \"int256\";\n  }\n  if (type.startsWith(\"uint[\")) {\n    return `uint256${type.slice(4)}`;\n  }\n  if (type === \"uint\") {\n    return \"uint256\";\n  }\n  if (type.startsWith(\"fixed[\")) {\n    return `fixed128x128${type.slice(5)}`;\n  }\n  if (type === \"fixed\") {\n    return \"fixed128x128\";\n  }\n  if (type.startsWith(\"ufixed[\")) {\n    return `ufixed128x128${type.slice(6)}`;\n  }\n  if (type === \"ufixed\") {\n    return \"ufixed128x128\";\n  }\n  return type;\n}\nfunction correctSelectors(bytecodes, compilerOutput) {\n  for (const bytecode of bytecodes) {\n    if (bytecode.isDeployment) {\n      continue;\n    }\n    const contract = bytecode.contract;\n    const methodIdentifiers = compilerOutput.contracts[contract.location.file.sourceName][contract.name].evm.methodIdentifiers;\n    for (const [signature, hexSelector] of Object.entries(methodIdentifiers)) {\n      const functionName = signature.slice(0, signature.indexOf(\"(\"));\n      const selector = Buffer.from(hexSelector, \"hex\");\n      const contractFunction = contract.getFunctionFromSelector(selector);\n      if (contractFunction !== undefined) {\n        continue;\n      }\n      const fixedSelector = contract.correctSelector(functionName, selector);\n      if (!fixedSelector) {\n        // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n        throw new Error(`Failed to compute the selector one or more implementations of ${contract.name}#${functionName}. Hardhat Network can automatically fix this problem if you don't use function overloading.`);\n      }\n    }\n  }\n}","map":{"version":3,"names":["debug_1","__importDefault","require","library_utils_1","model_1","source_maps_1","abi","log","default","createModelsAndDecodeBytecodes","solcVersion","compilerInput","compilerOutput","fileIdToSourceFile","Map","contractIdToContract","createSourcesModelFromAst","bytecodes","decodeBytecodes","correctSelectors","exports","contractIdToLinearizedBaseContractIds","sourceNameToContractToAbi","sourceName","contracts","Object","entries","contractToAbi","set","contractName","contract","source","sources","get","file","SourceFile","content","id","node","ast","nodes","nodeType","contractType","contractKindToContractType","contractKind","undefined","contractAbi","name","processContractAstNode","processFunctionDefinitionAstNode","applyContractsInheritance","contractNode","contractLocation","astSrcToSourceLocation","src","Contract","linearizedBaseContracts","addContract","functionAbis","filter","abiEntry","processModifierDefinitionAstNode","getterAbi","find","processVariableDeclarationAstNode","functionDefinitionNode","implemented","functionType","functionDefinitionKindToFunctionType","kind","functionLocation","visibility","astVisibilityToVisibility","selector","ContractFunctionType","FUNCTION","ContractFunctionVisibility","EXTERNAL","PUBLIC","astFunctionDefinitionToSelector","matchingFunctionAbi","functionAbi","functionAbiSelector","methodID","inputs","map","input","type","equals","paramTypes","cf","ContractFunction","stateMutability","addLocalFunction","addFunction","modifierDefinitionNode","MODIFIER","canonicalAbiTypeForElementaryOrUserDefinedTypes","keyType","isElementaryType","toCanonicalAbiType","isEnumType","isContractType","getPublicVariableSelectorFromDeclarationAstNode","variableDeclaration","functionSelector","Buffer","from","nextType","typeName","canonicalType","push","valueType","variableDeclarationNode","GETTER","cid","inheritanceIds","baseId","baseContract","addNextLinearizedBaseContract","values","contractFile","location","contractEvmOutput","evm","contractAbiOutput","abiItem","customError","CustomError","fromABI","addCustomError","bytecode","object","deploymentBytecode","decodeEvmBytecode","runtimeBytecode","deployedBytecode","isDeployment","compilerBytecode","libraryAddressPositions","getLibraryAddressPositions","immutableReferences","reduce","previousValue","currentValue","normalizedCode","normalizeCompilerOutputBytecode","instructions","decodeInstructions","sourceMap","Bytecode","offset","length","fileId","split","p","SourceLocation","ContractType","LIBRARY","CONTRACT","PRIVATE","INTERNAL","CONSTRUCTOR","FALLBACK","RECEIVE","FREE_FUNCTION","functionDefinition","param","parameters","typename","typeDescriptions","typeString","startsWith","slice","methodIdentifiers","signature","hexSelector","functionName","indexOf","contractFunction","getFunctionFromSelector","fixedSelector","correctSelector","Error"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\internal\\hardhat-network\\stack-traces\\compiler-to-model.ts"],"sourcesContent":["import debug from \"debug\";\n\nimport {\n  CompilerInput,\n  CompilerOutput,\n  CompilerOutputBytecode,\n} from \"../../../types\";\n\nimport {\n  getLibraryAddressPositions,\n  normalizeCompilerOutputBytecode,\n} from \"./library-utils\";\nimport {\n  Bytecode,\n  Contract,\n  ContractFunction,\n  ContractFunctionType,\n  ContractFunctionVisibility,\n  ContractType,\n  CustomError,\n  SourceFile,\n  SourceLocation,\n} from \"./model\";\nimport { decodeInstructions } from \"./source-maps\";\n\nconst abi = require(\"ethereumjs-abi\");\n\nconst log = debug(\"hardhat:core:hardhat-network:compiler-to-model\");\n\ninterface ContractAbiEntry {\n  name?: string;\n  inputs?: Array<{\n    type: string;\n  }>;\n}\n\ntype ContractAbi = ContractAbiEntry[];\n\nexport function createModelsAndDecodeBytecodes(\n  solcVersion: string,\n  compilerInput: CompilerInput,\n  compilerOutput: CompilerOutput\n): Bytecode[] {\n  const fileIdToSourceFile = new Map<number, SourceFile>();\n  const contractIdToContract = new Map<number, Contract>();\n\n  createSourcesModelFromAst(\n    compilerOutput,\n    compilerInput,\n    fileIdToSourceFile,\n    contractIdToContract\n  );\n\n  const bytecodes = decodeBytecodes(\n    solcVersion,\n    compilerOutput,\n    fileIdToSourceFile,\n    contractIdToContract\n  );\n\n  correctSelectors(bytecodes, compilerOutput);\n\n  return bytecodes;\n}\n\nfunction createSourcesModelFromAst(\n  compilerOutput: CompilerOutput,\n  compilerInput: CompilerInput,\n  fileIdToSourceFile: Map<number, SourceFile>,\n  contractIdToContract: Map<number, Contract>\n) {\n  const contractIdToLinearizedBaseContractIds = new Map<number, number[]>();\n\n  // Create a `sourceName => contract => abi` mapping\n  const sourceNameToContractToAbi = new Map<string, Map<string, ContractAbi>>();\n  for (const [sourceName, contracts] of Object.entries(\n    compilerOutput.contracts\n  )) {\n    const contractToAbi = new Map<string, ContractAbi>();\n    sourceNameToContractToAbi.set(sourceName, contractToAbi);\n    for (const [contractName, contract] of Object.entries(contracts)) {\n      contractToAbi.set(contractName, contract.abi);\n    }\n  }\n\n  for (const [sourceName, source] of Object.entries(compilerOutput.sources)) {\n    const contractToAbi = sourceNameToContractToAbi.get(sourceName);\n    const file = new SourceFile(\n      sourceName,\n      compilerInput.sources[sourceName].content\n    );\n\n    fileIdToSourceFile.set(source.id, file);\n\n    for (const node of source.ast.nodes) {\n      if (node.nodeType === \"ContractDefinition\") {\n        const contractType = contractKindToContractType(node.contractKind);\n\n        if (contractType === undefined) {\n          continue;\n        }\n\n        const contractAbi = contractToAbi?.get(node.name);\n\n        processContractAstNode(\n          file,\n          node,\n          fileIdToSourceFile,\n          contractType,\n          contractIdToContract,\n          contractIdToLinearizedBaseContractIds,\n          contractAbi\n        );\n      }\n\n      // top-level functions\n      if (node.nodeType === \"FunctionDefinition\") {\n        processFunctionDefinitionAstNode(\n          node,\n          fileIdToSourceFile,\n          undefined,\n          file\n        );\n      }\n    }\n  }\n\n  applyContractsInheritance(\n    contractIdToContract,\n    contractIdToLinearizedBaseContractIds\n  );\n}\n\nfunction processContractAstNode(\n  file: SourceFile,\n  contractNode: any,\n  fileIdToSourceFile: Map<number, SourceFile>,\n  contractType: ContractType,\n  contractIdToContract: Map<number, Contract>,\n  contractIdToLinearizedBaseContractIds: Map<number, number[]>,\n  contractAbi?: ContractAbi\n) {\n  const contractLocation = astSrcToSourceLocation(\n    contractNode.src,\n    fileIdToSourceFile\n  )!;\n\n  const contract = new Contract(\n    contractNode.name,\n    contractType,\n    contractLocation\n  );\n\n  contractIdToContract.set(contractNode.id, contract);\n  contractIdToLinearizedBaseContractIds.set(\n    contractNode.id,\n    contractNode.linearizedBaseContracts\n  );\n\n  file.addContract(contract);\n\n  for (const node of contractNode.nodes) {\n    if (node.nodeType === \"FunctionDefinition\") {\n      const functionAbis = contractAbi?.filter(\n        (abiEntry) => abiEntry.name === node.name\n      );\n\n      processFunctionDefinitionAstNode(\n        node,\n        fileIdToSourceFile,\n        contract,\n        file,\n        functionAbis\n      );\n    } else if (node.nodeType === \"ModifierDefinition\") {\n      processModifierDefinitionAstNode(\n        node,\n        fileIdToSourceFile,\n        contract,\n        file\n      );\n    } else if (node.nodeType === \"VariableDeclaration\") {\n      const getterAbi = contractAbi?.find(\n        (abiEntry) => abiEntry.name === node.name\n      );\n      processVariableDeclarationAstNode(\n        node,\n        fileIdToSourceFile,\n        contract,\n        file,\n        getterAbi\n      );\n    }\n  }\n}\n\nfunction processFunctionDefinitionAstNode(\n  functionDefinitionNode: any,\n  fileIdToSourceFile: Map<number, SourceFile>,\n  contract: Contract | undefined,\n  file: SourceFile,\n  functionAbis?: ContractAbiEntry[]\n) {\n  if (functionDefinitionNode.implemented === false) {\n    return;\n  }\n\n  const functionType = functionDefinitionKindToFunctionType(\n    functionDefinitionNode.kind\n  );\n  const functionLocation = astSrcToSourceLocation(\n    functionDefinitionNode.src,\n    fileIdToSourceFile\n  )!;\n  const visibility = astVisibilityToVisibility(\n    functionDefinitionNode.visibility\n  );\n\n  let selector: Buffer | undefined;\n  if (\n    functionType === ContractFunctionType.FUNCTION &&\n    (visibility === ContractFunctionVisibility.EXTERNAL ||\n      visibility === ContractFunctionVisibility.PUBLIC)\n  ) {\n    selector = astFunctionDefinitionToSelector(functionDefinitionNode);\n  }\n\n  // function can be overloaded, match the abi by the selector\n  const matchingFunctionAbi = functionAbis?.find((functionAbi) => {\n    if (functionAbi.name === undefined) {\n      return false;\n    }\n\n    const functionAbiSelector = abi.methodID(\n      functionAbi.name,\n      functionAbi.inputs?.map((input) => input.type) ?? []\n    );\n\n    if (selector === undefined || functionAbiSelector === undefined) {\n      return false;\n    }\n\n    return selector.equals(functionAbiSelector);\n  });\n\n  const paramTypes = matchingFunctionAbi?.inputs?.map((input) => input.type);\n\n  const cf = new ContractFunction(\n    functionDefinitionNode.name,\n    functionType,\n    functionLocation,\n    contract,\n    visibility,\n    functionDefinitionNode.stateMutability === \"payable\",\n    selector,\n    paramTypes\n  );\n\n  if (contract !== undefined) {\n    contract.addLocalFunction(cf);\n  }\n\n  file.addFunction(cf);\n}\n\nfunction processModifierDefinitionAstNode(\n  modifierDefinitionNode: any,\n  fileIdToSourceFile: Map<number, SourceFile>,\n  contract: Contract,\n  file: SourceFile\n) {\n  const functionLocation = astSrcToSourceLocation(\n    modifierDefinitionNode.src,\n    fileIdToSourceFile\n  )!;\n\n  const cf = new ContractFunction(\n    modifierDefinitionNode.name,\n    ContractFunctionType.MODIFIER,\n    functionLocation,\n    contract\n  );\n\n  contract.addLocalFunction(cf);\n  file.addFunction(cf);\n}\n\nfunction canonicalAbiTypeForElementaryOrUserDefinedTypes(keyType: any): any {\n  if (isElementaryType(keyType)) {\n    return toCanonicalAbiType(keyType.name);\n  }\n\n  if (isEnumType(keyType)) {\n    return \"uint256\";\n  }\n\n  if (isContractType(keyType)) {\n    return \"address\";\n  }\n\n  return undefined;\n}\n\nfunction getPublicVariableSelectorFromDeclarationAstNode(\n  variableDeclaration: any\n) {\n  if (variableDeclaration.functionSelector !== undefined) {\n    return Buffer.from(variableDeclaration.functionSelector, \"hex\");\n  }\n\n  const paramTypes: string[] = [];\n\n  // VariableDeclaration nodes for function parameters or state variables will always\n  // have their typeName fields defined.\n  let nextType = variableDeclaration.typeName;\n  while (true) {\n    if (nextType.nodeType === \"Mapping\") {\n      const canonicalType = canonicalAbiTypeForElementaryOrUserDefinedTypes(\n        nextType.keyType\n      );\n      paramTypes.push(canonicalType);\n\n      nextType = nextType.valueType;\n    } else {\n      if (nextType.nodeType === \"ArrayTypeName\") {\n        paramTypes.push(\"uint256\");\n      }\n\n      break;\n    }\n  }\n\n  return abi.methodID(variableDeclaration.name, paramTypes);\n}\n\nfunction processVariableDeclarationAstNode(\n  variableDeclarationNode: any,\n  fileIdToSourceFile: Map<number, SourceFile>,\n  contract: Contract,\n  file: SourceFile,\n  getterAbi?: ContractAbiEntry\n) {\n  const visibility = astVisibilityToVisibility(\n    variableDeclarationNode.visibility\n  );\n\n  // Variables can't be external\n  if (visibility !== ContractFunctionVisibility.PUBLIC) {\n    return;\n  }\n\n  const functionLocation = astSrcToSourceLocation(\n    variableDeclarationNode.src,\n    fileIdToSourceFile\n  )!;\n\n  const paramTypes = getterAbi?.inputs?.map((input) => input.type);\n\n  const cf = new ContractFunction(\n    variableDeclarationNode.name,\n    ContractFunctionType.GETTER,\n    functionLocation,\n    contract,\n    visibility,\n    false, // Getters aren't payable\n    getPublicVariableSelectorFromDeclarationAstNode(variableDeclarationNode),\n    paramTypes\n  );\n\n  contract.addLocalFunction(cf);\n  file.addFunction(cf);\n}\n\nfunction applyContractsInheritance(\n  contractIdToContract: Map<number, Contract>,\n  contractIdToLinearizedBaseContractIds: Map<number, number[]>\n) {\n  for (const [cid, contract] of contractIdToContract.entries()) {\n    const inheritanceIds = contractIdToLinearizedBaseContractIds.get(cid)!;\n\n    for (const baseId of inheritanceIds) {\n      const baseContract = contractIdToContract.get(baseId);\n\n      if (baseContract === undefined) {\n        // This list includes interface, which we don't model\n        continue;\n      }\n\n      contract.addNextLinearizedBaseContract(baseContract);\n    }\n  }\n}\n\nfunction decodeBytecodes(\n  solcVersion: string,\n  compilerOutput: CompilerOutput,\n  fileIdToSourceFile: Map<number, SourceFile>,\n  contractIdToContract: Map<number, Contract>\n): Bytecode[] {\n  const bytecodes: Bytecode[] = [];\n\n  for (const contract of contractIdToContract.values()) {\n    const contractFile = contract.location.file.sourceName;\n    const contractEvmOutput =\n      compilerOutput.contracts[contractFile][contract.name].evm;\n    const contractAbiOutput =\n      compilerOutput.contracts[contractFile][contract.name].abi;\n\n    for (const abiItem of contractAbiOutput) {\n      if (abiItem.type === \"error\") {\n        const customError = CustomError.fromABI(abiItem.name, abiItem.inputs);\n\n        if (customError !== undefined) {\n          contract.addCustomError(customError);\n        } else {\n          log(`Couldn't build CustomError for error '${abiItem.name}'`);\n        }\n      }\n    }\n\n    // This is an abstract contract\n    if (contractEvmOutput.bytecode.object === \"\") {\n      continue;\n    }\n\n    const deploymentBytecode = decodeEvmBytecode(\n      contract,\n      solcVersion,\n      true,\n      contractEvmOutput.bytecode,\n      fileIdToSourceFile\n    );\n\n    const runtimeBytecode = decodeEvmBytecode(\n      contract,\n      solcVersion,\n      false,\n      contractEvmOutput.deployedBytecode,\n      fileIdToSourceFile\n    );\n\n    bytecodes.push(deploymentBytecode);\n    bytecodes.push(runtimeBytecode);\n  }\n\n  return bytecodes;\n}\n\nfunction decodeEvmBytecode(\n  contract: Contract,\n  solcVersion: string,\n  isDeployment: boolean,\n  compilerBytecode: CompilerOutputBytecode,\n  fileIdToSourceFile: Map<number, SourceFile>\n): Bytecode {\n  const libraryAddressPositions = getLibraryAddressPositions(compilerBytecode);\n\n  const immutableReferences =\n    compilerBytecode.immutableReferences !== undefined\n      ? Object.values(compilerBytecode.immutableReferences).reduce(\n          (previousValue, currentValue) => [...previousValue, ...currentValue],\n          []\n        )\n      : [];\n\n  const normalizedCode = normalizeCompilerOutputBytecode(\n    compilerBytecode.object,\n    libraryAddressPositions\n  );\n\n  const instructions = decodeInstructions(\n    normalizedCode,\n    compilerBytecode.sourceMap,\n    fileIdToSourceFile,\n    isDeployment\n  );\n\n  return new Bytecode(\n    contract,\n    isDeployment,\n    normalizedCode,\n    instructions,\n    libraryAddressPositions,\n    immutableReferences,\n    solcVersion\n  );\n}\n\nfunction astSrcToSourceLocation(\n  src: string,\n  fileIdToSourceFile: Map<number, SourceFile>\n): SourceLocation | undefined {\n  const [offset, length, fileId] = src.split(\":\").map((p) => +p);\n  const file = fileIdToSourceFile.get(fileId);\n\n  if (file === undefined) {\n    return undefined;\n  }\n\n  return new SourceLocation(file, offset, length);\n}\n\nfunction contractKindToContractType(\n  contractKind?: string\n): ContractType | undefined {\n  if (contractKind === \"library\") {\n    return ContractType.LIBRARY;\n  }\n\n  if (contractKind === \"contract\") {\n    return ContractType.CONTRACT;\n  }\n\n  return undefined;\n}\n\nfunction astVisibilityToVisibility(\n  visibility: string\n): ContractFunctionVisibility {\n  if (visibility === \"private\") {\n    return ContractFunctionVisibility.PRIVATE;\n  }\n\n  if (visibility === \"internal\") {\n    return ContractFunctionVisibility.INTERNAL;\n  }\n\n  if (visibility === \"public\") {\n    return ContractFunctionVisibility.PUBLIC;\n  }\n\n  return ContractFunctionVisibility.EXTERNAL;\n}\n\nfunction functionDefinitionKindToFunctionType(\n  kind: string | undefined\n): ContractFunctionType {\n  if (kind === \"constructor\") {\n    return ContractFunctionType.CONSTRUCTOR;\n  }\n\n  if (kind === \"fallback\") {\n    return ContractFunctionType.FALLBACK;\n  }\n\n  if (kind === \"receive\") {\n    return ContractFunctionType.RECEIVE;\n  }\n\n  if (kind === \"freeFunction\") {\n    return ContractFunctionType.FREE_FUNCTION;\n  }\n\n  return ContractFunctionType.FUNCTION;\n}\n\nfunction astFunctionDefinitionToSelector(functionDefinition: any): Buffer {\n  const paramTypes: string[] = [];\n\n  // The function selector is available in solc versions >=0.6.0\n  if (functionDefinition.functionSelector !== undefined) {\n    return Buffer.from(functionDefinition.functionSelector, \"hex\");\n  }\n\n  for (const param of functionDefinition.parameters.parameters) {\n    if (isContractType(param)) {\n      paramTypes.push(\"address\");\n      continue;\n    }\n\n    // TODO: implement ABIv2 structs parsing\n    // This might mean we need to parse struct definitions before\n    // resolving types and trying to calculate function selectors.\n    // if (isStructType(param)) {\n    //   paramTypes.push(something);\n    //   continue;\n    // }\n\n    if (isEnumType(param)) {\n      // TODO: If the enum has >= 256 elements this will fail. It should be a uint16. This is\n      //  complicated, as enums can be inherited. Fortunately, if multiple parent contracts\n      //  define the same enum, solc fails to compile.\n      paramTypes.push(\"uint8\");\n      continue;\n    }\n\n    // The rest of the function parameters always have their typeName node defined\n    const typename = param.typeName;\n    if (\n      typename.nodeType === \"ArrayTypeName\" ||\n      typename.nodeType === \"FunctionTypeName\" ||\n      typename.nodeType === \"Mapping\"\n    ) {\n      paramTypes.push(typename.typeDescriptions.typeString);\n      continue;\n    }\n\n    paramTypes.push(toCanonicalAbiType(typename.name));\n  }\n\n  return abi.methodID(functionDefinition.name, paramTypes);\n}\n\nfunction isContractType(param: any): boolean {\n  return (\n    (param.typeName?.nodeType === \"UserDefinedTypeName\" ||\n      param?.nodeType === \"UserDefinedTypeName\") &&\n    param.typeDescriptions?.typeString !== undefined &&\n    param.typeDescriptions.typeString.startsWith(\"contract \")\n  );\n}\n\nfunction isEnumType(param: any): boolean {\n  return (\n    (param.typeName?.nodeType === \"UserDefinedTypeName\" ||\n      param?.nodeType === \"UserDefinedTypeName\") &&\n    param.typeDescriptions?.typeString !== undefined &&\n    param.typeDescriptions.typeString.startsWith(\"enum \")\n  );\n}\n\nfunction isElementaryType(param: any) {\n  return (\n    param.type === \"ElementaryTypeName\" ||\n    param.nodeType === \"ElementaryTypeName\"\n  );\n}\n\nfunction toCanonicalAbiType(type: string): string {\n  if (type.startsWith(\"int[\")) {\n    return `int256${type.slice(3)}`;\n  }\n\n  if (type === \"int\") {\n    return \"int256\";\n  }\n\n  if (type.startsWith(\"uint[\")) {\n    return `uint256${type.slice(4)}`;\n  }\n\n  if (type === \"uint\") {\n    return \"uint256\";\n  }\n\n  if (type.startsWith(\"fixed[\")) {\n    return `fixed128x128${type.slice(5)}`;\n  }\n\n  if (type === \"fixed\") {\n    return \"fixed128x128\";\n  }\n\n  if (type.startsWith(\"ufixed[\")) {\n    return `ufixed128x128${type.slice(6)}`;\n  }\n\n  if (type === \"ufixed\") {\n    return \"ufixed128x128\";\n  }\n\n  return type;\n}\n\nfunction correctSelectors(\n  bytecodes: Bytecode[],\n  compilerOutput: CompilerOutput\n) {\n  for (const bytecode of bytecodes) {\n    if (bytecode.isDeployment) {\n      continue;\n    }\n\n    const contract = bytecode.contract;\n    const methodIdentifiers =\n      compilerOutput.contracts[contract.location.file.sourceName][contract.name]\n        .evm.methodIdentifiers;\n\n    for (const [signature, hexSelector] of Object.entries(methodIdentifiers)) {\n      const functionName = signature.slice(0, signature.indexOf(\"(\"));\n      const selector = Buffer.from(hexSelector, \"hex\");\n\n      const contractFunction = contract.getFunctionFromSelector(selector);\n\n      if (contractFunction !== undefined) {\n        continue;\n      }\n\n      const fixedSelector = contract.correctSelector(functionName, selector);\n\n      if (!fixedSelector) {\n        // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n        throw new Error(\n          `Failed to compute the selector one or more implementations of ${contract.name}#${functionName}. Hardhat Network can automatically fix this problem if you don't use function overloading.`\n        );\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}