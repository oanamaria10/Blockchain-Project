{"ast":null,"code":"import * as API from '@ucanto/interface';\nimport { create as createLink } from './link.js';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport * as MF from 'multiformats/interface';\nimport * as CBOR from './cbor.js';\nimport { identity } from 'multiformats/hashes/identity';\nexport { CBOR, sha256, identity };\n\n/**\n * Function takes arbitrary value and if it happens to be an `IPLDView`\n * it will iterate over it's blocks. It is just a convenience for traversing\n * arbitrary structures that may contain `IPLDView`s in them.\n * Note if you pass anything other than `IPLDView` it will not attempt\n * to find views nested inside them, instead it will just emit no blocks.\n *\n * @param {unknown} value\n * @returns {IterableIterator<API.Block>}\n */\nexport const iterate = function* (value) {\n  if (value && typeof value === 'object' && 'iterateIPLDBlocks' in value && typeof value.iterateIPLDBlocks === 'function') {\n    yield* value.iterateIPLDBlocks();\n  }\n};\n\n/**\n * @template [T=unknown]\n * @typedef {Map<API.ToString<API.Link>, API.Block<T, number, number, 0>|API.Block<T, number, number, 1>>} BlockStore\n */\n\n/**\n * @template [T=unknown]\n * @param {API.Block<T>[]} blocks\n * @returns {API.BlockStore<T>}\n */\nexport const createStore = (blocks = []) => {\n  const store = new Map();\n  addEveryInto(blocks, store);\n  return store;\n};\n\n/** @type {API.MulticodecCode<typeof identity.code, typeof identity.name>} */\nconst EMBED_CODE = identity.code;\n\n/**\n * Gets block corresponding to the given CID from the store. If store does not\n * contain the block, `fallback` is returned. If `fallback` is not provided, it\n * will throw an error.\n *\n * @template {0|1} V\n * @template {T} U\n * @template T\n * @template {API.MulticodecCode} Format\n * @template {API.MulticodecCode} Alg\n * @template [E=never]\n * @param {API.Link<U, Format, Alg, V>} cid\n * @param {BlockStore<T>} store\n * @param {E} [fallback]\n * @returns {API.Block<U, Format, Alg, V>|E}\n */\nexport const get = (cid, store, fallback) => {\n  // If CID uses identity hash, we can return the block data directly\n  if (cid.multihash.code === EMBED_CODE) {\n    return {\n      cid,\n      bytes: cid.multihash.digest\n    };\n  }\n  const block = /** @type {API.Block<U, Format, Alg, V>|undefined} */\n  store.get(`${cid}`);\n  return block ? block : fallback === undefined ? notFound(cid) : fallback;\n};\n\n/**\n * @template T\n * @template {T} U\n * @param {U} source\n * @template {API.MulticodecCode} [C=API.MulticodecCode<typeof CBOR.code, typeof CBOR.name>]\n * @param {object} options\n * @param {MF.BlockEncoder<C, U>} [options.codec]\n * @returns {API.Block<U, C, typeof EMBED_CODE> & { data: U }}\n */\nexport const embed = (source, {\n  codec\n} = {}) => {\n  const encoder = /** @type {MF.BlockEncoder<C, U>}  */codec || CBOR;\n  const bytes = encoder.encode(source);\n  const digest = identity.digest(bytes);\n  return {\n    cid: createLink(encoder.code, digest),\n    bytes,\n    data: source\n  };\n};\n\n/**\n * @param {API.Link<*, *, *, *>} link\n * @returns {never}\n */\nexport const notFound = link => {\n  throw new Error(`Block for the ${link} is not found`);\n};\n\n/**\n * @template T\n * @template {T} U\n * @template {API.MulticodecCode} C\n * @template {API.MulticodecCode} A\n * @param {U} source\n * @param {BlockStore<T>} store\n * @param {object} options\n * @param {MF.BlockEncoder<C, unknown>} [options.codec]\n * @param {MF.MultihashHasher<A>} [options.hasher]\n * @returns {Promise<API.Block<U, C, A> & { data: U }>}\n */\nexport const writeInto = async (source, store, options = {}) => {\n  const codec = /** @type {MF.BlockEncoder<C, U>} */options.codec || CBOR;\n  const hasher = /** @type {MF.MultihashHasher<A>} */options.hasher || sha256;\n  const bytes = codec.encode(source);\n  const digest = await hasher.digest(bytes);\n  /** @type {API.Link<U, typeof codec.code, typeof hasher.code>} */\n  const link = createLink(codec.code, digest);\n  store.set( /** @type {API.ToString<typeof link>} */link.toString(), {\n    bytes,\n    cid: link\n  });\n  return {\n    bytes,\n    cid: link,\n    data: source\n  };\n};\n\n/**\n * @template T\n * @template {T} U\n * @param {API.Block<U>} block\n * @param {BlockStore<T>} store\n * @returns {API.Block<U>}\n */\nexport const addInto = ({\n  cid,\n  bytes\n}, store) => {\n  store.set( /** @type {API.ToString<typeof cid>} */cid.toString(), {\n    bytes,\n    cid\n  });\n  return {\n    bytes,\n    cid\n  };\n};\n\n/**\n * @template T\n * @template {T} U\n * @param {Iterable<API.Block<U>>} source\n * @param {BlockStore<T>} store\n */\nexport const addEveryInto = (source, store) => {\n  for (const block of source) {\n    addInto(block, store);\n  }\n};","map":{"version":3,"names":["API","create","createLink","sha256","MF","CBOR","identity","iterate","value","iterateIPLDBlocks","createStore","blocks","store","Map","addEveryInto","EMBED_CODE","code","get","cid","fallback","multihash","bytes","digest","block","undefined","notFound","embed","source","codec","encoder","encode","data","link","Error","writeInto","options","hasher","set","toString","addInto"],"sources":["C:/FACULTATE/Proiect/node_modules/@ucanto/core/src/dag.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport { create as createLink } from './link.js'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport * as MF from 'multiformats/interface'\nimport * as CBOR from './cbor.js'\nimport { identity } from 'multiformats/hashes/identity'\n\nexport { CBOR, sha256, identity }\n\n/**\n * Function takes arbitrary value and if it happens to be an `IPLDView`\n * it will iterate over it's blocks. It is just a convenience for traversing\n * arbitrary structures that may contain `IPLDView`s in them.\n * Note if you pass anything other than `IPLDView` it will not attempt\n * to find views nested inside them, instead it will just emit no blocks.\n *\n * @param {unknown} value\n * @returns {IterableIterator<API.Block>}\n */\nexport const iterate = function* (value) {\n  if (\n    value &&\n    typeof value === 'object' &&\n    'iterateIPLDBlocks' in value &&\n    typeof value.iterateIPLDBlocks === 'function'\n  ) {\n    yield* value.iterateIPLDBlocks()\n  }\n}\n\n/**\n * @template [T=unknown]\n * @typedef {Map<API.ToString<API.Link>, API.Block<T, number, number, 0>|API.Block<T, number, number, 1>>} BlockStore\n */\n\n/**\n * @template [T=unknown]\n * @param {API.Block<T>[]} blocks\n * @returns {API.BlockStore<T>}\n */\nexport const createStore = (blocks = []) => {\n  const store = new Map()\n  addEveryInto(blocks, store)\n  return store\n}\n\n/** @type {API.MulticodecCode<typeof identity.code, typeof identity.name>} */\nconst EMBED_CODE = identity.code\n\n/**\n * Gets block corresponding to the given CID from the store. If store does not\n * contain the block, `fallback` is returned. If `fallback` is not provided, it\n * will throw an error.\n *\n * @template {0|1} V\n * @template {T} U\n * @template T\n * @template {API.MulticodecCode} Format\n * @template {API.MulticodecCode} Alg\n * @template [E=never]\n * @param {API.Link<U, Format, Alg, V>} cid\n * @param {BlockStore<T>} store\n * @param {E} [fallback]\n * @returns {API.Block<U, Format, Alg, V>|E}\n */\nexport const get = (cid, store, fallback) => {\n  // If CID uses identity hash, we can return the block data directly\n  if (cid.multihash.code === EMBED_CODE) {\n    return { cid, bytes: cid.multihash.digest }\n  }\n\n  const block = /** @type {API.Block<U, Format, Alg, V>|undefined} */ (\n    store.get(`${cid}`)\n  )\n  return block ? block : fallback === undefined ? notFound(cid) : fallback\n}\n\n/**\n * @template T\n * @template {T} U\n * @param {U} source\n * @template {API.MulticodecCode} [C=API.MulticodecCode<typeof CBOR.code, typeof CBOR.name>]\n * @param {object} options\n * @param {MF.BlockEncoder<C, U>} [options.codec]\n * @returns {API.Block<U, C, typeof EMBED_CODE> & { data: U }}\n */\nexport const embed = (source, { codec } = {}) => {\n  const encoder = /** @type {MF.BlockEncoder<C, U>}  */ (codec || CBOR)\n  const bytes = encoder.encode(source)\n  const digest = identity.digest(bytes)\n  return {\n    cid: createLink(encoder.code, digest),\n    bytes,\n    data: source,\n  }\n}\n\n/**\n * @param {API.Link<*, *, *, *>} link\n * @returns {never}\n */\nexport const notFound = link => {\n  throw new Error(`Block for the ${link} is not found`)\n}\n\n/**\n * @template T\n * @template {T} U\n * @template {API.MulticodecCode} C\n * @template {API.MulticodecCode} A\n * @param {U} source\n * @param {BlockStore<T>} store\n * @param {object} options\n * @param {MF.BlockEncoder<C, unknown>} [options.codec]\n * @param {MF.MultihashHasher<A>} [options.hasher]\n * @returns {Promise<API.Block<U, C, A> & { data: U }>}\n */\nexport const writeInto = async (source, store, options = {}) => {\n  const codec = /** @type {MF.BlockEncoder<C, U>} */ (options.codec || CBOR)\n  const hasher = /** @type {MF.MultihashHasher<A>} */ (options.hasher || sha256)\n\n  const bytes = codec.encode(source)\n  const digest = await hasher.digest(bytes)\n  /** @type {API.Link<U, typeof codec.code, typeof hasher.code>} */\n  const link = createLink(codec.code, digest)\n  store.set(/** @type {API.ToString<typeof link>} */ (link.toString()), {\n    bytes,\n    cid: link,\n  })\n\n  return { bytes, cid: link, data: source }\n}\n\n/**\n * @template T\n * @template {T} U\n * @param {API.Block<U>} block\n * @param {BlockStore<T>} store\n * @returns {API.Block<U>}\n */\nexport const addInto = ({ cid, bytes }, store) => {\n  store.set(/** @type {API.ToString<typeof cid>} */ (cid.toString()), {\n    bytes,\n    cid,\n  })\n\n  return { bytes, cid }\n}\n\n/**\n * @template T\n * @template {T} U\n * @param {Iterable<API.Block<U>>} source\n * @param {BlockStore<T>} store\n */\nexport const addEveryInto = (source, store) => {\n  for (const block of source) {\n    addInto(block, store)\n  }\n}\n"],"mappings":"AAAA,OAAO,KAAKA,GAAG,MAAM,mBAAmB;AACxC,SAASC,MAAM,IAAIC,UAAU,QAAQ,WAAW;AAChD,SAASC,MAAM,QAAQ,0BAA0B;AACjD,OAAO,KAAKC,EAAE,MAAM,wBAAwB;AAC5C,OAAO,KAAKC,IAAI,MAAM,WAAW;AACjC,SAASC,QAAQ,QAAQ,8BAA8B;AAEvD,SAASD,IAAI,EAAEF,MAAM,EAAEG,QAAQ;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,OAAO,GAAG,UAAAA,CAAWC,KAAK,EAAE;EACvC,IACEA,KAAK,IACL,OAAOA,KAAK,KAAK,QAAQ,IACzB,mBAAmB,IAAIA,KAAK,IAC5B,OAAOA,KAAK,CAACC,iBAAiB,KAAK,UAAU,EAC7C;IACA,OAAOD,KAAK,CAACC,iBAAiB,CAAC,CAAC;EAClC;AACF,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,WAAW,GAAGA,CAACC,MAAM,GAAG,EAAE,KAAK;EAC1C,MAAMC,KAAK,GAAG,IAAIC,GAAG,CAAC,CAAC;EACvBC,YAAY,CAACH,MAAM,EAAEC,KAAK,CAAC;EAC3B,OAAOA,KAAK;AACd,CAAC;;AAED;AACA,MAAMG,UAAU,GAAGT,QAAQ,CAACU,IAAI;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,GAAG,GAAGA,CAACC,GAAG,EAAEN,KAAK,EAAEO,QAAQ,KAAK;EAC3C;EACA,IAAID,GAAG,CAACE,SAAS,CAACJ,IAAI,KAAKD,UAAU,EAAE;IACrC,OAAO;MAAEG,GAAG;MAAEG,KAAK,EAAEH,GAAG,CAACE,SAAS,CAACE;IAAO,CAAC;EAC7C;EAEA,MAAMC,KAAK,GAAG;EACZX,KAAK,CAACK,GAAG,CAAE,GAAEC,GAAI,EAAC,CACnB;EACD,OAAOK,KAAK,GAAGA,KAAK,GAAGJ,QAAQ,KAAKK,SAAS,GAAGC,QAAQ,CAACP,GAAG,CAAC,GAAGC,QAAQ;AAC1E,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMO,KAAK,GAAGA,CAACC,MAAM,EAAE;EAAEC;AAAM,CAAC,GAAG,CAAC,CAAC,KAAK;EAC/C,MAAMC,OAAO,GAAG,qCAAuCD,KAAK,IAAIvB,IAAK;EACrE,MAAMgB,KAAK,GAAGQ,OAAO,CAACC,MAAM,CAACH,MAAM,CAAC;EACpC,MAAML,MAAM,GAAGhB,QAAQ,CAACgB,MAAM,CAACD,KAAK,CAAC;EACrC,OAAO;IACLH,GAAG,EAAEhB,UAAU,CAAC2B,OAAO,CAACb,IAAI,EAAEM,MAAM,CAAC;IACrCD,KAAK;IACLU,IAAI,EAAEJ;EACR,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA,OAAO,MAAMF,QAAQ,GAAGO,IAAI,IAAI;EAC9B,MAAM,IAAIC,KAAK,CAAE,iBAAgBD,IAAK,eAAc,CAAC;AACvD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAME,SAAS,GAAG,MAAAA,CAAOP,MAAM,EAAEf,KAAK,EAAEuB,OAAO,GAAG,CAAC,CAAC,KAAK;EAC9D,MAAMP,KAAK,GAAG,oCAAsCO,OAAO,CAACP,KAAK,IAAIvB,IAAK;EAC1E,MAAM+B,MAAM,GAAG,oCAAsCD,OAAO,CAACC,MAAM,IAAIjC,MAAO;EAE9E,MAAMkB,KAAK,GAAGO,KAAK,CAACE,MAAM,CAACH,MAAM,CAAC;EAClC,MAAML,MAAM,GAAG,MAAMc,MAAM,CAACd,MAAM,CAACD,KAAK,CAAC;EACzC;EACA,MAAMW,IAAI,GAAG9B,UAAU,CAAC0B,KAAK,CAACZ,IAAI,EAAEM,MAAM,CAAC;EAC3CV,KAAK,CAACyB,GAAG,EAAC,wCAA0CL,IAAI,CAACM,QAAQ,CAAC,CAAC,EAAG;IACpEjB,KAAK;IACLH,GAAG,EAAEc;EACP,CAAC,CAAC;EAEF,OAAO;IAAEX,KAAK;IAAEH,GAAG,EAAEc,IAAI;IAAED,IAAI,EAAEJ;EAAO,CAAC;AAC3C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMY,OAAO,GAAGA,CAAC;EAAErB,GAAG;EAAEG;AAAM,CAAC,EAAET,KAAK,KAAK;EAChDA,KAAK,CAACyB,GAAG,EAAC,uCAAyCnB,GAAG,CAACoB,QAAQ,CAAC,CAAC,EAAG;IAClEjB,KAAK;IACLH;EACF,CAAC,CAAC;EAEF,OAAO;IAAEG,KAAK;IAAEH;EAAI,CAAC;AACvB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMJ,YAAY,GAAGA,CAACa,MAAM,EAAEf,KAAK,KAAK;EAC7C,KAAK,MAAMW,KAAK,IAAII,MAAM,EAAE;IAC1BY,OAAO,CAAChB,KAAK,EAAEX,KAAK,CAAC;EACvB;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}