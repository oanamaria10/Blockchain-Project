{"ast":null,"code":"import * as Layout from \"./api.js\";\nimport * as Queue from \"./queue/api.js\";\nexport * from \"./queue/api.js\";\n\n/**\n * @returns {Queue.Result}\n */\nexport const empty = () => ({\n  mutable: false,\n  needs: {},\n  nodes: {},\n  links: {},\n  linked: []\n});\nexport const mutable = () => ({\n  mutable: true,\n  needs: {},\n  nodes: {},\n  links: {},\n  linked: EMPTY\n});\n\n/**\n * Adds given layout node to the layout queue. If links for all of the node\n * children are available correspnoding linked node is added (removing links\n * form the queue) otherwise `nood` is added to the wait queue until all the\n * needed links are added.\n *\n *\n * @param {Layout.Branch} node\n * @param {Queue.Queue} queue\n * @returns {Queue.Result}\n */\nexport const addNode = (node, queue) => addNodes([node], queue);\n\n/**\n *\n * @param {Layout.Branch[]} newNodes\n * @param {Queue.Queue} input\n * @returns {Queue.Result}\n */\nexport const addNodes = (newNodes, input) => {\n  let queue = patch(input, {});\n  for (const node of newNodes) {\n    const {\n      ready,\n      has,\n      wants\n    } = collect(node.children, queue.links);\n    // If node isn't waiting on any of the children it's ready to be linked\n    // so we add linked node diretly.\n    if (wants.length === 0) {\n      queue = patch(queue, {\n        links: assign(undefined, has),\n        linked: [{\n          id: node.id,\n          links: ready\n        }]\n      });\n    } else {\n      queue = patch(queue, {\n        needs: assign(node.id, wants),\n        nodes: {\n          [node.id]: {\n            children: node.children,\n            count: wants.length\n          }\n        }\n      });\n    }\n  }\n  return queue;\n};\n\n/**\n * Adds link to the queue. If queue contains a node that needs this link it gets\n * updated. Either it's gets linked (when it was blocked only on this link) or\n * it's want could is reduced. If no node needed this link it just gets stored\n * for the future node that will need it.\n *\n *\n * @param {Queue.NodeID} id\n * @param {Queue.Link} link\n * @param {Queue.Queue} queue\n * @returns {Queue.Result}\n */\n\nexport const addLink = (id, link, queue) => {\n  const nodeID = queue.needs[id];\n  const node = queue.nodes[nodeID];\n  // We have node than needs this link.\n  if (node != null) {\n    // This is the only link it needed so we materialize the node and remove\n    // links and needs associated with it.\n    if (node.count === 1) {\n      const {\n        ready,\n        has\n      } = collect(node.children, {\n        ...queue.links,\n        [id]: link\n      });\n      return patch(queue, {\n        needs: {\n          [id]: undefined\n        },\n        links: assign(undefined, has),\n        nodes: {\n          [nodeID]: undefined\n        },\n        linked: [{\n          id: nodeID,\n          links: ready\n        }]\n      });\n    }\n    // If node needs more links we just reduce a want count and remove this\n    // need.\n    else {\n      return patch(queue, {\n        needs: {\n          [id]: undefined\n        },\n        links: {\n          [id]: link\n        },\n        nodes: {\n          [nodeID]: {\n            ...node,\n            count: node.count - 1\n          }\n        }\n      });\n    }\n  }\n  // If we have no one waiting for this link just add it to the queue\n  else {\n    return patch(queue, {\n      links: {\n        [id]: link\n      }\n    });\n  }\n};\n\n/**\n *\n * @param {Queue.Queue} queue\n * @param {Queue.Delta} delta\n */\n\nconst patch = (queue, {\n  needs,\n  nodes,\n  links,\n  linked\n}) => {\n  const result = queue.mutable ? queue : {\n    ...queue\n  };\n  const original = queue.mutable ? BLANK : undefined;\n  if (needs) {\n    result.needs = patchDict(queue.needs, needs, original);\n  }\n  if (nodes) {\n    result.nodes = patchDict(queue.nodes, nodes, original);\n  }\n  if (links) {\n    result.links = patchDict(queue.links, links, original);\n  }\n  result.linked = linked ? append(queue.linked || EMPTY, linked, EMPTY) : queue.linked || [];\n  return /** @type {Queue.Result} */result;\n};\n\n/**\n * @template V\n * @template {PropertyKey} K\n * @param {V} value\n * @param {K[]} keys\n * @returns {Record<K, V>}\n */\n\nconst assign = (value, keys) => {\n  const delta = /** @type {Record<K, V>} */{};\n  for (const key of keys) {\n    delta[key] = value;\n  }\n  return delta;\n};\n\n/**\n * @template {PropertyKey} K\n * @template V\n * @param {Record<K, V>} target\n *\n * @param {Record<K, V|void>} delta\n * @param {Record<K, V>} original\n * @returns {Record<K, V>}\n */\n\nconst patchDict = (target, delta, original = target) => {\n  const result = target === original ? {\n    ...target\n  } : target;\n  for (const entry of Object.entries(delta)) {\n    const [id, value] = /** @type {[K, V|void]} */entry;\n    if (value == null) {\n      delete result[id];\n    } else {\n      result[id] = value;\n    }\n  }\n  return result;\n};\n/**\n *\n * @param {Iterable<[Queue.NodeID, Queue.Link]>} entries\n * @param {Queue.Queue} queue\n * @returns {Queue.Queue}\n */\nexport const addLinks = (entries, queue) => {\n  for (const [id, link] of entries) {\n    queue = addLink(id, link, queue);\n  }\n  return queue;\n};\n\n/**\n * @param {Queue.Queue} queue\n */\n\nexport const isEmpty = queue => Object.keys(queue.nodes).length === 0 && Object.keys(queue.links).length === 0;\n\n/**\n * @template T\n * @param {T[]} target\n * @param {T[]} items\n * @param {T[]} original\n */\nconst append = (target, items, original = target) => {\n  if (target === original) {\n    return [...target, ...items];\n  } else {\n    for (const item of items) {\n      target.push(item);\n    }\n    return target;\n  }\n};\n\n/**\n * @param {Queue.NodeID[]} children\n * @param {Record<Queue.NodeID, Queue.Link>} source\n * @returns {{has:Queue.NodeID[], wants:Queue.NodeID[], ready:Queue.Link[]}}\n */\nconst collect = (children, source) => {\n  const has = [];\n  const wants = [];\n  const ready = [];\n  for (const child of children) {\n    const link = source[child];\n    if (link) {\n      has.push(child);\n      ready.push(link);\n    } else {\n      wants.push(child);\n    }\n  }\n  return {\n    has,\n    wants,\n    ready\n  };\n};\nconst EMPTY = /** @type {never[]} */Object.freeze([]);\nconst BLANK = /** @type {Record<never, never>} */Object.freeze({});","map":{"version":3,"names":["Layout","Queue","empty","mutable","needs","nodes","links","linked","EMPTY","addNode","node","queue","addNodes","newNodes","input","patch","ready","has","wants","collect","children","length","assign","undefined","id","count","addLink","link","nodeID","result","original","BLANK","patchDict","append","value","keys","delta","key","target","entry","Object","entries","addLinks","isEmpty","items","item","push","source","child","freeze"],"sources":["C:/FACULTATE/Proiect/node_modules/@ipld/unixfs/src/file/layout/queue.js"],"sourcesContent":["import * as Layout from \"./api.js\"\nimport * as Queue from \"./queue/api.js\"\nexport * from \"./queue/api.js\"\n\n/**\n * @returns {Queue.Result}\n */\nexport const empty = () => ({\n  mutable: false,\n  needs: {},\n  nodes: {},\n  links: {},\n  linked: [],\n})\n\nexport const mutable = () => ({\n  mutable: true,\n  needs: {},\n  nodes: {},\n  links: {},\n  linked: EMPTY,\n})\n\n/**\n * Adds given layout node to the layout queue. If links for all of the node\n * children are available correspnoding linked node is added (removing links\n * form the queue) otherwise `nood` is added to the wait queue until all the\n * needed links are added.\n *\n *\n * @param {Layout.Branch} node\n * @param {Queue.Queue} queue\n * @returns {Queue.Result}\n */\nexport const addNode = (node, queue) => addNodes([node], queue)\n\n/**\n *\n * @param {Layout.Branch[]} newNodes\n * @param {Queue.Queue} input\n * @returns {Queue.Result}\n */\nexport const addNodes = (newNodes, input) => {\n  let queue = patch(input, {})\n  for (const node of newNodes) {\n    const { ready, has, wants } = collect(node.children, queue.links)\n    // If node isn't waiting on any of the children it's ready to be linked\n    // so we add linked node diretly.\n    if (wants.length === 0) {\n      queue = patch(queue, {\n        links: assign(undefined, has),\n        linked: [{ id: node.id, links: ready }],\n      })\n    } else {\n      queue = patch(queue, {\n        needs: assign(node.id, wants),\n        nodes: {\n          [node.id]: {\n            children: node.children,\n            count: wants.length,\n          },\n        },\n      })\n    }\n  }\n\n  return queue\n}\n\n/**\n * Adds link to the queue. If queue contains a node that needs this link it gets\n * updated. Either it's gets linked (when it was blocked only on this link) or\n * it's want could is reduced. If no node needed this link it just gets stored\n * for the future node that will need it.\n *\n *\n * @param {Queue.NodeID} id\n * @param {Queue.Link} link\n * @param {Queue.Queue} queue\n * @returns {Queue.Result}\n */\n\nexport const addLink = (id, link, queue) => {\n  const nodeID = queue.needs[id]\n  const node = queue.nodes[nodeID]\n  // We have node than needs this link.\n  if (node != null) {\n    // This is the only link it needed so we materialize the node and remove\n    // links and needs associated with it.\n    if (node.count === 1) {\n      const { ready, has } = collect(node.children, {\n        ...queue.links,\n        [id]: link,\n      })\n\n      return patch(queue, {\n        needs: { [id]: undefined },\n        links: assign(undefined, has),\n        nodes: { [nodeID]: undefined },\n        linked: [{ id: nodeID, links: ready }],\n      })\n    }\n    // If node needs more links we just reduce a want count and remove this\n    // need.\n    else {\n      return patch(queue, {\n        needs: { [id]: undefined },\n        links: { [id]: link },\n        nodes: {\n          [nodeID]: {\n            ...node,\n            count: node.count - 1,\n          },\n        },\n      })\n    }\n  }\n  // If we have no one waiting for this link just add it to the queue\n  else {\n    return patch(queue, {\n      links: { [id]: link },\n    })\n  }\n}\n\n/**\n *\n * @param {Queue.Queue} queue\n * @param {Queue.Delta} delta\n */\n\nconst patch = (queue, { needs, nodes, links, linked }) => {\n  const result = queue.mutable ? queue : { ...queue }\n  const original = queue.mutable ? BLANK : undefined\n\n  if (needs) {\n    result.needs = patchDict(queue.needs, needs, original)\n  }\n\n  if (nodes) {\n    result.nodes = patchDict(queue.nodes, nodes, original)\n  }\n\n  if (links) {\n    result.links = patchDict(queue.links, links, original)\n  }\n\n  result.linked = linked\n    ? append(queue.linked || EMPTY, linked, EMPTY)\n    : queue.linked || []\n\n  return /** @type {Queue.Result} */ (result)\n}\n\n/**\n * @template V\n * @template {PropertyKey} K\n * @param {V} value\n * @param {K[]} keys\n * @returns {Record<K, V>}\n */\n\nconst assign = (value, keys) => {\n  const delta = /** @type {Record<K, V>} */ ({})\n  for (const key of keys) {\n    delta[key] = value\n  }\n\n  return delta\n}\n\n/**\n * @template {PropertyKey} K\n * @template V\n * @param {Record<K, V>} target\n *\n * @param {Record<K, V|void>} delta\n * @param {Record<K, V>} original\n * @returns {Record<K, V>}\n */\n\nconst patchDict = (target, delta, original = target) => {\n  const result = target === original ? { ...target } : target\n  for (const entry of Object.entries(delta)) {\n    const [id, value] = /** @type {[K, V|void]} */ (entry)\n    if (value == null) {\n      delete result[id]\n    } else {\n      result[id] = value\n    }\n  }\n\n  return result\n}\n/**\n *\n * @param {Iterable<[Queue.NodeID, Queue.Link]>} entries\n * @param {Queue.Queue} queue\n * @returns {Queue.Queue}\n */\nexport const addLinks = (entries, queue) => {\n  for (const [id, link] of entries) {\n    queue = addLink(id, link, queue)\n  }\n  return queue\n}\n\n/**\n * @param {Queue.Queue} queue\n */\n\nexport const isEmpty = queue =>\n  Object.keys(queue.nodes).length === 0 && Object.keys(queue.links).length === 0\n\n/**\n * @template T\n * @param {T[]} target\n * @param {T[]} items\n * @param {T[]} original\n */\nconst append = (target, items, original = target) => {\n  if (target === original) {\n    return [...target, ...items]\n  } else {\n    for (const item of items) {\n      target.push(item)\n    }\n    return target\n  }\n}\n\n/**\n * @param {Queue.NodeID[]} children\n * @param {Record<Queue.NodeID, Queue.Link>} source\n * @returns {{has:Queue.NodeID[], wants:Queue.NodeID[], ready:Queue.Link[]}}\n */\nconst collect = (children, source) => {\n  const has = []\n  const wants = []\n  const ready = []\n  for (const child of children) {\n    const link = source[child]\n    if (link) {\n      has.push(child)\n      ready.push(link)\n    } else {\n      wants.push(child)\n    }\n  }\n\n  return { has, wants, ready }\n}\n\nconst EMPTY = /** @type {never[]} */ (Object.freeze([]))\n\nconst BLANK = /** @type {Record<never, never>} */ (Object.freeze({}))\n"],"mappings":"AAAA,OAAO,KAAKA,MAAM,MAAM,UAAU;AAClC,OAAO,KAAKC,KAAK,MAAM,gBAAgB;AACvC,cAAc,gBAAgB;;AAE9B;AACA;AACA;AACA,OAAO,MAAMC,KAAK,GAAGA,CAAA,MAAO;EAC1BC,OAAO,EAAE,KAAK;EACdC,KAAK,EAAE,CAAC,CAAC;EACTC,KAAK,EAAE,CAAC,CAAC;EACTC,KAAK,EAAE,CAAC,CAAC;EACTC,MAAM,EAAE;AACV,CAAC,CAAC;AAEF,OAAO,MAAMJ,OAAO,GAAGA,CAAA,MAAO;EAC5BA,OAAO,EAAE,IAAI;EACbC,KAAK,EAAE,CAAC,CAAC;EACTC,KAAK,EAAE,CAAC,CAAC;EACTC,KAAK,EAAE,CAAC,CAAC;EACTC,MAAM,EAAEC;AACV,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,OAAO,GAAGA,CAACC,IAAI,EAAEC,KAAK,KAAKC,QAAQ,CAAC,CAACF,IAAI,CAAC,EAAEC,KAAK,CAAC;;AAE/D;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,QAAQ,GAAGA,CAACC,QAAQ,EAAEC,KAAK,KAAK;EAC3C,IAAIH,KAAK,GAAGI,KAAK,CAACD,KAAK,EAAE,CAAC,CAAC,CAAC;EAC5B,KAAK,MAAMJ,IAAI,IAAIG,QAAQ,EAAE;IAC3B,MAAM;MAAEG,KAAK;MAAEC,GAAG;MAAEC;IAAM,CAAC,GAAGC,OAAO,CAACT,IAAI,CAACU,QAAQ,EAAET,KAAK,CAACL,KAAK,CAAC;IACjE;IACA;IACA,IAAIY,KAAK,CAACG,MAAM,KAAK,CAAC,EAAE;MACtBV,KAAK,GAAGI,KAAK,CAACJ,KAAK,EAAE;QACnBL,KAAK,EAAEgB,MAAM,CAACC,SAAS,EAAEN,GAAG,CAAC;QAC7BV,MAAM,EAAE,CAAC;UAAEiB,EAAE,EAAEd,IAAI,CAACc,EAAE;UAAElB,KAAK,EAAEU;QAAM,CAAC;MACxC,CAAC,CAAC;IACJ,CAAC,MAAM;MACLL,KAAK,GAAGI,KAAK,CAACJ,KAAK,EAAE;QACnBP,KAAK,EAAEkB,MAAM,CAACZ,IAAI,CAACc,EAAE,EAAEN,KAAK,CAAC;QAC7Bb,KAAK,EAAE;UACL,CAACK,IAAI,CAACc,EAAE,GAAG;YACTJ,QAAQ,EAAEV,IAAI,CAACU,QAAQ;YACvBK,KAAK,EAAEP,KAAK,CAACG;UACf;QACF;MACF,CAAC,CAAC;IACJ;EACF;EAEA,OAAOV,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAMe,OAAO,GAAGA,CAACF,EAAE,EAAEG,IAAI,EAAEhB,KAAK,KAAK;EAC1C,MAAMiB,MAAM,GAAGjB,KAAK,CAACP,KAAK,CAACoB,EAAE,CAAC;EAC9B,MAAMd,IAAI,GAAGC,KAAK,CAACN,KAAK,CAACuB,MAAM,CAAC;EAChC;EACA,IAAIlB,IAAI,IAAI,IAAI,EAAE;IAChB;IACA;IACA,IAAIA,IAAI,CAACe,KAAK,KAAK,CAAC,EAAE;MACpB,MAAM;QAAET,KAAK;QAAEC;MAAI,CAAC,GAAGE,OAAO,CAACT,IAAI,CAACU,QAAQ,EAAE;QAC5C,GAAGT,KAAK,CAACL,KAAK;QACd,CAACkB,EAAE,GAAGG;MACR,CAAC,CAAC;MAEF,OAAOZ,KAAK,CAACJ,KAAK,EAAE;QAClBP,KAAK,EAAE;UAAE,CAACoB,EAAE,GAAGD;QAAU,CAAC;QAC1BjB,KAAK,EAAEgB,MAAM,CAACC,SAAS,EAAEN,GAAG,CAAC;QAC7BZ,KAAK,EAAE;UAAE,CAACuB,MAAM,GAAGL;QAAU,CAAC;QAC9BhB,MAAM,EAAE,CAAC;UAAEiB,EAAE,EAAEI,MAAM;UAAEtB,KAAK,EAAEU;QAAM,CAAC;MACvC,CAAC,CAAC;IACJ;IACA;IACA;IAAA,KACK;MACH,OAAOD,KAAK,CAACJ,KAAK,EAAE;QAClBP,KAAK,EAAE;UAAE,CAACoB,EAAE,GAAGD;QAAU,CAAC;QAC1BjB,KAAK,EAAE;UAAE,CAACkB,EAAE,GAAGG;QAAK,CAAC;QACrBtB,KAAK,EAAE;UACL,CAACuB,MAAM,GAAG;YACR,GAAGlB,IAAI;YACPe,KAAK,EAAEf,IAAI,CAACe,KAAK,GAAG;UACtB;QACF;MACF,CAAC,CAAC;IACJ;EACF;EACA;EAAA,KACK;IACH,OAAOV,KAAK,CAACJ,KAAK,EAAE;MAClBL,KAAK,EAAE;QAAE,CAACkB,EAAE,GAAGG;MAAK;IACtB,CAAC,CAAC;EACJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA,MAAMZ,KAAK,GAAGA,CAACJ,KAAK,EAAE;EAAEP,KAAK;EAAEC,KAAK;EAAEC,KAAK;EAAEC;AAAO,CAAC,KAAK;EACxD,MAAMsB,MAAM,GAAGlB,KAAK,CAACR,OAAO,GAAGQ,KAAK,GAAG;IAAE,GAAGA;EAAM,CAAC;EACnD,MAAMmB,QAAQ,GAAGnB,KAAK,CAACR,OAAO,GAAG4B,KAAK,GAAGR,SAAS;EAElD,IAAInB,KAAK,EAAE;IACTyB,MAAM,CAACzB,KAAK,GAAG4B,SAAS,CAACrB,KAAK,CAACP,KAAK,EAAEA,KAAK,EAAE0B,QAAQ,CAAC;EACxD;EAEA,IAAIzB,KAAK,EAAE;IACTwB,MAAM,CAACxB,KAAK,GAAG2B,SAAS,CAACrB,KAAK,CAACN,KAAK,EAAEA,KAAK,EAAEyB,QAAQ,CAAC;EACxD;EAEA,IAAIxB,KAAK,EAAE;IACTuB,MAAM,CAACvB,KAAK,GAAG0B,SAAS,CAACrB,KAAK,CAACL,KAAK,EAAEA,KAAK,EAAEwB,QAAQ,CAAC;EACxD;EAEAD,MAAM,CAACtB,MAAM,GAAGA,MAAM,GAClB0B,MAAM,CAACtB,KAAK,CAACJ,MAAM,IAAIC,KAAK,EAAED,MAAM,EAAEC,KAAK,CAAC,GAC5CG,KAAK,CAACJ,MAAM,IAAI,EAAE;EAEtB,OAAO,2BAA6BsB,MAAM;AAC5C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMP,MAAM,GAAGA,CAACY,KAAK,EAAEC,IAAI,KAAK;EAC9B,MAAMC,KAAK,GAAG,2BAA6B,CAAC,CAAE;EAC9C,KAAK,MAAMC,GAAG,IAAIF,IAAI,EAAE;IACtBC,KAAK,CAACC,GAAG,CAAC,GAAGH,KAAK;EACpB;EAEA,OAAOE,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMJ,SAAS,GAAGA,CAACM,MAAM,EAAEF,KAAK,EAAEN,QAAQ,GAAGQ,MAAM,KAAK;EACtD,MAAMT,MAAM,GAAGS,MAAM,KAAKR,QAAQ,GAAG;IAAE,GAAGQ;EAAO,CAAC,GAAGA,MAAM;EAC3D,KAAK,MAAMC,KAAK,IAAIC,MAAM,CAACC,OAAO,CAACL,KAAK,CAAC,EAAE;IACzC,MAAM,CAACZ,EAAE,EAAEU,KAAK,CAAC,GAAG,0BAA4BK,KAAM;IACtD,IAAIL,KAAK,IAAI,IAAI,EAAE;MACjB,OAAOL,MAAM,CAACL,EAAE,CAAC;IACnB,CAAC,MAAM;MACLK,MAAM,CAACL,EAAE,CAAC,GAAGU,KAAK;IACpB;EACF;EAEA,OAAOL,MAAM;AACf,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMa,QAAQ,GAAGA,CAACD,OAAO,EAAE9B,KAAK,KAAK;EAC1C,KAAK,MAAM,CAACa,EAAE,EAAEG,IAAI,CAAC,IAAIc,OAAO,EAAE;IAChC9B,KAAK,GAAGe,OAAO,CAACF,EAAE,EAAEG,IAAI,EAAEhB,KAAK,CAAC;EAClC;EACA,OAAOA,KAAK;AACd,CAAC;;AAED;AACA;AACA;;AAEA,OAAO,MAAMgC,OAAO,GAAGhC,KAAK,IAC1B6B,MAAM,CAACL,IAAI,CAACxB,KAAK,CAACN,KAAK,CAAC,CAACgB,MAAM,KAAK,CAAC,IAAImB,MAAM,CAACL,IAAI,CAACxB,KAAK,CAACL,KAAK,CAAC,CAACe,MAAM,KAAK,CAAC;;AAEhF;AACA;AACA;AACA;AACA;AACA;AACA,MAAMY,MAAM,GAAGA,CAACK,MAAM,EAAEM,KAAK,EAAEd,QAAQ,GAAGQ,MAAM,KAAK;EACnD,IAAIA,MAAM,KAAKR,QAAQ,EAAE;IACvB,OAAO,CAAC,GAAGQ,MAAM,EAAE,GAAGM,KAAK,CAAC;EAC9B,CAAC,MAAM;IACL,KAAK,MAAMC,IAAI,IAAID,KAAK,EAAE;MACxBN,MAAM,CAACQ,IAAI,CAACD,IAAI,CAAC;IACnB;IACA,OAAOP,MAAM;EACf;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAMnB,OAAO,GAAGA,CAACC,QAAQ,EAAE2B,MAAM,KAAK;EACpC,MAAM9B,GAAG,GAAG,EAAE;EACd,MAAMC,KAAK,GAAG,EAAE;EAChB,MAAMF,KAAK,GAAG,EAAE;EAChB,KAAK,MAAMgC,KAAK,IAAI5B,QAAQ,EAAE;IAC5B,MAAMO,IAAI,GAAGoB,MAAM,CAACC,KAAK,CAAC;IAC1B,IAAIrB,IAAI,EAAE;MACRV,GAAG,CAAC6B,IAAI,CAACE,KAAK,CAAC;MACfhC,KAAK,CAAC8B,IAAI,CAACnB,IAAI,CAAC;IAClB,CAAC,MAAM;MACLT,KAAK,CAAC4B,IAAI,CAACE,KAAK,CAAC;IACnB;EACF;EAEA,OAAO;IAAE/B,GAAG;IAAEC,KAAK;IAAEF;EAAM,CAAC;AAC9B,CAAC;AAED,MAAMR,KAAK,GAAG,sBAAwBgC,MAAM,CAACS,MAAM,CAAC,EAAE,CAAE;AAExD,MAAMlB,KAAK,GAAG,mCAAqCS,MAAM,CAACS,MAAM,CAAC,CAAC,CAAC,CAAE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}