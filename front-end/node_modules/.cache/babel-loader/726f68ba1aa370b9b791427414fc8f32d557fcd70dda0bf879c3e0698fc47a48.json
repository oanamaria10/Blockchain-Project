{"ast":null,"code":"const assert = require('assert');\nconst {\n  kRetryHandlerDefaultRetry\n} = require('../core/symbols');\nconst {\n  RequestRetryError\n} = require('../core/errors');\nconst {\n  isDisturbed,\n  parseHeaders,\n  parseRangeHeader\n} = require('../core/util');\nfunction calculateRetryAfterHeader(retryAfter) {\n  const current = Date.now();\n  const diff = new Date(retryAfter).getTime() - current;\n  return diff;\n}\nclass RetryHandler {\n  constructor(opts, handlers) {\n    const {\n      retryOptions,\n      ...dispatchOpts\n    } = opts;\n    const {\n      // Retry scoped\n      retry: retryFn,\n      maxRetries,\n      maxTimeout,\n      minTimeout,\n      timeoutFactor,\n      // Response scoped\n      methods,\n      errorCodes,\n      retryAfter,\n      statusCodes\n    } = retryOptions ?? {};\n    this.dispatch = handlers.dispatch;\n    this.handler = handlers.handler;\n    this.opts = dispatchOpts;\n    this.abort = null;\n    this.aborted = false;\n    this.retryOpts = {\n      retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],\n      retryAfter: retryAfter ?? true,\n      maxTimeout: maxTimeout ?? 30 * 1000,\n      // 30s,\n      timeout: minTimeout ?? 500,\n      // .5s\n      timeoutFactor: timeoutFactor ?? 2,\n      maxRetries: maxRetries ?? 5,\n      // What errors we should retry\n      methods: methods ?? ['GET', 'HEAD', 'OPTIONS', 'PUT', 'DELETE', 'TRACE'],\n      // Indicates which errors to retry\n      statusCodes: statusCodes ?? [500, 502, 503, 504, 429],\n      // List of errors to retry\n      errorCodes: errorCodes ?? ['ECONNRESET', 'ECONNREFUSED', 'ENOTFOUND', 'ENETDOWN', 'ENETUNREACH', 'EHOSTDOWN', 'EHOSTUNREACH', 'EPIPE']\n    };\n    this.retryCount = 0;\n    this.start = 0;\n    this.end = null;\n    this.etag = null;\n    this.resume = null;\n\n    // Handle possible onConnect duplication\n    this.handler.onConnect(reason => {\n      this.aborted = true;\n      if (this.abort) {\n        this.abort(reason);\n      } else {\n        this.reason = reason;\n      }\n    });\n  }\n  onRequestSent() {\n    if (this.handler.onRequestSent) {\n      this.handler.onRequestSent();\n    }\n  }\n  onUpgrade(statusCode, headers, socket) {\n    if (this.handler.onUpgrade) {\n      this.handler.onUpgrade(statusCode, headers, socket);\n    }\n  }\n  onConnect(abort) {\n    if (this.aborted) {\n      abort(this.reason);\n    } else {\n      this.abort = abort;\n    }\n  }\n  onBodySent(chunk) {\n    if (this.handler.onBodySent) return this.handler.onBodySent(chunk);\n  }\n  static [kRetryHandlerDefaultRetry](err, {\n    state,\n    opts\n  }, cb) {\n    const {\n      statusCode,\n      code,\n      headers\n    } = err;\n    const {\n      method,\n      retryOptions\n    } = opts;\n    const {\n      maxRetries,\n      timeout,\n      maxTimeout,\n      timeoutFactor,\n      statusCodes,\n      errorCodes,\n      methods\n    } = retryOptions;\n    let {\n      counter,\n      currentTimeout\n    } = state;\n    currentTimeout = currentTimeout != null && currentTimeout > 0 ? currentTimeout : timeout;\n\n    // Any code that is not a Undici's originated and allowed to retry\n    if (code && code !== 'UND_ERR_REQ_RETRY' && code !== 'UND_ERR_SOCKET' && !errorCodes.includes(code)) {\n      cb(err);\n      return;\n    }\n\n    // If a set of method are provided and the current method is not in the list\n    if (Array.isArray(methods) && !methods.includes(method)) {\n      cb(err);\n      return;\n    }\n\n    // If a set of status code are provided and the current status code is not in the list\n    if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {\n      cb(err);\n      return;\n    }\n\n    // If we reached the max number of retries\n    if (counter > maxRetries) {\n      cb(err);\n      return;\n    }\n    let retryAfterHeader = headers != null && headers['retry-after'];\n    if (retryAfterHeader) {\n      retryAfterHeader = Number(retryAfterHeader);\n      retryAfterHeader = isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1e3; // Retry-After is in seconds\n    }\n    const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout);\n    state.currentTimeout = retryTimeout;\n    setTimeout(() => cb(null), retryTimeout);\n  }\n  onHeaders(statusCode, rawHeaders, resume, statusMessage) {\n    const headers = parseHeaders(rawHeaders);\n    this.retryCount += 1;\n    if (statusCode >= 300) {\n      this.abort(new RequestRetryError('Request failed', statusCode, {\n        headers,\n        count: this.retryCount\n      }));\n      return false;\n    }\n\n    // Checkpoint for resume from where we left it\n    if (this.resume != null) {\n      this.resume = null;\n      if (statusCode !== 206) {\n        return true;\n      }\n      const contentRange = parseRangeHeader(headers['content-range']);\n      // If no content range\n      if (!contentRange) {\n        this.abort(new RequestRetryError('Content-Range mismatch', statusCode, {\n          headers,\n          count: this.retryCount\n        }));\n        return false;\n      }\n\n      // Let's start with a weak etag check\n      if (this.etag != null && this.etag !== headers.etag) {\n        this.abort(new RequestRetryError('ETag mismatch', statusCode, {\n          headers,\n          count: this.retryCount\n        }));\n        return false;\n      }\n      const {\n        start,\n        size,\n        end = size\n      } = contentRange;\n      assert(this.start === start, 'content-range mismatch');\n      assert(this.end == null || this.end === end, 'content-range mismatch');\n      this.resume = resume;\n      return true;\n    }\n    if (this.end == null) {\n      if (statusCode === 206) {\n        // First time we receive 206\n        const range = parseRangeHeader(headers['content-range']);\n        if (range == null) {\n          return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);\n        }\n        const {\n          start,\n          size,\n          end = size\n        } = range;\n        assert(start != null && Number.isFinite(start) && this.start !== start, 'content-range mismatch');\n        assert(Number.isFinite(start));\n        assert(end != null && Number.isFinite(end) && this.end !== end, 'invalid content-length');\n        this.start = start;\n        this.end = end;\n      }\n\n      // We make our best to checkpoint the body for further range headers\n      if (this.end == null) {\n        const contentLength = headers['content-length'];\n        this.end = contentLength != null ? Number(contentLength) : null;\n      }\n      assert(Number.isFinite(this.start));\n      assert(this.end == null || Number.isFinite(this.end), 'invalid content-length');\n      this.resume = resume;\n      this.etag = headers.etag != null ? headers.etag : null;\n      return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);\n    }\n    const err = new RequestRetryError('Request failed', statusCode, {\n      headers,\n      count: this.retryCount\n    });\n    this.abort(err);\n    return false;\n  }\n  onData(chunk) {\n    this.start += chunk.length;\n    return this.handler.onData(chunk);\n  }\n  onComplete(rawTrailers) {\n    this.retryCount = 0;\n    return this.handler.onComplete(rawTrailers);\n  }\n  onError(err) {\n    if (this.aborted || isDisturbed(this.opts.body)) {\n      return this.handler.onError(err);\n    }\n    this.retryOpts.retry(err, {\n      state: {\n        counter: this.retryCount++,\n        currentTimeout: this.retryAfter\n      },\n      opts: {\n        retryOptions: this.retryOpts,\n        ...this.opts\n      }\n    }, onRetry.bind(this));\n    function onRetry(err) {\n      if (err != null || this.aborted || isDisturbed(this.opts.body)) {\n        return this.handler.onError(err);\n      }\n      if (this.start !== 0) {\n        this.opts = {\n          ...this.opts,\n          headers: {\n            ...this.opts.headers,\n            range: `bytes=${this.start}-${this.end ?? ''}`\n          }\n        };\n      }\n      try {\n        this.dispatch(this.opts, this);\n      } catch (err) {\n        this.handler.onError(err);\n      }\n    }\n  }\n}\nmodule.exports = RetryHandler;","map":{"version":3,"names":["assert","require","kRetryHandlerDefaultRetry","RequestRetryError","isDisturbed","parseHeaders","parseRangeHeader","calculateRetryAfterHeader","retryAfter","current","Date","now","diff","getTime","RetryHandler","constructor","opts","handlers","retryOptions","dispatchOpts","retry","retryFn","maxRetries","maxTimeout","minTimeout","timeoutFactor","methods","errorCodes","statusCodes","dispatch","handler","abort","aborted","retryOpts","timeout","retryCount","start","end","etag","resume","onConnect","reason","onRequestSent","onUpgrade","statusCode","headers","socket","onBodySent","chunk","err","state","cb","code","method","counter","currentTimeout","includes","Array","isArray","retryAfterHeader","Number","isNaN","retryTimeout","Math","min","setTimeout","onHeaders","rawHeaders","statusMessage","count","contentRange","size","range","isFinite","contentLength","onData","length","onComplete","rawTrailers","onError","body","onRetry","bind","module","exports"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/undici/lib/handler/RetryHandler.js"],"sourcesContent":["const assert = require('assert')\n\nconst { kRetryHandlerDefaultRetry } = require('../core/symbols')\nconst { RequestRetryError } = require('../core/errors')\nconst { isDisturbed, parseHeaders, parseRangeHeader } = require('../core/util')\n\nfunction calculateRetryAfterHeader (retryAfter) {\n  const current = Date.now()\n  const diff = new Date(retryAfter).getTime() - current\n\n  return diff\n}\n\nclass RetryHandler {\n  constructor (opts, handlers) {\n    const { retryOptions, ...dispatchOpts } = opts\n    const {\n      // Retry scoped\n      retry: retryFn,\n      maxRetries,\n      maxTimeout,\n      minTimeout,\n      timeoutFactor,\n      // Response scoped\n      methods,\n      errorCodes,\n      retryAfter,\n      statusCodes\n    } = retryOptions ?? {}\n\n    this.dispatch = handlers.dispatch\n    this.handler = handlers.handler\n    this.opts = dispatchOpts\n    this.abort = null\n    this.aborted = false\n    this.retryOpts = {\n      retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],\n      retryAfter: retryAfter ?? true,\n      maxTimeout: maxTimeout ?? 30 * 1000, // 30s,\n      timeout: minTimeout ?? 500, // .5s\n      timeoutFactor: timeoutFactor ?? 2,\n      maxRetries: maxRetries ?? 5,\n      // What errors we should retry\n      methods: methods ?? ['GET', 'HEAD', 'OPTIONS', 'PUT', 'DELETE', 'TRACE'],\n      // Indicates which errors to retry\n      statusCodes: statusCodes ?? [500, 502, 503, 504, 429],\n      // List of errors to retry\n      errorCodes: errorCodes ?? [\n        'ECONNRESET',\n        'ECONNREFUSED',\n        'ENOTFOUND',\n        'ENETDOWN',\n        'ENETUNREACH',\n        'EHOSTDOWN',\n        'EHOSTUNREACH',\n        'EPIPE'\n      ]\n    }\n\n    this.retryCount = 0\n    this.start = 0\n    this.end = null\n    this.etag = null\n    this.resume = null\n\n    // Handle possible onConnect duplication\n    this.handler.onConnect(reason => {\n      this.aborted = true\n      if (this.abort) {\n        this.abort(reason)\n      } else {\n        this.reason = reason\n      }\n    })\n  }\n\n  onRequestSent () {\n    if (this.handler.onRequestSent) {\n      this.handler.onRequestSent()\n    }\n  }\n\n  onUpgrade (statusCode, headers, socket) {\n    if (this.handler.onUpgrade) {\n      this.handler.onUpgrade(statusCode, headers, socket)\n    }\n  }\n\n  onConnect (abort) {\n    if (this.aborted) {\n      abort(this.reason)\n    } else {\n      this.abort = abort\n    }\n  }\n\n  onBodySent (chunk) {\n    if (this.handler.onBodySent) return this.handler.onBodySent(chunk)\n  }\n\n  static [kRetryHandlerDefaultRetry] (err, { state, opts }, cb) {\n    const { statusCode, code, headers } = err\n    const { method, retryOptions } = opts\n    const {\n      maxRetries,\n      timeout,\n      maxTimeout,\n      timeoutFactor,\n      statusCodes,\n      errorCodes,\n      methods\n    } = retryOptions\n    let { counter, currentTimeout } = state\n\n    currentTimeout =\n      currentTimeout != null && currentTimeout > 0 ? currentTimeout : timeout\n\n    // Any code that is not a Undici's originated and allowed to retry\n    if (\n      code &&\n      code !== 'UND_ERR_REQ_RETRY' &&\n      code !== 'UND_ERR_SOCKET' &&\n      !errorCodes.includes(code)\n    ) {\n      cb(err)\n      return\n    }\n\n    // If a set of method are provided and the current method is not in the list\n    if (Array.isArray(methods) && !methods.includes(method)) {\n      cb(err)\n      return\n    }\n\n    // If a set of status code are provided and the current status code is not in the list\n    if (\n      statusCode != null &&\n      Array.isArray(statusCodes) &&\n      !statusCodes.includes(statusCode)\n    ) {\n      cb(err)\n      return\n    }\n\n    // If we reached the max number of retries\n    if (counter > maxRetries) {\n      cb(err)\n      return\n    }\n\n    let retryAfterHeader = headers != null && headers['retry-after']\n    if (retryAfterHeader) {\n      retryAfterHeader = Number(retryAfterHeader)\n      retryAfterHeader = isNaN(retryAfterHeader)\n        ? calculateRetryAfterHeader(retryAfterHeader)\n        : retryAfterHeader * 1e3 // Retry-After is in seconds\n    }\n\n    const retryTimeout =\n      retryAfterHeader > 0\n        ? Math.min(retryAfterHeader, maxTimeout)\n        : Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout)\n\n    state.currentTimeout = retryTimeout\n\n    setTimeout(() => cb(null), retryTimeout)\n  }\n\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    const headers = parseHeaders(rawHeaders)\n\n    this.retryCount += 1\n\n    if (statusCode >= 300) {\n      this.abort(\n        new RequestRetryError('Request failed', statusCode, {\n          headers,\n          count: this.retryCount\n        })\n      )\n      return false\n    }\n\n    // Checkpoint for resume from where we left it\n    if (this.resume != null) {\n      this.resume = null\n\n      if (statusCode !== 206) {\n        return true\n      }\n\n      const contentRange = parseRangeHeader(headers['content-range'])\n      // If no content range\n      if (!contentRange) {\n        this.abort(\n          new RequestRetryError('Content-Range mismatch', statusCode, {\n            headers,\n            count: this.retryCount\n          })\n        )\n        return false\n      }\n\n      // Let's start with a weak etag check\n      if (this.etag != null && this.etag !== headers.etag) {\n        this.abort(\n          new RequestRetryError('ETag mismatch', statusCode, {\n            headers,\n            count: this.retryCount\n          })\n        )\n        return false\n      }\n\n      const { start, size, end = size } = contentRange\n\n      assert(this.start === start, 'content-range mismatch')\n      assert(this.end == null || this.end === end, 'content-range mismatch')\n\n      this.resume = resume\n      return true\n    }\n\n    if (this.end == null) {\n      if (statusCode === 206) {\n        // First time we receive 206\n        const range = parseRangeHeader(headers['content-range'])\n\n        if (range == null) {\n          return this.handler.onHeaders(\n            statusCode,\n            rawHeaders,\n            resume,\n            statusMessage\n          )\n        }\n\n        const { start, size, end = size } = range\n\n        assert(\n          start != null && Number.isFinite(start) && this.start !== start,\n          'content-range mismatch'\n        )\n        assert(Number.isFinite(start))\n        assert(\n          end != null && Number.isFinite(end) && this.end !== end,\n          'invalid content-length'\n        )\n\n        this.start = start\n        this.end = end\n      }\n\n      // We make our best to checkpoint the body for further range headers\n      if (this.end == null) {\n        const contentLength = headers['content-length']\n        this.end = contentLength != null ? Number(contentLength) : null\n      }\n\n      assert(Number.isFinite(this.start))\n      assert(\n        this.end == null || Number.isFinite(this.end),\n        'invalid content-length'\n      )\n\n      this.resume = resume\n      this.etag = headers.etag != null ? headers.etag : null\n\n      return this.handler.onHeaders(\n        statusCode,\n        rawHeaders,\n        resume,\n        statusMessage\n      )\n    }\n\n    const err = new RequestRetryError('Request failed', statusCode, {\n      headers,\n      count: this.retryCount\n    })\n\n    this.abort(err)\n\n    return false\n  }\n\n  onData (chunk) {\n    this.start += chunk.length\n\n    return this.handler.onData(chunk)\n  }\n\n  onComplete (rawTrailers) {\n    this.retryCount = 0\n    return this.handler.onComplete(rawTrailers)\n  }\n\n  onError (err) {\n    if (this.aborted || isDisturbed(this.opts.body)) {\n      return this.handler.onError(err)\n    }\n\n    this.retryOpts.retry(\n      err,\n      {\n        state: { counter: this.retryCount++, currentTimeout: this.retryAfter },\n        opts: { retryOptions: this.retryOpts, ...this.opts }\n      },\n      onRetry.bind(this)\n    )\n\n    function onRetry (err) {\n      if (err != null || this.aborted || isDisturbed(this.opts.body)) {\n        return this.handler.onError(err)\n      }\n\n      if (this.start !== 0) {\n        this.opts = {\n          ...this.opts,\n          headers: {\n            ...this.opts.headers,\n            range: `bytes=${this.start}-${this.end ?? ''}`\n          }\n        }\n      }\n\n      try {\n        this.dispatch(this.opts, this)\n      } catch (err) {\n        this.handler.onError(err)\n      }\n    }\n  }\n}\n\nmodule.exports = RetryHandler\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}