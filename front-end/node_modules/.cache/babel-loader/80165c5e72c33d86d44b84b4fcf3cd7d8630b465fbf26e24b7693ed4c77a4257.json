{"ast":null,"code":"import * as API from '@ucanto/interface';\nimport * as DID from '@ipld/dag-ucan/did';\nimport * as Invocation from './invocation.js';\nimport * as Delegation from './delegation.js';\nimport * as Signature from '@ipld/dag-ucan/signature';\nimport * as DAG from './dag.js';\nimport * as CBOR from './cbor.js';\nimport { sha256 } from 'multiformats/hashes/sha2';\n\n/**\n * @template {{}} Ok\n * @template {{}} Error\n * @template {API.Invocation} Ran\n * @template [E=never]\n * @param {object} input\n * @param {API.Link<API.ReceiptModel<Ok, Error, Ran>>} input.root\n * @param {DAG.BlockStore} input.blocks\n * @param {E} [fallback]\n */\nexport const view = ({\n  root,\n  blocks\n}, fallback) => {\n  const block = DAG.get(root, blocks, null);\n  if (block == null) {\n    return fallback !== undefined ? fallback : DAG.notFound(root);\n  }\n  const data = CBOR.decode(block.bytes);\n  return new Receipt({\n    root: {\n      ...block,\n      data\n    },\n    store: blocks\n  });\n};\n\n/**\n * Represents a UCAN invocation receipt view over some block store e.g. in\n * memory CAR. It incrementally decodes proofs, ran invocation etc. on access\n * which reduces overhead but potentially defers errors if references blocks\n * do not conform to the expected IPLD schema.\n *\n * @template {{}} Ok\n * @template {{}} Error\n * @template {API.Invocation} Ran\n * @template {API.SigAlg} [SigAlg=API.SigAlg]\n * @implements {API.Receipt<Ok, Error, Ran, SigAlg>}\n */\nclass Receipt {\n  /**\n   * @param {object} input\n   * @param {Required<API.Block<API.ReceiptModel<Ok, Error, Ran>>>} input.root\n   * @param {DAG.BlockStore} input.store\n   * @param {API.Meta} [input.meta]\n   * @param {Ran|ReturnType<Ran['link']>} [input.ran]\n   * @param {API.EffectsModel} [input.fx]\n   * @param {API.SignatureView<API.OutcomeModel<Ok, Error, Ran>, SigAlg>} [input.signature]\n   * @param {API.UCAN.Principal} [input.issuer]\n   * @param {API.Proof[]} [input.proofs]\n   */\n  constructor({\n    root,\n    store,\n    ran,\n    issuer,\n    signature,\n    proofs\n  }) {\n    this.store = store;\n    this.root = root;\n    this._ran = ran;\n\n    // Field is materialized on demand when `fx` getter is first accessed.\n    /** @type {API.Effects|undefined} */\n    this._fx = undefined;\n    this._signature = signature;\n    this._proofs = proofs;\n    this._issuer = issuer;\n  }\n\n  /**\n   * @returns {Ran|ReturnType<Ran['link']>}\n   */\n  get ran() {\n    const ran = this._ran;\n    if (!ran) {\n      const ran = /** @type {Ran} */\n      Invocation.view({\n        root: this.root.data.ocm.ran,\n        blocks: this.store\n      }, this.root.data.ocm.ran);\n      this._ran = ran;\n      return ran;\n    } else {\n      return ran;\n    }\n  }\n  get proofs() {\n    const proofs = this._proofs;\n    if (proofs) {\n      return proofs;\n    } else {\n      const {\n        store,\n        root\n      } = this;\n      const {\n        prf\n      } = root.data.ocm;\n      const proofs = [];\n      if (prf) {\n        for (const link of prf) {\n          const proof = Delegation.view({\n            root: link,\n            blocks: store\n          }, link);\n          proofs.push(proof);\n        }\n      }\n      this._proofs = proofs;\n      return proofs;\n    }\n  }\n  link() {\n    return this.root.cid;\n  }\n  get meta() {\n    return this.root.data.ocm.meta;\n  }\n  get issuer() {\n    const issuer = this._issuer;\n    if (issuer) {\n      return issuer;\n    } else {\n      const {\n        iss\n      } = this.root.data.ocm;\n      if (iss) {\n        const issuer = DID.parse(iss);\n        this._issuer = issuer;\n        return issuer;\n      }\n    }\n  }\n  get out() {\n    return this.root.data.ocm.out;\n  }\n  get fx() {\n    let fx = this._fx;\n    if (!fx) {\n      const {\n        store: blocks\n      } = this;\n      const {\n        fork,\n        join\n      } = this.root.data.ocm.fx;\n      fx = {\n        fork: fork.map(root => Invocation.view({\n          root,\n          blocks\n        }, root))\n      };\n      if (join) {\n        fx.join = Invocation.view({\n          root: join,\n          blocks\n        }, join);\n      }\n      this._fx = fx;\n    }\n    return fx;\n  }\n  get signature() {\n    const signature = this._signature;\n    if (signature) {\n      return signature;\n    } else {\n      const signature = /** @type {API.SignatureView<API.OutcomeModel<Ok, Error, Ran>, SigAlg>} */\n      Signature.view(this.root.data.sig);\n      this._signature = signature;\n      return signature;\n    }\n  }\n\n  /**\n   * @param {API.Crypto.Verifier} signingPrincipal\n   */\n  verifySignature(signingPrincipal) {\n    return this.signature.verify(signingPrincipal, CBOR.encode(this.root.data.ocm));\n  }\n  buildIPLDView() {\n    return this;\n  }\n  *iterateIPLDBlocks() {\n    const {\n      ran,\n      fx,\n      proofs,\n      root\n    } = this;\n    yield* DAG.iterate(ran);\n    for (const fork of fx.fork) {\n      yield* DAG.iterate(fork);\n    }\n    if (fx.join) {\n      yield* DAG.iterate(fx.join);\n    }\n    for (const proof of proofs) {\n      yield* DAG.iterate(proof);\n    }\n    yield root;\n  }\n}\n\n/**\n * Represents a receipt builder that can be used to create a receipt that later\n * can be encoded into desired IPLD codec and hasher. In the future we may make\n * this an incremental builder so you could set some fields later on.\n *\n * @template {{}} Ok\n * @template {{}} Error\n * @template {API.Invocation} Ran\n * @template {API.SigAlg} SigAlg\n * @implements {API.IPLDViewBuilder<API.Receipt<Ok, Error, Ran, SigAlg>>}\n */\nclass ReceptBuilder {\n  /**\n   * @param {object} options\n   * @param {API.Signer<API.DID, SigAlg>} options.issuer\n   * @param {Ran|ReturnType<Ran['link']>} options.ran\n   * @param {API.Result<Ok, Error>} options.result\n   * @param {API.Effects} [options.fx]\n   * @param {API.Proof[]} [options.proofs]\n   * @param {Record<string, unknown>} [options.meta]\n   */\n  constructor({\n    issuer,\n    result,\n    ran,\n    fx = NOFX,\n    proofs = [],\n    meta = {}\n  }) {\n    this.issuer = issuer;\n    this.result = result;\n    this.ran = ran;\n    this.fx = fx;\n    this.proofs = proofs;\n    this.meta = meta;\n  }\n  async buildIPLDView({\n    hasher = sha256,\n    codec = CBOR\n  } = {}) {\n    const store = DAG.createStore();\n\n    // copy invocation blocks int\n    DAG.addEveryInto(DAG.iterate(this.ran), store);\n\n    // copy proof blocks into store\n    const prf = [];\n    for (const proof of this.proofs) {\n      DAG.addEveryInto(DAG.iterate(proof), store);\n      prf.push(proof.link());\n    }\n\n    // copy blocks from the embedded fx\n    /** @type {{fork: API.Run[], join?:API.Run}}  */\n    const fx = {\n      fork: []\n    };\n    for (const fork of this.fx.fork) {\n      DAG.addEveryInto(DAG.iterate(fork), store);\n      fx.fork.push(fork.link());\n    }\n    if (this.fx.join) {\n      DAG.addEveryInto(DAG.iterate(this.fx.join), store);\n      fx.join = this.fx.join.link();\n    }\n\n    /** @type {API.OutcomeModel<Ok, Error, Ran>} */\n    const outcome = {\n      ran: ( /** @type {ReturnType<Ran['link']>} */this.ran.link()),\n      out: this.result,\n      fx,\n      meta: this.meta,\n      iss: this.issuer.did(),\n      prf\n    };\n    const signature = await this.issuer.sign(CBOR.encode(outcome));\n\n    /** @type {API.ReceiptModel<Ok, Error, Ran>} */\n    const model = {\n      ocm: outcome,\n      sig: signature\n    };\n    const root = await DAG.writeInto(model, store, {\n      hasher,\n      codec\n    });\n    return new Receipt({\n      root,\n      store,\n      signature,\n      proofs: this.proofs,\n      ran: this.ran\n    });\n  }\n}\nconst NOFX = Object.freeze({\n  fork: Object.freeze([])\n});\n\n/**\n * Creates a receipt in CBOR with sha256 hashed links.\n *\n * @template {{}} Ok\n * @template {{}} Error\n * @template {API.Invocation} Ran\n * @template {API.SigAlg} SigAlg\n * @param {object} options\n * @param {API.Signer<API.DID, SigAlg>} options.issuer\n * @param {Ran|ReturnType<Ran['link']>} options.ran\n * @param {API.Result<Ok, Error>} options.result\n * @param {API.Effects} [options.fx]\n * @param {API.Proof[]} [options.proofs]\n * @param {Record<string, unknown>} [options.meta]\n * @returns {Promise<API.Receipt<Ok, Error, Ran, SigAlg>>}\n */\nexport const issue = options => new ReceptBuilder(options).buildIPLDView();","map":{"version":3,"names":["API","DID","Invocation","Delegation","Signature","DAG","CBOR","sha256","view","root","blocks","fallback","block","get","undefined","notFound","data","decode","bytes","Receipt","store","constructor","ran","issuer","signature","proofs","_ran","_fx","_signature","_proofs","_issuer","ocm","prf","link","proof","push","cid","meta","iss","parse","out","fx","fork","join","map","sig","verifySignature","signingPrincipal","verify","encode","buildIPLDView","iterateIPLDBlocks","iterate","ReceptBuilder","result","NOFX","hasher","codec","createStore","addEveryInto","outcome","did","sign","model","writeInto","Object","freeze","issue","options"],"sources":["C:/FACULTATE/Proiect/node_modules/@ucanto/core/src/receipt.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport * as DID from '@ipld/dag-ucan/did'\nimport * as Invocation from './invocation.js'\nimport * as Delegation from './delegation.js'\nimport * as Signature from '@ipld/dag-ucan/signature'\nimport * as DAG from './dag.js'\nimport * as CBOR from './cbor.js'\nimport { sha256 } from 'multiformats/hashes/sha2'\n\n/**\n * @template {{}} Ok\n * @template {{}} Error\n * @template {API.Invocation} Ran\n * @template [E=never]\n * @param {object} input\n * @param {API.Link<API.ReceiptModel<Ok, Error, Ran>>} input.root\n * @param {DAG.BlockStore} input.blocks\n * @param {E} [fallback]\n */\nexport const view = ({ root, blocks }, fallback) => {\n  const block = DAG.get(root, blocks, null)\n  if (block == null) {\n    return fallback !== undefined ? fallback : DAG.notFound(root)\n  }\n  const data = CBOR.decode(block.bytes)\n\n  return new Receipt({ root: { ...block, data }, store: blocks })\n}\n\n/**\n * Represents a UCAN invocation receipt view over some block store e.g. in\n * memory CAR. It incrementally decodes proofs, ran invocation etc. on access\n * which reduces overhead but potentially defers errors if references blocks\n * do not conform to the expected IPLD schema.\n *\n * @template {{}} Ok\n * @template {{}} Error\n * @template {API.Invocation} Ran\n * @template {API.SigAlg} [SigAlg=API.SigAlg]\n * @implements {API.Receipt<Ok, Error, Ran, SigAlg>}\n */\nclass Receipt {\n  /**\n   * @param {object} input\n   * @param {Required<API.Block<API.ReceiptModel<Ok, Error, Ran>>>} input.root\n   * @param {DAG.BlockStore} input.store\n   * @param {API.Meta} [input.meta]\n   * @param {Ran|ReturnType<Ran['link']>} [input.ran]\n   * @param {API.EffectsModel} [input.fx]\n   * @param {API.SignatureView<API.OutcomeModel<Ok, Error, Ran>, SigAlg>} [input.signature]\n   * @param {API.UCAN.Principal} [input.issuer]\n   * @param {API.Proof[]} [input.proofs]\n   */\n  constructor({ root, store, ran, issuer, signature, proofs }) {\n    this.store = store\n\n    this.root = root\n    this._ran = ran\n\n    // Field is materialized on demand when `fx` getter is first accessed.\n    /** @type {API.Effects|undefined} */\n    this._fx = undefined\n    this._signature = signature\n    this._proofs = proofs\n    this._issuer = issuer\n  }\n\n  /**\n   * @returns {Ran|ReturnType<Ran['link']>}\n   */\n  get ran() {\n    const ran = this._ran\n    if (!ran) {\n      const ran = /** @type {Ran} */ (\n        Invocation.view(\n          {\n            root: this.root.data.ocm.ran,\n            blocks: this.store,\n          },\n          this.root.data.ocm.ran\n        )\n      )\n      this._ran = ran\n      return ran\n    } else {\n      return ran\n    }\n  }\n  get proofs() {\n    const proofs = this._proofs\n    if (proofs) {\n      return proofs\n    } else {\n      const { store, root } = this\n      const { prf } = root.data.ocm\n      const proofs = []\n      if (prf) {\n        for (const link of prf) {\n          const proof = Delegation.view({ root: link, blocks: store }, link)\n          proofs.push(proof)\n        }\n      }\n\n      this._proofs = proofs\n      return proofs\n    }\n  }\n  link() {\n    return this.root.cid\n  }\n  get meta() {\n    return this.root.data.ocm.meta\n  }\n  get issuer() {\n    const issuer = this._issuer\n    if (issuer) {\n      return issuer\n    } else {\n      const { iss } = this.root.data.ocm\n      if (iss) {\n        const issuer = DID.parse(iss)\n        this._issuer = issuer\n        return issuer\n      }\n    }\n  }\n\n  get out() {\n    return this.root.data.ocm.out\n  }\n\n  get fx() {\n    let fx = this._fx\n    if (!fx) {\n      const { store: blocks } = this\n      const { fork, join } = this.root.data.ocm.fx\n\n      fx = {\n        fork: fork.map(root => Invocation.view({ root, blocks }, root)),\n      }\n\n      if (join) {\n        fx.join = Invocation.view({ root: join, blocks }, join)\n      }\n\n      this._fx = fx\n    }\n    return fx\n  }\n\n  get signature() {\n    const signature = this._signature\n    if (signature) {\n      return signature\n    } else {\n      const signature =\n        /** @type {API.SignatureView<API.OutcomeModel<Ok, Error, Ran>, SigAlg>} */ (\n          Signature.view(this.root.data.sig)\n        )\n      this._signature = signature\n      return signature\n    }\n  }\n\n  /**\n   * @param {API.Crypto.Verifier} signingPrincipal\n   */\n  verifySignature(signingPrincipal) {\n    return this.signature.verify(\n      signingPrincipal,\n      CBOR.encode(this.root.data.ocm)\n    )\n  }\n\n  buildIPLDView() {\n    return this\n  }\n\n  *iterateIPLDBlocks() {\n    const { ran, fx, proofs, root } = this\n\n    yield* DAG.iterate(ran)\n\n    for (const fork of fx.fork) {\n      yield* DAG.iterate(fork)\n    }\n\n    if (fx.join) {\n      yield* DAG.iterate(fx.join)\n    }\n\n    for (const proof of proofs) {\n      yield* DAG.iterate(proof)\n    }\n\n    yield root\n  }\n}\n\n/**\n * Represents a receipt builder that can be used to create a receipt that later\n * can be encoded into desired IPLD codec and hasher. In the future we may make\n * this an incremental builder so you could set some fields later on.\n *\n * @template {{}} Ok\n * @template {{}} Error\n * @template {API.Invocation} Ran\n * @template {API.SigAlg} SigAlg\n * @implements {API.IPLDViewBuilder<API.Receipt<Ok, Error, Ran, SigAlg>>}\n */\nclass ReceptBuilder {\n  /**\n   * @param {object} options\n   * @param {API.Signer<API.DID, SigAlg>} options.issuer\n   * @param {Ran|ReturnType<Ran['link']>} options.ran\n   * @param {API.Result<Ok, Error>} options.result\n   * @param {API.Effects} [options.fx]\n   * @param {API.Proof[]} [options.proofs]\n   * @param {Record<string, unknown>} [options.meta]\n   */\n  constructor({ issuer, result, ran, fx = NOFX, proofs = [], meta = {} }) {\n    this.issuer = issuer\n    this.result = result\n    this.ran = ran\n    this.fx = fx\n    this.proofs = proofs\n    this.meta = meta\n  }\n  async buildIPLDView({ hasher = sha256, codec = CBOR } = {}) {\n    const store = DAG.createStore()\n\n    // copy invocation blocks int\n    DAG.addEveryInto(DAG.iterate(this.ran), store)\n\n    // copy proof blocks into store\n    const prf = []\n    for (const proof of this.proofs) {\n      DAG.addEveryInto(DAG.iterate(proof), store)\n      prf.push(proof.link())\n    }\n\n    // copy blocks from the embedded fx\n    /** @type {{fork: API.Run[], join?:API.Run}}  */\n    const fx = { fork: [] }\n    for (const fork of this.fx.fork) {\n      DAG.addEveryInto(DAG.iterate(fork), store)\n      fx.fork.push(fork.link())\n    }\n\n    if (this.fx.join) {\n      DAG.addEveryInto(DAG.iterate(this.fx.join), store)\n      fx.join = this.fx.join.link()\n    }\n\n    /** @type {API.OutcomeModel<Ok, Error, Ran>} */\n    const outcome = {\n      ran: /** @type {ReturnType<Ran['link']>} */ (this.ran.link()),\n      out: this.result,\n      fx,\n      meta: this.meta,\n      iss: this.issuer.did(),\n      prf,\n    }\n\n    const signature = await this.issuer.sign(CBOR.encode(outcome))\n\n    /** @type {API.ReceiptModel<Ok, Error, Ran>} */\n    const model = {\n      ocm: outcome,\n      sig: signature,\n    }\n    const root = await DAG.writeInto(model, store, {\n      hasher,\n      codec,\n    })\n\n    return new Receipt({\n      root,\n      store,\n      signature,\n      proofs: this.proofs,\n      ran: this.ran,\n    })\n  }\n}\n\nconst NOFX = Object.freeze({ fork: Object.freeze([]) })\n\n/**\n * Creates a receipt in CBOR with sha256 hashed links.\n *\n * @template {{}} Ok\n * @template {{}} Error\n * @template {API.Invocation} Ran\n * @template {API.SigAlg} SigAlg\n * @param {object} options\n * @param {API.Signer<API.DID, SigAlg>} options.issuer\n * @param {Ran|ReturnType<Ran['link']>} options.ran\n * @param {API.Result<Ok, Error>} options.result\n * @param {API.Effects} [options.fx]\n * @param {API.Proof[]} [options.proofs]\n * @param {Record<string, unknown>} [options.meta]\n * @returns {Promise<API.Receipt<Ok, Error, Ran, SigAlg>>}\n */\nexport const issue = options => new ReceptBuilder(options).buildIPLDView()\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}