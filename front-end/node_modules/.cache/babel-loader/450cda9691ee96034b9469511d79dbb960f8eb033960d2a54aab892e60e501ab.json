{"ast":null,"code":"import { Indexed } from \"./indexed.js\";\n\n/**\n * @typedef {{\n * readonly byteOffset: number\n * readonly byteLength: number\n * readonly segments: Uint8Array[]\n * }} BufferSlice\n */\n\n/** @typedef {BufferView} View */\nexport const empty = () => new BufferView();\n\n/**\n * @param {Uint8Array[]} segments\n * @param {number} byteOffset\n * @param {number} byteLength\n */\nexport const create = (segments, byteOffset = 0, byteLength = totalByteLength(segments)) => new BufferView(segments, byteOffset, byteLength);\n\n/**\n *\n * @param {Uint8Array[]} segments\n * @returns\n */\nconst totalByteLength = segments => {\n  let byteLength = 0;\n  for (const segment of segments) {\n    byteLength += segment.byteLength;\n  }\n  return byteLength;\n};\n\n/**\n * @param {BufferSlice} buffer\n * @param {number} [startOffset]\n * @param {number} [endOffset]\n */\nexport const slice = (buffer, startOffset = 0, endOffset = buffer.byteLength) => {\n  const segments = [];\n  const start = startOffset < 0 ? buffer.byteLength - startOffset : startOffset;\n  const end = endOffset < 0 ? buffer.byteLength - endOffset : endOffset;\n\n  // If start at 0 offset and end is past buffer range it is effectively\n  // as same buffer.\n  if (start === 0 && end >= buffer.byteLength) {\n    return buffer;\n  }\n\n  // If range is not within the current buffer just create an empty slice.\n  if (start > end || start > buffer.byteLength || end <= 0) {\n    return empty();\n  }\n  let byteLength = 0;\n  let offset = 0;\n  for (const segment of buffer.segments) {\n    const nextOffset = offset + segment.byteLength;\n    // Have not found a start yet\n    if (byteLength === 0) {\n      // If end offset is within the current segment we know start is also,\n      // because it preceeds the end & we had not found start yet.\n      // In such case we create a view with only single segment of bytes\n      // in the range.\n      if (end <= nextOffset) {\n        const range = segment.subarray(start - offset, end - offset);\n        segments.push(range);\n        byteLength = range.byteLength;\n        break;\n      }\n      // If start offeset falls with in current range (but not the end)\n      // we save matching buffer slice and update byteLength.\n      else if (start < nextOffset) {\n        const range = start === offset ? segment : segment.subarray(start - offset);\n        segments.push(range);\n        byteLength = range.byteLength;\n      }\n    }\n    // Otherwise we already started collecting matching segments and are looking\n    // for the end end of the slice. If it is with in the current range capture\n    // the segment and create a view.\n    else if (end <= nextOffset) {\n      const range = end === nextOffset ? segment : segment.subarray(0, end - offset);\n      segments.push(range);\n      byteLength += range.byteLength;\n      break;\n    }\n    // If end is past current range we just save the segment and continue.\n    else {\n      segments.push(segment);\n      byteLength += segment.byteLength;\n    }\n    offset = nextOffset;\n  }\n  return new BufferView(segments, buffer.byteOffset + start, byteLength);\n};\n\n/**\n * @param {BufferSlice} buffer\n * @param {Uint8Array} part\n */\n\nexport const push = (buffer, part) => {\n  if (part.byteLength > 0) {\n    // We MUTATE here but that is ok because it is out of bound for the passed\n    // buffer view so there will be no visible side effects.\n    buffer.segments.push(part);\n    return new BufferView(buffer.segments, buffer.byteOffset, buffer.byteLength + part.byteLength);\n  } else {\n    return buffer;\n  }\n};\n\n/**\n * @param {BufferSlice} buffer\n * @param {number} n\n */\nexport const get = (buffer, n) => {\n  if (n < buffer.byteLength) {\n    let offset = 0;\n    for (const segment of buffer.segments) {\n      if (n < offset + segment.byteLength) {\n        return segment[n - offset];\n      } else {\n        offset += segment.byteLength;\n      }\n    }\n  }\n  return undefined;\n};\n\n/**\n *\n * @param {BufferView} buffer\n * @param {Uint8Array} target\n * @param {number} byteOffset\n */\nexport const copyTo = (buffer, target, byteOffset) => {\n  let offset = byteOffset;\n  for (const segment of buffer.segments) {\n    target.set(segment, offset);\n    offset += segment.byteLength;\n  }\n  return target;\n};\n\n/**\n *\n * @param {BufferView} buffer\n */\nexport function* iterate(buffer) {\n  for (const part of buffer.segments) {\n    yield* part;\n  }\n}\n\n/**\n * @extends {Indexed<number>}\n */\nclass BufferView extends Indexed {\n  /**\n   * @param {Uint8Array[]} segments\n   * @param {number} byteOffset\n   * @param {number} byteLength\n   */\n  constructor(segments = [], byteOffset = 0, byteLength = 0) {\n    super();\n    /** @hide */\n    this.segments = segments;\n    /** @readonly */\n    this.byteLength = byteLength;\n    /** @readonly */\n    this.length = byteLength;\n    /** @readonly */\n    this.byteOffset = byteOffset;\n  }\n  [Symbol.iterator]() {\n    return iterate(this);\n  }\n\n  /**\n   * @param {number} [start]\n   * @param {number} [end]\n   */\n  slice(start, end) {\n    return /** @type {BufferView} */slice(this, start, end);\n  }\n\n  /**\n   * @param {number} [start]\n   * @param {number} [end]\n   */\n  subarray(start, end) {\n    return /** @type {BufferView} */slice(this, start, end);\n  }\n\n  /**\n   *\n   * @param {Uint8Array} bytes\n   */\n  push(bytes) {\n    return /** @type {BufferView} */push(this, bytes);\n  }\n\n  /**\n   * @param {number} n\n   */\n  get(n) {\n    return get(this, n);\n  }\n\n  /**\n   *\n   * @param {Uint8Array} target\n   * @param {number} offset\n   */\n  copyTo(target, offset) {\n    return copyTo(this, target, offset);\n  }\n}","map":{"version":3,"names":["Indexed","empty","BufferView","create","segments","byteOffset","byteLength","totalByteLength","segment","slice","buffer","startOffset","endOffset","start","end","offset","nextOffset","range","subarray","push","part","get","n","undefined","copyTo","target","set","iterate","constructor","length","Symbol","iterator","bytes"],"sources":["C:/FACULTATE/Proiect/node_modules/@ipld/unixfs/src/file/chunker/buffer.js"],"sourcesContent":["import { Indexed } from \"./indexed.js\"\n\n/**\n * @typedef {{\n * readonly byteOffset: number\n * readonly byteLength: number\n * readonly segments: Uint8Array[]\n * }} BufferSlice\n */\n\n/** @typedef {BufferView} View */\nexport const empty = () => new BufferView()\n\n/**\n * @param {Uint8Array[]} segments\n * @param {number} byteOffset\n * @param {number} byteLength\n */\nexport const create = (\n  segments,\n  byteOffset = 0,\n  byteLength = totalByteLength(segments)\n) => new BufferView(segments, byteOffset, byteLength)\n\n/**\n *\n * @param {Uint8Array[]} segments\n * @returns\n */\nconst totalByteLength = segments => {\n  let byteLength = 0\n  for (const segment of segments) {\n    byteLength += segment.byteLength\n  }\n  return byteLength\n}\n\n/**\n * @param {BufferSlice} buffer\n * @param {number} [startOffset]\n * @param {number} [endOffset]\n */\nexport const slice = (\n  buffer,\n  startOffset = 0,\n  endOffset = buffer.byteLength\n) => {\n  const segments = []\n  const start = startOffset < 0 ? buffer.byteLength - startOffset : startOffset\n  const end = endOffset < 0 ? buffer.byteLength - endOffset : endOffset\n\n  // If start at 0 offset and end is past buffer range it is effectively\n  // as same buffer.\n  if (start === 0 && end >= buffer.byteLength) {\n    return buffer\n  }\n\n  // If range is not within the current buffer just create an empty slice.\n  if (start > end || start > buffer.byteLength || end <= 0) {\n    return empty()\n  }\n\n  let byteLength = 0\n  let offset = 0\n  for (const segment of buffer.segments) {\n    const nextOffset = offset + segment.byteLength\n    // Have not found a start yet\n    if (byteLength === 0) {\n      // If end offset is within the current segment we know start is also,\n      // because it preceeds the end & we had not found start yet.\n      // In such case we create a view with only single segment of bytes\n      // in the range.\n      if (end <= nextOffset) {\n        const range = segment.subarray(start - offset, end - offset)\n        segments.push(range)\n        byteLength = range.byteLength\n        break\n      }\n      // If start offeset falls with in current range (but not the end)\n      // we save matching buffer slice and update byteLength.\n      else if (start < nextOffset) {\n        const range =\n          start === offset ? segment : segment.subarray(start - offset)\n        segments.push(range)\n        byteLength = range.byteLength\n      }\n    }\n    // Otherwise we already started collecting matching segments and are looking\n    // for the end end of the slice. If it is with in the current range capture\n    // the segment and create a view.\n    else if (end <= nextOffset) {\n      const range =\n        end === nextOffset ? segment : segment.subarray(0, end - offset)\n      segments.push(range)\n      byteLength += range.byteLength\n      break\n    }\n    // If end is past current range we just save the segment and continue.\n    else {\n      segments.push(segment)\n      byteLength += segment.byteLength\n    }\n\n    offset = nextOffset\n  }\n\n  return new BufferView(segments, buffer.byteOffset + start, byteLength)\n}\n\n/**\n * @param {BufferSlice} buffer\n * @param {Uint8Array} part\n */\n\nexport const push = (buffer, part) => {\n  if (part.byteLength > 0) {\n    // We MUTATE here but that is ok because it is out of bound for the passed\n    // buffer view so there will be no visible side effects.\n    buffer.segments.push(part)\n    return new BufferView(\n      buffer.segments,\n      buffer.byteOffset,\n      buffer.byteLength + part.byteLength\n    )\n  } else {\n    return buffer\n  }\n}\n\n/**\n * @param {BufferSlice} buffer\n * @param {number} n\n */\nexport const get = (buffer, n) => {\n  if (n < buffer.byteLength) {\n    let offset = 0\n    for (const segment of buffer.segments) {\n      if (n < offset + segment.byteLength) {\n        return segment[n - offset]\n      } else {\n        offset += segment.byteLength\n      }\n    }\n  }\n\n  return undefined\n}\n\n/**\n *\n * @param {BufferView} buffer\n * @param {Uint8Array} target\n * @param {number} byteOffset\n */\nexport const copyTo = (buffer, target, byteOffset) => {\n  let offset = byteOffset\n  for (const segment of buffer.segments) {\n    target.set(segment, offset)\n    offset += segment.byteLength\n  }\n\n  return target\n}\n\n/**\n *\n * @param {BufferView} buffer\n */\nexport function* iterate(buffer) {\n  for (const part of buffer.segments) {\n    yield* part\n  }\n}\n\n/**\n * @extends {Indexed<number>}\n */\nclass BufferView extends Indexed {\n  /**\n   * @param {Uint8Array[]} segments\n   * @param {number} byteOffset\n   * @param {number} byteLength\n   */\n  constructor(segments = [], byteOffset = 0, byteLength = 0) {\n    super()\n    /** @hide */\n    this.segments = segments\n    /** @readonly */\n    this.byteLength = byteLength\n    /** @readonly */\n    this.length = byteLength\n    /** @readonly */\n    this.byteOffset = byteOffset\n  }\n\n  [Symbol.iterator]() {\n    return iterate(this)\n  }\n\n  /**\n   * @param {number} [start]\n   * @param {number} [end]\n   */\n  slice(start, end) {\n    return /** @type {BufferView} */ (slice(this, start, end))\n  }\n\n  /**\n   * @param {number} [start]\n   * @param {number} [end]\n   */\n  subarray(start, end) {\n    return /** @type {BufferView} */ (slice(this, start, end))\n  }\n\n  /**\n   *\n   * @param {Uint8Array} bytes\n   */\n  push(bytes) {\n    return /** @type {BufferView} */ (push(this, bytes))\n  }\n\n  /**\n   * @param {number} n\n   */\n  get(n) {\n    return get(this, n)\n  }\n\n  /**\n   *\n   * @param {Uint8Array} target\n   * @param {number} offset\n   */\n  copyTo(target, offset) {\n    return copyTo(this, target, offset)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}