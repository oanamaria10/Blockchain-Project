{"ast":null,"code":"'use strict';\n\nvar STREAM = require('stream'),\n  UTIL = require('util'),\n  StringDecoder = require('string_decoder').StringDecoder;\nfunction MemoryReadableStream(data, options) {\n  if (!(this instanceof MemoryReadableStream)) return new MemoryReadableStream(data, options);\n  MemoryReadableStream.super_.call(this, options);\n  this.init(data, options);\n}\nUTIL.inherits(MemoryReadableStream, STREAM.Readable);\nfunction MemoryWritableStream(data, options) {\n  if (!(this instanceof MemoryWritableStream)) return new MemoryWritableStream(data, options);\n  MemoryWritableStream.super_.call(this, options);\n  this.init(data, options);\n}\nUTIL.inherits(MemoryWritableStream, STREAM.Writable);\nfunction MemoryDuplexStream(data, options) {\n  if (!(this instanceof MemoryDuplexStream)) return new MemoryDuplexStream(data, options);\n  MemoryDuplexStream.super_.call(this, options);\n  this.init(data, options);\n}\nUTIL.inherits(MemoryDuplexStream, STREAM.Duplex);\nMemoryReadableStream.prototype.init = MemoryWritableStream.prototype.init = MemoryDuplexStream.prototype.init = function init(data, options) {\n  var self = this;\n  this.queue = [];\n  if (data) {\n    if (!Array.isArray(data)) {\n      data = [data];\n    }\n    data.forEach(function (chunk) {\n      if (!(chunk instanceof Buffer)) {\n        chunk = new Buffer(chunk);\n      }\n      self.queue.push(chunk);\n    });\n  }\n  options = options || {};\n  this.maxbufsize = options.hasOwnProperty('maxbufsize') ? options.maxbufsize : null;\n  this.bufoverflow = options.hasOwnProperty('bufoverflow') ? options.bufoverflow : null;\n  this.frequence = options.hasOwnProperty('frequence') ? options.frequence : null;\n};\nfunction MemoryStream(data, options) {\n  if (!(this instanceof MemoryStream)) return new MemoryStream(data, options);\n  options = options || {};\n  var readable = options.hasOwnProperty('readable') ? options.readable : true,\n    writable = options.hasOwnProperty('writable') ? options.writable : true;\n  if (readable && writable) {\n    return new MemoryDuplexStream(data, options);\n  } else if (readable) {\n    return new MemoryReadableStream(data, options);\n  } else if (writable) {\n    return new MemoryWritableStream(data, options);\n  } else {\n    throw new Error(\"Unknown stream type  Readable, Writable or Duplex \");\n  }\n}\nMemoryStream.createReadStream = function (data, options) {\n  options = options || {};\n  options.readable = true;\n  options.writable = false;\n  return new MemoryStream(data, options);\n};\nMemoryStream.createWriteStream = function (data, options) {\n  options = options || {};\n  options.readable = false;\n  options.writable = true;\n  return new MemoryStream(data, options);\n};\nMemoryReadableStream.prototype._read = MemoryDuplexStream.prototype._read = function _read(n) {\n  var self = this,\n    frequence = self.frequence || 0,\n    wait_data = this instanceof STREAM.Duplex && !this._writableState.finished ? true : false;\n  if (!this.queue.length && !wait_data) {\n    this.push(null); // finish stream\n  } else if (this.queue.length) {\n    setTimeout(function () {\n      if (self.queue.length) {\n        var chunk = self.queue.shift();\n        if (chunk && !self._readableState.ended) {\n          if (!self.push(chunk)) {\n            self.queue.unshift(chunk);\n          }\n        }\n      }\n    }, frequence);\n  }\n};\nMemoryWritableStream.prototype._write = MemoryDuplexStream.prototype._write = function _write(chunk, encoding, cb) {\n  var decoder = null;\n  try {\n    decoder = this.decodeStrings && encoding ? new StringDecoder(encoding) : null;\n  } catch (err) {\n    return cb(err);\n  }\n  var decoded_chunk = decoder ? decoder.write(chunk) : chunk,\n    queue_size = this._getQueueSize(),\n    chunk_size = decoded_chunk.length;\n  if (this.maxbufsize && queue_size + chunk_size > this.maxbufsize) {\n    if (this.bufoverflow) {\n      return cb(\"Buffer overflowed (\" + this.bufoverflow + \"/\" + queue_size + \")\");\n    } else {\n      return cb();\n    }\n  }\n  if (this instanceof STREAM.Duplex) {\n    while (this.queue.length) {\n      this.push(this.queue.shift());\n    }\n    this.push(decoded_chunk);\n  } else {\n    this.queue.push(decoded_chunk);\n  }\n  cb();\n};\nMemoryDuplexStream.prototype.end = function (chunk, encoding, cb) {\n  var self = this;\n  return MemoryDuplexStream.super_.prototype.end.call(this, chunk, encoding, function () {\n    self.push(null); //finish readble stream too\n    if (cb) cb();\n  });\n};\nMemoryReadableStream.prototype._getQueueSize = MemoryWritableStream.prototype._getQueueSize = MemoryDuplexStream.prototype._getQueueSize = function () {\n  var queuesize = 0,\n    i;\n  for (i = 0; i < this.queue.length; i++) {\n    queuesize += Array.isArray(this.queue[i]) ? this.queue[i][0].length : this.queue[i].length;\n  }\n  return queuesize;\n};\nMemoryWritableStream.prototype.toString = MemoryDuplexStream.prototype.toString = MemoryReadableStream.prototype.toString = MemoryWritableStream.prototype.getAll = MemoryDuplexStream.prototype.getAll = MemoryReadableStream.prototype.getAll = function () {\n  var self = this,\n    ret = '';\n  this.queue.forEach(function (data) {\n    ret += data;\n  });\n  return ret;\n};\nMemoryWritableStream.prototype.toBuffer = MemoryDuplexStream.prototype.toBuffer = MemoryReadableStream.prototype.toBuffer = function () {\n  var buffer = new Buffer(this._getQueueSize()),\n    currentOffset = 0;\n  this.queue.forEach(function (data) {\n    var data_buffer = data instanceof Buffer ? data : new Buffer(data);\n    data_buffer.copy(buffer, currentOffset);\n    currentOffset += data.length;\n  });\n  return buffer;\n};\nmodule.exports = MemoryStream;","map":{"version":3,"names":["STREAM","require","UTIL","StringDecoder","MemoryReadableStream","data","options","super_","call","init","inherits","Readable","MemoryWritableStream","Writable","MemoryDuplexStream","Duplex","prototype","self","queue","Array","isArray","forEach","chunk","Buffer","push","maxbufsize","hasOwnProperty","bufoverflow","frequence","MemoryStream","readable","writable","Error","createReadStream","createWriteStream","_read","n","wait_data","_writableState","finished","length","setTimeout","shift","_readableState","ended","unshift","_write","encoding","cb","decoder","decodeStrings","err","decoded_chunk","write","queue_size","_getQueueSize","chunk_size","end","queuesize","i","toString","getAll","ret","toBuffer","buffer","currentOffset","data_buffer","copy","module","exports"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/memorystream/index.js"],"sourcesContent":["'use strict';\n\nvar STREAM = require('stream'),\n    UTIL = require('util'),\n    StringDecoder = require('string_decoder').StringDecoder;\n\nfunction MemoryReadableStream(data, options) {\n    if (!(this instanceof MemoryReadableStream))\n        return new MemoryReadableStream(data, options);\n    MemoryReadableStream.super_.call(this, options);\n    this.init(data, options);\n}\nUTIL.inherits(MemoryReadableStream, STREAM.Readable);\n\n\nfunction MemoryWritableStream(data, options) {\n    if (!(this instanceof MemoryWritableStream))\n        return new MemoryWritableStream(data, options);\n    MemoryWritableStream.super_.call(this, options);\n    this.init(data, options);\n}\nUTIL.inherits(MemoryWritableStream, STREAM.Writable);\n\n\nfunction MemoryDuplexStream(data, options) {\n    if (!(this instanceof MemoryDuplexStream))\n        return new MemoryDuplexStream(data, options);\n    MemoryDuplexStream.super_.call(this, options);\n    this.init(data, options);\n}\nUTIL.inherits(MemoryDuplexStream, STREAM.Duplex);\n\n\nMemoryReadableStream.prototype.init =\nMemoryWritableStream.prototype.init =\nMemoryDuplexStream.prototype.init = function init (data, options) {\n    var self = this;\n    this.queue = [];\n\n    if (data) {\n        if (!Array.isArray(data)) {\n            data = [ data ];\n        }\n\n        data.forEach(function (chunk) {\n            if (!(chunk instanceof Buffer)) {\n                chunk = new Buffer(chunk);\n            }\n            self.queue.push(chunk);\n        });\n\n    }\n    \n    options = options || {};\n    \n    this.maxbufsize = options.hasOwnProperty('maxbufsize') ? options.maxbufsize\n            : null;\n    this.bufoverflow = options.hasOwnProperty('bufoverflow') ? options.bufoverflow\n            : null;\n    this.frequence = options.hasOwnProperty('frequence') ? options.frequence\n            : null;\n};\n\nfunction MemoryStream (data, options) {\n    if (!(this instanceof MemoryStream))\n        return new MemoryStream(data, options);\n    \n    options = options || {};\n    \n    var readable = options.hasOwnProperty('readable') ? options.readable : true,\n        writable = options.hasOwnProperty('writable') ? options.writable : true;\n    \n    if (readable && writable) {\n        return new MemoryDuplexStream(data, options);\n    } else if (readable) {\n        return new MemoryReadableStream(data, options);\n    } else if (writable) {\n        return new MemoryWritableStream(data, options);\n    } else {\n        throw new Error(\"Unknown stream type  Readable, Writable or Duplex \");\n    }\n}\n\n\nMemoryStream.createReadStream = function (data, options) {\n    options = options || {};\n    options.readable = true;\n    options.writable = false;\n\n    return new MemoryStream(data, options);\n};\n\n\nMemoryStream.createWriteStream = function (data, options) {\n    options = options || {};\n    options.readable = false;\n    options.writable = true;\n\n    return new MemoryStream(data, options);\n};\n\n\nMemoryReadableStream.prototype._read =\nMemoryDuplexStream.prototype._read = function _read (n) {\n    var self = this,\n        frequence = self.frequence || 0,\n        wait_data = this instanceof STREAM.Duplex && ! this._writableState.finished ? true : false;\n    if ( ! this.queue.length && ! wait_data) {\n        this.push(null);// finish stream\n    } else if (this.queue.length) {\n        setTimeout(function () {\n            if (self.queue.length) {\n                var chunk = self.queue.shift();\n                if (chunk && ! self._readableState.ended) {\n                    if ( ! self.push(chunk) ) {\n                        self.queue.unshift(chunk);\n                    }\n                }\n            }\n        }, frequence);\n    }\n};\n\n\nMemoryWritableStream.prototype._write =\nMemoryDuplexStream.prototype._write = function _write (chunk, encoding, cb) {\n    var decoder = null;\n    try {\n        decoder = this.decodeStrings && encoding ? new StringDecoder(encoding) : null;\n    } catch (err){\n        return cb(err);\n    }\n    \n    var decoded_chunk = decoder ? decoder.write(chunk) : chunk,\n        queue_size = this._getQueueSize(),\n        chunk_size = decoded_chunk.length;\n    \n    if (this.maxbufsize && (queue_size + chunk_size) > this.maxbufsize ) {\n        if (this.bufoverflow) {\n            return cb(\"Buffer overflowed (\" + this.bufoverflow + \"/\" + queue_size + \")\");\n        } else {\n            return cb();\n        }\n    }\n    \n    if (this instanceof STREAM.Duplex) {\n        while (this.queue.length) {\n            this.push(this.queue.shift());\n        }\n        this.push(decoded_chunk);\n    } else {\n        this.queue.push(decoded_chunk);\n    }\n    cb();\n};\n\n\nMemoryDuplexStream.prototype.end = function (chunk, encoding, cb) {\n    var self = this;\n    return MemoryDuplexStream.super_.prototype.end.call(this, chunk, encoding, function () {\n        self.push(null);//finish readble stream too\n        if (cb) cb();\n    });\n};\n\n\nMemoryReadableStream.prototype._getQueueSize =  \nMemoryWritableStream.prototype._getQueueSize = \nMemoryDuplexStream.prototype._getQueueSize = function () {\n    var queuesize = 0, i;\n    for (i = 0; i < this.queue.length; i++) {\n        queuesize += Array.isArray(this.queue[i]) ? this.queue[i][0].length\n                : this.queue[i].length;\n    }\n    return queuesize;\n};\n\n\nMemoryWritableStream.prototype.toString = \nMemoryDuplexStream.prototype.toString = \nMemoryReadableStream.prototype.toString = \nMemoryWritableStream.prototype.getAll = \nMemoryDuplexStream.prototype.getAll = \nMemoryReadableStream.prototype.getAll = function () {\n    var self = this,\n        ret = '';\n    this.queue.forEach(function (data) {\n        ret += data;\n    });\n    return ret;\n};\n\n\nMemoryWritableStream.prototype.toBuffer = \nMemoryDuplexStream.prototype.toBuffer = \nMemoryReadableStream.prototype.toBuffer = function () {\n    var buffer = new Buffer(this._getQueueSize()),\n        currentOffset = 0;\n\n    this.queue.forEach(function (data) {\n        var data_buffer = data instanceof Buffer ? data : new Buffer(data);\n        data_buffer.copy(buffer, currentOffset);\n        currentOffset += data.length;\n    });\n    return buffer;\n};\n\n\nmodule.exports = MemoryStream;\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC;EAC1BC,IAAI,GAAGD,OAAO,CAAC,MAAM,CAAC;EACtBE,aAAa,GAAGF,OAAO,CAAC,gBAAgB,CAAC,CAACE,aAAa;AAE3D,SAASC,oBAAoBA,CAACC,IAAI,EAAEC,OAAO,EAAE;EACzC,IAAI,EAAE,IAAI,YAAYF,oBAAoB,CAAC,EACvC,OAAO,IAAIA,oBAAoB,CAACC,IAAI,EAAEC,OAAO,CAAC;EAClDF,oBAAoB,CAACG,MAAM,CAACC,IAAI,CAAC,IAAI,EAAEF,OAAO,CAAC;EAC/C,IAAI,CAACG,IAAI,CAACJ,IAAI,EAAEC,OAAO,CAAC;AAC5B;AACAJ,IAAI,CAACQ,QAAQ,CAACN,oBAAoB,EAAEJ,MAAM,CAACW,QAAQ,CAAC;AAGpD,SAASC,oBAAoBA,CAACP,IAAI,EAAEC,OAAO,EAAE;EACzC,IAAI,EAAE,IAAI,YAAYM,oBAAoB,CAAC,EACvC,OAAO,IAAIA,oBAAoB,CAACP,IAAI,EAAEC,OAAO,CAAC;EAClDM,oBAAoB,CAACL,MAAM,CAACC,IAAI,CAAC,IAAI,EAAEF,OAAO,CAAC;EAC/C,IAAI,CAACG,IAAI,CAACJ,IAAI,EAAEC,OAAO,CAAC;AAC5B;AACAJ,IAAI,CAACQ,QAAQ,CAACE,oBAAoB,EAAEZ,MAAM,CAACa,QAAQ,CAAC;AAGpD,SAASC,kBAAkBA,CAACT,IAAI,EAAEC,OAAO,EAAE;EACvC,IAAI,EAAE,IAAI,YAAYQ,kBAAkB,CAAC,EACrC,OAAO,IAAIA,kBAAkB,CAACT,IAAI,EAAEC,OAAO,CAAC;EAChDQ,kBAAkB,CAACP,MAAM,CAACC,IAAI,CAAC,IAAI,EAAEF,OAAO,CAAC;EAC7C,IAAI,CAACG,IAAI,CAACJ,IAAI,EAAEC,OAAO,CAAC;AAC5B;AACAJ,IAAI,CAACQ,QAAQ,CAACI,kBAAkB,EAAEd,MAAM,CAACe,MAAM,CAAC;AAGhDX,oBAAoB,CAACY,SAAS,CAACP,IAAI,GACnCG,oBAAoB,CAACI,SAAS,CAACP,IAAI,GACnCK,kBAAkB,CAACE,SAAS,CAACP,IAAI,GAAG,SAASA,IAAIA,CAAEJ,IAAI,EAAEC,OAAO,EAAE;EAC9D,IAAIW,IAAI,GAAG,IAAI;EACf,IAAI,CAACC,KAAK,GAAG,EAAE;EAEf,IAAIb,IAAI,EAAE;IACN,IAAI,CAACc,KAAK,CAACC,OAAO,CAACf,IAAI,CAAC,EAAE;MACtBA,IAAI,GAAG,CAAEA,IAAI,CAAE;IACnB;IAEAA,IAAI,CAACgB,OAAO,CAAC,UAAUC,KAAK,EAAE;MAC1B,IAAI,EAAEA,KAAK,YAAYC,MAAM,CAAC,EAAE;QAC5BD,KAAK,GAAG,IAAIC,MAAM,CAACD,KAAK,CAAC;MAC7B;MACAL,IAAI,CAACC,KAAK,CAACM,IAAI,CAACF,KAAK,CAAC;IAC1B,CAAC,CAAC;EAEN;EAEAhB,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EAEvB,IAAI,CAACmB,UAAU,GAAGnB,OAAO,CAACoB,cAAc,CAAC,YAAY,CAAC,GAAGpB,OAAO,CAACmB,UAAU,GACjE,IAAI;EACd,IAAI,CAACE,WAAW,GAAGrB,OAAO,CAACoB,cAAc,CAAC,aAAa,CAAC,GAAGpB,OAAO,CAACqB,WAAW,GACpE,IAAI;EACd,IAAI,CAACC,SAAS,GAAGtB,OAAO,CAACoB,cAAc,CAAC,WAAW,CAAC,GAAGpB,OAAO,CAACsB,SAAS,GAC9D,IAAI;AAClB,CAAC;AAED,SAASC,YAAYA,CAAExB,IAAI,EAAEC,OAAO,EAAE;EAClC,IAAI,EAAE,IAAI,YAAYuB,YAAY,CAAC,EAC/B,OAAO,IAAIA,YAAY,CAACxB,IAAI,EAAEC,OAAO,CAAC;EAE1CA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EAEvB,IAAIwB,QAAQ,GAAGxB,OAAO,CAACoB,cAAc,CAAC,UAAU,CAAC,GAAGpB,OAAO,CAACwB,QAAQ,GAAG,IAAI;IACvEC,QAAQ,GAAGzB,OAAO,CAACoB,cAAc,CAAC,UAAU,CAAC,GAAGpB,OAAO,CAACyB,QAAQ,GAAG,IAAI;EAE3E,IAAID,QAAQ,IAAIC,QAAQ,EAAE;IACtB,OAAO,IAAIjB,kBAAkB,CAACT,IAAI,EAAEC,OAAO,CAAC;EAChD,CAAC,MAAM,IAAIwB,QAAQ,EAAE;IACjB,OAAO,IAAI1B,oBAAoB,CAACC,IAAI,EAAEC,OAAO,CAAC;EAClD,CAAC,MAAM,IAAIyB,QAAQ,EAAE;IACjB,OAAO,IAAInB,oBAAoB,CAACP,IAAI,EAAEC,OAAO,CAAC;EAClD,CAAC,MAAM;IACH,MAAM,IAAI0B,KAAK,CAAC,oDAAoD,CAAC;EACzE;AACJ;AAGAH,YAAY,CAACI,gBAAgB,GAAG,UAAU5B,IAAI,EAAEC,OAAO,EAAE;EACrDA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACvBA,OAAO,CAACwB,QAAQ,GAAG,IAAI;EACvBxB,OAAO,CAACyB,QAAQ,GAAG,KAAK;EAExB,OAAO,IAAIF,YAAY,CAACxB,IAAI,EAAEC,OAAO,CAAC;AAC1C,CAAC;AAGDuB,YAAY,CAACK,iBAAiB,GAAG,UAAU7B,IAAI,EAAEC,OAAO,EAAE;EACtDA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACvBA,OAAO,CAACwB,QAAQ,GAAG,KAAK;EACxBxB,OAAO,CAACyB,QAAQ,GAAG,IAAI;EAEvB,OAAO,IAAIF,YAAY,CAACxB,IAAI,EAAEC,OAAO,CAAC;AAC1C,CAAC;AAGDF,oBAAoB,CAACY,SAAS,CAACmB,KAAK,GACpCrB,kBAAkB,CAACE,SAAS,CAACmB,KAAK,GAAG,SAASA,KAAKA,CAAEC,CAAC,EAAE;EACpD,IAAInB,IAAI,GAAG,IAAI;IACXW,SAAS,GAAGX,IAAI,CAACW,SAAS,IAAI,CAAC;IAC/BS,SAAS,GAAG,IAAI,YAAYrC,MAAM,CAACe,MAAM,IAAI,CAAE,IAAI,CAACuB,cAAc,CAACC,QAAQ,GAAG,IAAI,GAAG,KAAK;EAC9F,IAAK,CAAE,IAAI,CAACrB,KAAK,CAACsB,MAAM,IAAI,CAAEH,SAAS,EAAE;IACrC,IAAI,CAACb,IAAI,CAAC,IAAI,CAAC,CAAC;EACpB,CAAC,MAAM,IAAI,IAAI,CAACN,KAAK,CAACsB,MAAM,EAAE;IAC1BC,UAAU,CAAC,YAAY;MACnB,IAAIxB,IAAI,CAACC,KAAK,CAACsB,MAAM,EAAE;QACnB,IAAIlB,KAAK,GAAGL,IAAI,CAACC,KAAK,CAACwB,KAAK,CAAC,CAAC;QAC9B,IAAIpB,KAAK,IAAI,CAAEL,IAAI,CAAC0B,cAAc,CAACC,KAAK,EAAE;UACtC,IAAK,CAAE3B,IAAI,CAACO,IAAI,CAACF,KAAK,CAAC,EAAG;YACtBL,IAAI,CAACC,KAAK,CAAC2B,OAAO,CAACvB,KAAK,CAAC;UAC7B;QACJ;MACJ;IACJ,CAAC,EAAEM,SAAS,CAAC;EACjB;AACJ,CAAC;AAGDhB,oBAAoB,CAACI,SAAS,CAAC8B,MAAM,GACrChC,kBAAkB,CAACE,SAAS,CAAC8B,MAAM,GAAG,SAASA,MAAMA,CAAExB,KAAK,EAAEyB,QAAQ,EAAEC,EAAE,EAAE;EACxE,IAAIC,OAAO,GAAG,IAAI;EAClB,IAAI;IACAA,OAAO,GAAG,IAAI,CAACC,aAAa,IAAIH,QAAQ,GAAG,IAAI5C,aAAa,CAAC4C,QAAQ,CAAC,GAAG,IAAI;EACjF,CAAC,CAAC,OAAOI,GAAG,EAAC;IACT,OAAOH,EAAE,CAACG,GAAG,CAAC;EAClB;EAEA,IAAIC,aAAa,GAAGH,OAAO,GAAGA,OAAO,CAACI,KAAK,CAAC/B,KAAK,CAAC,GAAGA,KAAK;IACtDgC,UAAU,GAAG,IAAI,CAACC,aAAa,CAAC,CAAC;IACjCC,UAAU,GAAGJ,aAAa,CAACZ,MAAM;EAErC,IAAI,IAAI,CAACf,UAAU,IAAK6B,UAAU,GAAGE,UAAU,GAAI,IAAI,CAAC/B,UAAU,EAAG;IACjE,IAAI,IAAI,CAACE,WAAW,EAAE;MAClB,OAAOqB,EAAE,CAAC,qBAAqB,GAAG,IAAI,CAACrB,WAAW,GAAG,GAAG,GAAG2B,UAAU,GAAG,GAAG,CAAC;IAChF,CAAC,MAAM;MACH,OAAON,EAAE,CAAC,CAAC;IACf;EACJ;EAEA,IAAI,IAAI,YAAYhD,MAAM,CAACe,MAAM,EAAE;IAC/B,OAAO,IAAI,CAACG,KAAK,CAACsB,MAAM,EAAE;MACtB,IAAI,CAAChB,IAAI,CAAC,IAAI,CAACN,KAAK,CAACwB,KAAK,CAAC,CAAC,CAAC;IACjC;IACA,IAAI,CAAClB,IAAI,CAAC4B,aAAa,CAAC;EAC5B,CAAC,MAAM;IACH,IAAI,CAAClC,KAAK,CAACM,IAAI,CAAC4B,aAAa,CAAC;EAClC;EACAJ,EAAE,CAAC,CAAC;AACR,CAAC;AAGDlC,kBAAkB,CAACE,SAAS,CAACyC,GAAG,GAAG,UAAUnC,KAAK,EAAEyB,QAAQ,EAAEC,EAAE,EAAE;EAC9D,IAAI/B,IAAI,GAAG,IAAI;EACf,OAAOH,kBAAkB,CAACP,MAAM,CAACS,SAAS,CAACyC,GAAG,CAACjD,IAAI,CAAC,IAAI,EAAEc,KAAK,EAAEyB,QAAQ,EAAE,YAAY;IACnF9B,IAAI,CAACO,IAAI,CAAC,IAAI,CAAC,CAAC;IAChB,IAAIwB,EAAE,EAAEA,EAAE,CAAC,CAAC;EAChB,CAAC,CAAC;AACN,CAAC;AAGD5C,oBAAoB,CAACY,SAAS,CAACuC,aAAa,GAC5C3C,oBAAoB,CAACI,SAAS,CAACuC,aAAa,GAC5CzC,kBAAkB,CAACE,SAAS,CAACuC,aAAa,GAAG,YAAY;EACrD,IAAIG,SAAS,GAAG,CAAC;IAAEC,CAAC;EACpB,KAAKA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACzC,KAAK,CAACsB,MAAM,EAAEmB,CAAC,EAAE,EAAE;IACpCD,SAAS,IAAIvC,KAAK,CAACC,OAAO,CAAC,IAAI,CAACF,KAAK,CAACyC,CAAC,CAAC,CAAC,GAAG,IAAI,CAACzC,KAAK,CAACyC,CAAC,CAAC,CAAC,CAAC,CAAC,CAACnB,MAAM,GACzD,IAAI,CAACtB,KAAK,CAACyC,CAAC,CAAC,CAACnB,MAAM;EAClC;EACA,OAAOkB,SAAS;AACpB,CAAC;AAGD9C,oBAAoB,CAACI,SAAS,CAAC4C,QAAQ,GACvC9C,kBAAkB,CAACE,SAAS,CAAC4C,QAAQ,GACrCxD,oBAAoB,CAACY,SAAS,CAAC4C,QAAQ,GACvChD,oBAAoB,CAACI,SAAS,CAAC6C,MAAM,GACrC/C,kBAAkB,CAACE,SAAS,CAAC6C,MAAM,GACnCzD,oBAAoB,CAACY,SAAS,CAAC6C,MAAM,GAAG,YAAY;EAChD,IAAI5C,IAAI,GAAG,IAAI;IACX6C,GAAG,GAAG,EAAE;EACZ,IAAI,CAAC5C,KAAK,CAACG,OAAO,CAAC,UAAUhB,IAAI,EAAE;IAC/ByD,GAAG,IAAIzD,IAAI;EACf,CAAC,CAAC;EACF,OAAOyD,GAAG;AACd,CAAC;AAGDlD,oBAAoB,CAACI,SAAS,CAAC+C,QAAQ,GACvCjD,kBAAkB,CAACE,SAAS,CAAC+C,QAAQ,GACrC3D,oBAAoB,CAACY,SAAS,CAAC+C,QAAQ,GAAG,YAAY;EAClD,IAAIC,MAAM,GAAG,IAAIzC,MAAM,CAAC,IAAI,CAACgC,aAAa,CAAC,CAAC,CAAC;IACzCU,aAAa,GAAG,CAAC;EAErB,IAAI,CAAC/C,KAAK,CAACG,OAAO,CAAC,UAAUhB,IAAI,EAAE;IAC/B,IAAI6D,WAAW,GAAG7D,IAAI,YAAYkB,MAAM,GAAGlB,IAAI,GAAG,IAAIkB,MAAM,CAAClB,IAAI,CAAC;IAClE6D,WAAW,CAACC,IAAI,CAACH,MAAM,EAAEC,aAAa,CAAC;IACvCA,aAAa,IAAI5D,IAAI,CAACmC,MAAM;EAChC,CAAC,CAAC;EACF,OAAOwB,MAAM;AACjB,CAAC;AAGDI,MAAM,CAACC,OAAO,GAAGxC,YAAY","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}