{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SolidityTracer = void 0;\nconst ethereumjs_util_1 = require(\"@nomicfoundation/ethereumjs-util\");\nconst return_data_1 = require(\"../provider/return-data\");\nconst exit_1 = require(\"../provider/vm/exit\");\nconst error_inferrer_1 = require(\"./error-inferrer\");\nconst mapped_inlined_internal_functions_heuristics_1 = require(\"./mapped-inlined-internal-functions-heuristics\");\nconst message_trace_1 = require(\"./message-trace\");\nconst model_1 = require(\"./model\");\nconst opcodes_1 = require(\"./opcodes\");\nconst solidity_stack_trace_1 = require(\"./solidity-stack-trace\");\nclass SolidityTracer {\n  constructor() {\n    this._errorInferrer = new error_inferrer_1.ErrorInferrer();\n  }\n  getStackTrace(maybeDecodedMessageTrace) {\n    if (!maybeDecodedMessageTrace.exit.isError()) {\n      return [];\n    }\n    if ((0, message_trace_1.isPrecompileTrace)(maybeDecodedMessageTrace)) {\n      return this._getPrecompileMessageStackTrace(maybeDecodedMessageTrace);\n    }\n    if ((0, message_trace_1.isDecodedCreateTrace)(maybeDecodedMessageTrace)) {\n      return this._getCreateMessageStackTrace(maybeDecodedMessageTrace);\n    }\n    if ((0, message_trace_1.isDecodedCallTrace)(maybeDecodedMessageTrace)) {\n      return this._getCallMessageStackTrace(maybeDecodedMessageTrace);\n    }\n    return this._getUnrecognizedMessageStackTrace(maybeDecodedMessageTrace);\n  }\n  _getCallMessageStackTrace(trace) {\n    const inferredError = this._errorInferrer.inferBeforeTracingCallMessage(trace);\n    if (inferredError !== undefined) {\n      return inferredError;\n    }\n    return this._traceEvmExecution(trace);\n  }\n  _getUnrecognizedMessageStackTrace(trace) {\n    const subtrace = this._getLastSubtrace(trace);\n    if (subtrace !== undefined) {\n      // This is not a very exact heuristic, but most of the time it will be right, as solidity\n      // reverts if a call fails, and most contracts are in solidity\n      if (subtrace.exit.isError() && (0, ethereumjs_util_1.equalsBytes)(trace.returnData, subtrace.returnData)) {\n        let unrecognizedEntry;\n        if ((0, message_trace_1.isCreateTrace)(trace)) {\n          unrecognizedEntry = {\n            type: solidity_stack_trace_1.StackTraceEntryType.UNRECOGNIZED_CREATE_CALLSTACK_ENTRY\n          };\n        } else {\n          unrecognizedEntry = {\n            type: solidity_stack_trace_1.StackTraceEntryType.UNRECOGNIZED_CONTRACT_CALLSTACK_ENTRY,\n            address: trace.address\n          };\n        }\n        return [unrecognizedEntry, ...this.getStackTrace(subtrace)];\n      }\n    }\n    if (trace.exit.kind === exit_1.ExitCode.CODESIZE_EXCEEDS_MAXIMUM) {\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.CONTRACT_TOO_LARGE_ERROR\n      }];\n    }\n    const isInvalidOpcodeError = trace.exit.kind === exit_1.ExitCode.INVALID_OPCODE;\n    if ((0, message_trace_1.isCreateTrace)(trace)) {\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.UNRECOGNIZED_CREATE_ERROR,\n        message: new return_data_1.ReturnData(trace.returnData),\n        isInvalidOpcodeError\n      }];\n    }\n    return [{\n      type: solidity_stack_trace_1.StackTraceEntryType.UNRECOGNIZED_CONTRACT_ERROR,\n      address: trace.address,\n      message: new return_data_1.ReturnData(trace.returnData),\n      isInvalidOpcodeError\n    }];\n  }\n  _getCreateMessageStackTrace(trace) {\n    const inferredError = this._errorInferrer.inferBeforeTracingCreateMessage(trace);\n    if (inferredError !== undefined) {\n      return inferredError;\n    }\n    return this._traceEvmExecution(trace);\n  }\n  _getPrecompileMessageStackTrace(trace) {\n    return [{\n      type: solidity_stack_trace_1.StackTraceEntryType.PRECOMPILE_ERROR,\n      precompile: trace.precompile\n    }];\n  }\n  _traceEvmExecution(trace) {\n    const stackTrace = this._rawTraceEvmExecution(trace);\n    if ((0, mapped_inlined_internal_functions_heuristics_1.stackTraceMayRequireAdjustments)(stackTrace, trace)) {\n      return (0, mapped_inlined_internal_functions_heuristics_1.adjustStackTrace)(stackTrace, trace);\n    }\n    return stackTrace;\n  }\n  _rawTraceEvmExecution(trace) {\n    const stacktrace = [];\n    let subtracesSeen = 0;\n    // There was a jump into a function according to the sourcemaps\n    let jumpedIntoFunction = false;\n    const functionJumpdests = [];\n    let lastSubmessageData;\n    for (let stepIndex = 0; stepIndex < trace.steps.length; stepIndex++) {\n      const step = trace.steps[stepIndex];\n      const nextStep = trace.steps[stepIndex + 1];\n      if ((0, message_trace_1.isEvmStep)(step)) {\n        const inst = trace.bytecode.getInstruction(step.pc);\n        if (inst.jumpType === model_1.JumpType.INTO_FUNCTION && nextStep !== undefined) {\n          const nextEvmStep = nextStep; // A jump can't be followed by a subtrace\n          const nextInst = trace.bytecode.getInstruction(nextEvmStep.pc);\n          if (nextInst !== undefined && nextInst.opcode === opcodes_1.Opcode.JUMPDEST) {\n            stacktrace.push((0, error_inferrer_1.instructionToCallstackStackTraceEntry)(trace.bytecode, inst));\n            if (nextInst.location !== undefined) {\n              jumpedIntoFunction = true;\n            }\n            functionJumpdests.push(nextInst);\n          }\n        } else if (inst.jumpType === model_1.JumpType.OUTOF_FUNCTION) {\n          stacktrace.pop();\n          functionJumpdests.pop();\n        }\n      } else {\n        subtracesSeen += 1;\n        // If there are more subtraces, this one didn't terminate the execution\n        if (subtracesSeen < trace.numberOfSubtraces) {\n          continue;\n        }\n        const submessageTrace = this.getStackTrace(step);\n        lastSubmessageData = {\n          messageTrace: step,\n          stepIndex,\n          stacktrace: submessageTrace\n        };\n      }\n    }\n    const stacktraceWithInferredError = this._errorInferrer.inferAfterTracing(trace, stacktrace, functionJumpdests, jumpedIntoFunction, lastSubmessageData);\n    return this._errorInferrer.filterRedundantFrames(stacktraceWithInferredError);\n  }\n  _getLastSubtrace(trace) {\n    if (trace.numberOfSubtraces < 1) {\n      return undefined;\n    }\n    let i = trace.steps.length - 1;\n    while ((0, message_trace_1.isEvmStep)(trace.steps[i])) {\n      i -= 1;\n    }\n    return trace.steps[i];\n  }\n}\nexports.SolidityTracer = SolidityTracer;","map":{"version":3,"names":["ethereumjs_util_1","require","return_data_1","exit_1","error_inferrer_1","mapped_inlined_internal_functions_heuristics_1","message_trace_1","model_1","opcodes_1","solidity_stack_trace_1","SolidityTracer","constructor","_errorInferrer","ErrorInferrer","getStackTrace","maybeDecodedMessageTrace","exit","isError","isPrecompileTrace","_getPrecompileMessageStackTrace","isDecodedCreateTrace","_getCreateMessageStackTrace","isDecodedCallTrace","_getCallMessageStackTrace","_getUnrecognizedMessageStackTrace","trace","inferredError","inferBeforeTracingCallMessage","undefined","_traceEvmExecution","subtrace","_getLastSubtrace","equalsBytes","returnData","unrecognizedEntry","isCreateTrace","type","StackTraceEntryType","UNRECOGNIZED_CREATE_CALLSTACK_ENTRY","UNRECOGNIZED_CONTRACT_CALLSTACK_ENTRY","address","kind","ExitCode","CODESIZE_EXCEEDS_MAXIMUM","CONTRACT_TOO_LARGE_ERROR","isInvalidOpcodeError","INVALID_OPCODE","UNRECOGNIZED_CREATE_ERROR","message","ReturnData","UNRECOGNIZED_CONTRACT_ERROR","inferBeforeTracingCreateMessage","PRECOMPILE_ERROR","precompile","stackTrace","_rawTraceEvmExecution","stackTraceMayRequireAdjustments","adjustStackTrace","stacktrace","subtracesSeen","jumpedIntoFunction","functionJumpdests","lastSubmessageData","stepIndex","steps","length","step","nextStep","isEvmStep","inst","bytecode","getInstruction","pc","jumpType","JumpType","INTO_FUNCTION","nextEvmStep","nextInst","opcode","Opcode","JUMPDEST","push","instructionToCallstackStackTraceEntry","location","OUTOF_FUNCTION","pop","numberOfSubtraces","submessageTrace","messageTrace","stacktraceWithInferredError","inferAfterTracing","filterRedundantFrames","i","exports"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\internal\\hardhat-network\\stack-traces\\solidityTracer.ts"],"sourcesContent":["import { equalsBytes } from \"@nomicfoundation/ethereumjs-util\";\n\nimport { ReturnData } from \"../provider/return-data\";\nimport { ExitCode } from \"../provider/vm/exit\";\n\nimport {\n  ErrorInferrer,\n  instructionToCallstackStackTraceEntry,\n  SubmessageData,\n} from \"./error-inferrer\";\nimport {\n  adjustStackTrace,\n  stackTraceMayRequireAdjustments,\n} from \"./mapped-inlined-internal-functions-heuristics\";\nimport {\n  DecodedCallMessageTrace,\n  DecodedCreateMessageTrace,\n  DecodedEvmMessageTrace,\n  EvmMessageTrace,\n  EvmStep,\n  isCreateTrace,\n  isDecodedCallTrace,\n  isDecodedCreateTrace,\n  isEvmStep,\n  isPrecompileTrace,\n  MessageTrace,\n  PrecompileMessageTrace,\n} from \"./message-trace\";\nimport { Instruction, JumpType } from \"./model\";\nimport { Opcode } from \"./opcodes\";\nimport {\n  SolidityStackTrace,\n  SolidityStackTraceEntry,\n  StackTraceEntryType,\n} from \"./solidity-stack-trace\";\n\nexport class SolidityTracer {\n  private _errorInferrer = new ErrorInferrer();\n\n  public getStackTrace(\n    maybeDecodedMessageTrace: MessageTrace\n  ): SolidityStackTrace {\n    if (!maybeDecodedMessageTrace.exit.isError()) {\n      return [];\n    }\n\n    if (isPrecompileTrace(maybeDecodedMessageTrace)) {\n      return this._getPrecompileMessageStackTrace(maybeDecodedMessageTrace);\n    }\n\n    if (isDecodedCreateTrace(maybeDecodedMessageTrace)) {\n      return this._getCreateMessageStackTrace(maybeDecodedMessageTrace);\n    }\n\n    if (isDecodedCallTrace(maybeDecodedMessageTrace)) {\n      return this._getCallMessageStackTrace(maybeDecodedMessageTrace);\n    }\n\n    return this._getUnrecognizedMessageStackTrace(maybeDecodedMessageTrace);\n  }\n\n  private _getCallMessageStackTrace(\n    trace: DecodedCallMessageTrace\n  ): SolidityStackTrace {\n    const inferredError =\n      this._errorInferrer.inferBeforeTracingCallMessage(trace);\n\n    if (inferredError !== undefined) {\n      return inferredError;\n    }\n\n    return this._traceEvmExecution(trace);\n  }\n\n  private _getUnrecognizedMessageStackTrace(\n    trace: EvmMessageTrace\n  ): SolidityStackTrace {\n    const subtrace = this._getLastSubtrace(trace);\n\n    if (subtrace !== undefined) {\n      // This is not a very exact heuristic, but most of the time it will be right, as solidity\n      // reverts if a call fails, and most contracts are in solidity\n      if (\n        subtrace.exit.isError() &&\n        equalsBytes(trace.returnData, subtrace.returnData)\n      ) {\n        let unrecognizedEntry: SolidityStackTraceEntry;\n\n        if (isCreateTrace(trace)) {\n          unrecognizedEntry = {\n            type: StackTraceEntryType.UNRECOGNIZED_CREATE_CALLSTACK_ENTRY,\n          };\n        } else {\n          unrecognizedEntry = {\n            type: StackTraceEntryType.UNRECOGNIZED_CONTRACT_CALLSTACK_ENTRY,\n            address: trace.address,\n          };\n        }\n\n        return [unrecognizedEntry, ...this.getStackTrace(subtrace)];\n      }\n    }\n\n    if (trace.exit.kind === ExitCode.CODESIZE_EXCEEDS_MAXIMUM) {\n      return [\n        {\n          type: StackTraceEntryType.CONTRACT_TOO_LARGE_ERROR,\n        },\n      ];\n    }\n\n    const isInvalidOpcodeError = trace.exit.kind === ExitCode.INVALID_OPCODE;\n\n    if (isCreateTrace(trace)) {\n      return [\n        {\n          type: StackTraceEntryType.UNRECOGNIZED_CREATE_ERROR,\n          message: new ReturnData(trace.returnData),\n          isInvalidOpcodeError,\n        },\n      ];\n    }\n\n    return [\n      {\n        type: StackTraceEntryType.UNRECOGNIZED_CONTRACT_ERROR,\n        address: trace.address,\n        message: new ReturnData(trace.returnData),\n        isInvalidOpcodeError,\n      },\n    ];\n  }\n\n  private _getCreateMessageStackTrace(\n    trace: DecodedCreateMessageTrace\n  ): SolidityStackTrace {\n    const inferredError =\n      this._errorInferrer.inferBeforeTracingCreateMessage(trace);\n\n    if (inferredError !== undefined) {\n      return inferredError;\n    }\n\n    return this._traceEvmExecution(trace);\n  }\n\n  private _getPrecompileMessageStackTrace(\n    trace: PrecompileMessageTrace\n  ): SolidityStackTrace {\n    return [\n      {\n        type: StackTraceEntryType.PRECOMPILE_ERROR,\n        precompile: trace.precompile,\n      },\n    ];\n  }\n\n  private _traceEvmExecution(\n    trace: DecodedEvmMessageTrace\n  ): SolidityStackTrace {\n    const stackTrace = this._rawTraceEvmExecution(trace);\n\n    if (stackTraceMayRequireAdjustments(stackTrace, trace)) {\n      return adjustStackTrace(stackTrace, trace);\n    }\n\n    return stackTrace;\n  }\n\n  private _rawTraceEvmExecution(\n    trace: DecodedEvmMessageTrace\n  ): SolidityStackTrace {\n    const stacktrace: SolidityStackTrace = [];\n\n    let subtracesSeen = 0;\n\n    // There was a jump into a function according to the sourcemaps\n    let jumpedIntoFunction = false;\n\n    const functionJumpdests: Instruction[] = [];\n\n    let lastSubmessageData: SubmessageData | undefined;\n\n    for (let stepIndex = 0; stepIndex < trace.steps.length; stepIndex++) {\n      const step = trace.steps[stepIndex];\n      const nextStep = trace.steps[stepIndex + 1];\n\n      if (isEvmStep(step)) {\n        const inst = trace.bytecode.getInstruction(step.pc);\n\n        if (\n          inst.jumpType === JumpType.INTO_FUNCTION &&\n          nextStep !== undefined\n        ) {\n          const nextEvmStep = nextStep as EvmStep; // A jump can't be followed by a subtrace\n          const nextInst = trace.bytecode.getInstruction(nextEvmStep.pc);\n\n          if (nextInst !== undefined && nextInst.opcode === Opcode.JUMPDEST) {\n            stacktrace.push(\n              instructionToCallstackStackTraceEntry(trace.bytecode, inst)\n            );\n            if (nextInst.location !== undefined) {\n              jumpedIntoFunction = true;\n            }\n            functionJumpdests.push(nextInst);\n          }\n        } else if (inst.jumpType === JumpType.OUTOF_FUNCTION) {\n          stacktrace.pop();\n          functionJumpdests.pop();\n        }\n      } else {\n        subtracesSeen += 1;\n\n        // If there are more subtraces, this one didn't terminate the execution\n        if (subtracesSeen < trace.numberOfSubtraces) {\n          continue;\n        }\n\n        const submessageTrace = this.getStackTrace(step);\n\n        lastSubmessageData = {\n          messageTrace: step,\n          stepIndex,\n          stacktrace: submessageTrace,\n        };\n      }\n    }\n\n    const stacktraceWithInferredError = this._errorInferrer.inferAfterTracing(\n      trace,\n      stacktrace,\n      functionJumpdests,\n      jumpedIntoFunction,\n      lastSubmessageData\n    );\n\n    return this._errorInferrer.filterRedundantFrames(\n      stacktraceWithInferredError\n    );\n  }\n\n  private _getLastSubtrace(trace: EvmMessageTrace): MessageTrace | undefined {\n    if (trace.numberOfSubtraces < 1) {\n      return undefined;\n    }\n\n    let i = trace.steps.length - 1;\n\n    while (isEvmStep(trace.steps[i])) {\n      i -= 1;\n    }\n\n    return trace.steps[i] as MessageTrace;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}