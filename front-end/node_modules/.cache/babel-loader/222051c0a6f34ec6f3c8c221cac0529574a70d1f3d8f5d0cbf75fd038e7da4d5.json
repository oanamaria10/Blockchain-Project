{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HttpProvider = exports.isErrorResponse = void 0;\nconst events_1 = require(\"events\");\nconst constants_1 = require(\"../../constants\");\nconst jsonrpc_1 = require(\"../../util/jsonrpc\");\nconst packageInfo_1 = require(\"../../util/packageInfo\");\nconst errors_1 = require(\"../errors\");\nconst errors_list_1 = require(\"../errors-list\");\nconst proxy_1 = require(\"../../util/proxy\");\nconst errors_2 = require(\"./errors\");\nfunction isErrorResponse(response) {\n  return typeof response.error !== \"undefined\";\n}\nexports.isErrorResponse = isErrorResponse;\nconst MAX_RETRIES = 6;\nconst MAX_RETRY_AWAIT_SECONDS = 5;\nconst TOO_MANY_REQUEST_STATUS = 429;\nconst hardhatVersion = (0, packageInfo_1.getHardhatVersion)();\nclass HttpProvider extends events_1.EventEmitter {\n  constructor(_url, _networkName, _extraHeaders = {}, _timeout = 20000, client = undefined) {\n    super();\n    this._url = _url;\n    this._networkName = _networkName;\n    this._extraHeaders = _extraHeaders;\n    this._timeout = _timeout;\n    this._nextRequestId = 1;\n    const {\n      Pool,\n      ProxyAgent\n    } = require(\"undici\");\n    const url = new URL(this._url);\n    this._path = url.pathname;\n    this._authHeader = url.username === \"\" ? undefined : `Basic ${Buffer.from(`${url.username}:${url.password}`, \"utf-8\").toString(\"base64\")}`;\n    try {\n      this._dispatcher = client ?? new Pool(url.origin);\n      if (process.env.http_proxy !== undefined && (0, proxy_1.shouldUseProxy)(url.origin)) {\n        this._dispatcher = new ProxyAgent(process.env.http_proxy);\n      }\n    } catch (e) {\n      if (e instanceof TypeError && e.message === \"Invalid URL\") {\n        e.message += ` ${url.origin}`;\n      }\n      // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n      throw e;\n    }\n  }\n  get url() {\n    return this._url;\n  }\n  async request(args) {\n    const jsonRpcRequest = this._getJsonRpcRequest(args.method, args.params);\n    const jsonRpcResponse = await this._fetchJsonRpcResponse(jsonRpcRequest);\n    if (isErrorResponse(jsonRpcResponse)) {\n      const error = new errors_2.ProviderError(jsonRpcResponse.error.message, jsonRpcResponse.error.code);\n      error.data = jsonRpcResponse.error.data;\n      // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n    if (args.method === \"hardhat_reset\") {\n      this.emit(constants_1.HARDHAT_NETWORK_RESET_EVENT);\n    }\n    if (args.method === \"evm_revert\") {\n      this.emit(constants_1.HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT);\n    }\n    return jsonRpcResponse.result;\n  }\n  /**\n   * Sends a batch of requests. Fails if any of them fails.\n   */\n  async sendBatch(batch) {\n    // We create the errors here to capture the stack traces at this point,\n    // the async call that follows would probably loose of the stack trace\n    const stackSavingError = new errors_2.ProviderError(\"HttpProviderError\", -1);\n    // we need this to sort the responses\n    const idToIndexMap = {};\n    const requests = batch.map((r, i) => {\n      const jsonRpcRequest = this._getJsonRpcRequest(r.method, r.params);\n      idToIndexMap[jsonRpcRequest.id] = i;\n      return jsonRpcRequest;\n    });\n    const jsonRpcResponses = await this._fetchJsonRpcResponse(requests);\n    for (const response of jsonRpcResponses) {\n      if (isErrorResponse(response)) {\n        const error = new errors_2.ProviderError(response.error.message, response.error.code, stackSavingError);\n        error.data = response.error.data;\n        // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n        throw error;\n      }\n    }\n    // We already know that it has this type, but TS can't infer it.\n    const responses = jsonRpcResponses;\n    // we use the id to sort the responses so that they match the order of the requests\n    const sortedResponses = responses.map(response => [idToIndexMap[response.id], response.result]).sort(([indexA], [indexB]) => indexA - indexB).map(([, result]) => result);\n    return sortedResponses;\n  }\n  async _fetchJsonRpcResponse(request, retryNumber = 0) {\n    const {\n      request: sendRequest\n    } = await Promise.resolve().then(() => __importStar(require(\"undici\")));\n    const url = new URL(this._url);\n    const headers = {\n      \"Content-Type\": \"application/json\",\n      \"User-Agent\": `hardhat ${hardhatVersion}`,\n      ...this._extraHeaders\n    };\n    if (this._authHeader !== undefined) {\n      headers.Authorization = this._authHeader;\n    }\n    try {\n      const response = await sendRequest(url, {\n        dispatcher: this._dispatcher,\n        method: \"POST\",\n        body: JSON.stringify(request),\n        maxRedirections: 10,\n        headersTimeout: process.env.DO_NOT_SET_THIS_ENV_VAR____IS_HARDHAT_CI !== undefined ? 0 : this._timeout,\n        headers\n      });\n      if (this._isRateLimitResponse(response)) {\n        // \"The Fetch Standard allows users to skip consuming the response body\n        // by relying on garbage collection to release connection resources.\n        // Undici does not do the same. Therefore, it is important to always\n        // either consume or cancel the response body.\"\n        // https://undici.nodejs.org/#/?id=garbage-collection\n        // It's not clear how to \"cancel\", so we'll just consume:\n        await response.body.text();\n        const seconds = this._getRetryAfterSeconds(response, retryNumber);\n        if (seconds !== undefined && this._shouldRetry(retryNumber, seconds)) {\n          return await this._retry(request, seconds, retryNumber);\n        }\n        // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n        throw new errors_2.ProviderError(`Too Many Requests error received from ${url.hostname}`, -32005 // Limit exceeded according to EIP1474\n        );\n      }\n      return (0, jsonrpc_1.parseJsonResponse)(await response.body.text());\n    } catch (error) {\n      if (error.code === \"ECONNREFUSED\") {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.NODE_IS_NOT_RUNNING, {\n          network: this._networkName\n        }, error);\n      }\n      if (error.type === \"request-timeout\") {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.NETWORK_TIMEOUT, {}, error);\n      }\n      // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n  }\n  async _retry(request, seconds, retryNumber) {\n    await new Promise(resolve => setTimeout(resolve, 1000 * seconds));\n    return this._fetchJsonRpcResponse(request, retryNumber + 1);\n  }\n  _getJsonRpcRequest(method, params = []) {\n    return {\n      jsonrpc: \"2.0\",\n      method,\n      params,\n      id: this._nextRequestId++\n    };\n  }\n  _shouldRetry(retryNumber, retryAfterSeconds) {\n    if (retryNumber > MAX_RETRIES) {\n      return false;\n    }\n    if (retryAfterSeconds > MAX_RETRY_AWAIT_SECONDS) {\n      return false;\n    }\n    return true;\n  }\n  _isRateLimitResponse(response) {\n    return response.statusCode === TOO_MANY_REQUEST_STATUS;\n  }\n  _getRetryAfterSeconds(response, retryNumber) {\n    const header = response.headers[\"retry-after\"];\n    if (header === undefined || header === null || Array.isArray(header)) {\n      // if the response doesn't have a retry-after header, we do\n      // an exponential backoff\n      return Math.min(2 ** retryNumber, MAX_RETRY_AWAIT_SECONDS);\n    }\n    const parsed = parseInt(header, 10);\n    if (isNaN(parsed)) {\n      return undefined;\n    }\n    return parsed;\n  }\n}\nexports.HttpProvider = HttpProvider;","map":{"version":3,"names":["events_1","require","constants_1","jsonrpc_1","packageInfo_1","errors_1","errors_list_1","proxy_1","errors_2","isErrorResponse","response","error","exports","MAX_RETRIES","MAX_RETRY_AWAIT_SECONDS","TOO_MANY_REQUEST_STATUS","hardhatVersion","getHardhatVersion","HttpProvider","EventEmitter","constructor","_url","_networkName","_extraHeaders","_timeout","client","undefined","_nextRequestId","Pool","ProxyAgent","url","URL","_path","pathname","_authHeader","username","Buffer","from","password","toString","_dispatcher","origin","process","env","http_proxy","shouldUseProxy","e","TypeError","message","request","args","jsonRpcRequest","_getJsonRpcRequest","method","params","jsonRpcResponse","_fetchJsonRpcResponse","ProviderError","code","data","emit","HARDHAT_NETWORK_RESET_EVENT","HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT","result","sendBatch","batch","stackSavingError","idToIndexMap","requests","map","r","i","id","jsonRpcResponses","responses","sortedResponses","sort","indexA","indexB","retryNumber","sendRequest","Promise","resolve","then","__importStar","headers","Authorization","dispatcher","body","JSON","stringify","maxRedirections","headersTimeout","DO_NOT_SET_THIS_ENV_VAR____IS_HARDHAT_CI","_isRateLimitResponse","text","seconds","_getRetryAfterSeconds","_shouldRetry","_retry","hostname","parseJsonResponse","HardhatError","ERRORS","NETWORK","NODE_IS_NOT_RUNNING","network","type","NETWORK_TIMEOUT","setTimeout","jsonrpc","retryAfterSeconds","statusCode","header","Array","isArray","Math","min","parsed","parseInt","isNaN"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\internal\\core\\providers\\http.ts"],"sourcesContent":["import type * as Undici from \"undici\";\n\nimport { EventEmitter } from \"events\";\n\nimport { EIP1193Provider, RequestArguments } from \"../../../types\";\nimport {\n  HARDHAT_NETWORK_RESET_EVENT,\n  HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT,\n} from \"../../constants\";\nimport {\n  FailedJsonRpcResponse,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  parseJsonResponse,\n  SuccessfulJsonRpcResponse,\n} from \"../../util/jsonrpc\";\nimport { getHardhatVersion } from \"../../util/packageInfo\";\nimport { HardhatError } from \"../errors\";\nimport { ERRORS } from \"../errors-list\";\nimport { shouldUseProxy } from \"../../util/proxy\";\n\nimport { ProviderError } from \"./errors\";\n\nexport function isErrorResponse(\n  response: any\n): response is FailedJsonRpcResponse {\n  return typeof response.error !== \"undefined\";\n}\n\nconst MAX_RETRIES = 6;\nconst MAX_RETRY_AWAIT_SECONDS = 5;\n\nconst TOO_MANY_REQUEST_STATUS = 429;\n\nconst hardhatVersion = getHardhatVersion();\n\nexport class HttpProvider extends EventEmitter implements EIP1193Provider {\n  private _nextRequestId = 1;\n  private _dispatcher: Undici.Dispatcher;\n  private _path: string;\n  private _authHeader: string | undefined;\n\n  constructor(\n    private readonly _url: string,\n    private readonly _networkName: string,\n    private readonly _extraHeaders: { [name: string]: string } = {},\n    private readonly _timeout = 20000,\n    client: Undici.Dispatcher | undefined = undefined\n  ) {\n    super();\n\n    const { Pool, ProxyAgent } = require(\"undici\") as typeof Undici;\n\n    const url = new URL(this._url);\n    this._path = url.pathname;\n    this._authHeader =\n      url.username === \"\"\n        ? undefined\n        : `Basic ${Buffer.from(\n            `${url.username}:${url.password}`,\n            \"utf-8\"\n          ).toString(\"base64\")}`;\n    try {\n      this._dispatcher = client ?? new Pool(url.origin);\n\n      if (process.env.http_proxy !== undefined && shouldUseProxy(url.origin)) {\n        this._dispatcher = new ProxyAgent(process.env.http_proxy);\n      }\n    } catch (e) {\n      if (e instanceof TypeError && e.message === \"Invalid URL\") {\n        e.message += ` ${url.origin}`;\n      }\n      // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n      throw e;\n    }\n  }\n\n  public get url(): string {\n    return this._url;\n  }\n\n  public async request(args: RequestArguments): Promise<unknown> {\n    const jsonRpcRequest = this._getJsonRpcRequest(\n      args.method,\n      args.params as any[]\n    );\n    const jsonRpcResponse = await this._fetchJsonRpcResponse(jsonRpcRequest);\n\n    if (isErrorResponse(jsonRpcResponse)) {\n      const error = new ProviderError(\n        jsonRpcResponse.error.message,\n        jsonRpcResponse.error.code\n      );\n      error.data = jsonRpcResponse.error.data;\n      // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n\n    if (args.method === \"hardhat_reset\") {\n      this.emit(HARDHAT_NETWORK_RESET_EVENT);\n    }\n    if (args.method === \"evm_revert\") {\n      this.emit(HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT);\n    }\n\n    return jsonRpcResponse.result;\n  }\n\n  /**\n   * Sends a batch of requests. Fails if any of them fails.\n   */\n  public async sendBatch(\n    batch: Array<{ method: string; params: any[] }>\n  ): Promise<any[]> {\n    // We create the errors here to capture the stack traces at this point,\n    // the async call that follows would probably loose of the stack trace\n    const stackSavingError = new ProviderError(\"HttpProviderError\", -1);\n\n    // we need this to sort the responses\n    const idToIndexMap: Record<string, number> = {};\n\n    const requests = batch.map((r, i) => {\n      const jsonRpcRequest = this._getJsonRpcRequest(r.method, r.params);\n      idToIndexMap[jsonRpcRequest.id] = i;\n      return jsonRpcRequest;\n    });\n\n    const jsonRpcResponses = await this._fetchJsonRpcResponse(requests);\n\n    for (const response of jsonRpcResponses) {\n      if (isErrorResponse(response)) {\n        const error = new ProviderError(\n          response.error.message,\n          response.error.code,\n          stackSavingError\n        );\n        error.data = response.error.data;\n        // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n        throw error;\n      }\n    }\n\n    // We already know that it has this type, but TS can't infer it.\n    const responses = jsonRpcResponses as SuccessfulJsonRpcResponse[];\n\n    // we use the id to sort the responses so that they match the order of the requests\n    const sortedResponses = responses\n      .map(\n        (response) =>\n          [idToIndexMap[response.id], response.result] as [number, any]\n      )\n      .sort(([indexA], [indexB]) => indexA - indexB)\n      .map(([, result]) => result);\n\n    return sortedResponses;\n  }\n\n  private async _fetchJsonRpcResponse(\n    request: JsonRpcRequest,\n    retryNumber?: number\n  ): Promise<JsonRpcResponse>;\n  private async _fetchJsonRpcResponse(\n    request: JsonRpcRequest[],\n    retryNumber?: number\n  ): Promise<JsonRpcResponse[]>;\n  private async _fetchJsonRpcResponse(\n    request: JsonRpcRequest | JsonRpcRequest[],\n    retryNumber?: number\n  ): Promise<JsonRpcResponse | JsonRpcResponse[]>;\n  private async _fetchJsonRpcResponse(\n    request: JsonRpcRequest | JsonRpcRequest[],\n    retryNumber = 0\n  ): Promise<JsonRpcResponse | JsonRpcResponse[]> {\n    const { request: sendRequest } = await import(\"undici\");\n    const url = new URL(this._url);\n\n    const headers: { [name: string]: string } = {\n      \"Content-Type\": \"application/json\",\n      \"User-Agent\": `hardhat ${hardhatVersion}`,\n      ...this._extraHeaders,\n    };\n\n    if (this._authHeader !== undefined) {\n      headers.Authorization = this._authHeader;\n    }\n\n    try {\n      const response = await sendRequest(url, {\n        dispatcher: this._dispatcher,\n        method: \"POST\",\n        body: JSON.stringify(request),\n        maxRedirections: 10,\n        headersTimeout:\n          process.env.DO_NOT_SET_THIS_ENV_VAR____IS_HARDHAT_CI !== undefined\n            ? 0\n            : this._timeout,\n        headers,\n      });\n\n      if (this._isRateLimitResponse(response)) {\n        // \"The Fetch Standard allows users to skip consuming the response body\n        // by relying on garbage collection to release connection resources.\n        // Undici does not do the same. Therefore, it is important to always\n        // either consume or cancel the response body.\"\n        // https://undici.nodejs.org/#/?id=garbage-collection\n        // It's not clear how to \"cancel\", so we'll just consume:\n        await response.body.text();\n        const seconds = this._getRetryAfterSeconds(response, retryNumber);\n        if (seconds !== undefined && this._shouldRetry(retryNumber, seconds)) {\n          return await this._retry(request, seconds, retryNumber);\n        }\n\n        // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n        throw new ProviderError(\n          `Too Many Requests error received from ${url.hostname}`,\n          -32005 // Limit exceeded according to EIP1474\n        );\n      }\n\n      return parseJsonResponse(await response.body.text());\n    } catch (error: any) {\n      if (error.code === \"ECONNREFUSED\") {\n        throw new HardhatError(\n          ERRORS.NETWORK.NODE_IS_NOT_RUNNING,\n          { network: this._networkName },\n          error\n        );\n      }\n\n      if (error.type === \"request-timeout\") {\n        throw new HardhatError(ERRORS.NETWORK.NETWORK_TIMEOUT, {}, error);\n      }\n\n      // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n  }\n\n  private async _retry(\n    request: JsonRpcRequest | JsonRpcRequest[],\n    seconds: number,\n    retryNumber: number\n  ) {\n    await new Promise((resolve) => setTimeout(resolve, 1000 * seconds));\n    return this._fetchJsonRpcResponse(request, retryNumber + 1);\n  }\n\n  private _getJsonRpcRequest(\n    method: string,\n    params: any[] = []\n  ): JsonRpcRequest {\n    return {\n      jsonrpc: \"2.0\",\n      method,\n      params,\n      id: this._nextRequestId++,\n    };\n  }\n\n  private _shouldRetry(retryNumber: number, retryAfterSeconds: number) {\n    if (retryNumber > MAX_RETRIES) {\n      return false;\n    }\n\n    if (retryAfterSeconds > MAX_RETRY_AWAIT_SECONDS) {\n      return false;\n    }\n\n    return true;\n  }\n\n  private _isRateLimitResponse(response: Undici.Dispatcher.ResponseData) {\n    return response.statusCode === TOO_MANY_REQUEST_STATUS;\n  }\n\n  private _getRetryAfterSeconds(\n    response: Undici.Dispatcher.ResponseData,\n    retryNumber: number\n  ): number | undefined {\n    const header = response.headers[\"retry-after\"];\n\n    if (header === undefined || header === null || Array.isArray(header)) {\n      // if the response doesn't have a retry-after header, we do\n      // an exponential backoff\n      return Math.min(2 ** retryNumber, MAX_RETRY_AWAIT_SECONDS);\n    }\n\n    const parsed = parseInt(header, 10);\n    if (isNaN(parsed)) {\n      return undefined;\n    }\n\n    return parsed;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}