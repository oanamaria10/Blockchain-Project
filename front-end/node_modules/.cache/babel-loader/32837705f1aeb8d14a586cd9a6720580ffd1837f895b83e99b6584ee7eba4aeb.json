{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.normalizeHardhatNetworkAccountsConfig = exports.derivePrivateKeys = void 0;\nconst keys_derivation_1 = require(\"../../util/keys-derivation\");\nconst default_config_1 = require(\"../config/default-config\");\nconst errors_1 = require(\"../errors\");\nconst errors_list_1 = require(\"../errors-list\");\nconst HD_PATH_REGEX = /^m(:?\\/\\d+'?)+\\/?$/;\nfunction derivePrivateKeys(mnemonic, hdpath, initialIndex, count, passphrase) {\n  if (hdpath.match(HD_PATH_REGEX) === null) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.INVALID_HD_PATH, {\n      path: hdpath\n    });\n  }\n  if (!hdpath.endsWith(\"/\")) {\n    hdpath += \"/\";\n  }\n  const privateKeys = [];\n  for (let i = initialIndex; i < initialIndex + count; i++) {\n    const privateKey = (0, keys_derivation_1.deriveKeyFromMnemonicAndPath)(mnemonic, hdpath + i.toString(), passphrase);\n    if (privateKey === undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.CANT_DERIVE_KEY, {\n        mnemonic,\n        path: hdpath\n      });\n    }\n    privateKeys.push(privateKey);\n  }\n  return privateKeys;\n}\nexports.derivePrivateKeys = derivePrivateKeys;\nfunction normalizeHardhatNetworkAccountsConfig(accountsConfig) {\n  if (Array.isArray(accountsConfig)) {\n    return accountsConfig;\n  }\n  const {\n    bytesToHex\n  } = require(\"@nomicfoundation/ethereumjs-util\");\n  return derivePrivateKeys(accountsConfig.mnemonic, accountsConfig.path, accountsConfig.initialIndex, accountsConfig.count, accountsConfig.passphrase).map(pk => ({\n    privateKey: bytesToHex(pk),\n    balance: accountsConfig.accountsBalance ?? default_config_1.DEFAULT_HARDHAT_NETWORK_BALANCE\n  }));\n}\nexports.normalizeHardhatNetworkAccountsConfig = normalizeHardhatNetworkAccountsConfig;","map":{"version":3,"names":["keys_derivation_1","require","default_config_1","errors_1","errors_list_1","HD_PATH_REGEX","derivePrivateKeys","mnemonic","hdpath","initialIndex","count","passphrase","match","HardhatError","ERRORS","NETWORK","INVALID_HD_PATH","path","endsWith","privateKeys","i","privateKey","deriveKeyFromMnemonicAndPath","toString","undefined","CANT_DERIVE_KEY","push","exports","normalizeHardhatNetworkAccountsConfig","accountsConfig","Array","isArray","bytesToHex","map","pk","balance","accountsBalance","DEFAULT_HARDHAT_NETWORK_BALANCE"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\internal\\core\\providers\\util.ts"],"sourcesContent":["import {\n  HardhatNetworkAccountConfig,\n  HardhatNetworkAccountsConfig,\n} from \"../../../types\";\nimport { deriveKeyFromMnemonicAndPath } from \"../../util/keys-derivation\";\nimport { DEFAULT_HARDHAT_NETWORK_BALANCE } from \"../config/default-config\";\nimport { HardhatError } from \"../errors\";\nimport { ERRORS } from \"../errors-list\";\n\nconst HD_PATH_REGEX = /^m(:?\\/\\d+'?)+\\/?$/;\n\nexport function derivePrivateKeys(\n  mnemonic: string,\n  hdpath: string,\n  initialIndex: number,\n  count: number,\n  passphrase: string\n): Buffer[] {\n  if (hdpath.match(HD_PATH_REGEX) === null) {\n    throw new HardhatError(ERRORS.NETWORK.INVALID_HD_PATH, { path: hdpath });\n  }\n\n  if (!hdpath.endsWith(\"/\")) {\n    hdpath += \"/\";\n  }\n\n  const privateKeys: Buffer[] = [];\n\n  for (let i = initialIndex; i < initialIndex + count; i++) {\n    const privateKey = deriveKeyFromMnemonicAndPath(\n      mnemonic,\n      hdpath + i.toString(),\n      passphrase\n    );\n\n    if (privateKey === undefined) {\n      throw new HardhatError(ERRORS.NETWORK.CANT_DERIVE_KEY, {\n        mnemonic,\n        path: hdpath,\n      });\n    }\n\n    privateKeys.push(privateKey);\n  }\n\n  return privateKeys;\n}\n\nexport function normalizeHardhatNetworkAccountsConfig(\n  accountsConfig: HardhatNetworkAccountsConfig\n): HardhatNetworkAccountConfig[] {\n  if (Array.isArray(accountsConfig)) {\n    return accountsConfig;\n  }\n\n  const { bytesToHex } = require(\"@nomicfoundation/ethereumjs-util\");\n\n  return derivePrivateKeys(\n    accountsConfig.mnemonic,\n    accountsConfig.path,\n    accountsConfig.initialIndex,\n    accountsConfig.count,\n    accountsConfig.passphrase\n  ).map((pk) => ({\n    privateKey: bytesToHex(pk),\n    balance: accountsConfig.accountsBalance ?? DEFAULT_HARDHAT_NETWORK_BALANCE,\n  }));\n}\n"],"mappings":";;;;;;AAIA,MAAAA,iBAAA,GAAAC,OAAA;AACA,MAAAC,gBAAA,GAAAD,OAAA;AACA,MAAAE,QAAA,GAAAF,OAAA;AACA,MAAAG,aAAA,GAAAH,OAAA;AAEA,MAAMI,aAAa,GAAG,oBAAoB;AAE1C,SAAgBC,iBAAiBA,CAC/BC,QAAgB,EAChBC,MAAc,EACdC,YAAoB,EACpBC,KAAa,EACbC,UAAkB;EAElB,IAAIH,MAAM,CAACI,KAAK,CAACP,aAAa,CAAC,KAAK,IAAI,EAAE;IACxC,MAAM,IAAIF,QAAA,CAAAU,YAAY,CAACT,aAAA,CAAAU,MAAM,CAACC,OAAO,CAACC,eAAe,EAAE;MAAEC,IAAI,EAAET;IAAM,CAAE,CAAC;;EAG1E,IAAI,CAACA,MAAM,CAACU,QAAQ,CAAC,GAAG,CAAC,EAAE;IACzBV,MAAM,IAAI,GAAG;;EAGf,MAAMW,WAAW,GAAa,EAAE;EAEhC,KAAK,IAAIC,CAAC,GAAGX,YAAY,EAAEW,CAAC,GAAGX,YAAY,GAAGC,KAAK,EAAEU,CAAC,EAAE,EAAE;IACxD,MAAMC,UAAU,GAAG,IAAArB,iBAAA,CAAAsB,4BAA4B,EAC7Cf,QAAQ,EACRC,MAAM,GAAGY,CAAC,CAACG,QAAQ,EAAE,EACrBZ,UAAU,CACX;IAED,IAAIU,UAAU,KAAKG,SAAS,EAAE;MAC5B,MAAM,IAAIrB,QAAA,CAAAU,YAAY,CAACT,aAAA,CAAAU,MAAM,CAACC,OAAO,CAACU,eAAe,EAAE;QACrDlB,QAAQ;QACRU,IAAI,EAAET;OACP,CAAC;;IAGJW,WAAW,CAACO,IAAI,CAACL,UAAU,CAAC;;EAG9B,OAAOF,WAAW;AACpB;AAnCAQ,OAAA,CAAArB,iBAAA,GAAAA,iBAAA;AAqCA,SAAgBsB,qCAAqCA,CACnDC,cAA4C;EAE5C,IAAIC,KAAK,CAACC,OAAO,CAACF,cAAc,CAAC,EAAE;IACjC,OAAOA,cAAc;;EAGvB,MAAM;IAAEG;EAAU,CAAE,GAAG/B,OAAO,CAAC,kCAAkC,CAAC;EAElE,OAAOK,iBAAiB,CACtBuB,cAAc,CAACtB,QAAQ,EACvBsB,cAAc,CAACZ,IAAI,EACnBY,cAAc,CAACpB,YAAY,EAC3BoB,cAAc,CAACnB,KAAK,EACpBmB,cAAc,CAAClB,UAAU,CAC1B,CAACsB,GAAG,CAAEC,EAAE,KAAM;IACbb,UAAU,EAAEW,UAAU,CAACE,EAAE,CAAC;IAC1BC,OAAO,EAAEN,cAAc,CAACO,eAAe,IAAIlC,gBAAA,CAAAmC;GAC5C,CAAC,CAAC;AACL;AAnBAV,OAAA,CAAAC,qCAAA,GAAAA,qCAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}