{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JsonRpcHandler = void 0;\nconst raw_body_1 = __importDefault(require(\"raw-body\"));\nconst errors_1 = require(\"../../core/providers/errors\");\nconst jsonrpc_1 = require(\"../../util/jsonrpc\");\n/* eslint-disable @nomicfoundation/hardhat-internal-rules/only-hardhat-error */\nclass JsonRpcHandler {\n  constructor(_provider) {\n    this._provider = _provider;\n    this.handleHttp = async (req, res) => {\n      this._setCorsHeaders(res);\n      if (req.method === \"OPTIONS\") {\n        this._sendEmptyResponse(res);\n        return;\n      }\n      let jsonHttpRequest;\n      try {\n        jsonHttpRequest = await _readJsonHttpRequest(req);\n      } catch (error) {\n        this._sendResponse(res, _handleError(error));\n        return;\n      }\n      if (Array.isArray(jsonHttpRequest)) {\n        const responses = await Promise.all(jsonHttpRequest.map(singleReq => this._handleSingleRequest(singleReq)));\n        this._sendResponse(res, responses);\n        return;\n      }\n      const rpcResp = await this._handleSingleRequest(jsonHttpRequest);\n      this._sendResponse(res, rpcResp);\n    };\n    this.handleWs = async ws => {\n      const subscriptions = [];\n      let isClosed = false;\n      const listener = payload => {\n        // Don't attempt to send a message to the websocket if we already know it is closed,\n        // or the current websocket connection isn't interested in the particular subscription.\n        if (isClosed || !subscriptions.includes(payload.subscription)) {\n          return;\n        }\n        try {\n          ws.send(JSON.stringify({\n            jsonrpc: \"2.0\",\n            method: \"eth_subscription\",\n            params: payload\n          }));\n        } catch (error) {\n          _handleError(error);\n        }\n      };\n      // Handle eth_subscribe notifications.\n      this._provider.addListener(\"notification\", listener);\n      ws.on(\"message\", async msg => {\n        let rpcReq;\n        let rpcResp;\n        try {\n          rpcReq = _readWsRequest(msg);\n          rpcResp = Array.isArray(rpcReq) ? await Promise.all(rpcReq.map(req => this._handleSingleWsRequest(req, subscriptions))) : await this._handleSingleWsRequest(rpcReq, subscriptions);\n        } catch (error) {\n          rpcResp = _handleError(error);\n        }\n        ws.send(JSON.stringify(rpcResp));\n      });\n      ws.on(\"close\", () => {\n        // Remove eth_subscribe listener.\n        this._provider.removeListener(\"notification\", listener);\n        // Clear any active subscriptions for the closed websocket connection.\n        isClosed = true;\n        subscriptions.forEach(async subscriptionId => {\n          await this._provider.request({\n            method: \"eth_unsubscribe\",\n            params: [subscriptionId]\n          });\n        });\n      });\n    };\n    this._handleRequest = async req => {\n      const result = await this._provider.request({\n        method: req.method,\n        params: req.params\n      });\n      return {\n        jsonrpc: \"2.0\",\n        id: req.id,\n        result\n      };\n    };\n  }\n  _sendEmptyResponse(res) {\n    res.writeHead(200);\n    res.end();\n  }\n  _setCorsHeaders(res) {\n    res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n    res.setHeader(\"Access-Control-Request-Method\", \"*\");\n    res.setHeader(\"Access-Control-Allow-Methods\", \"OPTIONS, GET\");\n    res.setHeader(\"Access-Control-Allow-Headers\", \"*\");\n  }\n  _sendResponse(res, rpcResp) {\n    res.statusCode = 200;\n    res.setHeader(\"Content-Type\", \"application/json\");\n    res.end(JSON.stringify(rpcResp));\n  }\n  async _handleSingleRequest(req) {\n    if (!(0, jsonrpc_1.isValidJsonRequest)(req)) {\n      return _handleError(new errors_1.InvalidRequestError(\"Invalid request\"));\n    }\n    const rpcReq = req;\n    let rpcResp;\n    try {\n      rpcResp = await this._handleRequest(rpcReq);\n    } catch (error) {\n      rpcResp = _handleError(error);\n    }\n    // Validate the RPC response.\n    if (!(0, jsonrpc_1.isValidJsonResponse)(rpcResp)) {\n      // Malformed response coming from the provider, report to user as an internal error.\n      rpcResp = _handleError(new errors_1.InternalError(\"Internal error\"));\n    }\n    if (rpcReq !== undefined) {\n      rpcResp.id = rpcReq.id !== undefined ? rpcReq.id : null;\n    }\n    return rpcResp;\n  }\n  async _handleSingleWsRequest(rpcReq, subscriptions) {\n    const rpcResp = await this._handleSingleRequest(rpcReq);\n    // If eth_subscribe was successful, keep track of the subscription id,\n    // so we can cleanup on websocket close.\n    if (rpcReq.method === \"eth_subscribe\" && (0, jsonrpc_1.isSuccessfulJsonResponse)(rpcResp)) {\n      subscriptions.push(rpcResp.result);\n    }\n    return rpcResp;\n  }\n}\nexports.JsonRpcHandler = JsonRpcHandler;\nconst _readJsonHttpRequest = async req => {\n  let json;\n  try {\n    const buf = await (0, raw_body_1.default)(req);\n    const text = buf.toString();\n    json = JSON.parse(text);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new errors_1.InvalidJsonInputError(`Parse error: ${error.message}`);\n    }\n    // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n  return json;\n};\nconst _readWsRequest = msg => {\n  let json;\n  try {\n    json = JSON.parse(msg);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new errors_1.InvalidJsonInputError(`Parse error: ${error.message}`);\n    }\n    // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n  return json;\n};\nconst _handleError = error => {\n  // extract the relevant fields from the error before wrapping it\n  let txHash;\n  let returnData;\n  if (error.transactionHash !== undefined) {\n    txHash = error.transactionHash;\n  }\n  if (error.data !== undefined) {\n    if (error.data?.data !== undefined) {\n      returnData = error.data.data;\n    } else {\n      returnData = error.data;\n    }\n    if (txHash === undefined && error.data?.transactionHash !== undefined) {\n      txHash = error.data.transactionHash;\n    }\n  }\n  // In case of non-hardhat error, treat it as internal and associate the appropriate error code.\n  if (!errors_1.ProviderError.isProviderError(error)) {\n    error = new errors_1.InternalError(error);\n  }\n  const response = {\n    jsonrpc: \"2.0\",\n    id: null,\n    error: {\n      code: error.code,\n      message: error.message\n    }\n  };\n  response.error.data = {\n    message: error.message\n  };\n  if (txHash !== undefined) {\n    response.error.data.txHash = txHash;\n  }\n  if (returnData !== undefined) {\n    response.error.data.data = returnData;\n  }\n  return response;\n};","map":{"version":3,"names":["raw_body_1","__importDefault","require","errors_1","jsonrpc_1","JsonRpcHandler","constructor","_provider","handleHttp","req","res","_setCorsHeaders","method","_sendEmptyResponse","jsonHttpRequest","_readJsonHttpRequest","error","_sendResponse","_handleError","Array","isArray","responses","Promise","all","map","singleReq","_handleSingleRequest","rpcResp","handleWs","ws","subscriptions","isClosed","listener","payload","includes","subscription","send","JSON","stringify","jsonrpc","params","addListener","on","msg","rpcReq","_readWsRequest","_handleSingleWsRequest","removeListener","forEach","subscriptionId","request","_handleRequest","result","id","writeHead","end","setHeader","statusCode","isValidJsonRequest","InvalidRequestError","isValidJsonResponse","InternalError","undefined","isSuccessfulJsonResponse","push","exports","json","buf","default","text","toString","parse","Error","InvalidJsonInputError","message","txHash","returnData","transactionHash","data","ProviderError","isProviderError","response","code"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\internal\\hardhat-network\\jsonrpc\\handler.ts"],"sourcesContent":["import { IncomingMessage, ServerResponse } from \"http\";\nimport getRawBody from \"raw-body\";\nimport WebSocket from \"ws\";\n\nimport { EIP1193Provider } from \"../../../types\";\nimport {\n  InternalError,\n  InvalidJsonInputError,\n  InvalidRequestError,\n  ProviderError,\n} from \"../../core/providers/errors\";\nimport {\n  FailedJsonRpcResponse,\n  isSuccessfulJsonResponse,\n  isValidJsonRequest,\n  isValidJsonResponse,\n  JsonRpcRequest,\n  JsonRpcResponse,\n} from \"../../util/jsonrpc\";\n\n/* eslint-disable @nomicfoundation/hardhat-internal-rules/only-hardhat-error */\n\nexport class JsonRpcHandler {\n  constructor(private readonly _provider: EIP1193Provider) {}\n\n  public handleHttp = async (req: IncomingMessage, res: ServerResponse) => {\n    this._setCorsHeaders(res);\n    if (req.method === \"OPTIONS\") {\n      this._sendEmptyResponse(res);\n      return;\n    }\n\n    let jsonHttpRequest: any;\n    try {\n      jsonHttpRequest = await _readJsonHttpRequest(req);\n    } catch (error) {\n      this._sendResponse(res, _handleError(error));\n      return;\n    }\n\n    if (Array.isArray(jsonHttpRequest)) {\n      const responses = await Promise.all(\n        jsonHttpRequest.map((singleReq: any) =>\n          this._handleSingleRequest(singleReq)\n        )\n      );\n\n      this._sendResponse(res, responses);\n      return;\n    }\n\n    const rpcResp = await this._handleSingleRequest(jsonHttpRequest);\n\n    this._sendResponse(res, rpcResp);\n  };\n\n  public handleWs = async (ws: WebSocket) => {\n    const subscriptions: string[] = [];\n    let isClosed = false;\n\n    const listener = (payload: { subscription: string; result: any }) => {\n      // Don't attempt to send a message to the websocket if we already know it is closed,\n      // or the current websocket connection isn't interested in the particular subscription.\n      if (isClosed || !subscriptions.includes(payload.subscription)) {\n        return;\n      }\n\n      try {\n        ws.send(\n          JSON.stringify({\n            jsonrpc: \"2.0\",\n            method: \"eth_subscription\",\n            params: payload,\n          })\n        );\n      } catch (error) {\n        _handleError(error);\n      }\n    };\n\n    // Handle eth_subscribe notifications.\n    this._provider.addListener(\"notification\", listener);\n\n    ws.on(\"message\", async (msg) => {\n      let rpcReq: JsonRpcRequest | JsonRpcRequest[];\n      let rpcResp: JsonRpcResponse | JsonRpcResponse[];\n\n      try {\n        rpcReq = _readWsRequest(msg as string);\n\n        rpcResp = Array.isArray(rpcReq)\n          ? await Promise.all(\n              rpcReq.map((req) =>\n                this._handleSingleWsRequest(req, subscriptions)\n              )\n            )\n          : await this._handleSingleWsRequest(rpcReq, subscriptions);\n      } catch (error) {\n        rpcResp = _handleError(error);\n      }\n\n      ws.send(JSON.stringify(rpcResp));\n    });\n\n    ws.on(\"close\", () => {\n      // Remove eth_subscribe listener.\n      this._provider.removeListener(\"notification\", listener);\n\n      // Clear any active subscriptions for the closed websocket connection.\n      isClosed = true;\n      subscriptions.forEach(async (subscriptionId) => {\n        await this._provider.request({\n          method: \"eth_unsubscribe\",\n          params: [subscriptionId],\n        });\n      });\n    });\n  };\n\n  private _sendEmptyResponse(res: ServerResponse) {\n    res.writeHead(200);\n    res.end();\n  }\n\n  private _setCorsHeaders(res: ServerResponse) {\n    res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n    res.setHeader(\"Access-Control-Request-Method\", \"*\");\n    res.setHeader(\"Access-Control-Allow-Methods\", \"OPTIONS, GET\");\n    res.setHeader(\"Access-Control-Allow-Headers\", \"*\");\n  }\n\n  private _sendResponse(\n    res: ServerResponse,\n    rpcResp: JsonRpcResponse | JsonRpcResponse[]\n  ) {\n    res.statusCode = 200;\n    res.setHeader(\"Content-Type\", \"application/json\");\n    res.end(JSON.stringify(rpcResp));\n  }\n\n  private async _handleSingleRequest(\n    req: JsonRpcRequest\n  ): Promise<JsonRpcResponse> {\n    if (!isValidJsonRequest(req)) {\n      return _handleError(new InvalidRequestError(\"Invalid request\"));\n    }\n\n    const rpcReq: JsonRpcRequest = req;\n    let rpcResp: JsonRpcResponse | undefined;\n\n    try {\n      rpcResp = await this._handleRequest(rpcReq);\n    } catch (error) {\n      rpcResp = _handleError(error);\n    }\n\n    // Validate the RPC response.\n    if (!isValidJsonResponse(rpcResp)) {\n      // Malformed response coming from the provider, report to user as an internal error.\n      rpcResp = _handleError(new InternalError(\"Internal error\"));\n    }\n\n    if (rpcReq !== undefined) {\n      rpcResp.id = rpcReq.id !== undefined ? rpcReq.id : null;\n    }\n\n    return rpcResp;\n  }\n\n  private async _handleSingleWsRequest(\n    rpcReq: JsonRpcRequest,\n    subscriptions: string[]\n  ) {\n    const rpcResp = await this._handleSingleRequest(rpcReq);\n\n    // If eth_subscribe was successful, keep track of the subscription id,\n    // so we can cleanup on websocket close.\n    if (\n      rpcReq.method === \"eth_subscribe\" &&\n      isSuccessfulJsonResponse(rpcResp)\n    ) {\n      subscriptions.push(rpcResp.result);\n    }\n\n    return rpcResp;\n  }\n\n  private _handleRequest = async (\n    req: JsonRpcRequest\n  ): Promise<JsonRpcResponse> => {\n    const result = await this._provider.request({\n      method: req.method,\n      params: req.params,\n    });\n\n    return {\n      jsonrpc: \"2.0\",\n      id: req.id,\n      result,\n    };\n  };\n}\n\nconst _readJsonHttpRequest = async (req: IncomingMessage): Promise<any> => {\n  let json;\n\n  try {\n    const buf = await getRawBody(req);\n    const text = buf.toString();\n\n    json = JSON.parse(text);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new InvalidJsonInputError(`Parse error: ${error.message}`);\n    }\n\n    // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n\n  return json;\n};\n\nconst _readWsRequest = (msg: string): JsonRpcRequest | JsonRpcRequest[] => {\n  let json: any;\n  try {\n    json = JSON.parse(msg);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new InvalidJsonInputError(`Parse error: ${error.message}`);\n    }\n\n    // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n\n  return json;\n};\n\nconst _handleError = (error: any): JsonRpcResponse => {\n  // extract the relevant fields from the error before wrapping it\n  let txHash: string | undefined;\n  let returnData: string | undefined;\n\n  if (error.transactionHash !== undefined) {\n    txHash = error.transactionHash;\n  }\n  if (error.data !== undefined) {\n    if (error.data?.data !== undefined) {\n      returnData = error.data.data;\n    } else {\n      returnData = error.data;\n    }\n\n    if (txHash === undefined && error.data?.transactionHash !== undefined) {\n      txHash = error.data.transactionHash;\n    }\n  }\n\n  // In case of non-hardhat error, treat it as internal and associate the appropriate error code.\n  if (!ProviderError.isProviderError(error)) {\n    error = new InternalError(error);\n  }\n\n  const response: FailedJsonRpcResponse = {\n    jsonrpc: \"2.0\",\n    id: null,\n    error: {\n      code: error.code,\n      message: error.message,\n    },\n  };\n\n  response.error.data = {\n    message: error.message,\n  };\n\n  if (txHash !== undefined) {\n    response.error.data.txHash = txHash;\n  }\n\n  if (returnData !== undefined) {\n    response.error.data.data = returnData;\n  }\n\n  return response;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}