{"ast":null,"code":"import { addInstrumentationHandler, getGlobalObject, logger } from '@sentry/utils';\nvar global = getGlobalObject();\n/**\n * Default function implementing pageload and navigation transactions\n */\nexport function defaultRoutingInstrumentation(startTransaction, startTransactionOnPageLoad, startTransactionOnLocationChange) {\n  if (startTransactionOnPageLoad === void 0) {\n    startTransactionOnPageLoad = true;\n  }\n  if (startTransactionOnLocationChange === void 0) {\n    startTransactionOnLocationChange = true;\n  }\n  if (!global || !global.location) {\n    logger.warn('Could not initialize routing instrumentation due to invalid location');\n    return;\n  }\n  var startingUrl = global.location.href;\n  var activeTransaction;\n  if (startTransactionOnPageLoad) {\n    activeTransaction = startTransaction({\n      name: global.location.pathname,\n      op: 'pageload'\n    });\n  }\n  if (startTransactionOnLocationChange) {\n    addInstrumentationHandler({\n      callback: function (_a) {\n        var to = _a.to,\n          from = _a.from;\n        /**\n         * This early return is there to account for some cases where a navigation transaction starts right after\n         * long-running pageload. We make sure that if `from` is undefined and a valid `startingURL` exists, we don't\n         * create an uneccessary navigation transaction.\n         *\n         * This was hard to duplicate, but this behavior stopped as soon as this fix was applied. This issue might also\n         * only be caused in certain development environments where the usage of a hot module reloader is causing\n         * errors.\n         */\n        if (from === undefined && startingUrl && startingUrl.indexOf(to) !== -1) {\n          startingUrl = undefined;\n          return;\n        }\n        if (from !== to) {\n          startingUrl = undefined;\n          if (activeTransaction) {\n            logger.log(\"[Tracing] Finishing current transaction with op: \" + activeTransaction.op);\n            // If there's an open transaction on the scope, we need to finish it before creating an new one.\n            activeTransaction.finish();\n          }\n          activeTransaction = startTransaction({\n            name: global.location.pathname,\n            op: 'navigation'\n          });\n        }\n      },\n      type: 'history'\n    });\n  }\n}","map":{"version":3,"names":["addInstrumentationHandler","getGlobalObject","logger","global","defaultRoutingInstrumentation","startTransaction","startTransactionOnPageLoad","startTransactionOnLocationChange","location","warn","startingUrl","href","activeTransaction","name","pathname","op","callback","_a","to","from","undefined","indexOf","log","finish","type"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\@sentry\\tracing\\src\\browser\\router.ts"],"sourcesContent":["import { Transaction, TransactionContext } from '@sentry/types';\nimport { addInstrumentationHandler, getGlobalObject, logger } from '@sentry/utils';\n\nconst global = getGlobalObject<Window>();\n\n/**\n * Default function implementing pageload and navigation transactions\n */\nexport function defaultRoutingInstrumentation<T extends Transaction>(\n  startTransaction: (context: TransactionContext) => T | undefined,\n  startTransactionOnPageLoad: boolean = true,\n  startTransactionOnLocationChange: boolean = true,\n): void {\n  if (!global || !global.location) {\n    logger.warn('Could not initialize routing instrumentation due to invalid location');\n    return;\n  }\n\n  let startingUrl: string | undefined = global.location.href;\n\n  let activeTransaction: T | undefined;\n  if (startTransactionOnPageLoad) {\n    activeTransaction = startTransaction({ name: global.location.pathname, op: 'pageload' });\n  }\n\n  if (startTransactionOnLocationChange) {\n    addInstrumentationHandler({\n      callback: ({ to, from }: { to: string; from?: string }) => {\n        /**\n         * This early return is there to account for some cases where a navigation transaction starts right after\n         * long-running pageload. We make sure that if `from` is undefined and a valid `startingURL` exists, we don't\n         * create an uneccessary navigation transaction.\n         *\n         * This was hard to duplicate, but this behavior stopped as soon as this fix was applied. This issue might also\n         * only be caused in certain development environments where the usage of a hot module reloader is causing\n         * errors.\n         */\n        if (from === undefined && startingUrl && startingUrl.indexOf(to) !== -1) {\n          startingUrl = undefined;\n          return;\n        }\n\n        if (from !== to) {\n          startingUrl = undefined;\n          if (activeTransaction) {\n            logger.log(`[Tracing] Finishing current transaction with op: ${activeTransaction.op}`);\n            // If there's an open transaction on the scope, we need to finish it before creating an new one.\n            activeTransaction.finish();\n          }\n          activeTransaction = startTransaction({ name: global.location.pathname, op: 'navigation' });\n        }\n      },\n      type: 'history',\n    });\n  }\n}\n"],"mappings":"AACA,SAASA,yBAAyB,EAAEC,eAAe,EAAEC,MAAM,QAAQ,eAAe;AAElF,IAAMC,MAAM,GAAGF,eAAe,EAAU;AAExC;;;AAGA,OAAM,SAAUG,6BAA6BA,CAC3CC,gBAAgE,EAChEC,0BAA0C,EAC1CC,gCAAgD;EADhD,IAAAD,0BAAA;IAAAA,0BAAA,OAA0C;EAAA;EAC1C,IAAAC,gCAAA;IAAAA,gCAAA,OAAgD;EAAA;EAEhD,IAAI,CAACJ,MAAM,IAAI,CAACA,MAAM,CAACK,QAAQ,EAAE;IAC/BN,MAAM,CAACO,IAAI,CAAC,sEAAsE,CAAC;IACnF;;EAGF,IAAIC,WAAW,GAAuBP,MAAM,CAACK,QAAQ,CAACG,IAAI;EAE1D,IAAIC,iBAAgC;EACpC,IAAIN,0BAA0B,EAAE;IAC9BM,iBAAiB,GAAGP,gBAAgB,CAAC;MAAEQ,IAAI,EAAEV,MAAM,CAACK,QAAQ,CAACM,QAAQ;MAAEC,EAAE,EAAE;IAAU,CAAE,CAAC;;EAG1F,IAAIR,gCAAgC,EAAE;IACpCP,yBAAyB,CAAC;MACxBgB,QAAQ,EAAE,SAAAA,CAACC,EAA2C;YAAzCC,EAAA,GAAAD,EAAA,CAAAC,EAAE;UAAEC,IAAA,GAAAF,EAAA,CAAAE,IAAI;QACnB;;;;;;;;;QASA,IAAIA,IAAI,KAAKC,SAAS,IAAIV,WAAW,IAAIA,WAAW,CAACW,OAAO,CAACH,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE;UACvER,WAAW,GAAGU,SAAS;UACvB;;QAGF,IAAID,IAAI,KAAKD,EAAE,EAAE;UACfR,WAAW,GAAGU,SAAS;UACvB,IAAIR,iBAAiB,EAAE;YACrBV,MAAM,CAACoB,GAAG,CAAC,sDAAoDV,iBAAiB,CAACG,EAAI,CAAC;YACtF;YACAH,iBAAiB,CAACW,MAAM,EAAE;;UAE5BX,iBAAiB,GAAGP,gBAAgB,CAAC;YAAEQ,IAAI,EAAEV,MAAM,CAACK,QAAQ,CAACM,QAAQ;YAAEC,EAAE,EAAE;UAAY,CAAE,CAAC;;MAE9F,CAAC;MACDS,IAAI,EAAE;KACP,CAAC;;AAEN","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}