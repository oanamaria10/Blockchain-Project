{"ast":null,"code":"import * as UCAN from \"./ucan.js\";\nimport * as UTF8 from \"./utf8.js\";\nimport * as Link from \"multiformats/link\";\nimport { identity } from \"multiformats/hashes/identity\";\nimport * as DID from \"./did.js\";\nimport * as raw from \"multiformats/codecs/raw\";\nimport * as Signature from \"./signature.js\";\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {Record<string, unknown>|UCAN.Payload<C>} data\n * @returns {UCAN.Payload<C>}\n */\nexport const readPayload = data => readPayloadWith(data, {\n  readPrincipal,\n  readProof\n});\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {Record<string, unknown>|UCAN.Payload<C>} data\n * @returns {UCAN.Payload<C>}\n */\nexport const readJWTPayload = data => readPayloadWith(data, {\n  readPrincipal: readStringPrincipal,\n  readProof: readStringProof\n});\n/**\n *\n * @template {UCAN.Capabilities} C\n * @param {Record<string, unknown>|UCAN.Payload<C>} data\n * @param {object} readers\n * @param {(source:unknown, context:string) => UCAN.Principal} readers.readPrincipal\n * @param {(source:unknown, context:string) => UCAN.Link} readers.readProof\n * @returns {UCAN.Payload<C>}\n */\nconst readPayloadWith = (data, {\n  readPrincipal,\n  readProof\n}) => ({\n  iss: readPrincipal(data.iss, \"iss\"),\n  aud: readPrincipal(data.aud, \"aud\"),\n  att: readCapabilities(data.att, \"att\"),\n  prf: readOptionalArray(data.prf, readProof, \"prf\") || [],\n  exp: readNullable(data.exp === Infinity ? null : data.exp, readInt, \"exp\"),\n  nbf: readOptional(data.nbf, readInt, \"nbf\"),\n  fct: readOptionalArray(data.fct, readFact, \"fct\") || [],\n  nnc: readOptional(data.nnc, readString, \"nnc\")\n});\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @param {UCAN.ByteView<UCAN.Signature<T, A>>|unknown} source\n */\nexport const readSignature = source => {\n  if (source instanceof Uint8Array) {\n    return Signature.decode(source);\n  } else {\n    throw new TypeError(`Can only decode Uint8Array into a Signature, instead got ${JSON.stringify(source)}`);\n  }\n};\n\n/**\n * @param {unknown} input\n * @param {string} name\n * @returns {number}\n */\nexport const readInt = (input, name) => Number.isInteger(input) ? ( /** @type {number} */input) : ParseError.throw(`Expected ${name} to be integer, instead got ${JSON.stringify(input)}`);\n\n/**\n * @param {unknown} input\n * @param {string} context\n */\n\nexport const readCapability = (input, context) => readStruct(input, asCapability, context);\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {unknown|C} input\n * @param {string} context\n * @returns {C}\n */\nexport const readCapabilities = (input, context) => ( /** @type {C} */readArray(input, readCapability, context));\n\n/**\n * @template {UCAN.Capability} C\n * @param {object & {can?:unknown, with?:unknown}|C} input\n * @returns {C}\n */\nexport const asCapability = input => ( /** @type {C} */{\n  ...input,\n  can: readAbility(input.can),\n  with: readResource(input.with)\n});\n\n/**\n * @param {unknown} input\n */\nconst readAbility = input => typeof input !== \"string\" ? ParseError.throw(`Capability has invalid 'can: ${JSON.stringify(input)}', value must be a string`) : input.slice(1, -1).includes(\"/\") ? ( /** @type {UCAN.Ability} */input.toLocaleLowerCase()) : input === \"*\" ? input : ParseError.throw(`Capability has invalid 'can: \"${input}\"', value must have at least one path segment`);\n\n/**\n * @param {unknown} input\n */\nconst readResource = input => typeof input !== \"string\" ? ParseError.throw(`Capability has invalid 'with: ${JSON.stringify(input)}', value must be a string`) : parseURL(input) || ParseError.throw(`Capability has invalid 'with: \"${input}\"', value must be a valid URI string`);\n\n/**\n * @param {string} input\n */\nconst parseURL = input => {\n  try {\n    new URL(input);\n    return input;\n  } catch (_) {\n    return null;\n  }\n};\n/**\n * @template T\n * @param {unknown} input\n * @param {(input:unknown, context:string) => T} read\n * @param {string} context\n * @returns {T[]}\n */\nexport const readArray = (input, read, context) => Array.isArray(input) ? input.map((element, n) => read(element, `${context}[${n}]`)) : ParseError.throw(`${context} must be an array`);\n\n/**\n * @template T\n * @param {unknown} input\n * @param {(input:unknown, context: string) => T} reader\n * @param {string} context\n * @returns {T[]|undefined}\n */\nexport const readOptionalArray = (input, reader, context) => input === undefined ? input : readArray(input, reader, context);\n\n/**\n * @template T\n * @param {unknown} input\n * @param {(input:object) => T} reader\n * @param {string} context\n * @returns {T}\n */\nexport const readStruct = (input, reader, context) => input != null && typeof input === \"object\" ? reader(input) : ParseError.throw(`${context} must be of type object, instead got ${input}`);\n\n/**\n * @param {unknown} input\n * @param {string} context\n * @returns {UCAN.Fact}\n */\nexport const readFact = (input, context) => readStruct(input, Object, context);\n\n/**\n * @param {unknown} source\n * @param {string} context\n * @returns {UCAN.Link}\n */\nexport const readProof = (source, context) => Link.isLink(source) ? ( /** @type {UCAN.Link} */source) : fail(`Expected ${context} to be IPLD link, instead got ${JSON.stringify(source)}`);\n\n/**\n * @param {unknown} source\n * @param {string} context\n * @returns {UCAN.Link}\n */\nexport const readStringProof = (source, context) => parseProof(readString(source, context));\n\n/**\n * @param {string} source\n * @returns {UCAN.Link}\n */\nconst parseProof = source => {\n  // First we attempt to read proof as CID, if we fail fallback to reading it as\n  // an inline proof.\n  try {\n    return Link.parse(source);\n  } catch (error) {\n    return Link.create(raw.code, identity.digest(UTF8.encode(source)));\n  }\n};\n\n/**\n * @param {unknown} input\n * @param {string} context\n */\nexport const readPrincipal = (input, context) => DID.decode(readBytes(input, context));\n\n/**\n * @param {unknown} source\n * @param {string} context\n */\nexport const readStringPrincipal = (source, context) => DID.parse(readString(source, context));\n\n/**\n * @template T\n * @param {unknown} source\n * @param {(source:unknown, context:string) => T} read\n * @param {string} [context]\n * @returns {T|undefined}\n */\nexport const readOptional = (source, read, context = \"Field\") => source !== undefined ? read(source, context) : undefined;\n\n/**\n * @template T\n * @param {unknown} source\n * @param {(source:unknown, context:string) => T} read\n * @param {string} context\n * @returns {T|null}\n */\nexport const readNullable = (source, read, context) => source === null ? null : read(source, context);\n\n/**\n * @param {unknown} source\n * @param {string} [context]\n * @returns {string}\n */\nexport const readString = (source, context = \"Field\") => typeof source === \"string\" ? source : fail(`${context} has invalid value ${source}`);\n\n/**\n *\n * @param {unknown} source\n * @param {string} context\n * @returns {Uint8Array}\n */\nexport const readBytes = (source, context) => source instanceof Uint8Array ? source : fail(`Expected ${context} to be Uint8Array, instead got ${JSON.stringify(source)}`);\n\n/**\n * @param {unknown} input\n * @param {string} context\n * @returns {UCAN.Version}\n */\nexport const readVersion = (input, context) => /\\d+\\.\\d+\\.\\d+/.test( /** @type {string} */input) ? ( /** @type {UCAN.Version} */input) : ParseError.throw(`Invalid version '${context}: ${JSON.stringify(input)}'`);\n\n/**\n * @template {string|number|boolean|null} T\n * @param {unknown} input\n * @param {T} literal\n * @param {string} context\n * @returns {T}\n */\nexport const readLiteral = (input, literal, context) => input === literal ? literal : ParseError.throw(`Expected ${context} to be a ${JSON.stringify(literal)} instead got ${JSON.stringify(input)}`);\nexport class ParseError extends TypeError {\n  get name() {\n    return \"ParseError\";\n  }\n  /**\n   * @param {string} message\n   * @returns {never}\n   */\n  static throw(message) {\n    throw new this(message);\n  }\n}\n\n/**\n * @param {string} reason\n */\nexport const fail = reason => ParseError.throw(reason);\nexport { fail as throw };","map":{"version":3,"names":["UCAN","UTF8","Link","identity","DID","raw","Signature","readPayload","data","readPayloadWith","readPrincipal","readProof","readJWTPayload","readStringPrincipal","readStringProof","iss","aud","att","readCapabilities","prf","readOptionalArray","exp","readNullable","Infinity","readInt","nbf","readOptional","fct","readFact","nnc","readString","readSignature","source","Uint8Array","decode","TypeError","JSON","stringify","input","name","Number","isInteger","ParseError","throw","readCapability","context","readStruct","asCapability","readArray","can","readAbility","with","readResource","slice","includes","toLocaleLowerCase","parseURL","URL","_","read","Array","isArray","map","element","n","reader","undefined","Object","isLink","fail","parseProof","parse","error","create","code","digest","encode","readBytes","readVersion","test","readLiteral","literal","message","reason"],"sources":["C:/FACULTATE/Proiect/node_modules/@ipld/dag-ucan/src/schema.js"],"sourcesContent":["import * as UCAN from \"./ucan.js\"\nimport * as UTF8 from \"./utf8.js\"\nimport * as Link from \"multiformats/link\"\nimport { identity } from \"multiformats/hashes/identity\"\nimport * as DID from \"./did.js\"\nimport * as raw from \"multiformats/codecs/raw\"\nimport * as Signature from \"./signature.js\"\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {Record<string, unknown>|UCAN.Payload<C>} data\n * @returns {UCAN.Payload<C>}\n */\nexport const readPayload = data =>\n  readPayloadWith(data, {\n    readPrincipal,\n    readProof,\n  })\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {Record<string, unknown>|UCAN.Payload<C>} data\n * @returns {UCAN.Payload<C>}\n */\nexport const readJWTPayload = data =>\n  readPayloadWith(data, {\n    readPrincipal: readStringPrincipal,\n    readProof: readStringProof,\n  })\n/**\n *\n * @template {UCAN.Capabilities} C\n * @param {Record<string, unknown>|UCAN.Payload<C>} data\n * @param {object} readers\n * @param {(source:unknown, context:string) => UCAN.Principal} readers.readPrincipal\n * @param {(source:unknown, context:string) => UCAN.Link} readers.readProof\n * @returns {UCAN.Payload<C>}\n */\nconst readPayloadWith = (data, { readPrincipal, readProof }) => ({\n  iss: readPrincipal(data.iss, \"iss\"),\n  aud: readPrincipal(data.aud, \"aud\"),\n  att: readCapabilities(data.att, \"att\"),\n  prf: readOptionalArray(data.prf, readProof, \"prf\") || [],\n  exp: readNullable(data.exp === Infinity ? null : data.exp, readInt, \"exp\"),\n  nbf: readOptional(data.nbf, readInt, \"nbf\"),\n  fct: readOptionalArray(data.fct, readFact, \"fct\") || [],\n  nnc: readOptional(data.nnc, readString, \"nnc\"),\n})\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @param {UCAN.ByteView<UCAN.Signature<T, A>>|unknown} source\n */\nexport const readSignature = source => {\n  if (source instanceof Uint8Array) {\n    return Signature.decode(source)\n  } else {\n    throw new TypeError(\n      `Can only decode Uint8Array into a Signature, instead got ${JSON.stringify(\n        source\n      )}`\n    )\n  }\n}\n\n/**\n * @param {unknown} input\n * @param {string} name\n * @returns {number}\n */\nexport const readInt = (input, name) =>\n  Number.isInteger(input)\n    ? /** @type {number} */ (input)\n    : ParseError.throw(\n        `Expected ${name} to be integer, instead got ${JSON.stringify(input)}`\n      )\n\n/**\n * @param {unknown} input\n * @param {string} context\n */\n\nexport const readCapability = (input, context) =>\n  readStruct(input, asCapability, context)\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {unknown|C} input\n * @param {string} context\n * @returns {C}\n */\nexport const readCapabilities = (input, context) =>\n  /** @type {C} */ (readArray(input, readCapability, context))\n\n/**\n * @template {UCAN.Capability} C\n * @param {object & {can?:unknown, with?:unknown}|C} input\n * @returns {C}\n */\nexport const asCapability = input =>\n  /** @type {C} */ ({\n    ...input,\n    can: readAbility(input.can),\n    with: readResource(input.with),\n  })\n\n/**\n * @param {unknown} input\n */\nconst readAbility = input =>\n  typeof input !== \"string\"\n    ? ParseError.throw(\n        `Capability has invalid 'can: ${JSON.stringify(\n          input\n        )}', value must be a string`\n      )\n    : input.slice(1, -1).includes(\"/\")\n    ? /** @type {UCAN.Ability} */ (input.toLocaleLowerCase())\n    : input === \"*\"\n    ? input\n    : ParseError.throw(\n        `Capability has invalid 'can: \"${input}\"', value must have at least one path segment`\n      )\n\n/**\n * @param {unknown} input\n */\nconst readResource = input =>\n  typeof input !== \"string\"\n    ? ParseError.throw(\n        `Capability has invalid 'with: ${JSON.stringify(\n          input\n        )}', value must be a string`\n      )\n    : parseURL(input) ||\n      ParseError.throw(\n        `Capability has invalid 'with: \"${input}\"', value must be a valid URI string`\n      )\n\n/**\n * @param {string} input\n */\nconst parseURL = input => {\n  try {\n    new URL(input)\n    return input\n  } catch (_) {\n    return null\n  }\n}\n/**\n * @template T\n * @param {unknown} input\n * @param {(input:unknown, context:string) => T} read\n * @param {string} context\n * @returns {T[]}\n */\nexport const readArray = (input, read, context) =>\n  Array.isArray(input)\n    ? input.map((element, n) => read(element, `${context}[${n}]`))\n    : ParseError.throw(`${context} must be an array`)\n\n/**\n * @template T\n * @param {unknown} input\n * @param {(input:unknown, context: string) => T} reader\n * @param {string} context\n * @returns {T[]|undefined}\n */\nexport const readOptionalArray = (input, reader, context) =>\n  input === undefined ? input : readArray(input, reader, context)\n\n/**\n * @template T\n * @param {unknown} input\n * @param {(input:object) => T} reader\n * @param {string} context\n * @returns {T}\n */\nexport const readStruct = (input, reader, context) =>\n  input != null && typeof input === \"object\"\n    ? reader(input)\n    : ParseError.throw(\n        `${context} must be of type object, instead got ${input}`\n      )\n\n/**\n * @param {unknown} input\n * @param {string} context\n * @returns {UCAN.Fact}\n */\nexport const readFact = (input, context) => readStruct(input, Object, context)\n\n/**\n * @param {unknown} source\n * @param {string} context\n * @returns {UCAN.Link}\n */\nexport const readProof = (source, context) =>\n  Link.isLink(source)\n    ? /** @type {UCAN.Link} */ (source)\n    : fail(\n        `Expected ${context} to be IPLD link, instead got ${JSON.stringify(\n          source\n        )}`\n      )\n\n/**\n * @param {unknown} source\n * @param {string} context\n * @returns {UCAN.Link}\n */\nexport const readStringProof = (source, context) =>\n  parseProof(readString(source, context))\n\n/**\n * @param {string} source\n * @returns {UCAN.Link}\n */\nconst parseProof = source => {\n  // First we attempt to read proof as CID, if we fail fallback to reading it as\n  // an inline proof.\n  try {\n    return Link.parse(source)\n  } catch (error) {\n    return Link.create(raw.code, identity.digest(UTF8.encode(source)))\n  }\n}\n\n/**\n * @param {unknown} input\n * @param {string} context\n */\nexport const readPrincipal = (input, context) =>\n  DID.decode(readBytes(input, context))\n\n/**\n * @param {unknown} source\n * @param {string} context\n */\nexport const readStringPrincipal = (source, context) =>\n  DID.parse(readString(source, context))\n\n/**\n * @template T\n * @param {unknown} source\n * @param {(source:unknown, context:string) => T} read\n * @param {string} [context]\n * @returns {T|undefined}\n */\nexport const readOptional = (source, read, context = \"Field\") =>\n  source !== undefined ? read(source, context) : undefined\n\n/**\n * @template T\n * @param {unknown} source\n * @param {(source:unknown, context:string) => T} read\n * @param {string} context\n * @returns {T|null}\n */\nexport const readNullable = (source, read, context) =>\n  source === null ? null : read(source, context)\n\n/**\n * @param {unknown} source\n * @param {string} [context]\n * @returns {string}\n */\nexport const readString = (source, context = \"Field\") =>\n  typeof source === \"string\"\n    ? source\n    : fail(`${context} has invalid value ${source}`)\n\n/**\n *\n * @param {unknown} source\n * @param {string} context\n * @returns {Uint8Array}\n */\nexport const readBytes = (source, context) =>\n  source instanceof Uint8Array\n    ? source\n    : fail(\n        `Expected ${context} to be Uint8Array, instead got ${JSON.stringify(\n          source\n        )}`\n      )\n\n/**\n * @param {unknown} input\n * @param {string} context\n * @returns {UCAN.Version}\n */\nexport const readVersion = (input, context) =>\n  /\\d+\\.\\d+\\.\\d+/.test(/** @type {string} */ (input))\n    ? /** @type {UCAN.Version} */ (input)\n    : ParseError.throw(`Invalid version '${context}: ${JSON.stringify(input)}'`)\n\n/**\n * @template {string|number|boolean|null} T\n * @param {unknown} input\n * @param {T} literal\n * @param {string} context\n * @returns {T}\n */\nexport const readLiteral = (input, literal, context) =>\n  input === literal\n    ? literal\n    : ParseError.throw(\n        `Expected ${context} to be a ${JSON.stringify(\n          literal\n        )} instead got ${JSON.stringify(input)}`\n      )\n\nexport class ParseError extends TypeError {\n  get name() {\n    return \"ParseError\"\n  }\n  /**\n   * @param {string} message\n   * @returns {never}\n   */\n  static throw(message) {\n    throw new this(message)\n  }\n}\n\n/**\n * @param {string} reason\n */\nexport const fail = reason => ParseError.throw(reason)\n\nexport { fail as throw }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}