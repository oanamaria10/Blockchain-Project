{"ast":null,"code":"'use strict';\n\nconst {\n  kProxy,\n  kClose,\n  kDestroy,\n  kInterceptors\n} = require('./core/symbols');\nconst {\n  URL\n} = require('url');\nconst Agent = require('./agent');\nconst Pool = require('./pool');\nconst DispatcherBase = require('./dispatcher-base');\nconst {\n  InvalidArgumentError,\n  RequestAbortedError\n} = require('./core/errors');\nconst buildConnector = require('./core/connect');\nconst kAgent = Symbol('proxy agent');\nconst kClient = Symbol('proxy client');\nconst kProxyHeaders = Symbol('proxy headers');\nconst kRequestTls = Symbol('request tls settings');\nconst kProxyTls = Symbol('proxy tls settings');\nconst kConnectEndpoint = Symbol('connect endpoint function');\nfunction defaultProtocolPort(protocol) {\n  return protocol === 'https:' ? 443 : 80;\n}\nfunction buildProxyOptions(opts) {\n  if (typeof opts === 'string') {\n    opts = {\n      uri: opts\n    };\n  }\n  if (!opts || !opts.uri) {\n    throw new InvalidArgumentError('Proxy opts.uri is mandatory');\n  }\n  return {\n    uri: opts.uri,\n    protocol: opts.protocol || 'https'\n  };\n}\nfunction defaultFactory(origin, opts) {\n  return new Pool(origin, opts);\n}\nclass ProxyAgent extends DispatcherBase {\n  constructor(opts) {\n    super(opts);\n    this[kProxy] = buildProxyOptions(opts);\n    this[kAgent] = new Agent(opts);\n    this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];\n    if (typeof opts === 'string') {\n      opts = {\n        uri: opts\n      };\n    }\n    if (!opts || !opts.uri) {\n      throw new InvalidArgumentError('Proxy opts.uri is mandatory');\n    }\n    const {\n      clientFactory = defaultFactory\n    } = opts;\n    if (typeof clientFactory !== 'function') {\n      throw new InvalidArgumentError('Proxy opts.clientFactory must be a function.');\n    }\n    this[kRequestTls] = opts.requestTls;\n    this[kProxyTls] = opts.proxyTls;\n    this[kProxyHeaders] = opts.headers || {};\n    const resolvedUrl = new URL(opts.uri);\n    const {\n      origin,\n      port,\n      host,\n      username,\n      password\n    } = resolvedUrl;\n    if (opts.auth && opts.token) {\n      throw new InvalidArgumentError('opts.auth cannot be used in combination with opts.token');\n    } else if (opts.auth) {\n      /* @deprecated in favour of opts.token */\n      this[kProxyHeaders]['proxy-authorization'] = `Basic ${opts.auth}`;\n    } else if (opts.token) {\n      this[kProxyHeaders]['proxy-authorization'] = opts.token;\n    } else if (username && password) {\n      this[kProxyHeaders]['proxy-authorization'] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString('base64')}`;\n    }\n    const connect = buildConnector({\n      ...opts.proxyTls\n    });\n    this[kConnectEndpoint] = buildConnector({\n      ...opts.requestTls\n    });\n    this[kClient] = clientFactory(resolvedUrl, {\n      connect\n    });\n    this[kAgent] = new Agent({\n      ...opts,\n      connect: async (opts, callback) => {\n        let requestedHost = opts.host;\n        if (!opts.port) {\n          requestedHost += `:${defaultProtocolPort(opts.protocol)}`;\n        }\n        try {\n          const {\n            socket,\n            statusCode\n          } = await this[kClient].connect({\n            origin,\n            port,\n            path: requestedHost,\n            signal: opts.signal,\n            headers: {\n              ...this[kProxyHeaders],\n              host\n            }\n          });\n          if (statusCode !== 200) {\n            socket.on('error', () => {}).destroy();\n            callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));\n          }\n          if (opts.protocol !== 'https:') {\n            callback(null, socket);\n            return;\n          }\n          let servername;\n          if (this[kRequestTls]) {\n            servername = this[kRequestTls].servername;\n          } else {\n            servername = opts.servername;\n          }\n          this[kConnectEndpoint]({\n            ...opts,\n            servername,\n            httpSocket: socket\n          }, callback);\n        } catch (err) {\n          callback(err);\n        }\n      }\n    });\n  }\n  dispatch(opts, handler) {\n    const {\n      host\n    } = new URL(opts.origin);\n    const headers = buildHeaders(opts.headers);\n    throwIfProxyAuthIsSent(headers);\n    return this[kAgent].dispatch({\n      ...opts,\n      headers: {\n        ...headers,\n        host\n      }\n    }, handler);\n  }\n  async [kClose]() {\n    await this[kAgent].close();\n    await this[kClient].close();\n  }\n  async [kDestroy]() {\n    await this[kAgent].destroy();\n    await this[kClient].destroy();\n  }\n}\n\n/**\n * @param {string[] | Record<string, string>} headers\n * @returns {Record<string, string>}\n */\nfunction buildHeaders(headers) {\n  // When using undici.fetch, the headers list is stored\n  // as an array.\n  if (Array.isArray(headers)) {\n    /** @type {Record<string, string>} */\n    const headersPair = {};\n    for (let i = 0; i < headers.length; i += 2) {\n      headersPair[headers[i]] = headers[i + 1];\n    }\n    return headersPair;\n  }\n  return headers;\n}\n\n/**\n * @param {Record<string, string>} headers\n *\n * Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers\n * Nevertheless, it was changed and to avoid a security vulnerability by end users\n * this check was created.\n * It should be removed in the next major version for performance reasons\n */\nfunction throwIfProxyAuthIsSent(headers) {\n  const existProxyAuth = headers && Object.keys(headers).find(key => key.toLowerCase() === 'proxy-authorization');\n  if (existProxyAuth) {\n    throw new InvalidArgumentError('Proxy-Authorization should be sent in ProxyAgent constructor');\n  }\n}\nmodule.exports = ProxyAgent;","map":{"version":3,"names":["kProxy","kClose","kDestroy","kInterceptors","require","URL","Agent","Pool","DispatcherBase","InvalidArgumentError","RequestAbortedError","buildConnector","kAgent","Symbol","kClient","kProxyHeaders","kRequestTls","kProxyTls","kConnectEndpoint","defaultProtocolPort","protocol","buildProxyOptions","opts","uri","defaultFactory","origin","ProxyAgent","constructor","interceptors","Array","isArray","clientFactory","requestTls","proxyTls","headers","resolvedUrl","port","host","username","password","auth","token","Buffer","from","decodeURIComponent","toString","connect","callback","requestedHost","socket","statusCode","path","signal","on","destroy","servername","httpSocket","err","dispatch","handler","buildHeaders","throwIfProxyAuthIsSent","close","headersPair","i","length","existProxyAuth","Object","keys","find","key","toLowerCase","module","exports"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/undici/lib/proxy-agent.js"],"sourcesContent":["'use strict'\n\nconst { kProxy, kClose, kDestroy, kInterceptors } = require('./core/symbols')\nconst { URL } = require('url')\nconst Agent = require('./agent')\nconst Pool = require('./pool')\nconst DispatcherBase = require('./dispatcher-base')\nconst { InvalidArgumentError, RequestAbortedError } = require('./core/errors')\nconst buildConnector = require('./core/connect')\n\nconst kAgent = Symbol('proxy agent')\nconst kClient = Symbol('proxy client')\nconst kProxyHeaders = Symbol('proxy headers')\nconst kRequestTls = Symbol('request tls settings')\nconst kProxyTls = Symbol('proxy tls settings')\nconst kConnectEndpoint = Symbol('connect endpoint function')\n\nfunction defaultProtocolPort (protocol) {\n  return protocol === 'https:' ? 443 : 80\n}\n\nfunction buildProxyOptions (opts) {\n  if (typeof opts === 'string') {\n    opts = { uri: opts }\n  }\n\n  if (!opts || !opts.uri) {\n    throw new InvalidArgumentError('Proxy opts.uri is mandatory')\n  }\n\n  return {\n    uri: opts.uri,\n    protocol: opts.protocol || 'https'\n  }\n}\n\nfunction defaultFactory (origin, opts) {\n  return new Pool(origin, opts)\n}\n\nclass ProxyAgent extends DispatcherBase {\n  constructor (opts) {\n    super(opts)\n    this[kProxy] = buildProxyOptions(opts)\n    this[kAgent] = new Agent(opts)\n    this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent)\n      ? opts.interceptors.ProxyAgent\n      : []\n\n    if (typeof opts === 'string') {\n      opts = { uri: opts }\n    }\n\n    if (!opts || !opts.uri) {\n      throw new InvalidArgumentError('Proxy opts.uri is mandatory')\n    }\n\n    const { clientFactory = defaultFactory } = opts\n\n    if (typeof clientFactory !== 'function') {\n      throw new InvalidArgumentError('Proxy opts.clientFactory must be a function.')\n    }\n\n    this[kRequestTls] = opts.requestTls\n    this[kProxyTls] = opts.proxyTls\n    this[kProxyHeaders] = opts.headers || {}\n\n    const resolvedUrl = new URL(opts.uri)\n    const { origin, port, host, username, password } = resolvedUrl\n\n    if (opts.auth && opts.token) {\n      throw new InvalidArgumentError('opts.auth cannot be used in combination with opts.token')\n    } else if (opts.auth) {\n      /* @deprecated in favour of opts.token */\n      this[kProxyHeaders]['proxy-authorization'] = `Basic ${opts.auth}`\n    } else if (opts.token) {\n      this[kProxyHeaders]['proxy-authorization'] = opts.token\n    } else if (username && password) {\n      this[kProxyHeaders]['proxy-authorization'] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString('base64')}`\n    }\n\n    const connect = buildConnector({ ...opts.proxyTls })\n    this[kConnectEndpoint] = buildConnector({ ...opts.requestTls })\n    this[kClient] = clientFactory(resolvedUrl, { connect })\n    this[kAgent] = new Agent({\n      ...opts,\n      connect: async (opts, callback) => {\n        let requestedHost = opts.host\n        if (!opts.port) {\n          requestedHost += `:${defaultProtocolPort(opts.protocol)}`\n        }\n        try {\n          const { socket, statusCode } = await this[kClient].connect({\n            origin,\n            port,\n            path: requestedHost,\n            signal: opts.signal,\n            headers: {\n              ...this[kProxyHeaders],\n              host\n            }\n          })\n          if (statusCode !== 200) {\n            socket.on('error', () => {}).destroy()\n            callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`))\n          }\n          if (opts.protocol !== 'https:') {\n            callback(null, socket)\n            return\n          }\n          let servername\n          if (this[kRequestTls]) {\n            servername = this[kRequestTls].servername\n          } else {\n            servername = opts.servername\n          }\n          this[kConnectEndpoint]({ ...opts, servername, httpSocket: socket }, callback)\n        } catch (err) {\n          callback(err)\n        }\n      }\n    })\n  }\n\n  dispatch (opts, handler) {\n    const { host } = new URL(opts.origin)\n    const headers = buildHeaders(opts.headers)\n    throwIfProxyAuthIsSent(headers)\n    return this[kAgent].dispatch(\n      {\n        ...opts,\n        headers: {\n          ...headers,\n          host\n        }\n      },\n      handler\n    )\n  }\n\n  async [kClose] () {\n    await this[kAgent].close()\n    await this[kClient].close()\n  }\n\n  async [kDestroy] () {\n    await this[kAgent].destroy()\n    await this[kClient].destroy()\n  }\n}\n\n/**\n * @param {string[] | Record<string, string>} headers\n * @returns {Record<string, string>}\n */\nfunction buildHeaders (headers) {\n  // When using undici.fetch, the headers list is stored\n  // as an array.\n  if (Array.isArray(headers)) {\n    /** @type {Record<string, string>} */\n    const headersPair = {}\n\n    for (let i = 0; i < headers.length; i += 2) {\n      headersPair[headers[i]] = headers[i + 1]\n    }\n\n    return headersPair\n  }\n\n  return headers\n}\n\n/**\n * @param {Record<string, string>} headers\n *\n * Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers\n * Nevertheless, it was changed and to avoid a security vulnerability by end users\n * this check was created.\n * It should be removed in the next major version for performance reasons\n */\nfunction throwIfProxyAuthIsSent (headers) {\n  const existProxyAuth = headers && Object.keys(headers)\n    .find((key) => key.toLowerCase() === 'proxy-authorization')\n  if (existProxyAuth) {\n    throw new InvalidArgumentError('Proxy-Authorization should be sent in ProxyAgent constructor')\n  }\n}\n\nmodule.exports = ProxyAgent\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}