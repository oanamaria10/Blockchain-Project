{"ast":null,"code":"/* eslint-disable */\n\n'use strict';\n\n// Extracted from node/lib/internal/fixed_queue.js\n\n// Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.\nconst kSize = 2048;\nconst kMask = kSize - 1;\n\n// The FixedQueue is implemented as a singly-linked list of fixed-size\n// circular buffers. It looks something like this:\n//\n//  head                                                       tail\n//    |                                                          |\n//    v                                                          v\n// +-----------+ <-----\\       +-----------+ <------\\         +-----------+\n// |  [null]   |        \\----- |   next    |         \\------- |   next    |\n// +-----------+               +-----------+                  +-----------+\n// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |       bottom --> |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |    ...    |               |    ...    |                  |    ...    |\n// |   item    |               |   item    |                  |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |  [empty]  | <-- top       |   item    |                  |   item    |\n// |  [empty]  |               |   item    |                  |   item    |\n// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |\n// +-----------+               +-----------+                  +-----------+\n//\n// Or, if there is only one circular buffer, it looks something\n// like either of these:\n//\n//  head   tail                                 head   tail\n//    |     |                                     |     |\n//    v     v                                     v     v\n// +-----------+                               +-----------+\n// |  [null]   |                               |  [null]   |\n// +-----------+                               +-----------+\n// |  [empty]  |                               |   item    |\n// |  [empty]  |                               |   item    |\n// |   item    | <-- bottom            top --> |  [empty]  |\n// |   item    |                               |  [empty]  |\n// |  [empty]  | <-- top            bottom --> |   item    |\n// |  [empty]  |                               |   item    |\n// +-----------+                               +-----------+\n//\n// Adding a value means moving `top` forward by one, removing means\n// moving `bottom` forward by one. After reaching the end, the queue\n// wraps around.\n//\n// When `top === bottom` the current queue is empty and when\n// `top + 1 === bottom` it's full. This wastes a single space of storage\n// but allows much quicker checks.\n\nclass FixedCircularBuffer {\n  constructor() {\n    this.bottom = 0;\n    this.top = 0;\n    this.list = new Array(kSize);\n    this.next = null;\n  }\n  isEmpty() {\n    return this.top === this.bottom;\n  }\n  isFull() {\n    return (this.top + 1 & kMask) === this.bottom;\n  }\n  push(data) {\n    this.list[this.top] = data;\n    this.top = this.top + 1 & kMask;\n  }\n  shift() {\n    const nextItem = this.list[this.bottom];\n    if (nextItem === undefined) return null;\n    this.list[this.bottom] = undefined;\n    this.bottom = this.bottom + 1 & kMask;\n    return nextItem;\n  }\n}\nmodule.exports = class FixedQueue {\n  constructor() {\n    this.head = this.tail = new FixedCircularBuffer();\n  }\n  isEmpty() {\n    return this.head.isEmpty();\n  }\n  push(data) {\n    if (this.head.isFull()) {\n      // Head is full: Creates a new queue, sets the old queue's `.next` to it,\n      // and sets it as the new main queue.\n      this.head = this.head.next = new FixedCircularBuffer();\n    }\n    this.head.push(data);\n  }\n  shift() {\n    const tail = this.tail;\n    const next = tail.shift();\n    if (tail.isEmpty() && tail.next !== null) {\n      // If there is another queue, it forms the new tail.\n      this.tail = tail.next;\n    }\n    return next;\n  }\n};","map":{"version":3,"names":["kSize","kMask","FixedCircularBuffer","constructor","bottom","top","list","Array","next","isEmpty","isFull","push","data","shift","nextItem","undefined","module","exports","FixedQueue","head","tail"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/undici/lib/node/fixed-queue.js"],"sourcesContent":["/* eslint-disable */\n\n'use strict'\n\n// Extracted from node/lib/internal/fixed_queue.js\n\n// Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.\nconst kSize = 2048;\nconst kMask = kSize - 1;\n\n// The FixedQueue is implemented as a singly-linked list of fixed-size\n// circular buffers. It looks something like this:\n//\n//  head                                                       tail\n//    |                                                          |\n//    v                                                          v\n// +-----------+ <-----\\       +-----------+ <------\\         +-----------+\n// |  [null]   |        \\----- |   next    |         \\------- |   next    |\n// +-----------+               +-----------+                  +-----------+\n// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |       bottom --> |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |    ...    |               |    ...    |                  |    ...    |\n// |   item    |               |   item    |                  |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |  [empty]  | <-- top       |   item    |                  |   item    |\n// |  [empty]  |               |   item    |                  |   item    |\n// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |\n// +-----------+               +-----------+                  +-----------+\n//\n// Or, if there is only one circular buffer, it looks something\n// like either of these:\n//\n//  head   tail                                 head   tail\n//    |     |                                     |     |\n//    v     v                                     v     v\n// +-----------+                               +-----------+\n// |  [null]   |                               |  [null]   |\n// +-----------+                               +-----------+\n// |  [empty]  |                               |   item    |\n// |  [empty]  |                               |   item    |\n// |   item    | <-- bottom            top --> |  [empty]  |\n// |   item    |                               |  [empty]  |\n// |  [empty]  | <-- top            bottom --> |   item    |\n// |  [empty]  |                               |   item    |\n// +-----------+                               +-----------+\n//\n// Adding a value means moving `top` forward by one, removing means\n// moving `bottom` forward by one. After reaching the end, the queue\n// wraps around.\n//\n// When `top === bottom` the current queue is empty and when\n// `top + 1 === bottom` it's full. This wastes a single space of storage\n// but allows much quicker checks.\n\nclass FixedCircularBuffer {\n  constructor() {\n    this.bottom = 0;\n    this.top = 0;\n    this.list = new Array(kSize);\n    this.next = null;\n  }\n\n  isEmpty() {\n    return this.top === this.bottom;\n  }\n\n  isFull() {\n    return ((this.top + 1) & kMask) === this.bottom;\n  }\n\n  push(data) {\n    this.list[this.top] = data;\n    this.top = (this.top + 1) & kMask;\n  }\n\n  shift() {\n    const nextItem = this.list[this.bottom];\n    if (nextItem === undefined)\n      return null;\n    this.list[this.bottom] = undefined;\n    this.bottom = (this.bottom + 1) & kMask;\n    return nextItem;\n  }\n}\n\nmodule.exports = class FixedQueue {\n  constructor() {\n    this.head = this.tail = new FixedCircularBuffer();\n  }\n\n  isEmpty() {\n    return this.head.isEmpty();\n  }\n\n  push(data) {\n    if (this.head.isFull()) {\n      // Head is full: Creates a new queue, sets the old queue's `.next` to it,\n      // and sets it as the new main queue.\n      this.head = this.head.next = new FixedCircularBuffer();\n    }\n    this.head.push(data);\n  }\n\n  shift() {\n    const tail = this.tail;\n    const next = tail.shift();\n    if (tail.isEmpty() && tail.next !== null) {\n      // If there is another queue, it forms the new tail.\n      this.tail = tail.next;\n    }\n    return next;\n  }\n};\n"],"mappings":"AAAA;;AAEA,YAAY;;AAEZ;;AAEA;AACA,MAAMA,KAAK,GAAG,IAAI;AAClB,MAAMC,KAAK,GAAGD,KAAK,GAAG,CAAC;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAME,mBAAmB,CAAC;EACxBC,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACC,MAAM,GAAG,CAAC;IACf,IAAI,CAACC,GAAG,GAAG,CAAC;IACZ,IAAI,CAACC,IAAI,GAAG,IAAIC,KAAK,CAACP,KAAK,CAAC;IAC5B,IAAI,CAACQ,IAAI,GAAG,IAAI;EAClB;EAEAC,OAAOA,CAAA,EAAG;IACR,OAAO,IAAI,CAACJ,GAAG,KAAK,IAAI,CAACD,MAAM;EACjC;EAEAM,MAAMA,CAAA,EAAG;IACP,OAAO,CAAE,IAAI,CAACL,GAAG,GAAG,CAAC,GAAIJ,KAAK,MAAM,IAAI,CAACG,MAAM;EACjD;EAEAO,IAAIA,CAACC,IAAI,EAAE;IACT,IAAI,CAACN,IAAI,CAAC,IAAI,CAACD,GAAG,CAAC,GAAGO,IAAI;IAC1B,IAAI,CAACP,GAAG,GAAI,IAAI,CAACA,GAAG,GAAG,CAAC,GAAIJ,KAAK;EACnC;EAEAY,KAAKA,CAAA,EAAG;IACN,MAAMC,QAAQ,GAAG,IAAI,CAACR,IAAI,CAAC,IAAI,CAACF,MAAM,CAAC;IACvC,IAAIU,QAAQ,KAAKC,SAAS,EACxB,OAAO,IAAI;IACb,IAAI,CAACT,IAAI,CAAC,IAAI,CAACF,MAAM,CAAC,GAAGW,SAAS;IAClC,IAAI,CAACX,MAAM,GAAI,IAAI,CAACA,MAAM,GAAG,CAAC,GAAIH,KAAK;IACvC,OAAOa,QAAQ;EACjB;AACF;AAEAE,MAAM,CAACC,OAAO,GAAG,MAAMC,UAAU,CAAC;EAChCf,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACgB,IAAI,GAAG,IAAI,CAACC,IAAI,GAAG,IAAIlB,mBAAmB,CAAC,CAAC;EACnD;EAEAO,OAAOA,CAAA,EAAG;IACR,OAAO,IAAI,CAACU,IAAI,CAACV,OAAO,CAAC,CAAC;EAC5B;EAEAE,IAAIA,CAACC,IAAI,EAAE;IACT,IAAI,IAAI,CAACO,IAAI,CAACT,MAAM,CAAC,CAAC,EAAE;MACtB;MACA;MACA,IAAI,CAACS,IAAI,GAAG,IAAI,CAACA,IAAI,CAACX,IAAI,GAAG,IAAIN,mBAAmB,CAAC,CAAC;IACxD;IACA,IAAI,CAACiB,IAAI,CAACR,IAAI,CAACC,IAAI,CAAC;EACtB;EAEAC,KAAKA,CAAA,EAAG;IACN,MAAMO,IAAI,GAAG,IAAI,CAACA,IAAI;IACtB,MAAMZ,IAAI,GAAGY,IAAI,CAACP,KAAK,CAAC,CAAC;IACzB,IAAIO,IAAI,CAACX,OAAO,CAAC,CAAC,IAAIW,IAAI,CAACZ,IAAI,KAAK,IAAI,EAAE;MACxC;MACA,IAAI,CAACY,IAAI,GAAGA,IAAI,CAACZ,IAAI;IACvB;IACA,OAAOA,IAAI;EACb;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}