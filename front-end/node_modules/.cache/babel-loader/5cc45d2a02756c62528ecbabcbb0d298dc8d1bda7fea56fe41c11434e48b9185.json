{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SimpleScopeDefinition = exports.OverriddenTaskDefinition = exports.SimpleTaskDefinition = void 0;\nconst errors_1 = require(\"../errors\");\nconst errors_list_1 = require(\"../errors-list\");\nconst types = __importStar(require(\"../params/argumentTypes\"));\nconst hardhat_params_1 = require(\"../params/hardhat-params\");\nconst util_1 = require(\"./util\");\nfunction isCLIArgumentType(type) {\n  return \"parse\" in type;\n}\n/**\n * This class creates a task definition, which consists of:\n * * a name, that should be unique and will be used to call the task.\n * * a description. This is optional.\n * * the action that the task will execute.\n * * a set of parameters that can be used by the action.\n *\n */\nclass SimpleTaskDefinition {\n  get name() {\n    return this._task;\n  }\n  get scope() {\n    return this._scope;\n  }\n  get description() {\n    return this._description;\n  }\n  /**\n   * Creates an empty task definition.\n   *\n   * This definition will have no params, and will throw a HH205 if executed.\n   *\n   * @param taskIdentifier The task's identifier.\n   * @param isSubtask `true` if the task is a subtask, `false` otherwise.\n   */\n  constructor(taskIdentifier, isSubtask = false) {\n    this.isSubtask = isSubtask;\n    this.paramDefinitions = {};\n    this.positionalParamDefinitions = [];\n    this._positionalParamNames = new Set();\n    this._hasVariadicParam = false;\n    this._hasOptionalPositionalParam = false;\n    const {\n      scope,\n      task\n    } = (0, util_1.parseTaskIdentifier)(taskIdentifier);\n    this._scope = scope;\n    this._task = task;\n    this.action = () => {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.TASK_DEFINITIONS.ACTION_NOT_SET, {\n        taskName: this._task\n      });\n    };\n  }\n  /**\n   * Sets the task's description.\n   * @param description The description.\n   */\n  setDescription(description) {\n    this._description = description;\n    return this;\n  }\n  /**\n   * Sets the task's action.\n   * @param action The action.\n   */\n  setAction(action) {\n    // TODO: There's probably something bad here. See types.ts for more info.\n    this.action = action;\n    return this;\n  }\n  /**\n   * Adds a parameter to the task's definition.\n   *\n   * @remarks This will throw if the `name` is already used by this task or\n   * by Hardhat's global parameters.\n   *\n   * @param name The parameter's name.\n   * @param description The parameter's description.\n   * @param defaultValue A default value. This must be `undefined` if `isOptional` is `true`.\n   * @param type The param's `ArgumentType`. It will parse and validate the user's input.\n   * @param isOptional `true` if the parameter is optional. It's default value is `true` if `defaultValue` is not `undefined`.\n   */\n  addParam(name, description, defaultValue, type, isOptional = defaultValue !== undefined) {\n    if (type === undefined) {\n      if (defaultValue === undefined) {\n        return this.addParam(name, description, undefined, types.string, isOptional);\n      }\n      if (typeof defaultValue !== \"string\") {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.TASK_DEFINITIONS.DEFAULT_VALUE_WRONG_TYPE, {\n          paramName: name,\n          taskName: this.name\n        });\n      }\n      return this.addParam(name, description, defaultValue, types.string, isOptional);\n    }\n    this._validateParamNameCasing(name);\n    this._validateNameNotUsed(name);\n    this._validateNoDefaultValueForMandatoryParam(defaultValue, isOptional, name);\n    this._validateCLIArgumentTypesForExternalTasks(type);\n    this.paramDefinitions[name] = {\n      name,\n      defaultValue,\n      type,\n      description,\n      isOptional,\n      isFlag: false,\n      isVariadic: false\n    };\n    return this;\n  }\n  /**\n   * Adds an optional parameter to the task's definition.\n   *\n   * @see addParam.\n   *\n   * @param name the parameter's name.\n   * @param description the parameter's description.\n   * @param defaultValue a default value.\n   * @param type param's type.\n   */\n  addOptionalParam(name, description, defaultValue, type) {\n    return this.addParam(name, description, defaultValue, type, true);\n  }\n  /**\n   * Adds a boolean parameter or flag to the task's definition.\n   *\n   * Flags are params with default value set to `false`, and that don't expect\n   * values to be set in the CLI. A normal boolean param must be called with\n   * `--param true`, while a flag is called with `--flag`.\n   *\n   * @param name the parameter's name.\n   * @param description the parameter's description.\n   */\n  addFlag(name, description) {\n    this._validateParamNameCasing(name);\n    this._validateNameNotUsed(name);\n    this.paramDefinitions[name] = {\n      name,\n      defaultValue: false,\n      type: types.boolean,\n      description,\n      isFlag: true,\n      isOptional: true,\n      isVariadic: false\n    };\n    return this;\n  }\n  /**\n   * Adds a positional parameter to the task's definition.\n   *\n   * @remarks This will throw if the `name` is already used by this task or\n   * by Hardhat's global parameters.\n   * @remarks This will throw if `isOptional` is `false` and an optional positional\n   * param was already set.\n   * @remarks This will throw if a variadic positional param is already set.\n   *\n   * @param name The parameter's name.\n   * @param description The parameter's description.\n   * @param defaultValue A default value. This must be `undefined` if `isOptional` is `true`.\n   * @param type The param's `ArgumentType`. It will parse and validate the user's input.\n   * @param isOptional `true` if the parameter is optional. It's default value is `true` if `defaultValue` is not `undefined`.\n   */\n  addPositionalParam(name, description, defaultValue, type, isOptional = defaultValue !== undefined) {\n    if (type === undefined) {\n      if (defaultValue === undefined) {\n        return this.addPositionalParam(name, description, undefined, types.string, isOptional);\n      }\n      if (typeof defaultValue !== \"string\") {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.TASK_DEFINITIONS.DEFAULT_VALUE_WRONG_TYPE, {\n          paramName: name,\n          taskName: this.name\n        });\n      }\n      return this.addPositionalParam(name, description, defaultValue, types.string, isOptional);\n    }\n    this._validateParamNameCasing(name);\n    this._validateNameNotUsed(name);\n    this._validateNotAfterVariadicParam(name);\n    this._validateNoMandatoryParamAfterOptionalOnes(name, isOptional);\n    this._validateNoDefaultValueForMandatoryParam(defaultValue, isOptional, name);\n    this._validateCLIArgumentTypesForExternalTasks(type);\n    const definition = {\n      name,\n      defaultValue,\n      type,\n      description,\n      isVariadic: false,\n      isOptional,\n      isFlag: false\n    };\n    this._addPositionalParamDefinition(definition);\n    return this;\n  }\n  /**\n   * Adds an optional positional parameter to the task's definition.\n   *\n   * @see addPositionalParam.\n   *\n   * @param name the parameter's name.\n   * @param description the parameter's description.\n   * @param defaultValue a default value.\n   * @param type param's type.\n   */\n  addOptionalPositionalParam(name, description, defaultValue, type) {\n    return this.addPositionalParam(name, description, defaultValue, type, true);\n  }\n  /**\n   * Adds a variadic positional parameter to the task's definition. Variadic\n   * positional params act as `...rest` parameters in JavaScript.\n   *\n   * @param name The parameter's name.\n   * @param description The parameter's description.\n   * @param defaultValue A default value. This must be `undefined` if `isOptional` is `true`.\n   * @param type The param's `ArgumentType`. It will parse and validate the user's input.\n   * @param isOptional `true` if the parameter is optional. It's default value is `true` if `defaultValue` is not `undefined`.\n   */\n  addVariadicPositionalParam(name, description, defaultValue, type, isOptional = defaultValue !== undefined) {\n    if (defaultValue !== undefined && !Array.isArray(defaultValue)) {\n      defaultValue = [defaultValue];\n    }\n    if (type === undefined) {\n      if (defaultValue === undefined) {\n        return this.addVariadicPositionalParam(name, description, undefined, types.string, isOptional);\n      }\n      if (!this._isStringArray(defaultValue)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.TASK_DEFINITIONS.DEFAULT_VALUE_WRONG_TYPE, {\n          paramName: name,\n          taskName: this.name\n        });\n      }\n      return this.addVariadicPositionalParam(name, description, defaultValue, types.string, isOptional);\n    }\n    this._validateParamNameCasing(name);\n    this._validateNameNotUsed(name);\n    this._validateNotAfterVariadicParam(name);\n    this._validateNoMandatoryParamAfterOptionalOnes(name, isOptional);\n    this._validateNoDefaultValueForMandatoryParam(defaultValue, isOptional, name);\n    this._validateCLIArgumentTypesForExternalTasks(type);\n    const definition = {\n      name,\n      defaultValue,\n      type,\n      description,\n      isVariadic: true,\n      isOptional,\n      isFlag: false\n    };\n    this._addPositionalParamDefinition(definition);\n    return this;\n  }\n  /**\n   * Adds a positional parameter to the task's definition.\n   *\n   * This will check if the `name` is already used and\n   * if the parameter is being added after a varidic argument.\n   *\n   * @param name the parameter's name.\n   * @param description the parameter's description.\n   * @param defaultValue a default value.\n   * @param type param's type.\n   */\n  addOptionalVariadicPositionalParam(name, description, defaultValue, type) {\n    return this.addVariadicPositionalParam(name, description, defaultValue, type, true);\n  }\n  /**\n   * Adds a positional parameter to the task's definition.\n   *\n   * @param definition the param's definition\n   */\n  _addPositionalParamDefinition(definition) {\n    if (definition.isVariadic) {\n      this._hasVariadicParam = true;\n    }\n    if (definition.isOptional) {\n      this._hasOptionalPositionalParam = true;\n    }\n    this._positionalParamNames.add(definition.name);\n    this.positionalParamDefinitions.push(definition);\n  }\n  /**\n   * Validates if the given param's name is after a variadic parameter.\n   * @param name the param's name.\n   * @throws HH200\n   */\n  _validateNotAfterVariadicParam(name) {\n    if (this._hasVariadicParam) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.TASK_DEFINITIONS.PARAM_AFTER_VARIADIC, {\n        paramName: name,\n        taskName: this.name\n      });\n    }\n  }\n  /**\n   * Validates if the param's name is already used.\n   * @param name the param's name.\n   *\n   * @throws HH201 if `name` is already used as a param.\n   * @throws HH202 if `name` is already used as a param by Hardhat\n   */\n  _validateNameNotUsed(name) {\n    if (this._hasParamDefined(name)) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.TASK_DEFINITIONS.PARAM_ALREADY_DEFINED, {\n        paramName: name,\n        taskName: this.name\n      });\n    }\n    if (Object.keys(hardhat_params_1.HARDHAT_PARAM_DEFINITIONS).includes(name)) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.TASK_DEFINITIONS.PARAM_CLASHES_WITH_HARDHAT_PARAM, {\n        paramName: name,\n        taskName: this.name\n      });\n    }\n  }\n  /**\n   * Checks if the given name is already used.\n   * @param name the param's name.\n   */\n  _hasParamDefined(name) {\n    return this.paramDefinitions[name] !== undefined || this._positionalParamNames.has(name);\n  }\n  /**\n   * Validates if a mandatory param is being added after optional params.\n   *\n   * @param name the param's name to be added.\n   * @param isOptional true if the new param is optional, false otherwise.\n   *\n   * @throws HH203 if validation fail\n   */\n  _validateNoMandatoryParamAfterOptionalOnes(name, isOptional) {\n    if (!isOptional && this._hasOptionalPositionalParam) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.TASK_DEFINITIONS.MANDATORY_PARAM_AFTER_OPTIONAL, {\n        paramName: name,\n        taskName: this.name\n      });\n    }\n  }\n  _validateParamNameCasing(name) {\n    const pattern = /^[a-z]+([a-zA-Z0-9])*$/;\n    const match = name.match(pattern);\n    if (match === null) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.TASK_DEFINITIONS.INVALID_PARAM_NAME_CASING, {\n        paramName: name,\n        taskName: this.name\n      });\n    }\n  }\n  _validateNoDefaultValueForMandatoryParam(defaultValue, isOptional, name) {\n    if (defaultValue !== undefined && !isOptional) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.TASK_DEFINITIONS.DEFAULT_IN_MANDATORY_PARAM, {\n        paramName: name,\n        taskName: this.name\n      });\n    }\n  }\n  _isStringArray(values) {\n    return Array.isArray(values) && values.every(v => typeof v === \"string\");\n  }\n  _validateCLIArgumentTypesForExternalTasks(type) {\n    if (this.isSubtask) {\n      return;\n    }\n    if (!isCLIArgumentType(type)) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.TASK_DEFINITIONS.CLI_ARGUMENT_TYPE_REQUIRED, {\n        task: this.name,\n        type: type.name\n      });\n    }\n  }\n}\nexports.SimpleTaskDefinition = SimpleTaskDefinition;\n/**\n * Allows you to override a previously defined task.\n *\n * When overriding a task you can:\n *  * flag it as a subtask\n *  * set a new description\n *  * set a new action\n *\n */\nclass OverriddenTaskDefinition {\n  constructor(parentTaskDefinition, isSubtask = false) {\n    this.parentTaskDefinition = parentTaskDefinition;\n    this.isSubtask = isSubtask;\n    this.isSubtask = isSubtask;\n    this.parentTaskDefinition = parentTaskDefinition;\n  }\n  /**\n   * Sets the task's description.\n   * @param description The description.\n   */\n  setDescription(description) {\n    this._description = description;\n    return this;\n  }\n  /**\n   * Overrides the parent task's action.\n   * @param action the action.\n   */\n  setAction(action) {\n    // TODO: There's probably something bad here. See types.ts for more info.\n    this._action = action;\n    return this;\n  }\n  /**\n   * Retrieves the parent task's scope.\n   */\n  get scope() {\n    return this.parentTaskDefinition.scope;\n  }\n  /**\n   * Retrieves the parent task's name.\n   */\n  get name() {\n    return this.parentTaskDefinition.name;\n  }\n  /**\n   * Retrieves, if defined, the description of the overriden task,\n   * otherwise retrieves the description of the parent task.\n   */\n  get description() {\n    if (this._description !== undefined) {\n      return this._description;\n    }\n    return this.parentTaskDefinition.description;\n  }\n  /**\n   * Retrieves, if defined, the action of the overriden task,\n   * otherwise retrieves the action of the parent task.\n   */\n  get action() {\n    if (this._action !== undefined) {\n      return this._action;\n    }\n    return this.parentTaskDefinition.action;\n  }\n  /**\n   * Retrieves the parent task's param definitions.\n   */\n  get paramDefinitions() {\n    return this.parentTaskDefinition.paramDefinitions;\n  }\n  /**\n   * Retrieves the parent task's positional param definitions.\n   */\n  get positionalParamDefinitions() {\n    return this.parentTaskDefinition.positionalParamDefinitions;\n  }\n  /**\n   * Overriden tasks can't add new parameters.\n   */\n  addParam(name, description, defaultValue, type, isOptional) {\n    if (isOptional === undefined || !isOptional) {\n      return this._throwNoParamsOverrideError(errors_list_1.ERRORS.TASK_DEFINITIONS.OVERRIDE_NO_MANDATORY_PARAMS);\n    }\n    return this.addOptionalParam(name, description, defaultValue, type);\n  }\n  /**\n   * Overriden tasks can't add new parameters.\n   */\n  addOptionalParam(name, description, defaultValue, type) {\n    this.parentTaskDefinition.addOptionalParam(name, description, defaultValue, type);\n    return this;\n  }\n  /**\n   * Overriden tasks can't add new parameters.\n   */\n  addPositionalParam(_name, _description, _defaultValue, _type, _isOptional) {\n    return this._throwNoParamsOverrideError(errors_list_1.ERRORS.TASK_DEFINITIONS.OVERRIDE_NO_POSITIONAL_PARAMS);\n  }\n  /**\n   * Overriden tasks can't add new parameters.\n   */\n  addOptionalPositionalParam(_name, _description, _defaultValue, _type) {\n    return this._throwNoParamsOverrideError(errors_list_1.ERRORS.TASK_DEFINITIONS.OVERRIDE_NO_POSITIONAL_PARAMS);\n  }\n  /**\n   * Overriden tasks can't add new parameters.\n   */\n  addVariadicPositionalParam(_name, _description, _defaultValue, _type, _isOptional) {\n    return this._throwNoParamsOverrideError(errors_list_1.ERRORS.TASK_DEFINITIONS.OVERRIDE_NO_VARIADIC_PARAMS);\n  }\n  /**\n   * Overriden tasks can't add new parameters.\n   */\n  addOptionalVariadicPositionalParam(_name, _description, _defaultValue, _type) {\n    return this._throwNoParamsOverrideError(errors_list_1.ERRORS.TASK_DEFINITIONS.OVERRIDE_NO_VARIADIC_PARAMS);\n  }\n  /**\n   * Add a flag param to the overridden task.\n   * @throws HH201 if param name was already defined in any parent task.\n   * @throws HH209 if param name is not in camelCase.\n   */\n  addFlag(name, description) {\n    this.parentTaskDefinition.addFlag(name, description);\n    return this;\n  }\n  _throwNoParamsOverrideError(errorDescriptor) {\n    throw new errors_1.HardhatError(errorDescriptor, {\n      taskName: this.name\n    });\n  }\n}\nexports.OverriddenTaskDefinition = OverriddenTaskDefinition;\nclass SimpleScopeDefinition {\n  constructor(name, _description, _addTask, _addSubtask) {\n    this.name = name;\n    this._description = _description;\n    this._addTask = _addTask;\n    this._addSubtask = _addSubtask;\n    this.tasks = {};\n  }\n  get description() {\n    return this._description;\n  }\n  setDescription(description) {\n    this._description = description;\n    return this;\n  }\n  task(name, descriptionOrAction, action) {\n    const task = this._addTask(name, descriptionOrAction, action);\n    this.tasks[name] = task;\n    return task;\n  }\n  subtask(name, descriptionOrAction, action) {\n    const subtask = this._addSubtask(name, descriptionOrAction, action);\n    this.tasks[name] = subtask;\n    return subtask;\n  }\n}\nexports.SimpleScopeDefinition = SimpleScopeDefinition;","map":{"version":3,"names":["errors_1","require","errors_list_1","types","__importStar","hardhat_params_1","util_1","isCLIArgumentType","type","SimpleTaskDefinition","name","_task","scope","_scope","description","_description","constructor","taskIdentifier","isSubtask","paramDefinitions","positionalParamDefinitions","_positionalParamNames","Set","_hasVariadicParam","_hasOptionalPositionalParam","task","parseTaskIdentifier","action","HardhatError","ERRORS","TASK_DEFINITIONS","ACTION_NOT_SET","taskName","setDescription","setAction","addParam","defaultValue","isOptional","undefined","string","DEFAULT_VALUE_WRONG_TYPE","paramName","_validateParamNameCasing","_validateNameNotUsed","_validateNoDefaultValueForMandatoryParam","_validateCLIArgumentTypesForExternalTasks","isFlag","isVariadic","addOptionalParam","addFlag","boolean","addPositionalParam","_validateNotAfterVariadicParam","_validateNoMandatoryParamAfterOptionalOnes","definition","_addPositionalParamDefinition","addOptionalPositionalParam","addVariadicPositionalParam","Array","isArray","_isStringArray","addOptionalVariadicPositionalParam","add","push","PARAM_AFTER_VARIADIC","_hasParamDefined","PARAM_ALREADY_DEFINED","Object","keys","HARDHAT_PARAM_DEFINITIONS","includes","PARAM_CLASHES_WITH_HARDHAT_PARAM","has","MANDATORY_PARAM_AFTER_OPTIONAL","pattern","match","INVALID_PARAM_NAME_CASING","DEFAULT_IN_MANDATORY_PARAM","values","every","v","CLI_ARGUMENT_TYPE_REQUIRED","exports","OverriddenTaskDefinition","parentTaskDefinition","_action","_throwNoParamsOverrideError","OVERRIDE_NO_MANDATORY_PARAMS","_name","_defaultValue","_type","_isOptional","OVERRIDE_NO_POSITIONAL_PARAMS","OVERRIDE_NO_VARIADIC_PARAMS","errorDescriptor","SimpleScopeDefinition","_addTask","_addSubtask","tasks","descriptionOrAction","subtask"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\internal\\core\\tasks\\task-definitions.ts"],"sourcesContent":["import {\n  ActionType,\n  ArgumentType,\n  CLIArgumentType,\n  ParamDefinition,\n  ParamDefinitionsMap,\n  ScopeDefinition,\n  TaskArguments,\n  TaskDefinition,\n  TaskIdentifier,\n  TasksMap,\n} from \"../../../types\";\nimport { HardhatError } from \"../errors\";\nimport { ErrorDescriptor, ERRORS } from \"../errors-list\";\nimport * as types from \"../params/argumentTypes\";\nimport { HARDHAT_PARAM_DEFINITIONS } from \"../params/hardhat-params\";\nimport { parseTaskIdentifier } from \"./util\";\n\nfunction isCLIArgumentType(\n  type: ArgumentType<any>\n): type is CLIArgumentType<any> {\n  return \"parse\" in type;\n}\n/**\n * This class creates a task definition, which consists of:\n * * a name, that should be unique and will be used to call the task.\n * * a description. This is optional.\n * * the action that the task will execute.\n * * a set of parameters that can be used by the action.\n *\n */\nexport class SimpleTaskDefinition implements TaskDefinition {\n  public get name() {\n    return this._task;\n  }\n  public get scope() {\n    return this._scope;\n  }\n  public get description() {\n    return this._description;\n  }\n  public readonly paramDefinitions: ParamDefinitionsMap = {};\n  public readonly positionalParamDefinitions: Array<ParamDefinition<any>> = [];\n  public action: ActionType<TaskArguments>;\n\n  private _positionalParamNames: Set<string>;\n  private _hasVariadicParam: boolean;\n  private _hasOptionalPositionalParam: boolean;\n  private _scope?: string;\n  private _task: string;\n  private _description?: string;\n\n  /**\n   * Creates an empty task definition.\n   *\n   * This definition will have no params, and will throw a HH205 if executed.\n   *\n   * @param taskIdentifier The task's identifier.\n   * @param isSubtask `true` if the task is a subtask, `false` otherwise.\n   */\n  constructor(\n    taskIdentifier: TaskIdentifier,\n    public readonly isSubtask: boolean = false\n  ) {\n    this._positionalParamNames = new Set();\n    this._hasVariadicParam = false;\n    this._hasOptionalPositionalParam = false;\n    const { scope, task } = parseTaskIdentifier(taskIdentifier);\n    this._scope = scope;\n    this._task = task;\n    this.action = () => {\n      throw new HardhatError(ERRORS.TASK_DEFINITIONS.ACTION_NOT_SET, {\n        taskName: this._task,\n      });\n    };\n  }\n\n  /**\n   * Sets the task's description.\n   * @param description The description.\n   */\n  public setDescription(description: string) {\n    this._description = description;\n    return this;\n  }\n\n  /**\n   * Sets the task's action.\n   * @param action The action.\n   */\n  public setAction<TaskArgumentsT extends TaskArguments>(\n    action: ActionType<TaskArgumentsT>\n  ) {\n    // TODO: There's probably something bad here. See types.ts for more info.\n    this.action = action;\n    return this;\n  }\n\n  /**\n   * Adds a parameter to the task's definition.\n   *\n   * @remarks This will throw if the `name` is already used by this task or\n   * by Hardhat's global parameters.\n   *\n   * @param name The parameter's name.\n   * @param description The parameter's description.\n   * @param defaultValue A default value. This must be `undefined` if `isOptional` is `true`.\n   * @param type The param's `ArgumentType`. It will parse and validate the user's input.\n   * @param isOptional `true` if the parameter is optional. It's default value is `true` if `defaultValue` is not `undefined`.\n   */\n  public addParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>,\n    isOptional: boolean = defaultValue !== undefined\n  ): this {\n    if (type === undefined) {\n      if (defaultValue === undefined) {\n        return this.addParam(\n          name,\n          description,\n          undefined,\n          types.string,\n          isOptional\n        );\n      }\n\n      if (typeof defaultValue !== \"string\") {\n        throw new HardhatError(\n          ERRORS.TASK_DEFINITIONS.DEFAULT_VALUE_WRONG_TYPE,\n          {\n            paramName: name,\n            taskName: this.name,\n          }\n        );\n      }\n\n      return this.addParam(\n        name,\n        description,\n        defaultValue,\n        types.string,\n        isOptional\n      );\n    }\n\n    this._validateParamNameCasing(name);\n    this._validateNameNotUsed(name);\n    this._validateNoDefaultValueForMandatoryParam(\n      defaultValue,\n      isOptional,\n      name\n    );\n    this._validateCLIArgumentTypesForExternalTasks(type);\n\n    this.paramDefinitions[name] = {\n      name,\n      defaultValue,\n      type,\n      description,\n      isOptional,\n      isFlag: false,\n      isVariadic: false,\n    };\n\n    return this;\n  }\n\n  /**\n   * Adds an optional parameter to the task's definition.\n   *\n   * @see addParam.\n   *\n   * @param name the parameter's name.\n   * @param description the parameter's description.\n   * @param defaultValue a default value.\n   * @param type param's type.\n   */\n  public addOptionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>\n  ): this {\n    return this.addParam(name, description, defaultValue, type, true);\n  }\n\n  /**\n   * Adds a boolean parameter or flag to the task's definition.\n   *\n   * Flags are params with default value set to `false`, and that don't expect\n   * values to be set in the CLI. A normal boolean param must be called with\n   * `--param true`, while a flag is called with `--flag`.\n   *\n   * @param name the parameter's name.\n   * @param description the parameter's description.\n   */\n  public addFlag(name: string, description?: string) {\n    this._validateParamNameCasing(name);\n    this._validateNameNotUsed(name);\n\n    this.paramDefinitions[name] = {\n      name,\n      defaultValue: false,\n      type: types.boolean,\n      description,\n      isFlag: true,\n      isOptional: true,\n      isVariadic: false,\n    };\n\n    return this;\n  }\n\n  /**\n   * Adds a positional parameter to the task's definition.\n   *\n   * @remarks This will throw if the `name` is already used by this task or\n   * by Hardhat's global parameters.\n   * @remarks This will throw if `isOptional` is `false` and an optional positional\n   * param was already set.\n   * @remarks This will throw if a variadic positional param is already set.\n   *\n   * @param name The parameter's name.\n   * @param description The parameter's description.\n   * @param defaultValue A default value. This must be `undefined` if `isOptional` is `true`.\n   * @param type The param's `ArgumentType`. It will parse and validate the user's input.\n   * @param isOptional `true` if the parameter is optional. It's default value is `true` if `defaultValue` is not `undefined`.\n   */\n  public addPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>,\n    isOptional = defaultValue !== undefined\n  ): this {\n    if (type === undefined) {\n      if (defaultValue === undefined) {\n        return this.addPositionalParam(\n          name,\n          description,\n          undefined,\n          types.string,\n          isOptional\n        );\n      }\n\n      if (typeof defaultValue !== \"string\") {\n        throw new HardhatError(\n          ERRORS.TASK_DEFINITIONS.DEFAULT_VALUE_WRONG_TYPE,\n          {\n            paramName: name,\n            taskName: this.name,\n          }\n        );\n      }\n\n      return this.addPositionalParam(\n        name,\n        description,\n        defaultValue,\n        types.string,\n        isOptional\n      );\n    }\n\n    this._validateParamNameCasing(name);\n    this._validateNameNotUsed(name);\n    this._validateNotAfterVariadicParam(name);\n    this._validateNoMandatoryParamAfterOptionalOnes(name, isOptional);\n    this._validateNoDefaultValueForMandatoryParam(\n      defaultValue,\n      isOptional,\n      name\n    );\n    this._validateCLIArgumentTypesForExternalTasks(type);\n\n    const definition = {\n      name,\n      defaultValue,\n      type,\n      description,\n      isVariadic: false,\n      isOptional,\n      isFlag: false,\n    };\n\n    this._addPositionalParamDefinition(definition);\n\n    return this;\n  }\n\n  /**\n   * Adds an optional positional parameter to the task's definition.\n   *\n   * @see addPositionalParam.\n   *\n   * @param name the parameter's name.\n   * @param description the parameter's description.\n   * @param defaultValue a default value.\n   * @param type param's type.\n   */\n  public addOptionalPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>\n  ): this {\n    return this.addPositionalParam(name, description, defaultValue, type, true);\n  }\n\n  /**\n   * Adds a variadic positional parameter to the task's definition. Variadic\n   * positional params act as `...rest` parameters in JavaScript.\n   *\n   * @param name The parameter's name.\n   * @param description The parameter's description.\n   * @param defaultValue A default value. This must be `undefined` if `isOptional` is `true`.\n   * @param type The param's `ArgumentType`. It will parse and validate the user's input.\n   * @param isOptional `true` if the parameter is optional. It's default value is `true` if `defaultValue` is not `undefined`.\n   */\n  public addVariadicPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T[] | T,\n    type?: ArgumentType<T>,\n    isOptional = defaultValue !== undefined\n  ): this {\n    if (defaultValue !== undefined && !Array.isArray(defaultValue)) {\n      defaultValue = [defaultValue];\n    }\n\n    if (type === undefined) {\n      if (defaultValue === undefined) {\n        return this.addVariadicPositionalParam(\n          name,\n          description,\n          undefined,\n          types.string,\n          isOptional\n        );\n      }\n\n      if (!this._isStringArray(defaultValue)) {\n        throw new HardhatError(\n          ERRORS.TASK_DEFINITIONS.DEFAULT_VALUE_WRONG_TYPE,\n          {\n            paramName: name,\n            taskName: this.name,\n          }\n        );\n      }\n\n      return this.addVariadicPositionalParam(\n        name,\n        description,\n        defaultValue,\n        types.string,\n        isOptional\n      );\n    }\n\n    this._validateParamNameCasing(name);\n    this._validateNameNotUsed(name);\n    this._validateNotAfterVariadicParam(name);\n    this._validateNoMandatoryParamAfterOptionalOnes(name, isOptional);\n    this._validateNoDefaultValueForMandatoryParam(\n      defaultValue,\n      isOptional,\n      name\n    );\n    this._validateCLIArgumentTypesForExternalTasks(type);\n\n    const definition = {\n      name,\n      defaultValue,\n      type,\n      description,\n      isVariadic: true,\n      isOptional,\n      isFlag: false,\n    };\n\n    this._addPositionalParamDefinition(definition);\n\n    return this;\n  }\n\n  /**\n   * Adds a positional parameter to the task's definition.\n   *\n   * This will check if the `name` is already used and\n   * if the parameter is being added after a varidic argument.\n   *\n   * @param name the parameter's name.\n   * @param description the parameter's description.\n   * @param defaultValue a default value.\n   * @param type param's type.\n   */\n  public addOptionalVariadicPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T[] | T,\n    type?: ArgumentType<T>\n  ): this {\n    return this.addVariadicPositionalParam(\n      name,\n      description,\n      defaultValue,\n      type,\n      true\n    );\n  }\n\n  /**\n   * Adds a positional parameter to the task's definition.\n   *\n   * @param definition the param's definition\n   */\n  private _addPositionalParamDefinition(definition: ParamDefinition<any>) {\n    if (definition.isVariadic) {\n      this._hasVariadicParam = true;\n    }\n\n    if (definition.isOptional) {\n      this._hasOptionalPositionalParam = true;\n    }\n\n    this._positionalParamNames.add(definition.name);\n    this.positionalParamDefinitions.push(definition);\n  }\n\n  /**\n   * Validates if the given param's name is after a variadic parameter.\n   * @param name the param's name.\n   * @throws HH200\n   */\n  private _validateNotAfterVariadicParam(name: string) {\n    if (this._hasVariadicParam) {\n      throw new HardhatError(ERRORS.TASK_DEFINITIONS.PARAM_AFTER_VARIADIC, {\n        paramName: name,\n        taskName: this.name,\n      });\n    }\n  }\n\n  /**\n   * Validates if the param's name is already used.\n   * @param name the param's name.\n   *\n   * @throws HH201 if `name` is already used as a param.\n   * @throws HH202 if `name` is already used as a param by Hardhat\n   */\n  private _validateNameNotUsed(name: string) {\n    if (this._hasParamDefined(name)) {\n      throw new HardhatError(ERRORS.TASK_DEFINITIONS.PARAM_ALREADY_DEFINED, {\n        paramName: name,\n        taskName: this.name,\n      });\n    }\n\n    if (Object.keys(HARDHAT_PARAM_DEFINITIONS).includes(name)) {\n      throw new HardhatError(\n        ERRORS.TASK_DEFINITIONS.PARAM_CLASHES_WITH_HARDHAT_PARAM,\n        {\n          paramName: name,\n          taskName: this.name,\n        }\n      );\n    }\n  }\n\n  /**\n   * Checks if the given name is already used.\n   * @param name the param's name.\n   */\n  private _hasParamDefined(name: string) {\n    return (\n      this.paramDefinitions[name] !== undefined ||\n      this._positionalParamNames.has(name)\n    );\n  }\n\n  /**\n   * Validates if a mandatory param is being added after optional params.\n   *\n   * @param name the param's name to be added.\n   * @param isOptional true if the new param is optional, false otherwise.\n   *\n   * @throws HH203 if validation fail\n   */\n  private _validateNoMandatoryParamAfterOptionalOnes(\n    name: string,\n    isOptional: boolean\n  ) {\n    if (!isOptional && this._hasOptionalPositionalParam) {\n      throw new HardhatError(\n        ERRORS.TASK_DEFINITIONS.MANDATORY_PARAM_AFTER_OPTIONAL,\n        {\n          paramName: name,\n          taskName: this.name,\n        }\n      );\n    }\n  }\n\n  private _validateParamNameCasing(name: string) {\n    const pattern = /^[a-z]+([a-zA-Z0-9])*$/;\n    const match = name.match(pattern);\n    if (match === null) {\n      throw new HardhatError(\n        ERRORS.TASK_DEFINITIONS.INVALID_PARAM_NAME_CASING,\n        {\n          paramName: name,\n          taskName: this.name,\n        }\n      );\n    }\n  }\n\n  private _validateNoDefaultValueForMandatoryParam(\n    defaultValue: any | undefined,\n    isOptional: boolean,\n    name: string\n  ) {\n    if (defaultValue !== undefined && !isOptional) {\n      throw new HardhatError(\n        ERRORS.TASK_DEFINITIONS.DEFAULT_IN_MANDATORY_PARAM,\n        {\n          paramName: name,\n          taskName: this.name,\n        }\n      );\n    }\n  }\n\n  private _isStringArray(values: any): values is string[] {\n    return Array.isArray(values) && values.every((v) => typeof v === \"string\");\n  }\n\n  private _validateCLIArgumentTypesForExternalTasks(type: ArgumentType<any>) {\n    if (this.isSubtask) {\n      return;\n    }\n\n    if (!isCLIArgumentType(type)) {\n      throw new HardhatError(\n        ERRORS.TASK_DEFINITIONS.CLI_ARGUMENT_TYPE_REQUIRED,\n        {\n          task: this.name,\n          type: type.name,\n        }\n      );\n    }\n  }\n}\n\n/**\n * Allows you to override a previously defined task.\n *\n * When overriding a task you can:\n *  * flag it as a subtask\n *  * set a new description\n *  * set a new action\n *\n */\nexport class OverriddenTaskDefinition implements TaskDefinition {\n  private _description?: string;\n  private _action?: ActionType<TaskArguments>;\n\n  constructor(\n    public readonly parentTaskDefinition: TaskDefinition,\n    public readonly isSubtask: boolean = false\n  ) {\n    this.isSubtask = isSubtask;\n    this.parentTaskDefinition = parentTaskDefinition;\n  }\n\n  /**\n   * Sets the task's description.\n   * @param description The description.\n   */\n  public setDescription(description: string) {\n    this._description = description;\n    return this;\n  }\n\n  /**\n   * Overrides the parent task's action.\n   * @param action the action.\n   */\n  public setAction<TaskArgumentsT extends TaskArguments>(\n    action: ActionType<TaskArgumentsT>\n  ) {\n    // TODO: There's probably something bad here. See types.ts for more info.\n    this._action = action;\n    return this;\n  }\n\n  /**\n   * Retrieves the parent task's scope.\n   */\n  public get scope() {\n    return this.parentTaskDefinition.scope;\n  }\n\n  /**\n   * Retrieves the parent task's name.\n   */\n  public get name() {\n    return this.parentTaskDefinition.name;\n  }\n\n  /**\n   * Retrieves, if defined, the description of the overriden task,\n   * otherwise retrieves the description of the parent task.\n   */\n  public get description() {\n    if (this._description !== undefined) {\n      return this._description;\n    }\n\n    return this.parentTaskDefinition.description;\n  }\n\n  /**\n   * Retrieves, if defined, the action of the overriden task,\n   * otherwise retrieves the action of the parent task.\n   */\n  public get action() {\n    if (this._action !== undefined) {\n      return this._action;\n    }\n\n    return this.parentTaskDefinition.action;\n  }\n\n  /**\n   * Retrieves the parent task's param definitions.\n   */\n  public get paramDefinitions() {\n    return this.parentTaskDefinition.paramDefinitions;\n  }\n\n  /**\n   * Retrieves the parent task's positional param definitions.\n   */\n  public get positionalParamDefinitions() {\n    return this.parentTaskDefinition.positionalParamDefinitions;\n  }\n\n  /**\n   * Overriden tasks can't add new parameters.\n   */\n  public addParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this {\n    if (isOptional === undefined || !isOptional) {\n      return this._throwNoParamsOverrideError(\n        ERRORS.TASK_DEFINITIONS.OVERRIDE_NO_MANDATORY_PARAMS\n      );\n    }\n    return this.addOptionalParam(name, description, defaultValue, type);\n  }\n\n  /**\n   * Overriden tasks can't add new parameters.\n   */\n  public addOptionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>\n  ): this {\n    this.parentTaskDefinition.addOptionalParam(\n      name,\n      description,\n      defaultValue,\n      type\n    );\n    return this;\n  }\n\n  /**\n   * Overriden tasks can't add new parameters.\n   */\n  public addPositionalParam<T>(\n    _name: string,\n    _description?: string,\n    _defaultValue?: T,\n    _type?: ArgumentType<T>,\n    _isOptional?: boolean\n  ): this {\n    return this._throwNoParamsOverrideError(\n      ERRORS.TASK_DEFINITIONS.OVERRIDE_NO_POSITIONAL_PARAMS\n    );\n  }\n\n  /**\n   * Overriden tasks can't add new parameters.\n   */\n  public addOptionalPositionalParam<T>(\n    _name: string,\n    _description?: string,\n    _defaultValue?: T,\n    _type?: ArgumentType<T>\n  ): this {\n    return this._throwNoParamsOverrideError(\n      ERRORS.TASK_DEFINITIONS.OVERRIDE_NO_POSITIONAL_PARAMS\n    );\n  }\n\n  /**\n   * Overriden tasks can't add new parameters.\n   */\n  public addVariadicPositionalParam<T>(\n    _name: string,\n    _description?: string,\n    _defaultValue?: T[],\n    _type?: ArgumentType<T>,\n    _isOptional?: boolean\n  ): this {\n    return this._throwNoParamsOverrideError(\n      ERRORS.TASK_DEFINITIONS.OVERRIDE_NO_VARIADIC_PARAMS\n    );\n  }\n\n  /**\n   * Overriden tasks can't add new parameters.\n   */\n  public addOptionalVariadicPositionalParam<T>(\n    _name: string,\n    _description?: string,\n    _defaultValue?: T[],\n    _type?: ArgumentType<T>\n  ): this {\n    return this._throwNoParamsOverrideError(\n      ERRORS.TASK_DEFINITIONS.OVERRIDE_NO_VARIADIC_PARAMS\n    );\n  }\n\n  /**\n   * Add a flag param to the overridden task.\n   * @throws HH201 if param name was already defined in any parent task.\n   * @throws HH209 if param name is not in camelCase.\n   */\n  public addFlag(name: string, description?: string): this {\n    this.parentTaskDefinition.addFlag(name, description);\n    return this;\n  }\n\n  private _throwNoParamsOverrideError(errorDescriptor: ErrorDescriptor): never {\n    throw new HardhatError(errorDescriptor, {\n      taskName: this.name,\n    });\n  }\n}\n\ntype AddTaskFunction = <TaskArgumentsT extends TaskArguments>(\n  name: string,\n  descriptionOrAction?: string | ActionType<TaskArgumentsT>,\n  action?: ActionType<TaskArgumentsT>\n) => TaskDefinition;\n\nexport class SimpleScopeDefinition implements ScopeDefinition {\n  public tasks: TasksMap = {};\n\n  constructor(\n    public readonly name: string,\n    private _description: string | undefined,\n    private _addTask: AddTaskFunction,\n    private _addSubtask: AddTaskFunction\n  ) {}\n\n  public get description() {\n    return this._description;\n  }\n\n  public setDescription(description: string): this {\n    this._description = description;\n    return this;\n  }\n\n  public task<TaskArgumentsT extends TaskArguments>(\n    name: string,\n    description?: string,\n    action?: ActionType<TaskArgumentsT>\n  ): TaskDefinition;\n  public task<TaskArgumentsT extends TaskArguments>(\n    name: string,\n    action: ActionType<TaskArgumentsT>\n  ): TaskDefinition;\n  public task<TaskArgumentsT extends TaskArguments>(\n    name: string,\n    descriptionOrAction?: string | ActionType<TaskArgumentsT>,\n    action?: ActionType<TaskArgumentsT>\n  ) {\n    const task = this._addTask(name, descriptionOrAction, action);\n\n    this.tasks[name] = task;\n\n    return task;\n  }\n\n  public subtask<TaskArgumentsT extends TaskArguments>(\n    name: string,\n    description?: string,\n    action?: ActionType<TaskArgumentsT>\n  ): TaskDefinition;\n  public subtask<TaskArgumentsT extends TaskArguments>(\n    name: string,\n    action: ActionType<TaskArgumentsT>\n  ): TaskDefinition;\n  public subtask<TaskArgumentsT extends TaskArguments>(\n    name: string,\n    descriptionOrAction?: string | ActionType<TaskArgumentsT>,\n    action?: ActionType<TaskArgumentsT>\n  ) {\n    const subtask = this._addSubtask(name, descriptionOrAction, action);\n\n    this.tasks[name] = subtask;\n\n    return subtask;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}