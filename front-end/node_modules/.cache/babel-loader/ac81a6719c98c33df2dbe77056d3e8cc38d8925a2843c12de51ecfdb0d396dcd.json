{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.instructionToCallstackStackTraceEntry = exports.ErrorInferrer = void 0;\n/* eslint \"@typescript-eslint/no-non-null-assertion\": \"error\" */\nconst abi_1 = require(\"@ethersproject/abi\");\nconst ethereumjs_util_1 = require(\"@nomicfoundation/ethereumjs-util\");\nconst semver_1 = __importDefault(require(\"semver\"));\nconst errors_1 = require(\"../../core/errors\");\nconst abi_helpers_1 = require(\"../../util/abi-helpers\");\nconst return_data_1 = require(\"../provider/return-data\");\nconst exit_1 = require(\"../provider/vm/exit\");\nconst message_trace_1 = require(\"./message-trace\");\nconst model_1 = require(\"./model\");\nconst opcodes_1 = require(\"./opcodes\");\nconst solidity_stack_trace_1 = require(\"./solidity-stack-trace\");\nconst FIRST_SOLC_VERSION_CREATE_PARAMS_VALIDATION = \"0.5.9\";\nconst FIRST_SOLC_VERSION_RECEIVE_FUNCTION = \"0.6.0\";\nconst FIRST_SOLC_VERSION_WITH_UNMAPPED_REVERTS = \"0.6.3\";\n/* eslint-disable @nomicfoundation/hardhat-internal-rules/only-hardhat-error */\nclass ErrorInferrer {\n  inferBeforeTracingCallMessage(trace) {\n    if (this._isDirectLibraryCall(trace)) {\n      return this._getDirectLibraryCallErrorStackTrace(trace);\n    }\n    const calledFunction = trace.bytecode.contract.getFunctionFromSelector(trace.calldata.slice(0, 4));\n    if (calledFunction !== undefined && this._isFunctionNotPayableError(trace, calledFunction)) {\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.FUNCTION_NOT_PAYABLE_ERROR,\n        sourceReference: this._getFunctionStartSourceReference(trace, calledFunction),\n        value: trace.value\n      }];\n    }\n    if (this._isMissingFunctionAndFallbackError(trace, calledFunction)) {\n      if (this._emptyCalldataAndNoReceive(trace)) {\n        return [{\n          type: solidity_stack_trace_1.StackTraceEntryType.MISSING_FALLBACK_OR_RECEIVE_ERROR,\n          sourceReference: this._getContractStartWithoutFunctionSourceReference(trace)\n        }];\n      }\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.UNRECOGNIZED_FUNCTION_WITHOUT_FALLBACK_ERROR,\n        sourceReference: this._getContractStartWithoutFunctionSourceReference(trace)\n      }];\n    }\n    if (this._isFallbackNotPayableError(trace, calledFunction)) {\n      if (this._emptyCalldataAndNoReceive(trace)) {\n        return [{\n          type: solidity_stack_trace_1.StackTraceEntryType.FALLBACK_NOT_PAYABLE_AND_NO_RECEIVE_ERROR,\n          sourceReference: this._getFallbackStartSourceReference(trace),\n          value: trace.value\n        }];\n      }\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.FALLBACK_NOT_PAYABLE_ERROR,\n        sourceReference: this._getFallbackStartSourceReference(trace),\n        value: trace.value\n      }];\n    }\n  }\n  inferBeforeTracingCreateMessage(trace) {\n    if (this._isConstructorNotPayableError(trace)) {\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.FUNCTION_NOT_PAYABLE_ERROR,\n        sourceReference: this._getConstructorStartSourceReference(trace),\n        value: trace.value\n      }];\n    }\n    if (this._isConstructorInvalidArgumentsError(trace)) {\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.INVALID_PARAMS_ERROR,\n        sourceReference: this._getConstructorStartSourceReference(trace)\n      }];\n    }\n  }\n  inferAfterTracing(trace, stacktrace, functionJumpdests, jumpedIntoFunction, lastSubmessageData) {\n    return this._checkLastSubmessage(trace, stacktrace, lastSubmessageData) ?? this._checkFailedLastCall(trace, stacktrace) ?? this._checkLastInstruction(trace, stacktrace, functionJumpdests, jumpedIntoFunction) ?? this._checkNonContractCalled(trace, stacktrace) ?? this._checkSolidity063UnmappedRevert(trace, stacktrace) ?? this._checkContractTooLarge(trace) ?? this._otherExecutionErrorStacktrace(trace, stacktrace);\n  }\n  filterRedundantFrames(stacktrace) {\n    return stacktrace.filter((frame, i) => {\n      if (i + 1 === stacktrace.length) {\n        return true;\n      }\n      const nextFrame = stacktrace[i + 1];\n      // we can only filter frames if we know their sourceReference\n      // and the one from the next frame\n      if (frame.sourceReference === undefined || nextFrame.sourceReference === undefined) {\n        return true;\n      }\n      // look TWO frames ahead to determine if this is a specific occurrence of\n      // a redundant CALLSTACK_ENTRY frame observed when using Solidity 0.8.5:\n      if (frame.type === solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY && i + 2 < stacktrace.length && stacktrace[i + 2].sourceReference !== undefined && stacktrace[i + 2].type === solidity_stack_trace_1.StackTraceEntryType.RETURNDATA_SIZE_ERROR) {\n        // ! below for tsc. we confirmed existence in the enclosing conditional.\n        const thatSrcRef = stacktrace[i + 2].sourceReference;\n        if (thatSrcRef !== undefined && frame.sourceReference.range[0] === thatSrcRef.range[0] && frame.sourceReference.range[1] === thatSrcRef.range[1] && frame.sourceReference.line === thatSrcRef.line) {\n          return false;\n        }\n      }\n      // constructors contain the whole contract, so we ignore them\n      if (frame.sourceReference.function === \"constructor\" && nextFrame.sourceReference.function !== \"constructor\") {\n        return true;\n      }\n      // this is probably a recursive call\n      if (i > 0 && frame.type === nextFrame.type && frame.sourceReference.range[0] === nextFrame.sourceReference.range[0] && frame.sourceReference.range[1] === nextFrame.sourceReference.range[1] && frame.sourceReference.line === nextFrame.sourceReference.line) {\n        return true;\n      }\n      if (frame.sourceReference.range[0] <= nextFrame.sourceReference.range[0] && frame.sourceReference.range[1] >= nextFrame.sourceReference.range[1]) {\n        return false;\n      }\n      return true;\n    });\n  }\n  // Heuristics\n  /**\n   * Check if the last submessage can be used to generate the stack trace.\n   */\n  _checkLastSubmessage(trace, stacktrace, lastSubmessageData) {\n    if (lastSubmessageData === undefined) {\n      return undefined;\n    }\n    const inferredStacktrace = [...stacktrace];\n    // get the instruction before the submessage and add it to the stack trace\n    const callStep = trace.steps[lastSubmessageData.stepIndex - 1];\n    if (!(0, message_trace_1.isEvmStep)(callStep)) {\n      throw new Error(\"This should not happen: MessageTrace should be preceded by a EVM step\");\n    }\n    const callInst = trace.bytecode.getInstruction(callStep.pc);\n    const callStackFrame = instructionToCallstackStackTraceEntry(trace.bytecode, callInst);\n    const lastMessageFailed = lastSubmessageData.messageTrace.exit.isError();\n    if (lastMessageFailed) {\n      // add the call/create that generated the message to the stack trace\n      inferredStacktrace.push(callStackFrame);\n      if (this._isSubtraceErrorPropagated(trace, lastSubmessageData.stepIndex) || this._isProxyErrorPropagated(trace, lastSubmessageData.stepIndex)) {\n        inferredStacktrace.push(...lastSubmessageData.stacktrace);\n        if (this._isContractCallRunOutOfGasError(trace, lastSubmessageData.stepIndex)) {\n          const lastFrame = inferredStacktrace.pop();\n          (0, errors_1.assertHardhatInvariant)(lastFrame !== undefined, \"Expected inferred stack trace to have at least one frame\");\n          inferredStacktrace.push({\n            type: solidity_stack_trace_1.StackTraceEntryType.CONTRACT_CALL_RUN_OUT_OF_GAS_ERROR,\n            sourceReference: lastFrame.sourceReference\n          });\n        }\n        return this._fixInitialModifier(trace, inferredStacktrace);\n      }\n    } else {\n      const isReturnDataSizeError = this._failsRightAfterCall(trace, lastSubmessageData.stepIndex);\n      if (isReturnDataSizeError) {\n        inferredStacktrace.push({\n          type: solidity_stack_trace_1.StackTraceEntryType.RETURNDATA_SIZE_ERROR,\n          sourceReference: callStackFrame.sourceReference\n        });\n        return this._fixInitialModifier(trace, inferredStacktrace);\n      }\n    }\n  }\n  /**\n   * Check if the last call/create that was done failed.\n   */\n  _checkFailedLastCall(trace, stacktrace) {\n    for (let stepIndex = trace.steps.length - 2; stepIndex >= 0; stepIndex--) {\n      const step = trace.steps[stepIndex];\n      const nextStep = trace.steps[stepIndex + 1];\n      if (!(0, message_trace_1.isEvmStep)(step)) {\n        return;\n      }\n      const inst = trace.bytecode.getInstruction(step.pc);\n      const isCallOrCreate = (0, opcodes_1.isCall)(inst.opcode) || (0, opcodes_1.isCreate)(inst.opcode);\n      if (isCallOrCreate && (0, message_trace_1.isEvmStep)(nextStep)) {\n        if (this._isCallFailedError(trace, stepIndex, inst)) {\n          const inferredStacktrace = [...stacktrace, this._callInstructionToCallFailedToExecuteStackTraceEntry(trace.bytecode, inst)];\n          return this._fixInitialModifier(trace, inferredStacktrace);\n        }\n      }\n    }\n  }\n  /**\n   * Check if the execution stopped with a revert or an invalid opcode.\n   */\n  _checkRevertOrInvalidOpcode(trace, stacktrace, lastInstruction, functionJumpdests, jumpedIntoFunction) {\n    if (lastInstruction.opcode !== opcodes_1.Opcode.REVERT && lastInstruction.opcode !== opcodes_1.Opcode.INVALID) {\n      return;\n    }\n    const inferredStacktrace = [...stacktrace];\n    if (lastInstruction.location !== undefined && (!(0, message_trace_1.isDecodedCallTrace)(trace) || jumpedIntoFunction)) {\n      // There should always be a function here, but that's not the case with optimizations.\n      //\n      // If this is a create trace, we already checked args and nonpayable failures before\n      // calling this function.\n      //\n      // If it's a call trace, we already jumped into a function. But optimizations can happen.\n      const failingFunction = lastInstruction.location.getContainingFunction();\n      // If the failure is in a modifier we add an entry with the function/constructor\n      if (failingFunction !== undefined && failingFunction.type === model_1.ContractFunctionType.MODIFIER) {\n        inferredStacktrace.push(this._getEntryBeforeFailureInModifier(trace, functionJumpdests));\n      }\n    }\n    const panicStacktrace = this._checkPanic(trace, inferredStacktrace, lastInstruction);\n    if (panicStacktrace !== undefined) {\n      return panicStacktrace;\n    }\n    const customErrorStacktrace = this._checkCustomErrors(trace, inferredStacktrace, lastInstruction);\n    if (customErrorStacktrace !== undefined) {\n      return customErrorStacktrace;\n    }\n    if (lastInstruction.location !== undefined && (!(0, message_trace_1.isDecodedCallTrace)(trace) || jumpedIntoFunction)) {\n      const failingFunction = lastInstruction.location.getContainingFunction();\n      if (failingFunction !== undefined) {\n        inferredStacktrace.push(this._instructionWithinFunctionToRevertStackTraceEntry(trace, lastInstruction));\n      } else if ((0, message_trace_1.isDecodedCallTrace)(trace)) {\n        // This is here because of the optimizations\n        const functionSelector = trace.bytecode.contract.getFunctionFromSelector(trace.calldata.slice(0, 4));\n        // in general this shouldn't happen, but it does when viaIR is enabled,\n        // \"optimizerSteps\": \"u\" is used, and the called function is fallback or\n        // receive\n        if (functionSelector === undefined) {\n          return;\n        }\n        inferredStacktrace.push({\n          type: solidity_stack_trace_1.StackTraceEntryType.REVERT_ERROR,\n          sourceReference: this._getFunctionStartSourceReference(trace, functionSelector),\n          message: new return_data_1.ReturnData(trace.returnData),\n          isInvalidOpcodeError: lastInstruction.opcode === opcodes_1.Opcode.INVALID\n        });\n      } else {\n        // This is here because of the optimizations\n        inferredStacktrace.push({\n          type: solidity_stack_trace_1.StackTraceEntryType.REVERT_ERROR,\n          sourceReference: this._getConstructorStartSourceReference(trace),\n          message: new return_data_1.ReturnData(trace.returnData),\n          isInvalidOpcodeError: lastInstruction.opcode === opcodes_1.Opcode.INVALID\n        });\n      }\n      return this._fixInitialModifier(trace, inferredStacktrace);\n    }\n    // If the revert instruction is not mapped but there is return data,\n    // we add the frame anyway, sith the best sourceReference we can get\n    if (lastInstruction.location === undefined && trace.returnData.length > 0) {\n      const revertFrame = {\n        type: solidity_stack_trace_1.StackTraceEntryType.REVERT_ERROR,\n        sourceReference: this._getLastSourceReference(trace) ?? this._getContractStartWithoutFunctionSourceReference(trace),\n        message: new return_data_1.ReturnData(trace.returnData),\n        isInvalidOpcodeError: lastInstruction.opcode === opcodes_1.Opcode.INVALID\n      };\n      inferredStacktrace.push(revertFrame);\n      return this._fixInitialModifier(trace, inferredStacktrace);\n    }\n  }\n  /**\n   * Check if the trace reverted with a panic error.\n   */\n  _checkPanic(trace, stacktrace, lastInstruction) {\n    if (!this._isPanicReturnData(trace.returnData)) {\n      return;\n    }\n    // If the last frame is an internal function, it means that the trace\n    // jumped there to return the panic. If that's the case, we remove that\n    // frame.\n    const lastFrame = stacktrace[stacktrace.length - 1];\n    if (lastFrame?.type === solidity_stack_trace_1.StackTraceEntryType.INTERNAL_FUNCTION_CALLSTACK_ENTRY) {\n      stacktrace.splice(-1);\n    }\n    const panicReturnData = new return_data_1.ReturnData(trace.returnData);\n    const errorCode = panicReturnData.decodePanic();\n    // if the error comes from a call to a zero-initialized function,\n    // we remove the last frame, which represents the call, to avoid\n    // having duplicated frames\n    if (errorCode === 0x51n) {\n      stacktrace.splice(-1);\n    }\n    const inferredStacktrace = [...stacktrace];\n    inferredStacktrace.push(this._instructionWithinFunctionToPanicStackTraceEntry(trace, lastInstruction, errorCode));\n    return this._fixInitialModifier(trace, inferredStacktrace);\n  }\n  _checkCustomErrors(trace, stacktrace, lastInstruction) {\n    const returnData = new return_data_1.ReturnData(trace.returnData);\n    if (returnData.isEmpty() || returnData.isErrorReturnData()) {\n      // if there is no return data, or if it's a Error(string),\n      // then it can't be a custom error\n      return;\n    }\n    const rawReturnData = Buffer.from(returnData.value).toString(\"hex\");\n    let errorMessage = `reverted with an unrecognized custom error (return data: 0x${rawReturnData})`;\n    for (const customError of trace.bytecode.contract.customErrors) {\n      if (returnData.matchesSelector(customError.selector)) {\n        // if the return data matches a custom error in the called contract,\n        // we format the message using the returnData and the custom error instance\n        const decodedValues = abi_1.defaultAbiCoder.decode(customError.paramTypes, returnData.value.slice(4));\n        const params = abi_helpers_1.AbiHelpers.formatValues([...decodedValues]);\n        errorMessage = `reverted with custom error '${customError.name}(${params})'`;\n        break;\n      }\n    }\n    const inferredStacktrace = [...stacktrace];\n    inferredStacktrace.push(this._instructionWithinFunctionToCustomErrorStackTraceEntry(trace, lastInstruction, errorMessage));\n    return this._fixInitialModifier(trace, inferredStacktrace);\n  }\n  /**\n   * Check last instruction to try to infer the error.\n   */\n  _checkLastInstruction(trace, stacktrace, functionJumpdests, jumpedIntoFunction) {\n    if (trace.steps.length === 0) {\n      return;\n    }\n    const lastStep = trace.steps[trace.steps.length - 1];\n    if (!(0, message_trace_1.isEvmStep)(lastStep)) {\n      throw new Error(\"This should not happen: MessageTrace ends with a subtrace\");\n    }\n    const lastInstruction = trace.bytecode.getInstruction(lastStep.pc);\n    const revertOrInvalidStacktrace = this._checkRevertOrInvalidOpcode(trace, stacktrace, lastInstruction, functionJumpdests, jumpedIntoFunction);\n    if (revertOrInvalidStacktrace !== undefined) {\n      return revertOrInvalidStacktrace;\n    }\n    if ((0, message_trace_1.isDecodedCallTrace)(trace) && !jumpedIntoFunction) {\n      if (this._hasFailedInsideTheFallbackFunction(trace) || this._hasFailedInsideTheReceiveFunction(trace)) {\n        return [this._instructionWithinFunctionToRevertStackTraceEntry(trace, lastInstruction)];\n      }\n      // Sometimes we do fail inside of a function but there's no jump into\n      if (lastInstruction.location !== undefined) {\n        const failingFunction = lastInstruction.location.getContainingFunction();\n        if (failingFunction !== undefined) {\n          return [{\n            type: solidity_stack_trace_1.StackTraceEntryType.REVERT_ERROR,\n            sourceReference: this._getFunctionStartSourceReference(trace, failingFunction),\n            message: new return_data_1.ReturnData(trace.returnData),\n            isInvalidOpcodeError: lastInstruction.opcode === opcodes_1.Opcode.INVALID\n          }];\n        }\n      }\n      const calledFunction = trace.bytecode.contract.getFunctionFromSelector(trace.calldata.slice(0, 4));\n      if (calledFunction !== undefined) {\n        const isValidCalldata = calledFunction.isValidCalldata(trace.calldata.slice(4));\n        if (!isValidCalldata) {\n          return [{\n            type: solidity_stack_trace_1.StackTraceEntryType.INVALID_PARAMS_ERROR,\n            sourceReference: this._getFunctionStartSourceReference(trace, calledFunction)\n          }];\n        }\n      }\n      if (this._solidity063MaybeUnmappedRevert(trace)) {\n        const revertFrame = this._solidity063GetFrameForUnmappedRevertBeforeFunction(trace);\n        if (revertFrame !== undefined) {\n          return [revertFrame];\n        }\n      }\n      return [this._getOtherErrorBeforeCalledFunctionStackTraceEntry(trace)];\n    }\n  }\n  _checkNonContractCalled(trace, stacktrace) {\n    if (this._isCalledNonContractAccountError(trace)) {\n      const sourceReference = this._getLastSourceReference(trace);\n      // We are sure this is not undefined because there was at least a call instruction\n      (0, errors_1.assertHardhatInvariant)(sourceReference !== undefined, \"Expected source reference to be defined\");\n      const nonContractCalledFrame = {\n        type: solidity_stack_trace_1.StackTraceEntryType.NONCONTRACT_ACCOUNT_CALLED_ERROR,\n        sourceReference\n      };\n      return [...stacktrace, nonContractCalledFrame];\n    }\n  }\n  _checkSolidity063UnmappedRevert(trace, stacktrace) {\n    if (this._solidity063MaybeUnmappedRevert(trace)) {\n      const revertFrame = this._solidity063GetFrameForUnmappedRevertWithinFunction(trace);\n      if (revertFrame !== undefined) {\n        return [...stacktrace, revertFrame];\n      }\n    }\n  }\n  _checkContractTooLarge(trace) {\n    if ((0, message_trace_1.isCreateTrace)(trace) && this._isContractTooLargeError(trace)) {\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.CONTRACT_TOO_LARGE_ERROR,\n        sourceReference: this._getConstructorStartSourceReference(trace)\n      }];\n    }\n  }\n  _otherExecutionErrorStacktrace(trace, stacktrace) {\n    const otherExecutionErrorFrame = {\n      type: solidity_stack_trace_1.StackTraceEntryType.OTHER_EXECUTION_ERROR,\n      sourceReference: this._getLastSourceReference(trace)\n    };\n    return [...stacktrace, otherExecutionErrorFrame];\n  }\n  // Helpers\n  _fixInitialModifier(trace, stacktrace) {\n    const firstEntry = stacktrace[0];\n    if (firstEntry !== undefined && firstEntry.type === solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY && firstEntry.functionType === model_1.ContractFunctionType.MODIFIER) {\n      return [this._getEntryBeforeInitialModifierCallstackEntry(trace), ...stacktrace];\n    }\n    return stacktrace;\n  }\n  _isDirectLibraryCall(trace) {\n    return trace.depth === 0 && trace.bytecode.contract.type === model_1.ContractType.LIBRARY;\n  }\n  _getDirectLibraryCallErrorStackTrace(trace) {\n    const func = trace.bytecode.contract.getFunctionFromSelector(trace.calldata.slice(0, 4));\n    if (func !== undefined) {\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.DIRECT_LIBRARY_CALL_ERROR,\n        sourceReference: this._getFunctionStartSourceReference(trace, func)\n      }];\n    }\n    return [{\n      type: solidity_stack_trace_1.StackTraceEntryType.DIRECT_LIBRARY_CALL_ERROR,\n      sourceReference: this._getContractStartWithoutFunctionSourceReference(trace)\n    }];\n  }\n  _isFunctionNotPayableError(trace, calledFunction) {\n    // This error doesn't return data\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n    if (trace.value <= 0n) {\n      return false;\n    }\n    // Libraries don't have a nonpayable check\n    if (trace.bytecode.contract.type === model_1.ContractType.LIBRARY) {\n      return false;\n    }\n    return calledFunction.isPayable === undefined || !calledFunction.isPayable;\n  }\n  _getFunctionStartSourceReference(trace, func) {\n    return {\n      sourceName: func.location.file.sourceName,\n      sourceContent: func.location.file.content,\n      contract: trace.bytecode.contract.name,\n      function: func.name,\n      line: func.location.getStartingLineNumber(),\n      range: [func.location.offset, func.location.offset + func.location.length]\n    };\n  }\n  _isMissingFunctionAndFallbackError(trace, calledFunction) {\n    // This error doesn't return data\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n    // the called function exists in the contract\n    if (calledFunction !== undefined) {\n      return false;\n    }\n    // there's a receive function and no calldata\n    if (trace.calldata.length === 0 && trace.bytecode.contract.receive !== undefined) {\n      return false;\n    }\n    return trace.bytecode.contract.fallback === undefined;\n  }\n  _emptyCalldataAndNoReceive(trace) {\n    // this only makes sense when receive functions are available\n    if (semver_1.default.lt(trace.bytecode.compilerVersion, FIRST_SOLC_VERSION_RECEIVE_FUNCTION)) {\n      return false;\n    }\n    return trace.calldata.length === 0 && trace.bytecode.contract.receive === undefined;\n  }\n  _getContractStartWithoutFunctionSourceReference(trace) {\n    const location = trace.bytecode.contract.location;\n    return {\n      sourceName: location.file.sourceName,\n      sourceContent: location.file.content,\n      contract: trace.bytecode.contract.name,\n      line: location.getStartingLineNumber(),\n      range: [location.offset, location.offset + location.length]\n    };\n  }\n  _isFallbackNotPayableError(trace, calledFunction) {\n    if (calledFunction !== undefined) {\n      return false;\n    }\n    // This error doesn't return data\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n    if (trace.value <= 0n) {\n      return false;\n    }\n    if (trace.bytecode.contract.fallback === undefined) {\n      return false;\n    }\n    const isPayable = trace.bytecode.contract.fallback.isPayable;\n    return isPayable === undefined || !isPayable;\n  }\n  _getFallbackStartSourceReference(trace) {\n    const func = trace.bytecode.contract.fallback;\n    if (func === undefined) {\n      throw new Error(\"This shouldn't happen: trying to get fallback source reference from a contract without fallback\");\n    }\n    return {\n      sourceName: func.location.file.sourceName,\n      sourceContent: func.location.file.content,\n      contract: trace.bytecode.contract.name,\n      function: solidity_stack_trace_1.FALLBACK_FUNCTION_NAME,\n      line: func.location.getStartingLineNumber(),\n      range: [func.location.offset, func.location.offset + func.location.length]\n    };\n  }\n  _isConstructorNotPayableError(trace) {\n    // This error doesn't return data\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n    const constructor = trace.bytecode.contract.constructorFunction;\n    // This function is only matters with contracts that have constructors defined. The ones that\n    // don't are abstract contracts, or their constructor doesn't take any argument.\n    if (constructor === undefined) {\n      return false;\n    }\n    return trace.value > 0n && (constructor.isPayable === undefined || !constructor.isPayable);\n  }\n  /**\n   * Returns a source reference pointing to the constructor if it exists, or to the contract\n   * otherwise.\n   */\n  _getConstructorStartSourceReference(trace) {\n    const contract = trace.bytecode.contract;\n    const constructor = contract.constructorFunction;\n    const line = constructor !== undefined ? constructor.location.getStartingLineNumber() : contract.location.getStartingLineNumber();\n    return {\n      sourceName: contract.location.file.sourceName,\n      sourceContent: contract.location.file.content,\n      contract: contract.name,\n      function: solidity_stack_trace_1.CONSTRUCTOR_FUNCTION_NAME,\n      line,\n      range: [contract.location.offset, contract.location.offset + contract.location.length]\n    };\n  }\n  _isConstructorInvalidArgumentsError(trace) {\n    // This error doesn't return data\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n    const contract = trace.bytecode.contract;\n    const constructor = contract.constructorFunction;\n    // This function is only matters with contracts that have constructors defined. The ones that\n    // don't are abstract contracts, or their constructor doesn't take any argument.\n    if (constructor === undefined) {\n      return false;\n    }\n    if (semver_1.default.lt(trace.bytecode.compilerVersion, FIRST_SOLC_VERSION_CREATE_PARAMS_VALIDATION)) {\n      return false;\n    }\n    const lastStep = trace.steps[trace.steps.length - 1];\n    if (!(0, message_trace_1.isEvmStep)(lastStep)) {\n      return false;\n    }\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n    if (lastInst.opcode !== opcodes_1.Opcode.REVERT || lastInst.location !== undefined) {\n      return false;\n    }\n    let hasReadDeploymentCodeSize = false;\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\n    for (let stepIndex = 0; stepIndex < trace.steps.length; stepIndex++) {\n      const step = trace.steps[stepIndex];\n      if (!(0, message_trace_1.isEvmStep)(step)) {\n        return false;\n      }\n      const inst = trace.bytecode.getInstruction(step.pc);\n      if (inst.location !== undefined && !contract.location.equals(inst.location) && !constructor.location.equals(inst.location)) {\n        return false;\n      }\n      if (inst.opcode === opcodes_1.Opcode.CODESIZE && (0, message_trace_1.isCreateTrace)(trace)) {\n        hasReadDeploymentCodeSize = true;\n      }\n    }\n    return hasReadDeploymentCodeSize;\n  }\n  _getEntryBeforeInitialModifierCallstackEntry(trace) {\n    if ((0, message_trace_1.isDecodedCreateTrace)(trace)) {\n      return {\n        type: solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY,\n        sourceReference: this._getConstructorStartSourceReference(trace),\n        functionType: model_1.ContractFunctionType.CONSTRUCTOR\n      };\n    }\n    const calledFunction = trace.bytecode.contract.getFunctionFromSelector(trace.calldata.slice(0, 4));\n    if (calledFunction !== undefined) {\n      return {\n        type: solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY,\n        sourceReference: this._getFunctionStartSourceReference(trace, calledFunction),\n        functionType: model_1.ContractFunctionType.FUNCTION\n      };\n    }\n    // If it failed or made a call from within a modifier, and the selector doesn't match\n    // any function, it must have a fallback.\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY,\n      sourceReference: this._getFallbackStartSourceReference(trace),\n      functionType: model_1.ContractFunctionType.FALLBACK\n    };\n  }\n  _getLastSourceReference(trace) {\n    for (let i = trace.steps.length - 1; i >= 0; i--) {\n      const step = trace.steps[i];\n      if (!(0, message_trace_1.isEvmStep)(step)) {\n        continue;\n      }\n      const inst = trace.bytecode.getInstruction(step.pc);\n      if (inst.location === undefined) {\n        continue;\n      }\n      const sourceReference = sourceLocationToSourceReference(trace.bytecode, inst.location);\n      if (sourceReference !== undefined) {\n        return sourceReference;\n      }\n    }\n    return undefined;\n  }\n  _hasFailedInsideTheFallbackFunction(trace) {\n    const contract = trace.bytecode.contract;\n    if (contract.fallback === undefined) {\n      return false;\n    }\n    return this._hasFailedInsideFunction(trace, contract.fallback);\n  }\n  _hasFailedInsideTheReceiveFunction(trace) {\n    const contract = trace.bytecode.contract;\n    if (contract.receive === undefined) {\n      return false;\n    }\n    return this._hasFailedInsideFunction(trace, contract.receive);\n  }\n  _hasFailedInsideFunction(trace, func) {\n    const lastStep = trace.steps[trace.steps.length - 1];\n    const lastInstruction = trace.bytecode.getInstruction(lastStep.pc);\n    return lastInstruction.location !== undefined && lastInstruction.opcode === opcodes_1.Opcode.REVERT && func.location.contains(lastInstruction.location);\n  }\n  _instructionWithinFunctionToRevertStackTraceEntry(trace, inst) {\n    const sourceReference = sourceLocationToSourceReference(trace.bytecode, inst.location);\n    (0, errors_1.assertHardhatInvariant)(sourceReference !== undefined, \"Expected source reference to be defined\");\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.REVERT_ERROR,\n      sourceReference,\n      message: new return_data_1.ReturnData(trace.returnData),\n      isInvalidOpcodeError: inst.opcode === opcodes_1.Opcode.INVALID\n    };\n  }\n  _instructionWithinFunctionToUnmappedSolc063RevertErrorStackTraceEntry(trace, inst) {\n    const sourceReference = sourceLocationToSourceReference(trace.bytecode, inst.location);\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR,\n      sourceReference\n    };\n  }\n  _instructionWithinFunctionToPanicStackTraceEntry(trace, inst, errorCode) {\n    const lastSourceReference = this._getLastSourceReference(trace);\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.PANIC_ERROR,\n      sourceReference: sourceLocationToSourceReference(trace.bytecode, inst.location) ?? lastSourceReference,\n      errorCode\n    };\n  }\n  _instructionWithinFunctionToCustomErrorStackTraceEntry(trace, inst, message) {\n    const lastSourceReference = this._getLastSourceReference(trace);\n    (0, errors_1.assertHardhatInvariant)(lastSourceReference !== undefined, \"Expected last source reference to be defined\");\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.CUSTOM_ERROR,\n      sourceReference: sourceLocationToSourceReference(trace.bytecode, inst.location) ?? lastSourceReference,\n      message\n    };\n  }\n  _solidity063MaybeUnmappedRevert(trace) {\n    if (trace.steps.length === 0) {\n      return false;\n    }\n    const lastStep = trace.steps[trace.steps.length - 1];\n    if (!(0, message_trace_1.isEvmStep)(lastStep)) {\n      return false;\n    }\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n    return semver_1.default.satisfies(trace.bytecode.compilerVersion, `^${FIRST_SOLC_VERSION_WITH_UNMAPPED_REVERTS}`) && lastInst.opcode === opcodes_1.Opcode.REVERT;\n  }\n  // Solidity 0.6.3 unmapped reverts special handling\n  // For more info: https://github.com/ethereum/solidity/issues/9006\n  _solidity063GetFrameForUnmappedRevertBeforeFunction(trace) {\n    let revertFrame = this._solidity063GetFrameForUnmappedRevertWithinFunction(trace);\n    if (revertFrame === undefined || revertFrame.sourceReference === undefined) {\n      if (trace.bytecode.contract.receive === undefined || trace.calldata.length > 0) {\n        if (trace.bytecode.contract.fallback !== undefined) {\n          // Failed within the fallback\n          const location = trace.bytecode.contract.fallback.location;\n          revertFrame = {\n            type: solidity_stack_trace_1.StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR,\n            sourceReference: {\n              contract: trace.bytecode.contract.name,\n              function: solidity_stack_trace_1.FALLBACK_FUNCTION_NAME,\n              sourceName: location.file.sourceName,\n              sourceContent: location.file.content,\n              line: location.getStartingLineNumber(),\n              range: [location.offset, location.offset + location.length]\n            }\n          };\n          this._solidity063CorrectLineNumber(revertFrame);\n        }\n      } else {\n        // Failed within the receive function\n        const location = trace.bytecode.contract.receive.location;\n        revertFrame = {\n          type: solidity_stack_trace_1.StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR,\n          sourceReference: {\n            contract: trace.bytecode.contract.name,\n            function: solidity_stack_trace_1.RECEIVE_FUNCTION_NAME,\n            sourceName: location.file.sourceName,\n            sourceContent: location.file.content,\n            line: location.getStartingLineNumber(),\n            range: [location.offset, location.offset + location.length]\n          }\n        };\n        this._solidity063CorrectLineNumber(revertFrame);\n      }\n    }\n    return revertFrame;\n  }\n  _getOtherErrorBeforeCalledFunctionStackTraceEntry(trace) {\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.OTHER_EXECUTION_ERROR,\n      sourceReference: this._getContractStartWithoutFunctionSourceReference(trace)\n    };\n  }\n  _isCalledNonContractAccountError(trace) {\n    // We could change this to checking that the last valid location maps to a call, but\n    // it's way more complex as we need to get the ast node from that location.\n    const lastIndex = this._getLastInstructionWithValidLocationStepIndex(trace);\n    if (lastIndex === undefined || lastIndex === 0) {\n      return false;\n    }\n    const lastStep = trace.steps[lastIndex]; // We know this is an EVM step\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n    if (lastInst.opcode !== opcodes_1.Opcode.ISZERO) {\n      return false;\n    }\n    const prevStep = trace.steps[lastIndex - 1]; // We know this is an EVM step\n    const prevInst = trace.bytecode.getInstruction(prevStep.pc);\n    return prevInst.opcode === opcodes_1.Opcode.EXTCODESIZE;\n  }\n  _solidity063GetFrameForUnmappedRevertWithinFunction(trace) {\n    // If we are within a function there's a last valid location. It may\n    // be the entire contract.\n    const prevInst = this._getLastInstructionWithValidLocation(trace);\n    const lastStep = trace.steps[trace.steps.length - 1];\n    const nextInstPc = lastStep.pc + 1;\n    const hasNextInst = trace.bytecode.hasInstruction(nextInstPc);\n    if (hasNextInst) {\n      const nextInst = trace.bytecode.getInstruction(nextInstPc);\n      const prevLoc = prevInst?.location;\n      const nextLoc = nextInst.location;\n      const prevFunc = prevLoc?.getContainingFunction();\n      const nextFunc = nextLoc?.getContainingFunction();\n      // This is probably a require. This means that we have the exact\n      // line, but the stack trace may be degraded (e.g. missing our\n      // synthetic call frames when failing in a modifier) so we still\n      // add this frame as UNMAPPED_SOLC_0_6_3_REVERT_ERROR\n      if (prevFunc !== undefined && nextLoc !== undefined && prevLoc !== undefined && prevLoc.equals(nextLoc)) {\n        return this._instructionWithinFunctionToUnmappedSolc063RevertErrorStackTraceEntry(trace, nextInst);\n      }\n      let revertFrame;\n      // If the previous and next location don't match, we try to use the\n      // previous one if it's inside a function, otherwise we use the next one\n      if (prevFunc !== undefined && prevInst !== undefined) {\n        revertFrame = this._instructionWithinFunctionToUnmappedSolc063RevertErrorStackTraceEntry(trace, prevInst);\n      } else if (nextFunc !== undefined) {\n        revertFrame = this._instructionWithinFunctionToUnmappedSolc063RevertErrorStackTraceEntry(trace, nextInst);\n      }\n      if (revertFrame !== undefined) {\n        this._solidity063CorrectLineNumber(revertFrame);\n      }\n      return revertFrame;\n    }\n    if ((0, message_trace_1.isCreateTrace)(trace) && prevInst !== undefined) {\n      // Solidity is smart enough to stop emitting extra instructions after\n      // an unconditional revert happens in a constructor. If this is the case\n      // we just return a special error.\n      const constructorRevertFrame = this._instructionWithinFunctionToUnmappedSolc063RevertErrorStackTraceEntry(trace, prevInst);\n      // When the latest instruction is not within a function we need\n      // some default sourceReference to show to the user\n      if (constructorRevertFrame.sourceReference === undefined) {\n        const location = trace.bytecode.contract.location;\n        const defaultSourceReference = {\n          function: solidity_stack_trace_1.CONSTRUCTOR_FUNCTION_NAME,\n          contract: trace.bytecode.contract.name,\n          sourceName: location.file.sourceName,\n          sourceContent: location.file.content,\n          line: location.getStartingLineNumber(),\n          range: [location.offset, location.offset + location.length]\n        };\n        if (trace.bytecode.contract.constructorFunction !== undefined) {\n          defaultSourceReference.line = trace.bytecode.contract.constructorFunction.location.getStartingLineNumber();\n        }\n        constructorRevertFrame.sourceReference = defaultSourceReference;\n      } else {\n        this._solidity063CorrectLineNumber(constructorRevertFrame);\n      }\n      return constructorRevertFrame;\n    }\n    if (prevInst !== undefined) {\n      // We may as well just be in a function or modifier and just happen\n      // to be at the last instruction of the runtime bytecode.\n      // In this case we just return whatever the last mapped intruction\n      // points to.\n      const latestInstructionRevertFrame = this._instructionWithinFunctionToUnmappedSolc063RevertErrorStackTraceEntry(trace, prevInst);\n      if (latestInstructionRevertFrame.sourceReference !== undefined) {\n        this._solidity063CorrectLineNumber(latestInstructionRevertFrame);\n      }\n      return latestInstructionRevertFrame;\n    }\n  }\n  _isContractTooLargeError(trace) {\n    return trace.exit.kind === exit_1.ExitCode.CODESIZE_EXCEEDS_MAXIMUM;\n  }\n  _solidity063CorrectLineNumber(revertFrame) {\n    if (revertFrame.sourceReference === undefined) {\n      return;\n    }\n    const lines = revertFrame.sourceReference.sourceContent.split(\"\\n\");\n    const currentLine = lines[revertFrame.sourceReference.line - 1];\n    if (currentLine.includes(\"require\") || currentLine.includes(\"revert\")) {\n      return;\n    }\n    const nextLines = lines.slice(revertFrame.sourceReference.line);\n    const firstNonEmptyLine = nextLines.findIndex(l => l.trim() !== \"\");\n    if (firstNonEmptyLine === -1) {\n      return;\n    }\n    const nextLine = nextLines[firstNonEmptyLine];\n    if (nextLine.includes(\"require\") || nextLine.includes(\"revert\")) {\n      revertFrame.sourceReference.line += 1 + firstNonEmptyLine;\n    }\n  }\n  _getLastInstructionWithValidLocationStepIndex(trace) {\n    for (let i = trace.steps.length - 1; i >= 0; i--) {\n      const step = trace.steps[i];\n      if (!(0, message_trace_1.isEvmStep)(step)) {\n        return undefined;\n      }\n      const inst = trace.bytecode.getInstruction(step.pc);\n      if (inst.location !== undefined) {\n        return i;\n      }\n    }\n    return undefined;\n  }\n  _getLastInstructionWithValidLocation(trace) {\n    const lastLocationIndex = this._getLastInstructionWithValidLocationStepIndex(trace);\n    if (lastLocationIndex === undefined) {\n      return undefined;\n    }\n    const lastLocationStep = trace.steps[lastLocationIndex];\n    if ((0, message_trace_1.isEvmStep)(lastLocationStep)) {\n      const lastInstructionWithLocation = trace.bytecode.getInstruction(lastLocationStep.pc);\n      return lastInstructionWithLocation;\n    }\n    return undefined;\n  }\n  _callInstructionToCallFailedToExecuteStackTraceEntry(bytecode, callInst) {\n    const sourceReference = sourceLocationToSourceReference(bytecode, callInst.location);\n    (0, errors_1.assertHardhatInvariant)(sourceReference !== undefined, \"Expected source reference to be defined\");\n    // Calls only happen within functions\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.CALL_FAILED_ERROR,\n      sourceReference\n    };\n  }\n  _getEntryBeforeFailureInModifier(trace, functionJumpdests) {\n    // If there's a jumpdest, this modifier belongs to the last function that it represents\n    if (functionJumpdests.length > 0) {\n      return instructionToCallstackStackTraceEntry(trace.bytecode, functionJumpdests[functionJumpdests.length - 1]);\n    }\n    // This function is only called after we jumped into the initial function in call traces, so\n    // there should always be at least a function jumpdest.\n    if (!(0, message_trace_1.isDecodedCreateTrace)(trace)) {\n      throw new Error(\"This shouldn't happen: a call trace has no functionJumpdest but has already jumped into a function\");\n    }\n    // If there's no jump dest, we point to the constructor.\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY,\n      sourceReference: this._getConstructorStartSourceReference(trace),\n      functionType: model_1.ContractFunctionType.CONSTRUCTOR\n    };\n  }\n  _failsRightAfterCall(trace, callSubtraceStepIndex) {\n    const lastStep = trace.steps[trace.steps.length - 1];\n    if (!(0, message_trace_1.isEvmStep)(lastStep)) {\n      return false;\n    }\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n    if (lastInst.opcode !== opcodes_1.Opcode.REVERT) {\n      return false;\n    }\n    const callOpcodeStep = trace.steps[callSubtraceStepIndex - 1];\n    const callInst = trace.bytecode.getInstruction(callOpcodeStep.pc);\n    // Calls are always made from within functions\n    (0, errors_1.assertHardhatInvariant)(callInst.location !== undefined, \"Expected call instruction location to be defined\");\n    return this._isLastLocation(trace, callSubtraceStepIndex + 1, callInst.location);\n  }\n  _isCallFailedError(trace, instIndex, callInstruction) {\n    const callLocation = callInstruction.location;\n    // Calls are always made from within functions\n    (0, errors_1.assertHardhatInvariant)(callLocation !== undefined, \"Expected call location to be defined\");\n    return this._isLastLocation(trace, instIndex, callLocation);\n  }\n  _isLastLocation(trace, fromStep, location) {\n    for (let i = fromStep; i < trace.steps.length; i++) {\n      const step = trace.steps[i];\n      if (!(0, message_trace_1.isEvmStep)(step)) {\n        return false;\n      }\n      const stepInst = trace.bytecode.getInstruction(step.pc);\n      if (stepInst.location === undefined) {\n        continue;\n      }\n      if (!location.equals(stepInst.location)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  _isSubtraceErrorPropagated(trace, callSubtraceStepIndex) {\n    const call = trace.steps[callSubtraceStepIndex];\n    if (!(0, ethereumjs_util_1.equalsBytes)(trace.returnData, call.returnData)) {\n      return false;\n    }\n    if (trace.exit.kind === exit_1.ExitCode.OUT_OF_GAS && call.exit.kind === exit_1.ExitCode.OUT_OF_GAS) {\n      return true;\n    }\n    // If the return data is not empty, and it's still the same, we assume it\n    // is being propagated\n    if (trace.returnData.length > 0) {\n      return true;\n    }\n    return this._failsRightAfterCall(trace, callSubtraceStepIndex);\n  }\n  _isProxyErrorPropagated(trace, callSubtraceStepIndex) {\n    if (!(0, message_trace_1.isDecodedCallTrace)(trace)) {\n      return false;\n    }\n    const callStep = trace.steps[callSubtraceStepIndex - 1];\n    if (!(0, message_trace_1.isEvmStep)(callStep)) {\n      return false;\n    }\n    const callInst = trace.bytecode.getInstruction(callStep.pc);\n    if (callInst.opcode !== opcodes_1.Opcode.DELEGATECALL) {\n      return false;\n    }\n    const subtrace = trace.steps[callSubtraceStepIndex];\n    if ((0, message_trace_1.isEvmStep)(subtrace)) {\n      return false;\n    }\n    if ((0, message_trace_1.isPrecompileTrace)(subtrace)) {\n      return false;\n    }\n    // If we can't recognize the implementation we'd better don't consider it as such\n    if (subtrace.bytecode === undefined) {\n      return false;\n    }\n    if (subtrace.bytecode.contract.type === model_1.ContractType.LIBRARY) {\n      return false;\n    }\n    if (!(0, ethereumjs_util_1.equalsBytes)(trace.returnData, subtrace.returnData)) {\n      return false;\n    }\n    for (let i = callSubtraceStepIndex + 1; i < trace.steps.length; i++) {\n      const step = trace.steps[i];\n      if (!(0, message_trace_1.isEvmStep)(step)) {\n        return false;\n      }\n      const inst = trace.bytecode.getInstruction(step.pc);\n      // All the remaining locations should be valid, as they are part of the inline asm\n      if (inst.location === undefined) {\n        return false;\n      }\n      if (inst.jumpType === model_1.JumpType.INTO_FUNCTION || inst.jumpType === model_1.JumpType.OUTOF_FUNCTION) {\n        return false;\n      }\n    }\n    const lastStep = trace.steps[trace.steps.length - 1];\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n    return lastInst.opcode === opcodes_1.Opcode.REVERT;\n  }\n  _isContractCallRunOutOfGasError(trace, callStepIndex) {\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n    if (trace.exit.kind !== exit_1.ExitCode.REVERT) {\n      return false;\n    }\n    const call = trace.steps[callStepIndex];\n    if (call.exit.kind !== exit_1.ExitCode.OUT_OF_GAS) {\n      return false;\n    }\n    return this._failsRightAfterCall(trace, callStepIndex);\n  }\n  _isPanicReturnData(returnData) {\n    return new return_data_1.ReturnData(returnData).isPanicReturnData();\n  }\n}\nexports.ErrorInferrer = ErrorInferrer;\nfunction instructionToCallstackStackTraceEntry(bytecode, inst) {\n  // This means that a jump is made from within an internal solc function.\n  // These are normally made from yul code, so they don't map to any Solidity\n  // function\n  if (inst.location === undefined) {\n    const location = bytecode.contract.location;\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.INTERNAL_FUNCTION_CALLSTACK_ENTRY,\n      pc: inst.pc,\n      sourceReference: {\n        sourceName: bytecode.contract.location.file.sourceName,\n        sourceContent: bytecode.contract.location.file.content,\n        contract: bytecode.contract.name,\n        function: undefined,\n        line: bytecode.contract.location.getStartingLineNumber(),\n        range: [location.offset, location.offset + location.length]\n      }\n    };\n  }\n  const func = inst.location?.getContainingFunction();\n  if (func !== undefined) {\n    const sourceReference = sourceLocationToSourceReference(bytecode, inst.location);\n    (0, errors_1.assertHardhatInvariant)(sourceReference !== undefined, \"Expected source reference to be defined\");\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY,\n      sourceReference,\n      functionType: func.type\n    };\n  }\n  (0, errors_1.assertHardhatInvariant)(inst.location !== undefined, \"Expected instruction location to be defined\");\n  return {\n    type: solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY,\n    sourceReference: {\n      function: undefined,\n      contract: bytecode.contract.name,\n      sourceName: inst.location.file.sourceName,\n      sourceContent: inst.location.file.content,\n      line: inst.location.getStartingLineNumber(),\n      range: [inst.location.offset, inst.location.offset + inst.location.length]\n    },\n    functionType: model_1.ContractFunctionType.FUNCTION\n  };\n}\nexports.instructionToCallstackStackTraceEntry = instructionToCallstackStackTraceEntry;\nfunction sourceLocationToSourceReference(bytecode, location) {\n  if (location === undefined) {\n    return undefined;\n  }\n  const func = location.getContainingFunction();\n  if (func === undefined) {\n    return undefined;\n  }\n  let funcName = func.name;\n  if (func.type === model_1.ContractFunctionType.CONSTRUCTOR) {\n    funcName = solidity_stack_trace_1.CONSTRUCTOR_FUNCTION_NAME;\n  } else if (func.type === model_1.ContractFunctionType.FALLBACK) {\n    funcName = solidity_stack_trace_1.FALLBACK_FUNCTION_NAME;\n  } else if (func.type === model_1.ContractFunctionType.RECEIVE) {\n    funcName = solidity_stack_trace_1.RECEIVE_FUNCTION_NAME;\n  }\n  return {\n    function: funcName,\n    contract: func.type === model_1.ContractFunctionType.FREE_FUNCTION ? undefined : bytecode.contract.name,\n    sourceName: func.location.file.sourceName,\n    sourceContent: func.location.file.content,\n    line: location.getStartingLineNumber(),\n    range: [location.offset, location.offset + location.length]\n  };\n}","map":{"version":3,"names":["abi_1","require","ethereumjs_util_1","semver_1","__importDefault","errors_1","abi_helpers_1","return_data_1","exit_1","message_trace_1","model_1","opcodes_1","solidity_stack_trace_1","FIRST_SOLC_VERSION_CREATE_PARAMS_VALIDATION","FIRST_SOLC_VERSION_RECEIVE_FUNCTION","FIRST_SOLC_VERSION_WITH_UNMAPPED_REVERTS","ErrorInferrer","inferBeforeTracingCallMessage","trace","_isDirectLibraryCall","_getDirectLibraryCallErrorStackTrace","calledFunction","bytecode","contract","getFunctionFromSelector","calldata","slice","undefined","_isFunctionNotPayableError","type","StackTraceEntryType","FUNCTION_NOT_PAYABLE_ERROR","sourceReference","_getFunctionStartSourceReference","value","_isMissingFunctionAndFallbackError","_emptyCalldataAndNoReceive","MISSING_FALLBACK_OR_RECEIVE_ERROR","_getContractStartWithoutFunctionSourceReference","UNRECOGNIZED_FUNCTION_WITHOUT_FALLBACK_ERROR","_isFallbackNotPayableError","FALLBACK_NOT_PAYABLE_AND_NO_RECEIVE_ERROR","_getFallbackStartSourceReference","FALLBACK_NOT_PAYABLE_ERROR","inferBeforeTracingCreateMessage","_isConstructorNotPayableError","_getConstructorStartSourceReference","_isConstructorInvalidArgumentsError","INVALID_PARAMS_ERROR","inferAfterTracing","stacktrace","functionJumpdests","jumpedIntoFunction","lastSubmessageData","_checkLastSubmessage","_checkFailedLastCall","_checkLastInstruction","_checkNonContractCalled","_checkSolidity063UnmappedRevert","_checkContractTooLarge","_otherExecutionErrorStacktrace","filterRedundantFrames","filter","frame","i","length","nextFrame","CALLSTACK_ENTRY","RETURNDATA_SIZE_ERROR","thatSrcRef","range","line","function","inferredStacktrace","callStep","steps","stepIndex","isEvmStep","Error","callInst","getInstruction","pc","callStackFrame","instructionToCallstackStackTraceEntry","lastMessageFailed","messageTrace","exit","isError","push","_isSubtraceErrorPropagated","_isProxyErrorPropagated","_isContractCallRunOutOfGasError","lastFrame","pop","assertHardhatInvariant","CONTRACT_CALL_RUN_OUT_OF_GAS_ERROR","_fixInitialModifier","isReturnDataSizeError","_failsRightAfterCall","step","nextStep","inst","isCallOrCreate","isCall","opcode","isCreate","_isCallFailedError","_callInstructionToCallFailedToExecuteStackTraceEntry","_checkRevertOrInvalidOpcode","lastInstruction","Opcode","REVERT","INVALID","location","isDecodedCallTrace","failingFunction","getContainingFunction","ContractFunctionType","MODIFIER","_getEntryBeforeFailureInModifier","panicStacktrace","_checkPanic","customErrorStacktrace","_checkCustomErrors","_instructionWithinFunctionToRevertStackTraceEntry","functionSelector","REVERT_ERROR","message","ReturnData","returnData","isInvalidOpcodeError","revertFrame","_getLastSourceReference","_isPanicReturnData","INTERNAL_FUNCTION_CALLSTACK_ENTRY","splice","panicReturnData","errorCode","decodePanic","_instructionWithinFunctionToPanicStackTraceEntry","isEmpty","isErrorReturnData","rawReturnData","Buffer","from","toString","errorMessage","customError","customErrors","matchesSelector","selector","decodedValues","defaultAbiCoder","decode","paramTypes","params","AbiHelpers","formatValues","name","_instructionWithinFunctionToCustomErrorStackTraceEntry","lastStep","revertOrInvalidStacktrace","_hasFailedInsideTheFallbackFunction","_hasFailedInsideTheReceiveFunction","isValidCalldata","_solidity063MaybeUnmappedRevert","_solidity063GetFrameForUnmappedRevertBeforeFunction","_getOtherErrorBeforeCalledFunctionStackTraceEntry","_isCalledNonContractAccountError","nonContractCalledFrame","NONCONTRACT_ACCOUNT_CALLED_ERROR","_solidity063GetFrameForUnmappedRevertWithinFunction","isCreateTrace","_isContractTooLargeError","CONTRACT_TOO_LARGE_ERROR","otherExecutionErrorFrame","OTHER_EXECUTION_ERROR","firstEntry","functionType","_getEntryBeforeInitialModifierCallstackEntry","depth","ContractType","LIBRARY","func","DIRECT_LIBRARY_CALL_ERROR","isPayable","sourceName","file","sourceContent","content","getStartingLineNumber","offset","receive","fallback","default","lt","compilerVersion","FALLBACK_FUNCTION_NAME","constructor","constructorFunction","CONSTRUCTOR_FUNCTION_NAME","lastInst","hasReadDeploymentCodeSize","equals","CODESIZE","isDecodedCreateTrace","CONSTRUCTOR","FUNCTION","FALLBACK","sourceLocationToSourceReference","_hasFailedInsideFunction","contains","_instructionWithinFunctionToUnmappedSolc063RevertErrorStackTraceEntry","UNMAPPED_SOLC_0_6_3_REVERT_ERROR","lastSourceReference","PANIC_ERROR","CUSTOM_ERROR","satisfies","_solidity063CorrectLineNumber","RECEIVE_FUNCTION_NAME","lastIndex","_getLastInstructionWithValidLocationStepIndex","ISZERO","prevStep","prevInst","EXTCODESIZE","_getLastInstructionWithValidLocation","nextInstPc","hasNextInst","hasInstruction","nextInst","prevLoc","nextLoc","prevFunc","nextFunc","constructorRevertFrame","defaultSourceReference","latestInstructionRevertFrame","kind","ExitCode","CODESIZE_EXCEEDS_MAXIMUM","lines","split","currentLine","includes","nextLines","firstNonEmptyLine","findIndex","l","trim","nextLine","lastLocationIndex","lastLocationStep","lastInstructionWithLocation","CALL_FAILED_ERROR","callSubtraceStepIndex","callOpcodeStep","_isLastLocation","instIndex","callInstruction","callLocation","fromStep","stepInst","call","equalsBytes","OUT_OF_GAS","DELEGATECALL","subtrace","isPrecompileTrace","jumpType","JumpType","INTO_FUNCTION","OUTOF_FUNCTION","callStepIndex","isPanicReturnData","exports","funcName","RECEIVE","FREE_FUNCTION"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\internal\\hardhat-network\\stack-traces\\error-inferrer.ts"],"sourcesContent":["/* eslint \"@typescript-eslint/no-non-null-assertion\": \"error\" */\nimport { defaultAbiCoder as abi } from \"@ethersproject/abi\";\nimport { equalsBytes } from \"@nomicfoundation/ethereumjs-util\";\nimport semver from \"semver\";\n\nimport { assertHardhatInvariant } from \"../../core/errors\";\nimport { AbiHelpers } from \"../../util/abi-helpers\";\nimport { ReturnData } from \"../provider/return-data\";\nimport { ExitCode } from \"../provider/vm/exit\";\n\nimport {\n  DecodedCallMessageTrace,\n  DecodedCreateMessageTrace,\n  DecodedEvmMessageTrace,\n  EvmStep,\n  isCreateTrace,\n  isDecodedCallTrace,\n  isDecodedCreateTrace,\n  isEvmStep,\n  isPrecompileTrace,\n  MessageTrace,\n} from \"./message-trace\";\nimport {\n  Bytecode,\n  ContractFunction,\n  ContractFunctionType,\n  ContractType,\n  Instruction,\n  JumpType,\n  SourceLocation,\n} from \"./model\";\nimport { isCall, isCreate, Opcode } from \"./opcodes\";\nimport {\n  CallFailedErrorStackTraceEntry,\n  CallstackEntryStackTraceEntry,\n  CONSTRUCTOR_FUNCTION_NAME,\n  CustomErrorStackTraceEntry,\n  FALLBACK_FUNCTION_NAME,\n  InternalFunctionCallStackEntry,\n  OtherExecutionErrorStackTraceEntry,\n  PanicErrorStackTraceEntry,\n  RECEIVE_FUNCTION_NAME,\n  RevertErrorStackTraceEntry,\n  SolidityStackTrace,\n  SolidityStackTraceEntry,\n  SourceReference,\n  StackTraceEntryType,\n  UnmappedSolc063RevertErrorStackTraceEntry,\n} from \"./solidity-stack-trace\";\n\nconst FIRST_SOLC_VERSION_CREATE_PARAMS_VALIDATION = \"0.5.9\";\nconst FIRST_SOLC_VERSION_RECEIVE_FUNCTION = \"0.6.0\";\nconst FIRST_SOLC_VERSION_WITH_UNMAPPED_REVERTS = \"0.6.3\";\n\nexport interface SubmessageData {\n  messageTrace: MessageTrace;\n  stacktrace: SolidityStackTrace;\n  stepIndex: number;\n}\n\n/* eslint-disable @nomicfoundation/hardhat-internal-rules/only-hardhat-error */\n\nexport class ErrorInferrer {\n  public inferBeforeTracingCallMessage(\n    trace: DecodedCallMessageTrace\n  ): SolidityStackTrace | undefined {\n    if (this._isDirectLibraryCall(trace)) {\n      return this._getDirectLibraryCallErrorStackTrace(trace);\n    }\n\n    const calledFunction = trace.bytecode.contract.getFunctionFromSelector(\n      trace.calldata.slice(0, 4)\n    );\n\n    if (\n      calledFunction !== undefined &&\n      this._isFunctionNotPayableError(trace, calledFunction)\n    ) {\n      return [\n        {\n          type: StackTraceEntryType.FUNCTION_NOT_PAYABLE_ERROR,\n          sourceReference: this._getFunctionStartSourceReference(\n            trace,\n            calledFunction\n          ),\n          value: trace.value,\n        },\n      ];\n    }\n\n    if (this._isMissingFunctionAndFallbackError(trace, calledFunction)) {\n      if (this._emptyCalldataAndNoReceive(trace)) {\n        return [\n          {\n            type: StackTraceEntryType.MISSING_FALLBACK_OR_RECEIVE_ERROR,\n            sourceReference:\n              this._getContractStartWithoutFunctionSourceReference(trace),\n          },\n        ];\n      }\n\n      return [\n        {\n          type: StackTraceEntryType.UNRECOGNIZED_FUNCTION_WITHOUT_FALLBACK_ERROR,\n          sourceReference:\n            this._getContractStartWithoutFunctionSourceReference(trace),\n        },\n      ];\n    }\n\n    if (this._isFallbackNotPayableError(trace, calledFunction)) {\n      if (this._emptyCalldataAndNoReceive(trace)) {\n        return [\n          {\n            type: StackTraceEntryType.FALLBACK_NOT_PAYABLE_AND_NO_RECEIVE_ERROR,\n            sourceReference: this._getFallbackStartSourceReference(trace),\n            value: trace.value,\n          },\n        ];\n      }\n\n      return [\n        {\n          type: StackTraceEntryType.FALLBACK_NOT_PAYABLE_ERROR,\n          sourceReference: this._getFallbackStartSourceReference(trace),\n          value: trace.value,\n        },\n      ];\n    }\n  }\n\n  public inferBeforeTracingCreateMessage(\n    trace: DecodedCreateMessageTrace\n  ): SolidityStackTrace | undefined {\n    if (this._isConstructorNotPayableError(trace)) {\n      return [\n        {\n          type: StackTraceEntryType.FUNCTION_NOT_PAYABLE_ERROR,\n          sourceReference: this._getConstructorStartSourceReference(trace),\n          value: trace.value,\n        },\n      ];\n    }\n\n    if (this._isConstructorInvalidArgumentsError(trace)) {\n      return [\n        {\n          type: StackTraceEntryType.INVALID_PARAMS_ERROR,\n          sourceReference: this._getConstructorStartSourceReference(trace),\n        },\n      ];\n    }\n  }\n\n  public inferAfterTracing(\n    trace: DecodedEvmMessageTrace,\n    stacktrace: SolidityStackTrace,\n    functionJumpdests: Instruction[],\n    jumpedIntoFunction: boolean,\n    lastSubmessageData: SubmessageData | undefined\n  ): SolidityStackTrace {\n    return (\n      this._checkLastSubmessage(trace, stacktrace, lastSubmessageData) ??\n      this._checkFailedLastCall(trace, stacktrace) ??\n      this._checkLastInstruction(\n        trace,\n        stacktrace,\n        functionJumpdests,\n        jumpedIntoFunction\n      ) ??\n      this._checkNonContractCalled(trace, stacktrace) ??\n      this._checkSolidity063UnmappedRevert(trace, stacktrace) ??\n      this._checkContractTooLarge(trace) ??\n      this._otherExecutionErrorStacktrace(trace, stacktrace)\n    );\n  }\n\n  public filterRedundantFrames(\n    stacktrace: SolidityStackTrace\n  ): SolidityStackTrace {\n    return stacktrace.filter((frame, i) => {\n      if (i + 1 === stacktrace.length) {\n        return true;\n      }\n\n      const nextFrame = stacktrace[i + 1];\n\n      // we can only filter frames if we know their sourceReference\n      // and the one from the next frame\n      if (\n        frame.sourceReference === undefined ||\n        nextFrame.sourceReference === undefined\n      ) {\n        return true;\n      }\n\n      // look TWO frames ahead to determine if this is a specific occurrence of\n      // a redundant CALLSTACK_ENTRY frame observed when using Solidity 0.8.5:\n      if (\n        frame.type === StackTraceEntryType.CALLSTACK_ENTRY &&\n        i + 2 < stacktrace.length &&\n        stacktrace[i + 2].sourceReference !== undefined &&\n        stacktrace[i + 2].type === StackTraceEntryType.RETURNDATA_SIZE_ERROR\n      ) {\n        // ! below for tsc. we confirmed existence in the enclosing conditional.\n        const thatSrcRef = stacktrace[i + 2].sourceReference;\n        if (\n          thatSrcRef !== undefined &&\n          frame.sourceReference.range[0] === thatSrcRef.range[0] &&\n          frame.sourceReference.range[1] === thatSrcRef.range[1] &&\n          frame.sourceReference.line === thatSrcRef.line\n        ) {\n          return false;\n        }\n      }\n\n      // constructors contain the whole contract, so we ignore them\n      if (\n        frame.sourceReference.function === \"constructor\" &&\n        nextFrame.sourceReference.function !== \"constructor\"\n      ) {\n        return true;\n      }\n\n      // this is probably a recursive call\n      if (\n        i > 0 &&\n        frame.type === nextFrame.type &&\n        frame.sourceReference.range[0] === nextFrame.sourceReference.range[0] &&\n        frame.sourceReference.range[1] === nextFrame.sourceReference.range[1] &&\n        frame.sourceReference.line === nextFrame.sourceReference.line\n      ) {\n        return true;\n      }\n\n      if (\n        frame.sourceReference.range[0] <= nextFrame.sourceReference.range[0] &&\n        frame.sourceReference.range[1] >= nextFrame.sourceReference.range[1]\n      ) {\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  // Heuristics\n\n  /**\n   * Check if the last submessage can be used to generate the stack trace.\n   */\n  private _checkLastSubmessage(\n    trace: DecodedEvmMessageTrace,\n    stacktrace: SolidityStackTrace,\n    lastSubmessageData: SubmessageData | undefined\n  ): SolidityStackTrace | undefined {\n    if (lastSubmessageData === undefined) {\n      return undefined;\n    }\n\n    const inferredStacktrace = [...stacktrace];\n\n    // get the instruction before the submessage and add it to the stack trace\n    const callStep = trace.steps[lastSubmessageData.stepIndex - 1];\n\n    if (!isEvmStep(callStep)) {\n      throw new Error(\n        \"This should not happen: MessageTrace should be preceded by a EVM step\"\n      );\n    }\n\n    const callInst = trace.bytecode.getInstruction(callStep.pc);\n    const callStackFrame = instructionToCallstackStackTraceEntry(\n      trace.bytecode,\n      callInst\n    );\n\n    const lastMessageFailed = lastSubmessageData.messageTrace.exit.isError();\n    if (lastMessageFailed) {\n      // add the call/create that generated the message to the stack trace\n      inferredStacktrace.push(callStackFrame);\n\n      if (\n        this._isSubtraceErrorPropagated(trace, lastSubmessageData.stepIndex) ||\n        this._isProxyErrorPropagated(trace, lastSubmessageData.stepIndex)\n      ) {\n        inferredStacktrace.push(...lastSubmessageData.stacktrace);\n\n        if (\n          this._isContractCallRunOutOfGasError(\n            trace,\n            lastSubmessageData.stepIndex\n          )\n        ) {\n          const lastFrame = inferredStacktrace.pop();\n          assertHardhatInvariant(\n            lastFrame !== undefined,\n            \"Expected inferred stack trace to have at least one frame\"\n          );\n          inferredStacktrace.push({\n            type: StackTraceEntryType.CONTRACT_CALL_RUN_OUT_OF_GAS_ERROR,\n            sourceReference: lastFrame.sourceReference,\n          });\n        }\n\n        return this._fixInitialModifier(trace, inferredStacktrace);\n      }\n    } else {\n      const isReturnDataSizeError = this._failsRightAfterCall(\n        trace,\n        lastSubmessageData.stepIndex\n      );\n      if (isReturnDataSizeError) {\n        inferredStacktrace.push({\n          type: StackTraceEntryType.RETURNDATA_SIZE_ERROR,\n          sourceReference: callStackFrame.sourceReference,\n        });\n\n        return this._fixInitialModifier(trace, inferredStacktrace);\n      }\n    }\n  }\n\n  /**\n   * Check if the last call/create that was done failed.\n   */\n  private _checkFailedLastCall(\n    trace: DecodedEvmMessageTrace,\n    stacktrace: SolidityStackTrace\n  ): SolidityStackTrace | undefined {\n    for (let stepIndex = trace.steps.length - 2; stepIndex >= 0; stepIndex--) {\n      const step = trace.steps[stepIndex];\n      const nextStep = trace.steps[stepIndex + 1];\n\n      if (!isEvmStep(step)) {\n        return;\n      }\n\n      const inst = trace.bytecode.getInstruction(step.pc);\n\n      const isCallOrCreate = isCall(inst.opcode) || isCreate(inst.opcode);\n\n      if (isCallOrCreate && isEvmStep(nextStep)) {\n        if (this._isCallFailedError(trace, stepIndex, inst)) {\n          const inferredStacktrace = [\n            ...stacktrace,\n            this._callInstructionToCallFailedToExecuteStackTraceEntry(\n              trace.bytecode,\n              inst\n            ),\n          ];\n\n          return this._fixInitialModifier(trace, inferredStacktrace);\n        }\n      }\n    }\n  }\n\n  /**\n   * Check if the execution stopped with a revert or an invalid opcode.\n   */\n  private _checkRevertOrInvalidOpcode(\n    trace: DecodedEvmMessageTrace,\n    stacktrace: SolidityStackTrace,\n    lastInstruction: Instruction,\n    functionJumpdests: Instruction[],\n    jumpedIntoFunction: boolean\n  ): SolidityStackTrace | undefined {\n    if (\n      lastInstruction.opcode !== Opcode.REVERT &&\n      lastInstruction.opcode !== Opcode.INVALID\n    ) {\n      return;\n    }\n\n    const inferredStacktrace = [...stacktrace];\n\n    if (\n      lastInstruction.location !== undefined &&\n      (!isDecodedCallTrace(trace) || jumpedIntoFunction)\n    ) {\n      // There should always be a function here, but that's not the case with optimizations.\n      //\n      // If this is a create trace, we already checked args and nonpayable failures before\n      // calling this function.\n      //\n      // If it's a call trace, we already jumped into a function. But optimizations can happen.\n      const failingFunction = lastInstruction.location.getContainingFunction();\n\n      // If the failure is in a modifier we add an entry with the function/constructor\n      if (\n        failingFunction !== undefined &&\n        failingFunction.type === ContractFunctionType.MODIFIER\n      ) {\n        inferredStacktrace.push(\n          this._getEntryBeforeFailureInModifier(trace, functionJumpdests)\n        );\n      }\n    }\n\n    const panicStacktrace = this._checkPanic(\n      trace,\n      inferredStacktrace,\n      lastInstruction\n    );\n    if (panicStacktrace !== undefined) {\n      return panicStacktrace;\n    }\n\n    const customErrorStacktrace = this._checkCustomErrors(\n      trace,\n      inferredStacktrace,\n      lastInstruction\n    );\n    if (customErrorStacktrace !== undefined) {\n      return customErrorStacktrace;\n    }\n\n    if (\n      lastInstruction.location !== undefined &&\n      (!isDecodedCallTrace(trace) || jumpedIntoFunction)\n    ) {\n      const failingFunction = lastInstruction.location.getContainingFunction();\n\n      if (failingFunction !== undefined) {\n        inferredStacktrace.push(\n          this._instructionWithinFunctionToRevertStackTraceEntry(\n            trace,\n            lastInstruction\n          )\n        );\n      } else if (isDecodedCallTrace(trace)) {\n        // This is here because of the optimizations\n        const functionSelector =\n          trace.bytecode.contract.getFunctionFromSelector(\n            trace.calldata.slice(0, 4)\n          );\n\n        // in general this shouldn't happen, but it does when viaIR is enabled,\n        // \"optimizerSteps\": \"u\" is used, and the called function is fallback or\n        // receive\n        if (functionSelector === undefined) {\n          return;\n        }\n\n        inferredStacktrace.push({\n          type: StackTraceEntryType.REVERT_ERROR,\n          sourceReference: this._getFunctionStartSourceReference(\n            trace,\n            functionSelector\n          ),\n          message: new ReturnData(trace.returnData),\n          isInvalidOpcodeError: lastInstruction.opcode === Opcode.INVALID,\n        });\n      } else {\n        // This is here because of the optimizations\n        inferredStacktrace.push({\n          type: StackTraceEntryType.REVERT_ERROR,\n          sourceReference: this._getConstructorStartSourceReference(trace),\n          message: new ReturnData(trace.returnData),\n          isInvalidOpcodeError: lastInstruction.opcode === Opcode.INVALID,\n        });\n      }\n\n      return this._fixInitialModifier(trace, inferredStacktrace);\n    }\n\n    // If the revert instruction is not mapped but there is return data,\n    // we add the frame anyway, sith the best sourceReference we can get\n    if (lastInstruction.location === undefined && trace.returnData.length > 0) {\n      const revertFrame: RevertErrorStackTraceEntry = {\n        type: StackTraceEntryType.REVERT_ERROR,\n        sourceReference:\n          this._getLastSourceReference(trace) ??\n          this._getContractStartWithoutFunctionSourceReference(trace),\n        message: new ReturnData(trace.returnData),\n        isInvalidOpcodeError: lastInstruction.opcode === Opcode.INVALID,\n      };\n      inferredStacktrace.push(revertFrame);\n\n      return this._fixInitialModifier(trace, inferredStacktrace);\n    }\n  }\n\n  /**\n   * Check if the trace reverted with a panic error.\n   */\n  private _checkPanic(\n    trace: DecodedEvmMessageTrace,\n    stacktrace: SolidityStackTrace,\n    lastInstruction: Instruction\n  ): SolidityStackTrace | undefined {\n    if (!this._isPanicReturnData(trace.returnData)) {\n      return;\n    }\n\n    // If the last frame is an internal function, it means that the trace\n    // jumped there to return the panic. If that's the case, we remove that\n    // frame.\n    const lastFrame = stacktrace[stacktrace.length - 1];\n    if (\n      lastFrame?.type === StackTraceEntryType.INTERNAL_FUNCTION_CALLSTACK_ENTRY\n    ) {\n      stacktrace.splice(-1);\n    }\n\n    const panicReturnData = new ReturnData(trace.returnData);\n    const errorCode = panicReturnData.decodePanic();\n\n    // if the error comes from a call to a zero-initialized function,\n    // we remove the last frame, which represents the call, to avoid\n    // having duplicated frames\n    if (errorCode === 0x51n) {\n      stacktrace.splice(-1);\n    }\n\n    const inferredStacktrace = [...stacktrace];\n    inferredStacktrace.push(\n      this._instructionWithinFunctionToPanicStackTraceEntry(\n        trace,\n        lastInstruction,\n        errorCode\n      )\n    );\n\n    return this._fixInitialModifier(trace, inferredStacktrace);\n  }\n\n  private _checkCustomErrors(\n    trace: DecodedEvmMessageTrace,\n    stacktrace: SolidityStackTrace,\n    lastInstruction: Instruction\n  ): SolidityStackTrace | undefined {\n    const returnData = new ReturnData(trace.returnData);\n\n    if (returnData.isEmpty() || returnData.isErrorReturnData()) {\n      // if there is no return data, or if it's a Error(string),\n      // then it can't be a custom error\n      return;\n    }\n\n    const rawReturnData = Buffer.from(returnData.value).toString(\"hex\");\n    let errorMessage = `reverted with an unrecognized custom error (return data: 0x${rawReturnData})`;\n\n    for (const customError of trace.bytecode.contract.customErrors) {\n      if (returnData.matchesSelector(customError.selector)) {\n        // if the return data matches a custom error in the called contract,\n        // we format the message using the returnData and the custom error instance\n        const decodedValues = abi.decode(\n          customError.paramTypes,\n          returnData.value.slice(4)\n        );\n\n        const params = AbiHelpers.formatValues([...decodedValues]);\n        errorMessage = `reverted with custom error '${customError.name}(${params})'`;\n        break;\n      }\n    }\n\n    const inferredStacktrace = [...stacktrace];\n    inferredStacktrace.push(\n      this._instructionWithinFunctionToCustomErrorStackTraceEntry(\n        trace,\n        lastInstruction,\n        errorMessage\n      )\n    );\n\n    return this._fixInitialModifier(trace, inferredStacktrace);\n  }\n\n  /**\n   * Check last instruction to try to infer the error.\n   */\n  private _checkLastInstruction(\n    trace: DecodedEvmMessageTrace,\n    stacktrace: SolidityStackTrace,\n    functionJumpdests: Instruction[],\n    jumpedIntoFunction: boolean\n  ): SolidityStackTrace | undefined {\n    if (trace.steps.length === 0) {\n      return;\n    }\n\n    const lastStep = trace.steps[trace.steps.length - 1];\n\n    if (!isEvmStep(lastStep)) {\n      throw new Error(\n        \"This should not happen: MessageTrace ends with a subtrace\"\n      );\n    }\n\n    const lastInstruction = trace.bytecode.getInstruction(lastStep.pc);\n\n    const revertOrInvalidStacktrace = this._checkRevertOrInvalidOpcode(\n      trace,\n      stacktrace,\n      lastInstruction,\n      functionJumpdests,\n      jumpedIntoFunction\n    );\n\n    if (revertOrInvalidStacktrace !== undefined) {\n      return revertOrInvalidStacktrace;\n    }\n\n    if (isDecodedCallTrace(trace) && !jumpedIntoFunction) {\n      if (\n        this._hasFailedInsideTheFallbackFunction(trace) ||\n        this._hasFailedInsideTheReceiveFunction(trace)\n      ) {\n        return [\n          this._instructionWithinFunctionToRevertStackTraceEntry(\n            trace,\n            lastInstruction\n          ),\n        ];\n      }\n\n      // Sometimes we do fail inside of a function but there's no jump into\n      if (lastInstruction.location !== undefined) {\n        const failingFunction =\n          lastInstruction.location.getContainingFunction();\n        if (failingFunction !== undefined) {\n          return [\n            {\n              type: StackTraceEntryType.REVERT_ERROR,\n              sourceReference: this._getFunctionStartSourceReference(\n                trace,\n                failingFunction\n              ),\n              message: new ReturnData(trace.returnData),\n              isInvalidOpcodeError: lastInstruction.opcode === Opcode.INVALID,\n            },\n          ];\n        }\n      }\n\n      const calledFunction = trace.bytecode.contract.getFunctionFromSelector(\n        trace.calldata.slice(0, 4)\n      );\n\n      if (calledFunction !== undefined) {\n        const isValidCalldata = calledFunction.isValidCalldata(\n          trace.calldata.slice(4)\n        );\n\n        if (!isValidCalldata) {\n          return [\n            {\n              type: StackTraceEntryType.INVALID_PARAMS_ERROR,\n              sourceReference: this._getFunctionStartSourceReference(\n                trace,\n                calledFunction\n              ),\n            },\n          ];\n        }\n      }\n\n      if (this._solidity063MaybeUnmappedRevert(trace)) {\n        const revertFrame =\n          this._solidity063GetFrameForUnmappedRevertBeforeFunction(trace);\n\n        if (revertFrame !== undefined) {\n          return [revertFrame];\n        }\n      }\n\n      return [this._getOtherErrorBeforeCalledFunctionStackTraceEntry(trace)];\n    }\n  }\n\n  private _checkNonContractCalled(\n    trace: DecodedEvmMessageTrace,\n    stacktrace: SolidityStackTrace\n  ): SolidityStackTrace | undefined {\n    if (this._isCalledNonContractAccountError(trace)) {\n      const sourceReference = this._getLastSourceReference(trace);\n\n      // We are sure this is not undefined because there was at least a call instruction\n      assertHardhatInvariant(\n        sourceReference !== undefined,\n        \"Expected source reference to be defined\"\n      );\n\n      const nonContractCalledFrame: SolidityStackTraceEntry = {\n        type: StackTraceEntryType.NONCONTRACT_ACCOUNT_CALLED_ERROR,\n        sourceReference,\n      };\n\n      return [...stacktrace, nonContractCalledFrame];\n    }\n  }\n\n  private _checkSolidity063UnmappedRevert(\n    trace: DecodedEvmMessageTrace,\n    stacktrace: SolidityStackTrace\n  ): SolidityStackTrace | undefined {\n    if (this._solidity063MaybeUnmappedRevert(trace)) {\n      const revertFrame =\n        this._solidity063GetFrameForUnmappedRevertWithinFunction(trace);\n\n      if (revertFrame !== undefined) {\n        return [...stacktrace, revertFrame];\n      }\n    }\n  }\n\n  private _checkContractTooLarge(\n    trace: DecodedEvmMessageTrace\n  ): SolidityStackTrace | undefined {\n    if (isCreateTrace(trace) && this._isContractTooLargeError(trace)) {\n      return [\n        {\n          type: StackTraceEntryType.CONTRACT_TOO_LARGE_ERROR,\n          sourceReference: this._getConstructorStartSourceReference(trace),\n        },\n      ];\n    }\n  }\n\n  private _otherExecutionErrorStacktrace(\n    trace: DecodedEvmMessageTrace,\n    stacktrace: SolidityStackTrace\n  ): SolidityStackTrace {\n    const otherExecutionErrorFrame: SolidityStackTraceEntry = {\n      type: StackTraceEntryType.OTHER_EXECUTION_ERROR,\n      sourceReference: this._getLastSourceReference(trace),\n    };\n\n    return [...stacktrace, otherExecutionErrorFrame];\n  }\n\n  // Helpers\n\n  private _fixInitialModifier(\n    trace: DecodedEvmMessageTrace,\n    stacktrace: SolidityStackTrace\n  ): SolidityStackTrace {\n    const firstEntry = stacktrace[0];\n    if (\n      firstEntry !== undefined &&\n      firstEntry.type === StackTraceEntryType.CALLSTACK_ENTRY &&\n      firstEntry.functionType === ContractFunctionType.MODIFIER\n    ) {\n      return [\n        this._getEntryBeforeInitialModifierCallstackEntry(trace),\n        ...stacktrace,\n      ];\n    }\n\n    return stacktrace;\n  }\n\n  private _isDirectLibraryCall(trace: DecodedCallMessageTrace): boolean {\n    return (\n      trace.depth === 0 && trace.bytecode.contract.type === ContractType.LIBRARY\n    );\n  }\n\n  private _getDirectLibraryCallErrorStackTrace(\n    trace: DecodedCallMessageTrace\n  ): SolidityStackTrace {\n    const func = trace.bytecode.contract.getFunctionFromSelector(\n      trace.calldata.slice(0, 4)\n    );\n\n    if (func !== undefined) {\n      return [\n        {\n          type: StackTraceEntryType.DIRECT_LIBRARY_CALL_ERROR,\n          sourceReference: this._getFunctionStartSourceReference(trace, func),\n        },\n      ];\n    }\n\n    return [\n      {\n        type: StackTraceEntryType.DIRECT_LIBRARY_CALL_ERROR,\n        sourceReference:\n          this._getContractStartWithoutFunctionSourceReference(trace),\n      },\n    ];\n  }\n\n  private _isFunctionNotPayableError(\n    trace: DecodedCallMessageTrace,\n    calledFunction: ContractFunction\n  ): boolean {\n    // This error doesn't return data\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n\n    if (trace.value <= 0n) {\n      return false;\n    }\n\n    // Libraries don't have a nonpayable check\n    if (trace.bytecode.contract.type === ContractType.LIBRARY) {\n      return false;\n    }\n\n    return calledFunction.isPayable === undefined || !calledFunction.isPayable;\n  }\n\n  private _getFunctionStartSourceReference(\n    trace: DecodedEvmMessageTrace,\n    func: ContractFunction\n  ): SourceReference {\n    return {\n      sourceName: func.location.file.sourceName,\n      sourceContent: func.location.file.content,\n      contract: trace.bytecode.contract.name,\n      function: func.name,\n      line: func.location.getStartingLineNumber(),\n      range: [\n        func.location.offset,\n        func.location.offset + func.location.length,\n      ],\n    };\n  }\n\n  private _isMissingFunctionAndFallbackError(\n    trace: DecodedCallMessageTrace,\n    calledFunction: ContractFunction | undefined\n  ): boolean {\n    // This error doesn't return data\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n\n    // the called function exists in the contract\n    if (calledFunction !== undefined) {\n      return false;\n    }\n\n    // there's a receive function and no calldata\n    if (\n      trace.calldata.length === 0 &&\n      trace.bytecode.contract.receive !== undefined\n    ) {\n      return false;\n    }\n\n    return trace.bytecode.contract.fallback === undefined;\n  }\n\n  private _emptyCalldataAndNoReceive(trace: DecodedCallMessageTrace): boolean {\n    // this only makes sense when receive functions are available\n    if (\n      semver.lt(\n        trace.bytecode.compilerVersion,\n        FIRST_SOLC_VERSION_RECEIVE_FUNCTION\n      )\n    ) {\n      return false;\n    }\n\n    return (\n      trace.calldata.length === 0 &&\n      trace.bytecode.contract.receive === undefined\n    );\n  }\n\n  private _getContractStartWithoutFunctionSourceReference(\n    trace: DecodedEvmMessageTrace\n  ): SourceReference {\n    const location = trace.bytecode.contract.location;\n    return {\n      sourceName: location.file.sourceName,\n      sourceContent: location.file.content,\n      contract: trace.bytecode.contract.name,\n      line: location.getStartingLineNumber(),\n      range: [location.offset, location.offset + location.length],\n    };\n  }\n\n  private _isFallbackNotPayableError(\n    trace: DecodedCallMessageTrace,\n    calledFunction: ContractFunction | undefined\n  ): boolean {\n    if (calledFunction !== undefined) {\n      return false;\n    }\n\n    // This error doesn't return data\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n\n    if (trace.value <= 0n) {\n      return false;\n    }\n\n    if (trace.bytecode.contract.fallback === undefined) {\n      return false;\n    }\n\n    const isPayable = trace.bytecode.contract.fallback.isPayable;\n\n    return isPayable === undefined || !isPayable;\n  }\n\n  private _getFallbackStartSourceReference(\n    trace: DecodedCallMessageTrace\n  ): SourceReference {\n    const func = trace.bytecode.contract.fallback;\n\n    if (func === undefined) {\n      throw new Error(\n        \"This shouldn't happen: trying to get fallback source reference from a contract without fallback\"\n      );\n    }\n\n    return {\n      sourceName: func.location.file.sourceName,\n      sourceContent: func.location.file.content,\n      contract: trace.bytecode.contract.name,\n      function: FALLBACK_FUNCTION_NAME,\n      line: func.location.getStartingLineNumber(),\n      range: [\n        func.location.offset,\n        func.location.offset + func.location.length,\n      ],\n    };\n  }\n\n  private _isConstructorNotPayableError(\n    trace: DecodedCreateMessageTrace\n  ): boolean {\n    // This error doesn't return data\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n\n    const constructor = trace.bytecode.contract.constructorFunction;\n\n    // This function is only matters with contracts that have constructors defined. The ones that\n    // don't are abstract contracts, or their constructor doesn't take any argument.\n    if (constructor === undefined) {\n      return false;\n    }\n\n    return (\n      trace.value > 0n &&\n      (constructor.isPayable === undefined || !constructor.isPayable)\n    );\n  }\n\n  /**\n   * Returns a source reference pointing to the constructor if it exists, or to the contract\n   * otherwise.\n   */\n  private _getConstructorStartSourceReference(\n    trace: DecodedCreateMessageTrace\n  ): SourceReference {\n    const contract = trace.bytecode.contract;\n    const constructor = contract.constructorFunction;\n\n    const line =\n      constructor !== undefined\n        ? constructor.location.getStartingLineNumber()\n        : contract.location.getStartingLineNumber();\n\n    return {\n      sourceName: contract.location.file.sourceName,\n      sourceContent: contract.location.file.content,\n      contract: contract.name,\n      function: CONSTRUCTOR_FUNCTION_NAME,\n      line,\n      range: [\n        contract.location.offset,\n        contract.location.offset + contract.location.length,\n      ],\n    };\n  }\n\n  private _isConstructorInvalidArgumentsError(\n    trace: DecodedCreateMessageTrace\n  ): boolean {\n    // This error doesn't return data\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n\n    const contract = trace.bytecode.contract;\n    const constructor = contract.constructorFunction;\n\n    // This function is only matters with contracts that have constructors defined. The ones that\n    // don't are abstract contracts, or their constructor doesn't take any argument.\n    if (constructor === undefined) {\n      return false;\n    }\n\n    if (\n      semver.lt(\n        trace.bytecode.compilerVersion,\n        FIRST_SOLC_VERSION_CREATE_PARAMS_VALIDATION\n      )\n    ) {\n      return false;\n    }\n\n    const lastStep = trace.steps[trace.steps.length - 1];\n    if (!isEvmStep(lastStep)) {\n      return false;\n    }\n\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n    if (lastInst.opcode !== Opcode.REVERT || lastInst.location !== undefined) {\n      return false;\n    }\n\n    let hasReadDeploymentCodeSize = false;\n\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\n    for (let stepIndex = 0; stepIndex < trace.steps.length; stepIndex++) {\n      const step = trace.steps[stepIndex];\n      if (!isEvmStep(step)) {\n        return false;\n      }\n\n      const inst = trace.bytecode.getInstruction(step.pc);\n\n      if (\n        inst.location !== undefined &&\n        !contract.location.equals(inst.location) &&\n        !constructor.location.equals(inst.location)\n      ) {\n        return false;\n      }\n\n      if (inst.opcode === Opcode.CODESIZE && isCreateTrace(trace)) {\n        hasReadDeploymentCodeSize = true;\n      }\n    }\n\n    return hasReadDeploymentCodeSize;\n  }\n\n  private _getEntryBeforeInitialModifierCallstackEntry(\n    trace: DecodedEvmMessageTrace\n  ): SolidityStackTraceEntry {\n    if (isDecodedCreateTrace(trace)) {\n      return {\n        type: StackTraceEntryType.CALLSTACK_ENTRY,\n        sourceReference: this._getConstructorStartSourceReference(trace),\n        functionType: ContractFunctionType.CONSTRUCTOR,\n      };\n    }\n\n    const calledFunction = trace.bytecode.contract.getFunctionFromSelector(\n      trace.calldata.slice(0, 4)\n    );\n\n    if (calledFunction !== undefined) {\n      return {\n        type: StackTraceEntryType.CALLSTACK_ENTRY,\n        sourceReference: this._getFunctionStartSourceReference(\n          trace,\n          calledFunction\n        ),\n        functionType: ContractFunctionType.FUNCTION,\n      };\n    }\n\n    // If it failed or made a call from within a modifier, and the selector doesn't match\n    // any function, it must have a fallback.\n    return {\n      type: StackTraceEntryType.CALLSTACK_ENTRY,\n      sourceReference: this._getFallbackStartSourceReference(trace),\n      functionType: ContractFunctionType.FALLBACK,\n    };\n  }\n\n  private _getLastSourceReference(\n    trace: DecodedEvmMessageTrace\n  ): SourceReference | undefined {\n    for (let i = trace.steps.length - 1; i >= 0; i--) {\n      const step = trace.steps[i];\n      if (!isEvmStep(step)) {\n        continue;\n      }\n\n      const inst = trace.bytecode.getInstruction(step.pc);\n\n      if (inst.location === undefined) {\n        continue;\n      }\n\n      const sourceReference = sourceLocationToSourceReference(\n        trace.bytecode,\n        inst.location\n      );\n\n      if (sourceReference !== undefined) {\n        return sourceReference;\n      }\n    }\n\n    return undefined;\n  }\n\n  private _hasFailedInsideTheFallbackFunction(\n    trace: DecodedCallMessageTrace\n  ): boolean {\n    const contract = trace.bytecode.contract;\n\n    if (contract.fallback === undefined) {\n      return false;\n    }\n\n    return this._hasFailedInsideFunction(trace, contract.fallback);\n  }\n\n  private _hasFailedInsideTheReceiveFunction(\n    trace: DecodedCallMessageTrace\n  ): boolean {\n    const contract = trace.bytecode.contract;\n\n    if (contract.receive === undefined) {\n      return false;\n    }\n\n    return this._hasFailedInsideFunction(trace, contract.receive);\n  }\n\n  private _hasFailedInsideFunction(\n    trace: DecodedCallMessageTrace,\n    func: ContractFunction\n  ) {\n    const lastStep = trace.steps[trace.steps.length - 1] as EvmStep;\n    const lastInstruction = trace.bytecode.getInstruction(lastStep.pc);\n\n    return (\n      lastInstruction.location !== undefined &&\n      lastInstruction.opcode === Opcode.REVERT &&\n      func.location.contains(lastInstruction.location)\n    );\n  }\n\n  private _instructionWithinFunctionToRevertStackTraceEntry(\n    trace: DecodedEvmMessageTrace,\n    inst: Instruction\n  ): RevertErrorStackTraceEntry {\n    const sourceReference = sourceLocationToSourceReference(\n      trace.bytecode,\n      inst.location\n    );\n    assertHardhatInvariant(\n      sourceReference !== undefined,\n      \"Expected source reference to be defined\"\n    );\n\n    return {\n      type: StackTraceEntryType.REVERT_ERROR,\n      sourceReference,\n      message: new ReturnData(trace.returnData),\n      isInvalidOpcodeError: inst.opcode === Opcode.INVALID,\n    };\n  }\n\n  private _instructionWithinFunctionToUnmappedSolc063RevertErrorStackTraceEntry(\n    trace: DecodedEvmMessageTrace,\n    inst: Instruction\n  ): UnmappedSolc063RevertErrorStackTraceEntry {\n    const sourceReference = sourceLocationToSourceReference(\n      trace.bytecode,\n      inst.location\n    );\n\n    return {\n      type: StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR,\n      sourceReference,\n    };\n  }\n\n  private _instructionWithinFunctionToPanicStackTraceEntry(\n    trace: DecodedEvmMessageTrace,\n    inst: Instruction,\n    errorCode: bigint\n  ): PanicErrorStackTraceEntry {\n    const lastSourceReference = this._getLastSourceReference(trace);\n    return {\n      type: StackTraceEntryType.PANIC_ERROR,\n      sourceReference:\n        sourceLocationToSourceReference(trace.bytecode, inst.location) ??\n        lastSourceReference,\n      errorCode,\n    };\n  }\n\n  private _instructionWithinFunctionToCustomErrorStackTraceEntry(\n    trace: DecodedEvmMessageTrace,\n    inst: Instruction,\n    message: string\n  ): CustomErrorStackTraceEntry {\n    const lastSourceReference = this._getLastSourceReference(trace);\n\n    assertHardhatInvariant(\n      lastSourceReference !== undefined,\n      \"Expected last source reference to be defined\"\n    );\n\n    return {\n      type: StackTraceEntryType.CUSTOM_ERROR,\n      sourceReference:\n        sourceLocationToSourceReference(trace.bytecode, inst.location) ??\n        lastSourceReference,\n      message,\n    };\n  }\n\n  private _solidity063MaybeUnmappedRevert(trace: DecodedEvmMessageTrace) {\n    if (trace.steps.length === 0) {\n      return false;\n    }\n\n    const lastStep = trace.steps[trace.steps.length - 1];\n    if (!isEvmStep(lastStep)) {\n      return false;\n    }\n\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n\n    return (\n      semver.satisfies(\n        trace.bytecode.compilerVersion,\n        `^${FIRST_SOLC_VERSION_WITH_UNMAPPED_REVERTS}`\n      ) && lastInst.opcode === Opcode.REVERT\n    );\n  }\n\n  // Solidity 0.6.3 unmapped reverts special handling\n  // For more info: https://github.com/ethereum/solidity/issues/9006\n  private _solidity063GetFrameForUnmappedRevertBeforeFunction(\n    trace: DecodedCallMessageTrace\n  ) {\n    let revertFrame =\n      this._solidity063GetFrameForUnmappedRevertWithinFunction(trace);\n\n    if (\n      revertFrame === undefined ||\n      revertFrame.sourceReference === undefined\n    ) {\n      if (\n        trace.bytecode.contract.receive === undefined ||\n        trace.calldata.length > 0\n      ) {\n        if (trace.bytecode.contract.fallback !== undefined) {\n          // Failed within the fallback\n          const location = trace.bytecode.contract.fallback.location;\n          revertFrame = {\n            type: StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR,\n            sourceReference: {\n              contract: trace.bytecode.contract.name,\n              function: FALLBACK_FUNCTION_NAME,\n              sourceName: location.file.sourceName,\n              sourceContent: location.file.content,\n              line: location.getStartingLineNumber(),\n              range: [location.offset, location.offset + location.length],\n            },\n          };\n\n          this._solidity063CorrectLineNumber(revertFrame);\n        }\n      } else {\n        // Failed within the receive function\n        const location = trace.bytecode.contract.receive.location;\n        revertFrame = {\n          type: StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR,\n          sourceReference: {\n            contract: trace.bytecode.contract.name,\n            function: RECEIVE_FUNCTION_NAME,\n            sourceName: location.file.sourceName,\n            sourceContent: location.file.content,\n            line: location.getStartingLineNumber(),\n            range: [location.offset, location.offset + location.length],\n          },\n        };\n\n        this._solidity063CorrectLineNumber(revertFrame);\n      }\n    }\n    return revertFrame;\n  }\n\n  private _getOtherErrorBeforeCalledFunctionStackTraceEntry(\n    trace: DecodedCallMessageTrace\n  ): OtherExecutionErrorStackTraceEntry {\n    return {\n      type: StackTraceEntryType.OTHER_EXECUTION_ERROR,\n      sourceReference:\n        this._getContractStartWithoutFunctionSourceReference(trace),\n    };\n  }\n\n  private _isCalledNonContractAccountError(\n    trace: DecodedEvmMessageTrace\n  ): boolean {\n    // We could change this to checking that the last valid location maps to a call, but\n    // it's way more complex as we need to get the ast node from that location.\n\n    const lastIndex = this._getLastInstructionWithValidLocationStepIndex(trace);\n    if (lastIndex === undefined || lastIndex === 0) {\n      return false;\n    }\n\n    const lastStep = trace.steps[lastIndex] as EvmStep; // We know this is an EVM step\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n    if (lastInst.opcode !== Opcode.ISZERO) {\n      return false;\n    }\n\n    const prevStep = trace.steps[lastIndex - 1] as EvmStep; // We know this is an EVM step\n    const prevInst = trace.bytecode.getInstruction(prevStep.pc);\n    return prevInst.opcode === Opcode.EXTCODESIZE;\n  }\n\n  private _solidity063GetFrameForUnmappedRevertWithinFunction(\n    trace: DecodedEvmMessageTrace\n  ): UnmappedSolc063RevertErrorStackTraceEntry | undefined {\n    // If we are within a function there's a last valid location. It may\n    // be the entire contract.\n    const prevInst = this._getLastInstructionWithValidLocation(trace);\n    const lastStep = trace.steps[trace.steps.length - 1] as EvmStep;\n    const nextInstPc = lastStep.pc + 1;\n    const hasNextInst = trace.bytecode.hasInstruction(nextInstPc);\n\n    if (hasNextInst) {\n      const nextInst = trace.bytecode.getInstruction(nextInstPc);\n      const prevLoc = prevInst?.location;\n      const nextLoc = nextInst.location;\n      const prevFunc = prevLoc?.getContainingFunction();\n      const nextFunc = nextLoc?.getContainingFunction();\n\n      // This is probably a require. This means that we have the exact\n      // line, but the stack trace may be degraded (e.g. missing our\n      // synthetic call frames when failing in a modifier) so we still\n      // add this frame as UNMAPPED_SOLC_0_6_3_REVERT_ERROR\n      if (\n        prevFunc !== undefined &&\n        nextLoc !== undefined &&\n        prevLoc !== undefined &&\n        prevLoc.equals(nextLoc)\n      ) {\n        return this._instructionWithinFunctionToUnmappedSolc063RevertErrorStackTraceEntry(\n          trace,\n          nextInst\n        );\n      }\n\n      let revertFrame: UnmappedSolc063RevertErrorStackTraceEntry | undefined;\n\n      // If the previous and next location don't match, we try to use the\n      // previous one if it's inside a function, otherwise we use the next one\n      if (prevFunc !== undefined && prevInst !== undefined) {\n        revertFrame =\n          this._instructionWithinFunctionToUnmappedSolc063RevertErrorStackTraceEntry(\n            trace,\n            prevInst\n          );\n      } else if (nextFunc !== undefined) {\n        revertFrame =\n          this._instructionWithinFunctionToUnmappedSolc063RevertErrorStackTraceEntry(\n            trace,\n            nextInst\n          );\n      }\n\n      if (revertFrame !== undefined) {\n        this._solidity063CorrectLineNumber(revertFrame);\n      }\n\n      return revertFrame;\n    }\n\n    if (isCreateTrace(trace) && prevInst !== undefined) {\n      // Solidity is smart enough to stop emitting extra instructions after\n      // an unconditional revert happens in a constructor. If this is the case\n      // we just return a special error.\n      const constructorRevertFrame: UnmappedSolc063RevertErrorStackTraceEntry =\n        this._instructionWithinFunctionToUnmappedSolc063RevertErrorStackTraceEntry(\n          trace,\n          prevInst\n        );\n\n      // When the latest instruction is not within a function we need\n      // some default sourceReference to show to the user\n      if (constructorRevertFrame.sourceReference === undefined) {\n        const location = trace.bytecode.contract.location;\n        const defaultSourceReference: SourceReference = {\n          function: CONSTRUCTOR_FUNCTION_NAME,\n          contract: trace.bytecode.contract.name,\n          sourceName: location.file.sourceName,\n          sourceContent: location.file.content,\n          line: location.getStartingLineNumber(),\n          range: [location.offset, location.offset + location.length],\n        };\n\n        if (trace.bytecode.contract.constructorFunction !== undefined) {\n          defaultSourceReference.line =\n            trace.bytecode.contract.constructorFunction.location.getStartingLineNumber();\n        }\n\n        constructorRevertFrame.sourceReference = defaultSourceReference;\n      } else {\n        this._solidity063CorrectLineNumber(constructorRevertFrame);\n      }\n\n      return constructorRevertFrame;\n    }\n\n    if (prevInst !== undefined) {\n      // We may as well just be in a function or modifier and just happen\n      // to be at the last instruction of the runtime bytecode.\n      // In this case we just return whatever the last mapped intruction\n      // points to.\n      const latestInstructionRevertFrame: UnmappedSolc063RevertErrorStackTraceEntry =\n        this._instructionWithinFunctionToUnmappedSolc063RevertErrorStackTraceEntry(\n          trace,\n          prevInst\n        );\n\n      if (latestInstructionRevertFrame.sourceReference !== undefined) {\n        this._solidity063CorrectLineNumber(latestInstructionRevertFrame);\n      }\n      return latestInstructionRevertFrame;\n    }\n  }\n\n  private _isContractTooLargeError(trace: DecodedCreateMessageTrace) {\n    return trace.exit.kind === ExitCode.CODESIZE_EXCEEDS_MAXIMUM;\n  }\n\n  private _solidity063CorrectLineNumber(\n    revertFrame: UnmappedSolc063RevertErrorStackTraceEntry\n  ) {\n    if (revertFrame.sourceReference === undefined) {\n      return;\n    }\n\n    const lines = revertFrame.sourceReference.sourceContent.split(\"\\n\");\n\n    const currentLine = lines[revertFrame.sourceReference.line - 1];\n\n    if (currentLine.includes(\"require\") || currentLine.includes(\"revert\")) {\n      return;\n    }\n\n    const nextLines = lines.slice(revertFrame.sourceReference.line);\n    const firstNonEmptyLine = nextLines.findIndex((l) => l.trim() !== \"\");\n\n    if (firstNonEmptyLine === -1) {\n      return;\n    }\n\n    const nextLine = nextLines[firstNonEmptyLine];\n\n    if (nextLine.includes(\"require\") || nextLine.includes(\"revert\")) {\n      revertFrame.sourceReference.line += 1 + firstNonEmptyLine;\n    }\n  }\n\n  private _getLastInstructionWithValidLocationStepIndex(\n    trace: DecodedEvmMessageTrace\n  ): number | undefined {\n    for (let i = trace.steps.length - 1; i >= 0; i--) {\n      const step = trace.steps[i];\n\n      if (!isEvmStep(step)) {\n        return undefined;\n      }\n\n      const inst = trace.bytecode.getInstruction(step.pc);\n\n      if (inst.location !== undefined) {\n        return i;\n      }\n    }\n\n    return undefined;\n  }\n\n  private _getLastInstructionWithValidLocation(\n    trace: DecodedEvmMessageTrace\n  ): Instruction | undefined {\n    const lastLocationIndex =\n      this._getLastInstructionWithValidLocationStepIndex(trace);\n\n    if (lastLocationIndex === undefined) {\n      return undefined;\n    }\n\n    const lastLocationStep = trace.steps[lastLocationIndex];\n    if (isEvmStep(lastLocationStep)) {\n      const lastInstructionWithLocation = trace.bytecode.getInstruction(\n        lastLocationStep.pc\n      );\n      return lastInstructionWithLocation;\n    }\n\n    return undefined;\n  }\n\n  private _callInstructionToCallFailedToExecuteStackTraceEntry(\n    bytecode: Bytecode,\n    callInst: Instruction\n  ): CallFailedErrorStackTraceEntry {\n    const sourceReference = sourceLocationToSourceReference(\n      bytecode,\n      callInst.location\n    );\n    assertHardhatInvariant(\n      sourceReference !== undefined,\n      \"Expected source reference to be defined\"\n    );\n\n    // Calls only happen within functions\n    return {\n      type: StackTraceEntryType.CALL_FAILED_ERROR,\n      sourceReference,\n    };\n  }\n\n  private _getEntryBeforeFailureInModifier(\n    trace: DecodedEvmMessageTrace,\n    functionJumpdests: Instruction[]\n  ): CallstackEntryStackTraceEntry | InternalFunctionCallStackEntry {\n    // If there's a jumpdest, this modifier belongs to the last function that it represents\n    if (functionJumpdests.length > 0) {\n      return instructionToCallstackStackTraceEntry(\n        trace.bytecode,\n        functionJumpdests[functionJumpdests.length - 1]\n      );\n    }\n\n    // This function is only called after we jumped into the initial function in call traces, so\n    // there should always be at least a function jumpdest.\n    if (!isDecodedCreateTrace(trace)) {\n      throw new Error(\n        \"This shouldn't happen: a call trace has no functionJumpdest but has already jumped into a function\"\n      );\n    }\n\n    // If there's no jump dest, we point to the constructor.\n    return {\n      type: StackTraceEntryType.CALLSTACK_ENTRY,\n      sourceReference: this._getConstructorStartSourceReference(trace),\n      functionType: ContractFunctionType.CONSTRUCTOR,\n    };\n  }\n\n  private _failsRightAfterCall(\n    trace: DecodedEvmMessageTrace,\n    callSubtraceStepIndex: number\n  ): boolean {\n    const lastStep = trace.steps[trace.steps.length - 1];\n    if (!isEvmStep(lastStep)) {\n      return false;\n    }\n\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n    if (lastInst.opcode !== Opcode.REVERT) {\n      return false;\n    }\n\n    const callOpcodeStep = trace.steps[callSubtraceStepIndex - 1] as EvmStep;\n    const callInst = trace.bytecode.getInstruction(callOpcodeStep.pc);\n\n    // Calls are always made from within functions\n    assertHardhatInvariant(\n      callInst.location !== undefined,\n      \"Expected call instruction location to be defined\"\n    );\n\n    return this._isLastLocation(\n      trace,\n      callSubtraceStepIndex + 1,\n      callInst.location\n    );\n  }\n\n  private _isCallFailedError(\n    trace: DecodedEvmMessageTrace,\n    instIndex: number,\n    callInstruction: Instruction\n  ): boolean {\n    const callLocation = callInstruction.location;\n\n    // Calls are always made from within functions\n    assertHardhatInvariant(\n      callLocation !== undefined,\n      \"Expected call location to be defined\"\n    );\n\n    return this._isLastLocation(trace, instIndex, callLocation);\n  }\n\n  private _isLastLocation(\n    trace: DecodedEvmMessageTrace,\n    fromStep: number,\n    location: SourceLocation\n  ): boolean {\n    for (let i = fromStep; i < trace.steps.length; i++) {\n      const step = trace.steps[i];\n\n      if (!isEvmStep(step)) {\n        return false;\n      }\n\n      const stepInst = trace.bytecode.getInstruction(step.pc);\n\n      if (stepInst.location === undefined) {\n        continue;\n      }\n\n      if (!location.equals(stepInst.location)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private _isSubtraceErrorPropagated(\n    trace: DecodedEvmMessageTrace,\n    callSubtraceStepIndex: number\n  ): boolean {\n    const call = trace.steps[callSubtraceStepIndex] as MessageTrace;\n\n    if (!equalsBytes(trace.returnData, call.returnData)) {\n      return false;\n    }\n\n    if (\n      trace.exit.kind === ExitCode.OUT_OF_GAS &&\n      call.exit.kind === ExitCode.OUT_OF_GAS\n    ) {\n      return true;\n    }\n\n    // If the return data is not empty, and it's still the same, we assume it\n    // is being propagated\n    if (trace.returnData.length > 0) {\n      return true;\n    }\n\n    return this._failsRightAfterCall(trace, callSubtraceStepIndex);\n  }\n\n  private _isProxyErrorPropagated(\n    trace: DecodedEvmMessageTrace,\n    callSubtraceStepIndex: number\n  ): boolean {\n    if (!isDecodedCallTrace(trace)) {\n      return false;\n    }\n\n    const callStep = trace.steps[callSubtraceStepIndex - 1];\n    if (!isEvmStep(callStep)) {\n      return false;\n    }\n\n    const callInst = trace.bytecode.getInstruction(callStep.pc);\n    if (callInst.opcode !== Opcode.DELEGATECALL) {\n      return false;\n    }\n\n    const subtrace = trace.steps[callSubtraceStepIndex];\n    if (isEvmStep(subtrace)) {\n      return false;\n    }\n\n    if (isPrecompileTrace(subtrace)) {\n      return false;\n    }\n\n    // If we can't recognize the implementation we'd better don't consider it as such\n    if (subtrace.bytecode === undefined) {\n      return false;\n    }\n\n    if (subtrace.bytecode.contract.type === ContractType.LIBRARY) {\n      return false;\n    }\n\n    if (!equalsBytes(trace.returnData, subtrace.returnData)) {\n      return false;\n    }\n\n    for (let i = callSubtraceStepIndex + 1; i < trace.steps.length; i++) {\n      const step = trace.steps[i];\n      if (!isEvmStep(step)) {\n        return false;\n      }\n\n      const inst = trace.bytecode.getInstruction(step.pc);\n\n      // All the remaining locations should be valid, as they are part of the inline asm\n      if (inst.location === undefined) {\n        return false;\n      }\n\n      if (\n        inst.jumpType === JumpType.INTO_FUNCTION ||\n        inst.jumpType === JumpType.OUTOF_FUNCTION\n      ) {\n        return false;\n      }\n    }\n\n    const lastStep = trace.steps[trace.steps.length - 1] as EvmStep;\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n\n    return lastInst.opcode === Opcode.REVERT;\n  }\n\n  private _isContractCallRunOutOfGasError(\n    trace: DecodedEvmMessageTrace,\n    callStepIndex: number\n  ): boolean {\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n\n    if (trace.exit.kind !== ExitCode.REVERT) {\n      return false;\n    }\n\n    const call = trace.steps[callStepIndex] as MessageTrace;\n    if (call.exit.kind !== ExitCode.OUT_OF_GAS) {\n      return false;\n    }\n\n    return this._failsRightAfterCall(trace, callStepIndex);\n  }\n\n  private _isPanicReturnData(returnData: Uint8Array): boolean {\n    return new ReturnData(returnData).isPanicReturnData();\n  }\n}\n\nexport function instructionToCallstackStackTraceEntry(\n  bytecode: Bytecode,\n  inst: Instruction\n): CallstackEntryStackTraceEntry | InternalFunctionCallStackEntry {\n  // This means that a jump is made from within an internal solc function.\n  // These are normally made from yul code, so they don't map to any Solidity\n  // function\n  if (inst.location === undefined) {\n    const location = bytecode.contract.location;\n    return {\n      type: StackTraceEntryType.INTERNAL_FUNCTION_CALLSTACK_ENTRY,\n      pc: inst.pc,\n      sourceReference: {\n        sourceName: bytecode.contract.location.file.sourceName,\n        sourceContent: bytecode.contract.location.file.content,\n        contract: bytecode.contract.name,\n        function: undefined,\n        line: bytecode.contract.location.getStartingLineNumber(),\n        range: [location.offset, location.offset + location.length],\n      },\n    };\n  }\n\n  const func = inst.location?.getContainingFunction();\n\n  if (func !== undefined) {\n    const sourceReference = sourceLocationToSourceReference(\n      bytecode,\n      inst.location\n    );\n    assertHardhatInvariant(\n      sourceReference !== undefined,\n      \"Expected source reference to be defined\"\n    );\n\n    return {\n      type: StackTraceEntryType.CALLSTACK_ENTRY,\n      sourceReference,\n      functionType: func.type,\n    };\n  }\n\n  assertHardhatInvariant(\n    inst.location !== undefined,\n    \"Expected instruction location to be defined\"\n  );\n\n  return {\n    type: StackTraceEntryType.CALLSTACK_ENTRY,\n    sourceReference: {\n      function: undefined,\n      contract: bytecode.contract.name,\n      sourceName: inst.location.file.sourceName,\n      sourceContent: inst.location.file.content,\n      line: inst.location.getStartingLineNumber(),\n      range: [\n        inst.location.offset,\n        inst.location.offset + inst.location.length,\n      ],\n    },\n    functionType: ContractFunctionType.FUNCTION,\n  };\n}\n\nfunction sourceLocationToSourceReference(\n  bytecode: Bytecode,\n  location?: SourceLocation\n): SourceReference | undefined {\n  if (location === undefined) {\n    return undefined;\n  }\n\n  const func = location.getContainingFunction();\n\n  if (func === undefined) {\n    return undefined;\n  }\n\n  let funcName = func.name;\n\n  if (func.type === ContractFunctionType.CONSTRUCTOR) {\n    funcName = CONSTRUCTOR_FUNCTION_NAME;\n  } else if (func.type === ContractFunctionType.FALLBACK) {\n    funcName = FALLBACK_FUNCTION_NAME;\n  } else if (func.type === ContractFunctionType.RECEIVE) {\n    funcName = RECEIVE_FUNCTION_NAME;\n  }\n\n  return {\n    function: funcName,\n    contract:\n      func.type === ContractFunctionType.FREE_FUNCTION\n        ? undefined\n        : bytecode.contract.name,\n    sourceName: func.location.file.sourceName,\n    sourceContent: func.location.file.content,\n    line: location.getStartingLineNumber(),\n    range: [location.offset, location.offset + location.length],\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}