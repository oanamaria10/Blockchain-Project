{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbiHelpers = void 0;\nconst abi = __importStar(require(\"@ethersproject/abi\"));\nclass AbiHelpers {\n  /**\n   * Try to compute the selector for the function/event/error\n   * with the given name and param types. Return undefined\n   * if it cannot do it. This can happen if some ParamType is\n   * not understood by @ethersproject/abi\n   */\n  static computeSelector(name, inputs) {\n    try {\n      const fragment = abi.FunctionFragment.from({\n        type: \"function\",\n        constant: true,\n        name,\n        inputs: inputs.map(i => abi.ParamType.from(i))\n      });\n      const selectorHex = abi.Interface.getSighash(fragment);\n      return Buffer.from(selectorHex.slice(2), \"hex\");\n    } catch {\n      return;\n    }\n  }\n  static isValidCalldata(inputs, calldata) {\n    try {\n      abi.defaultAbiCoder.decode(inputs, calldata);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n  static formatValues(values) {\n    return values.map(x => AbiHelpers._formatValue(x)).join(\", \");\n  }\n  static _formatValue(value) {\n    // print nested values as [value1, value2, ...]\n    if (Array.isArray(value)) {\n      return `[${value.map(v => AbiHelpers._formatValue(v)).join(\", \")}]`;\n    }\n    // surround string values with quotes\n    if (typeof value === \"string\") {\n      return `\"${value}\"`;\n    }\n    return value.toString();\n  }\n}\nexports.AbiHelpers = AbiHelpers;","map":{"version":3,"names":["abi","__importStar","require","AbiHelpers","computeSelector","name","inputs","fragment","FunctionFragment","from","type","constant","map","i","ParamType","selectorHex","Interface","getSighash","Buffer","slice","isValidCalldata","calldata","defaultAbiCoder","decode","formatValues","values","x","_formatValue","join","value","Array","isArray","v","toString","exports"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\internal\\util\\abi-helpers.ts"],"sourcesContent":["import * as abi from \"@ethersproject/abi\";\n\nexport class AbiHelpers {\n  /**\n   * Try to compute the selector for the function/event/error\n   * with the given name and param types. Return undefined\n   * if it cannot do it. This can happen if some ParamType is\n   * not understood by @ethersproject/abi\n   */\n  public static computeSelector(\n    name: string,\n    inputs: any[]\n  ): Uint8Array | undefined {\n    try {\n      const fragment = abi.FunctionFragment.from({\n        type: \"function\",\n        constant: true,\n        name,\n        inputs: inputs.map((i) => abi.ParamType.from(i)),\n      });\n      const selectorHex = abi.Interface.getSighash(fragment);\n\n      return Buffer.from(selectorHex.slice(2), \"hex\");\n    } catch {\n      return;\n    }\n  }\n\n  public static isValidCalldata(inputs: any[], calldata: Uint8Array): boolean {\n    try {\n      abi.defaultAbiCoder.decode(inputs, calldata);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  public static formatValues(values: any[]): string {\n    return values.map((x) => AbiHelpers._formatValue(x)).join(\", \");\n  }\n\n  private static _formatValue(value: any): string {\n    // print nested values as [value1, value2, ...]\n    if (Array.isArray(value)) {\n      return `[${value.map((v) => AbiHelpers._formatValue(v)).join(\", \")}]`;\n    }\n\n    // surround string values with quotes\n    if (typeof value === \"string\") {\n      return `\"${value}\"`;\n    }\n\n    return value.toString();\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAAA,GAAA,GAAAC,YAAA,CAAAC,OAAA;AAEA,MAAaC,UAAU;EACrB;;;;;;EAMO,OAAOC,eAAeA,CAC3BC,IAAY,EACZC,MAAa;IAEb,IAAI;MACF,MAAMC,QAAQ,GAAGP,GAAG,CAACQ,gBAAgB,CAACC,IAAI,CAAC;QACzCC,IAAI,EAAE,UAAU;QAChBC,QAAQ,EAAE,IAAI;QACdN,IAAI;QACJC,MAAM,EAAEA,MAAM,CAACM,GAAG,CAAEC,CAAC,IAAKb,GAAG,CAACc,SAAS,CAACL,IAAI,CAACI,CAAC,CAAC;OAChD,CAAC;MACF,MAAME,WAAW,GAAGf,GAAG,CAACgB,SAAS,CAACC,UAAU,CAACV,QAAQ,CAAC;MAEtD,OAAOW,MAAM,CAACT,IAAI,CAACM,WAAW,CAACI,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC;KAChD,CAAC,MAAM;MACN;;EAEJ;EAEO,OAAOC,eAAeA,CAACd,MAAa,EAAEe,QAAoB;IAC/D,IAAI;MACFrB,GAAG,CAACsB,eAAe,CAACC,MAAM,CAACjB,MAAM,EAAEe,QAAQ,CAAC;MAC5C,OAAO,IAAI;KACZ,CAAC,MAAM;MACN,OAAO,KAAK;;EAEhB;EAEO,OAAOG,YAAYA,CAACC,MAAa;IACtC,OAAOA,MAAM,CAACb,GAAG,CAAEc,CAAC,IAAKvB,UAAU,CAACwB,YAAY,CAACD,CAAC,CAAC,CAAC,CAACE,IAAI,CAAC,IAAI,CAAC;EACjE;EAEQ,OAAOD,YAAYA,CAACE,KAAU;IACpC;IACA,IAAIC,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,EAAE;MACxB,OAAO,IAAIA,KAAK,CAACjB,GAAG,CAAEoB,CAAC,IAAK7B,UAAU,CAACwB,YAAY,CAACK,CAAC,CAAC,CAAC,CAACJ,IAAI,CAAC,IAAI,CAAC,GAAG;;IAGvE;IACA,IAAI,OAAOC,KAAK,KAAK,QAAQ,EAAE;MAC7B,OAAO,IAAIA,KAAK,GAAG;;IAGrB,OAAOA,KAAK,CAACI,QAAQ,EAAE;EACzB;;AAnDFC,OAAA,CAAA/B,UAAA,GAAAA,UAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}