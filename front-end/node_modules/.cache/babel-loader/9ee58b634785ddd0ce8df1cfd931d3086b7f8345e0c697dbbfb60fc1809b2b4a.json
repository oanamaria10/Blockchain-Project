{"ast":null,"code":"import * as API from '@ucanto/interface';\n\n/**\n * @template {API.SignerImporter} L\n * @template {API.SignerImporter} R\n * @param {L} left\n * @param {R} right\n * @returns {API.CompositeImporter<[L, R]>}\n */\nexport const or = (left, right) => new Importer([left, right]);\n\n/**\n * @template {[API.SignerImporter, ...API.SignerImporter[]]} Importers\n * @implements {API.CompositeImporter<Importers>}\n */\nclass Importer {\n  /**\n   * @param {Importers} variants\n   */\n  constructor(variants) {\n    this.variants = variants;\n    this.from = create(variants);\n  }\n\n  /**\n   * @template {API.SignerImporter} Other\n   * @param {Other} other\n   * @returns {API.CompositeImporter<[Other, ...Importers]>}\n   */\n  or(other) {\n    return new Importer([other, ...this.variants]);\n  }\n}\n\n/**\n * @template {[API.SignerImporter, ...API.SignerImporter[]]} Importers\n * @param {Importers} importers\n */\nconst create = importers => {\n  /**\n   * @template {API.DID} ID - DID that can be imported, which may be a type union.\n   * @template {API.SigAlg} Alg - Multicodec code corresponding to signature algorithm.\n   * @param {API.SignerArchive<ID, Alg>} archive\n   * @returns {API.Signer<ID, Alg>}\n   */\n  const from = archive => {\n    if (archive.id.startsWith('did:key:')) {\n      return /** @type {API.Signer<ID, Alg>} */importWith(archive, importers);\n    } else {\n      for (const [name, key] of Object.entries(archive.keys)) {\n        const id = /** @type {API.DIDKey} */name;\n        const signer = /** @type {API.Signer<API.DIDKey, Alg>} */\n        importWith({\n          id,\n          keys: {\n            [id]: key\n          }\n        }, importers);\n        return signer.withDID(archive.id);\n      }\n      throw new Error(`Archive ${archive.id} contains no keys`);\n    }\n  };\n  return /** @type {API.Intersection<Importers[number]['from']>} */from;\n};\n\n/**\n * @param {API.SignerArchive} archive\n * @param {API.SignerImporter[]} importers\n * @returns {API.Signer}\n */\nconst importWith = (archive, importers) => {\n  for (const importer of importers) {\n    try {\n      return importer.from(archive);\n    } catch (_) {}\n  }\n  throw new Error(`Unsupported signer`);\n};\n/**\n * @template {number} Code\n * @template {API.DID} ID\n * @param {API.Signer<API.DID<'key'>, Code>} signer\n * @param {ID} id\n * @returns {API.Signer<ID, Code>}\n */\nexport const withDID = ({\n  signer,\n  verifier\n}, id) => new SignerWithDID(signer, verifier.withDID(id));\n\n/**\n * @template {API.DID} ID\n * @template {number} Code\n * @implements {API.Signer<ID, Code>}\n */\nclass SignerWithDID {\n  /**\n   * @param {API.Signer<API.DID<'key'>, Code>} key\n   * @param {API.Verifier<ID, Code>} verifier\n   */\n  constructor(key, verifier) {\n    this.key = key;\n    this.verifier = verifier;\n  }\n  /** @type {API.Signer<ID, Code>} */\n  get signer() {\n    return this;\n  }\n  get signatureAlgorithm() {\n    return this.key.signatureAlgorithm;\n  }\n  get signatureCode() {\n    return this.key.signatureCode;\n  }\n\n  /**\n   * @returns {ID}\n   */\n  did() {\n    return this.verifier.did();\n  }\n  toDIDKey() {\n    return this.verifier.toDIDKey();\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   */\n  withDID(id) {\n    return withDID(this.key, id);\n  }\n\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   */\n  sign(payload) {\n    return this.key.sign(payload);\n  }\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, Code>} signature\n   */\n  verify(payload, signature) {\n    return this.verifier.verify(payload, signature);\n  }\n  toArchive() {\n    const {\n      keys\n    } = this.key.toArchive();\n    return {\n      id: this.did(),\n      keys\n    };\n  }\n}","map":{"version":3,"names":["API","or","left","right","Importer","constructor","variants","from","create","other","importers","archive","id","startsWith","importWith","name","key","Object","entries","keys","signer","withDID","Error","importer","_","verifier","SignerWithDID","signatureAlgorithm","signatureCode","did","toDIDKey","sign","payload","verify","signature","toArchive"],"sources":["C:/FACULTATE/Proiect/node_modules/@ucanto/principal/src/signer.js"],"sourcesContent":["import * as API from '@ucanto/interface'\n\n/**\n * @template {API.SignerImporter} L\n * @template {API.SignerImporter} R\n * @param {L} left\n * @param {R} right\n * @returns {API.CompositeImporter<[L, R]>}\n */\nexport const or = (left, right) => new Importer([left, right])\n\n/**\n * @template {[API.SignerImporter, ...API.SignerImporter[]]} Importers\n * @implements {API.CompositeImporter<Importers>}\n */\nclass Importer {\n  /**\n   * @param {Importers} variants\n   */\n  constructor(variants) {\n    this.variants = variants\n    this.from = create(variants)\n  }\n\n  /**\n   * @template {API.SignerImporter} Other\n   * @param {Other} other\n   * @returns {API.CompositeImporter<[Other, ...Importers]>}\n   */\n  or(other) {\n    return new Importer([other, ...this.variants])\n  }\n}\n\n/**\n * @template {[API.SignerImporter, ...API.SignerImporter[]]} Importers\n * @param {Importers} importers\n */\nconst create = importers => {\n  /**\n   * @template {API.DID} ID - DID that can be imported, which may be a type union.\n   * @template {API.SigAlg} Alg - Multicodec code corresponding to signature algorithm.\n   * @param {API.SignerArchive<ID, Alg>} archive\n   * @returns {API.Signer<ID, Alg>}\n   */\n  const from = archive => {\n    if (archive.id.startsWith('did:key:')) {\n      return /** @type {API.Signer<ID, Alg>} */ (importWith(archive, importers))\n    } else {\n      for (const [name, key] of Object.entries(archive.keys)) {\n        const id = /** @type {API.DIDKey} */ (name)\n        const signer = /** @type {API.Signer<API.DIDKey, Alg>} */ (\n          importWith(\n            {\n              id,\n              keys: { [id]: key },\n            },\n            importers\n          )\n        )\n\n        return signer.withDID(archive.id)\n      }\n\n      throw new Error(`Archive ${archive.id} contains no keys`)\n    }\n  }\n\n  return /** @type {API.Intersection<Importers[number]['from']>} */ (from)\n}\n\n/**\n * @param {API.SignerArchive} archive\n * @param {API.SignerImporter[]} importers\n * @returns {API.Signer}\n */\nconst importWith = (archive, importers) => {\n  for (const importer of importers) {\n    try {\n      return importer.from(archive)\n    } catch (_) {}\n  }\n  throw new Error(`Unsupported signer`)\n}\n/**\n * @template {number} Code\n * @template {API.DID} ID\n * @param {API.Signer<API.DID<'key'>, Code>} signer\n * @param {ID} id\n * @returns {API.Signer<ID, Code>}\n */\nexport const withDID = ({ signer, verifier }, id) =>\n  new SignerWithDID(signer, verifier.withDID(id))\n\n/**\n * @template {API.DID} ID\n * @template {number} Code\n * @implements {API.Signer<ID, Code>}\n */\nclass SignerWithDID {\n  /**\n   * @param {API.Signer<API.DID<'key'>, Code>} key\n   * @param {API.Verifier<ID, Code>} verifier\n   */\n  constructor(key, verifier) {\n    this.key = key\n    this.verifier = verifier\n  }\n  /** @type {API.Signer<ID, Code>} */\n  get signer() {\n    return this\n  }\n\n  get signatureAlgorithm() {\n    return this.key.signatureAlgorithm\n  }\n  get signatureCode() {\n    return this.key.signatureCode\n  }\n\n  /**\n   * @returns {ID}\n   */\n  did() {\n    return this.verifier.did()\n  }\n\n  toDIDKey() {\n    return this.verifier.toDIDKey()\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   */\n  withDID(id) {\n    return withDID(this.key, id)\n  }\n\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   */\n  sign(payload) {\n    return this.key.sign(payload)\n  }\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, Code>} signature\n   */\n  verify(payload, signature) {\n    return this.verifier.verify(payload, signature)\n  }\n\n  toArchive() {\n    const { keys } = this.key.toArchive()\n    return {\n      id: this.did(),\n      keys,\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}