{"ast":null,"code":"const assert = require('assert');\nconst {\n  ResponseStatusCodeError\n} = require('../core/errors');\nconst {\n  toUSVString\n} = require('../core/util');\nasync function getResolveErrorBodyCallback({\n  callback,\n  body,\n  contentType,\n  statusCode,\n  statusMessage,\n  headers\n}) {\n  assert(body);\n  let chunks = [];\n  let limit = 0;\n  for await (const chunk of body) {\n    chunks.push(chunk);\n    limit += chunk.length;\n    if (limit > 128 * 1024) {\n      chunks = null;\n      break;\n    }\n  }\n  if (statusCode === 204 || !contentType || !chunks) {\n    process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers));\n    return;\n  }\n  try {\n    if (contentType.startsWith('application/json')) {\n      const payload = JSON.parse(toUSVString(Buffer.concat(chunks)));\n      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers, payload));\n      return;\n    }\n    if (contentType.startsWith('text/')) {\n      const payload = toUSVString(Buffer.concat(chunks));\n      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers, payload));\n      return;\n    }\n  } catch (err) {\n    // Process in a fallback if error\n  }\n  process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers));\n}\nmodule.exports = {\n  getResolveErrorBodyCallback\n};","map":{"version":3,"names":["assert","require","ResponseStatusCodeError","toUSVString","getResolveErrorBodyCallback","callback","body","contentType","statusCode","statusMessage","headers","chunks","limit","chunk","push","length","process","nextTick","startsWith","payload","JSON","parse","Buffer","concat","err","module","exports"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/undici/lib/api/util.js"],"sourcesContent":["const assert = require('assert')\nconst {\n  ResponseStatusCodeError\n} = require('../core/errors')\nconst { toUSVString } = require('../core/util')\n\nasync function getResolveErrorBodyCallback ({ callback, body, contentType, statusCode, statusMessage, headers }) {\n  assert(body)\n\n  let chunks = []\n  let limit = 0\n\n  for await (const chunk of body) {\n    chunks.push(chunk)\n    limit += chunk.length\n    if (limit > 128 * 1024) {\n      chunks = null\n      break\n    }\n  }\n\n  if (statusCode === 204 || !contentType || !chunks) {\n    process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers))\n    return\n  }\n\n  try {\n    if (contentType.startsWith('application/json')) {\n      const payload = JSON.parse(toUSVString(Buffer.concat(chunks)))\n      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers, payload))\n      return\n    }\n\n    if (contentType.startsWith('text/')) {\n      const payload = toUSVString(Buffer.concat(chunks))\n      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers, payload))\n      return\n    }\n  } catch (err) {\n    // Process in a fallback if error\n  }\n\n  process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers))\n}\n\nmodule.exports = { getResolveErrorBodyCallback }\n"],"mappings":"AAAA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAM;EACJC;AACF,CAAC,GAAGD,OAAO,CAAC,gBAAgB,CAAC;AAC7B,MAAM;EAAEE;AAAY,CAAC,GAAGF,OAAO,CAAC,cAAc,CAAC;AAE/C,eAAeG,2BAA2BA,CAAE;EAAEC,QAAQ;EAAEC,IAAI;EAAEC,WAAW;EAAEC,UAAU;EAAEC,aAAa;EAAEC;AAAQ,CAAC,EAAE;EAC/GV,MAAM,CAACM,IAAI,CAAC;EAEZ,IAAIK,MAAM,GAAG,EAAE;EACf,IAAIC,KAAK,GAAG,CAAC;EAEb,WAAW,MAAMC,KAAK,IAAIP,IAAI,EAAE;IAC9BK,MAAM,CAACG,IAAI,CAACD,KAAK,CAAC;IAClBD,KAAK,IAAIC,KAAK,CAACE,MAAM;IACrB,IAAIH,KAAK,GAAG,GAAG,GAAG,IAAI,EAAE;MACtBD,MAAM,GAAG,IAAI;MACb;IACF;EACF;EAEA,IAAIH,UAAU,KAAK,GAAG,IAAI,CAACD,WAAW,IAAI,CAACI,MAAM,EAAE;IACjDK,OAAO,CAACC,QAAQ,CAACZ,QAAQ,EAAE,IAAIH,uBAAuB,CAAE,wBAAuBM,UAAW,GAAEC,aAAa,GAAI,KAAIA,aAAc,EAAC,GAAG,EAAG,EAAC,EAAED,UAAU,EAAEE,OAAO,CAAC,CAAC;IAC9J;EACF;EAEA,IAAI;IACF,IAAIH,WAAW,CAACW,UAAU,CAAC,kBAAkB,CAAC,EAAE;MAC9C,MAAMC,OAAO,GAAGC,IAAI,CAACC,KAAK,CAAClB,WAAW,CAACmB,MAAM,CAACC,MAAM,CAACZ,MAAM,CAAC,CAAC,CAAC;MAC9DK,OAAO,CAACC,QAAQ,CAACZ,QAAQ,EAAE,IAAIH,uBAAuB,CAAE,wBAAuBM,UAAW,GAAEC,aAAa,GAAI,KAAIA,aAAc,EAAC,GAAG,EAAG,EAAC,EAAED,UAAU,EAAEE,OAAO,EAAES,OAAO,CAAC,CAAC;MACvK;IACF;IAEA,IAAIZ,WAAW,CAACW,UAAU,CAAC,OAAO,CAAC,EAAE;MACnC,MAAMC,OAAO,GAAGhB,WAAW,CAACmB,MAAM,CAACC,MAAM,CAACZ,MAAM,CAAC,CAAC;MAClDK,OAAO,CAACC,QAAQ,CAACZ,QAAQ,EAAE,IAAIH,uBAAuB,CAAE,wBAAuBM,UAAW,GAAEC,aAAa,GAAI,KAAIA,aAAc,EAAC,GAAG,EAAG,EAAC,EAAED,UAAU,EAAEE,OAAO,EAAES,OAAO,CAAC,CAAC;MACvK;IACF;EACF,CAAC,CAAC,OAAOK,GAAG,EAAE;IACZ;EAAA;EAGFR,OAAO,CAACC,QAAQ,CAACZ,QAAQ,EAAE,IAAIH,uBAAuB,CAAE,wBAAuBM,UAAW,GAAEC,aAAa,GAAI,KAAIA,aAAc,EAAC,GAAG,EAAG,EAAC,EAAED,UAAU,EAAEE,OAAO,CAAC,CAAC;AAChK;AAEAe,MAAM,CAACC,OAAO,GAAG;EAAEtB;AAA4B,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}