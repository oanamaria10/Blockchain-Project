{"ast":null,"code":"import { getRandomBytesSync } from 'ethereum-cryptography/random.js';\nimport { assertIsArray, assertIsBytes, assertIsHexString } from './helpers.js';\nimport { isHexPrefixed, isHexString, padToEven, stripHexPrefix } from './internal.js';\nconst BIGINT_0 = BigInt(0);\nfunction isBytes(a) {\n  return a instanceof Uint8Array ||\n  // eslint-disable-next-line eqeqeq\n  a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array';\n}\nconst hexes = Array.from({\n  length: 256\n}, (_, i) => i.toString(16).padStart(2, '0'));\nexport function _bytesToUnprefixedHex(bytes) {\n  if (!isBytes(bytes)) throw new Error('Uint8Array expected');\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n/**\n * @deprecated\n */\nexport const bytesToUnprefixedHex = _bytesToUnprefixedHex;\n// hexToBytes cache\nconst hexToBytesMapFirstKey = {};\nconst hexToBytesMapSecondKey = {};\nfor (let i = 0; i < 16; i++) {\n  const vSecondKey = i;\n  const vFirstKey = i * 16;\n  const key = i.toString(16).toLowerCase();\n  hexToBytesMapSecondKey[key] = vSecondKey;\n  hexToBytesMapSecondKey[key.toUpperCase()] = vSecondKey;\n  hexToBytesMapFirstKey[key] = vFirstKey;\n  hexToBytesMapFirstKey[key.toUpperCase()] = vFirstKey;\n}\n/**\n * NOTE: only use this function if the string is even, and only consists of hex characters\n * If this is not the case, this function could return weird results\n * @deprecated\n */\nfunction _unprefixedHexToBytes(hex) {\n  const byteLen = hex.length;\n  const bytes = new Uint8Array(byteLen / 2);\n  for (let i = 0; i < byteLen; i += 2) {\n    bytes[i / 2] = hexToBytesMapFirstKey[hex[i]] + hexToBytesMapSecondKey[hex[i + 1]];\n  }\n  return bytes;\n}\n/**\n * @deprecated\n */\nexport const unprefixedHexToBytes = inp => {\n  if (inp.slice(0, 2) === '0x') {\n    throw new Error('hex string is prefixed with 0x, should be unprefixed');\n  } else {\n    return _unprefixedHexToBytes(padToEven(inp));\n  }\n};\n/****************  Borrowed from @chainsafe/ssz */\n// Caching this info costs about ~1000 bytes and speeds up toHexString() by x6\nconst hexByByte = Array.from({\n  length: 256\n}, (v, i) => i.toString(16).padStart(2, '0'));\nexport const bytesToHex = bytes => {\n  let hex = '0x';\n  if (bytes === undefined || bytes.length === 0) return hex;\n  for (const byte of bytes) {\n    hex += hexByByte[byte];\n  }\n  return hex;\n};\n// BigInt cache for the numbers 0 - 256*256-1 (two-byte bytes)\nconst BIGINT_CACHE = [];\nfor (let i = 0; i <= 256 * 256 - 1; i++) {\n  BIGINT_CACHE[i] = BigInt(i);\n}\n/**\n * Converts a {@link Uint8Array} to a {@link bigint}\n * @param {Uint8Array} bytes the bytes to convert\n * @returns {bigint}\n */\nexport const bytesToBigInt = (bytes, littleEndian = false) => {\n  if (littleEndian) {\n    bytes.reverse();\n  }\n  const hex = bytesToHex(bytes);\n  if (hex === '0x') {\n    return BIGINT_0;\n  }\n  if (hex.length === 4) {\n    // If the byte length is 1 (this is faster than checking `bytes.length === 1`)\n    return BIGINT_CACHE[bytes[0]];\n  }\n  if (hex.length === 6) {\n    return BIGINT_CACHE[bytes[0] * 256 + bytes[1]];\n  }\n  return BigInt(hex);\n};\n/**\n * Converts a {@link Uint8Array} to a {@link number}.\n * @param {Uint8Array} bytes the bytes to convert\n * @return  {number}\n * @throws If the input number exceeds 53 bits.\n */\nexport const bytesToInt = bytes => {\n  const res = Number(bytesToBigInt(bytes));\n  if (!Number.isSafeInteger(res)) throw new Error('Number exceeds 53 bits');\n  return res;\n};\nexport const hexToBytes = hex => {\n  if (typeof hex !== 'string') {\n    throw new Error(`hex argument type ${typeof hex} must be of type string`);\n  }\n  if (!/^0x[0-9a-fA-F]*$/.test(hex)) {\n    throw new Error(`Input must be a 0x-prefixed hexadecimal string, got ${hex}`);\n  }\n  hex = hex.slice(2);\n  if (hex.length % 2 !== 0) {\n    hex = padToEven(hex);\n  }\n  return _unprefixedHexToBytes(hex);\n};\n/******************************************/\n/**\n * Converts a {@link number} into a {@link PrefixedHexString}\n * @param {number} i\n * @return {PrefixedHexString}\n */\nexport const intToHex = i => {\n  if (!Number.isSafeInteger(i) || i < 0) {\n    throw new Error(`Received an invalid integer type: ${i}`);\n  }\n  return `0x${i.toString(16)}`;\n};\n/**\n * Converts an {@link number} to a {@link Uint8Array}\n * @param {Number} i\n * @return {Uint8Array}\n */\nexport const intToBytes = i => {\n  const hex = intToHex(i);\n  return hexToBytes(hex);\n};\n/**\n * Converts a {@link bigint} to a {@link Uint8Array}\n *  * @param {bigint} num the bigint to convert\n * @returns {Uint8Array}\n */\nexport const bigIntToBytes = (num, littleEndian = false) => {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  const bytes = toBytes('0x' + padToEven(num.toString(16)));\n  return littleEndian ? bytes.reverse() : bytes;\n};\n/**\n * Returns a Uint8Array filled with 0s.\n * @param {number} bytes the number of bytes of the Uint8Array\n * @return {Uint8Array}\n */\nexport const zeros = bytes => {\n  return new Uint8Array(bytes);\n};\n/**\n * Pads a `Uint8Array` with zeros till it has `length` bytes.\n * Truncates the beginning or end of input if its length exceeds `length`.\n * @param {Uint8Array} msg the value to pad\n * @param {number} length the number of bytes the output should be\n * @param {boolean} right whether to start padding form the left or right\n * @return {Uint8Array}\n */\nconst setLength = (msg, length, right) => {\n  if (right) {\n    if (msg.length < length) {\n      return new Uint8Array([...msg, ...zeros(length - msg.length)]);\n    }\n    return msg.subarray(0, length);\n  } else {\n    if (msg.length < length) {\n      return new Uint8Array([...zeros(length - msg.length), ...msg]);\n    }\n    return msg.subarray(-length);\n  }\n};\n/**\n * Left Pads a `Uint8Array` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param {Uint8Array} msg the value to pad\n * @param {number} length the number of bytes the output should be\n * @return {Uint8Array}\n */\nexport const setLengthLeft = (msg, length) => {\n  assertIsBytes(msg);\n  return setLength(msg, length, false);\n};\n/**\n * Right Pads a `Uint8Array` with trailing zeros till it has `length` bytes.\n * it truncates the end if it exceeds.\n * @param {Uint8Array} msg the value to pad\n * @param {number} length the number of bytes the output should be\n * @return {Uint8Array}\n */\nexport const setLengthRight = (msg, length) => {\n  assertIsBytes(msg);\n  return setLength(msg, length, true);\n};\n/**\n * Trims leading zeros from a `Uint8Array`, `number[]` or PrefixedHexString`.\n * @param {Uint8Array|number[]|PrefixedHexString} a\n * @return {Uint8Array|number[]|PrefixedHexString}\n */\nconst stripZeros = a => {\n  let first = a[0];\n  while (a.length > 0 && first.toString() === '0') {\n    a = a.slice(1);\n    first = a[0];\n  }\n  return a;\n};\n/**\n * Trims leading zeros from a `Uint8Array`.\n * @param {Uint8Array} a\n * @return {Uint8Array}\n */\nexport const unpadBytes = a => {\n  assertIsBytes(a);\n  return stripZeros(a);\n};\n/**\n * Trims leading zeros from an `Array` (of numbers).\n * @param  {number[]} a\n * @return {number[]}\n */\nexport const unpadArray = a => {\n  assertIsArray(a);\n  return stripZeros(a);\n};\n/**\n * Trims leading zeros from a `PrefixedHexString`.\n * @param {PrefixedHexString} a\n * @return {PrefixedHexString}\n */\nexport const unpadHex = a => {\n  assertIsHexString(a);\n  a = stripHexPrefix(a);\n  return '0x' + stripZeros(a);\n};\n/**\n * Attempts to turn a value into a `Uint8Array`.\n * Inputs supported: `Buffer`, `Uint8Array`, `String` (hex-prefixed), `Number`, null/undefined, `BigInt` and other objects\n * with a `toArray()` or `toBytes()` method.\n * @param {ToBytesInputTypes} v the value\n * @return {Uint8Array}\n */\nexport const toBytes = v => {\n  if (v === null || v === undefined) {\n    return new Uint8Array();\n  }\n  if (Array.isArray(v) || v instanceof Uint8Array) {\n    return Uint8Array.from(v);\n  }\n  if (typeof v === 'string') {\n    if (!isHexString(v)) {\n      throw new Error(`Cannot convert string to Uint8Array. toBytes only supports 0x-prefixed hex strings and this string was given: ${v}`);\n    }\n    return hexToBytes(v);\n  }\n  if (typeof v === 'number') {\n    return intToBytes(v);\n  }\n  if (typeof v === 'bigint') {\n    if (v < BIGINT_0) {\n      throw new Error(`Cannot convert negative bigint to Uint8Array. Given: ${v}`);\n    }\n    let n = v.toString(16);\n    if (n.length % 2) n = '0' + n;\n    return unprefixedHexToBytes(n);\n  }\n  if (v.toBytes !== undefined) {\n    // converts a `TransformableToBytes` object to a Uint8Array\n    return v.toBytes();\n  }\n  throw new Error('invalid type');\n};\n/**\n * Interprets a `Uint8Array` as a signed integer and returns a `BigInt`. Assumes 256-bit numbers.\n * @param {Uint8Array} num Signed integer value\n * @returns {bigint}\n */\nexport const fromSigned = num => {\n  return BigInt.asIntN(256, bytesToBigInt(num));\n};\n/**\n * Converts a `BigInt` to an unsigned integer and returns it as a `Uint8Array`. Assumes 256-bit numbers.\n * @param {bigint} num\n * @returns {Uint8Array}\n */\nexport const toUnsigned = num => {\n  return bigIntToBytes(BigInt.asUintN(256, num));\n};\n/**\n * Adds \"0x\" to a given `string` if it does not already start with \"0x\".\n * @param {string} str\n * @return {PrefixedHexString}\n */\nexport const addHexPrefix = str => {\n  if (typeof str !== 'string') {\n    return str;\n  }\n  return isHexPrefixed(str) ? str : '0x' + str;\n};\n/**\n * Shortens a string  or Uint8Array's hex string representation to maxLength (default 50).\n *\n * Examples:\n *\n * Input:  '657468657265756d000000000000000000000000000000000000000000000000'\n * Output: '657468657265756d0000000000000000000000000000000000â€¦'\n * @param {Uint8Array | string} bytes\n * @param {number} maxLength\n * @return {string}\n */\nexport const short = (bytes, maxLength = 50) => {\n  const byteStr = bytes instanceof Uint8Array ? bytesToHex(bytes) : bytes;\n  const len = byteStr.slice(0, 2) === '0x' ? maxLength + 2 : maxLength;\n  if (byteStr.length <= len) {\n    return byteStr;\n  }\n  return byteStr.slice(0, len) + 'â€¦';\n};\n/**\n * Checks provided Uint8Array for leading zeroes and throws if found.\n *\n * Examples:\n *\n * Valid values: 0x1, 0x, 0x01, 0x1234\n * Invalid values: 0x0, 0x00, 0x001, 0x0001\n *\n * Note: This method is useful for validating that RLP encoded integers comply with the rule that all\n * integer values encoded to RLP must be in the most compact form and contain no leading zero bytes\n * @param values An object containing string keys and Uint8Array values\n * @throws if any provided value is found to have leading zero bytes\n */\nexport const validateNoLeadingZeroes = values => {\n  for (const [k, v] of Object.entries(values)) {\n    if (v !== undefined && v.length > 0 && v[0] === 0) {\n      throw new Error(`${k} cannot have leading zeroes, received: ${bytesToHex(v)}`);\n    }\n  }\n};\n/**\n * Converts a {@link bigint} to a `0x` prefixed hex string\n * @param {bigint} num the bigint to convert\n * @returns {PrefixedHexString}\n */\nexport const bigIntToHex = num => {\n  return '0x' + num.toString(16);\n};\n/**\n * Convert value from bigint to an unpadded Uint8Array\n * (useful for RLP transport)\n * @param {bigint} value the bigint to convert\n * @returns {Uint8Array}\n */\nexport const bigIntToUnpaddedBytes = value => {\n  return unpadBytes(bigIntToBytes(value));\n};\n/**\n * Convert value from number to an unpadded Uint8Array\n * (useful for RLP transport)\n * @param {number} value the bigint to convert\n * @returns {Uint8Array}\n */\nexport const intToUnpaddedBytes = value => {\n  return unpadBytes(intToBytes(value));\n};\n/**\n * Compares two Uint8Arrays and returns a number indicating their order in a sorted array.\n *\n * @param {Uint8Array} value1 - The first Uint8Array to compare.\n * @param {Uint8Array} value2 - The second Uint8Array to compare.\n * @returns {number} A positive number if value1 is larger than value2,\n *                   A negative number if value1 is smaller than value2,\n *                   or 0 if value1 and value2 are equal.\n */\nexport const compareBytes = (value1, value2) => {\n  const bigIntValue1 = bytesToBigInt(value1);\n  const bigIntValue2 = bytesToBigInt(value2);\n  return bigIntValue1 > bigIntValue2 ? 1 : bigIntValue1 < bigIntValue2 ? -1 : 0;\n};\n/**\n * Generates a Uint8Array of random bytes of specified length.\n *\n * @param {number} length - The length of the Uint8Array.\n * @returns {Uint8Array} A Uint8Array of random bytes of specified length.\n */\nexport const randomBytes = length => {\n  return getRandomBytesSync(length);\n};\n/**\n * This mirrors the functionality of the `ethereum-cryptography` export except\n * it skips the check to validate that every element of `arrays` is indead a `uint8Array`\n * Can give small performance gains on large arrays\n * @param {Uint8Array[]} arrays an array of Uint8Arrays\n * @returns {Uint8Array} one Uint8Array with all the elements of the original set\n * works like `Buffer.concat`\n */\nexport const concatBytes = (...arrays) => {\n  if (arrays.length === 1) return arrays[0];\n  const length = arrays.reduce((a, arr) => a + arr.length, 0);\n  const result = new Uint8Array(length);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n  return result;\n};\n/**\n * @notice Convert a Uint8Array to a 32-bit integer\n * @param {Uint8Array} bytes The input Uint8Array from which to read the 32-bit integer.\n * @param {boolean} littleEndian True for little-endian, undefined or false for big-endian.\n * @return {number} The 32-bit integer read from the input Uint8Array.\n */\nexport function bytesToInt32(bytes, littleEndian = false) {\n  if (bytes.length < 4) {\n    bytes = setLength(bytes, 4, littleEndian);\n  }\n  const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n  return dataView.getUint32(0, littleEndian);\n}\n/**\n * @notice Convert a Uint8Array to a 64-bit bigint\n * @param {Uint8Array} bytes The input Uint8Array from which to read the 64-bit bigint.\n * @param {boolean} littleEndian True for little-endian, undefined or false for big-endian.\n * @return {bigint} The 64-bit bigint read from the input Uint8Array.\n */\nexport function bytesToBigInt64(bytes, littleEndian = false) {\n  if (bytes.length < 8) {\n    bytes = setLength(bytes, 8, littleEndian);\n  }\n  const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n  return dataView.getBigUint64(0, littleEndian);\n}\n/**\n * @notice Convert a 32-bit integer to a Uint8Array.\n * @param {number} value The 32-bit integer to convert.\n * @param {boolean} littleEndian True for little-endian, undefined or false for big-endian.\n * @return {Uint8Array} A Uint8Array of length 4 containing the integer.\n */\nexport function int32ToBytes(value, littleEndian = false) {\n  const buffer = new ArrayBuffer(4);\n  const dataView = new DataView(buffer);\n  dataView.setUint32(0, value, littleEndian);\n  return new Uint8Array(buffer);\n}\n/**\n * @notice Convert a 64-bit bigint to a Uint8Array.\n * @param {bigint} value The 64-bit bigint to convert.\n * @param {boolean} littleEndian True for little-endian, undefined or false for big-endian.\n * @return {Uint8Array} A Uint8Array of length 8 containing the bigint.\n */\nexport function bigInt64ToBytes(value, littleEndian = false) {\n  const buffer = new ArrayBuffer(8);\n  const dataView = new DataView(buffer);\n  dataView.setBigUint64(0, value, littleEndian);\n  return new Uint8Array(buffer);\n}\nexport function equalsBytes(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nexport function bytesToUtf8(data) {\n  if (!(data instanceof Uint8Array)) {\n    throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);\n  }\n  return new TextDecoder().decode(data);\n}\nexport function utf8ToBytes(str) {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}","map":{"version":3,"names":["getRandomBytesSync","assertIsArray","assertIsBytes","assertIsHexString","isHexPrefixed","isHexString","padToEven","stripHexPrefix","BIGINT_0","BigInt","isBytes","a","Uint8Array","constructor","name","hexes","Array","from","length","_","i","toString","padStart","_bytesToUnprefixedHex","bytes","Error","hex","bytesToUnprefixedHex","hexToBytesMapFirstKey","hexToBytesMapSecondKey","vSecondKey","vFirstKey","key","toLowerCase","toUpperCase","_unprefixedHexToBytes","byteLen","unprefixedHexToBytes","inp","slice","hexByByte","v","bytesToHex","undefined","byte","BIGINT_CACHE","bytesToBigInt","littleEndian","reverse","bytesToInt","res","Number","isSafeInteger","hexToBytes","test","intToHex","intToBytes","bigIntToBytes","num","toBytes","zeros","setLength","msg","right","subarray","setLengthLeft","setLengthRight","stripZeros","first","unpadBytes","unpadArray","unpadHex","isArray","n","fromSigned","asIntN","toUnsigned","asUintN","addHexPrefix","str","short","maxLength","byteStr","len","validateNoLeadingZeroes","values","k","Object","entries","bigIntToHex","bigIntToUnpaddedBytes","value","intToUnpaddedBytes","compareBytes","value1","value2","bigIntValue1","bigIntValue2","randomBytes","concatBytes","arrays","reduce","arr","result","pad","set","bytesToInt32","dataView","DataView","buffer","byteOffset","byteLength","getUint32","bytesToBigInt64","getBigUint64","int32ToBytes","ArrayBuffer","setUint32","bigInt64ToBytes","setBigUint64","equalsBytes","b","bytesToUtf8","data","TypeError","TextDecoder","decode","utf8ToBytes","TextEncoder","encode"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\@nomicfoundation\\ethereumjs-util\\src\\bytes.ts"],"sourcesContent":["import { getRandomBytesSync } from 'ethereum-cryptography/random.js'\n\nimport { assertIsArray, assertIsBytes, assertIsHexString } from './helpers.js'\nimport { isHexPrefixed, isHexString, padToEven, stripHexPrefix } from './internal.js'\n\nimport type { PrefixedHexString, TransformabletoBytes } from './types.js'\n\nconst BIGINT_0 = BigInt(0)\n\nfunction isBytes(a: unknown): a is Uint8Array {\n  return (\n    a instanceof Uint8Array ||\n    // eslint-disable-next-line eqeqeq\n    (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array')\n  )\n}\n\nconst hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'))\n\nexport function _bytesToUnprefixedHex(bytes: Uint8Array): string {\n  if (!isBytes(bytes)) throw new Error('Uint8Array expected')\n  // pre-caching improves the speed 6x\n  let hex = ''\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]]\n  }\n  return hex\n}\n\n/**\n * @deprecated\n */\nexport const bytesToUnprefixedHex = _bytesToUnprefixedHex\n\n// hexToBytes cache\nconst hexToBytesMapFirstKey: { [key: string]: number } = {}\nconst hexToBytesMapSecondKey: { [key: string]: number } = {}\n\nfor (let i = 0; i < 16; i++) {\n  const vSecondKey = i\n  const vFirstKey = i * 16\n  const key = i.toString(16).toLowerCase()\n  hexToBytesMapSecondKey[key] = vSecondKey\n  hexToBytesMapSecondKey[key.toUpperCase()] = vSecondKey\n  hexToBytesMapFirstKey[key] = vFirstKey\n  hexToBytesMapFirstKey[key.toUpperCase()] = vFirstKey\n}\n\n/**\n * NOTE: only use this function if the string is even, and only consists of hex characters\n * If this is not the case, this function could return weird results\n * @deprecated\n */\nfunction _unprefixedHexToBytes(hex: string): Uint8Array {\n  const byteLen = hex.length\n  const bytes = new Uint8Array(byteLen / 2)\n  for (let i = 0; i < byteLen; i += 2) {\n    bytes[i / 2] = hexToBytesMapFirstKey[hex[i]] + hexToBytesMapSecondKey[hex[i + 1]]\n  }\n  return bytes\n}\n\n/**\n * @deprecated\n */\nexport const unprefixedHexToBytes = (inp: string) => {\n  if (inp.slice(0, 2) === '0x') {\n    throw new Error('hex string is prefixed with 0x, should be unprefixed')\n  } else {\n    return _unprefixedHexToBytes(padToEven(inp))\n  }\n}\n\n/****************  Borrowed from @chainsafe/ssz */\n// Caching this info costs about ~1000 bytes and speeds up toHexString() by x6\nconst hexByByte = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'))\n\nexport const bytesToHex = (bytes: Uint8Array): string => {\n  let hex = '0x'\n  if (bytes === undefined || bytes.length === 0) return hex\n  for (const byte of bytes) {\n    hex += hexByByte[byte]\n  }\n  return hex\n}\n\n// BigInt cache for the numbers 0 - 256*256-1 (two-byte bytes)\nconst BIGINT_CACHE: bigint[] = []\nfor (let i = 0; i <= 256 * 256 - 1; i++) {\n  BIGINT_CACHE[i] = BigInt(i)\n}\n\n/**\n * Converts a {@link Uint8Array} to a {@link bigint}\n * @param {Uint8Array} bytes the bytes to convert\n * @returns {bigint}\n */\nexport const bytesToBigInt = (bytes: Uint8Array, littleEndian = false): bigint => {\n  if (littleEndian) {\n    bytes.reverse()\n  }\n  const hex = bytesToHex(bytes)\n  if (hex === '0x') {\n    return BIGINT_0\n  }\n  if (hex.length === 4) {\n    // If the byte length is 1 (this is faster than checking `bytes.length === 1`)\n    return BIGINT_CACHE[bytes[0]]\n  }\n  if (hex.length === 6) {\n    return BIGINT_CACHE[bytes[0] * 256 + bytes[1]]\n  }\n  return BigInt(hex)\n}\n\n/**\n * Converts a {@link Uint8Array} to a {@link number}.\n * @param {Uint8Array} bytes the bytes to convert\n * @return  {number}\n * @throws If the input number exceeds 53 bits.\n */\nexport const bytesToInt = (bytes: Uint8Array): number => {\n  const res = Number(bytesToBigInt(bytes))\n  if (!Number.isSafeInteger(res)) throw new Error('Number exceeds 53 bits')\n  return res\n}\n\nexport const hexToBytes = (hex: string): Uint8Array => {\n  if (typeof hex !== 'string') {\n    throw new Error(`hex argument type ${typeof hex} must be of type string`)\n  }\n\n  if (!/^0x[0-9a-fA-F]*$/.test(hex)) {\n    throw new Error(`Input must be a 0x-prefixed hexadecimal string, got ${hex}`)\n  }\n\n  hex = hex.slice(2)\n\n  if (hex.length % 2 !== 0) {\n    hex = padToEven(hex)\n  }\n  return _unprefixedHexToBytes(hex)\n}\n\n/******************************************/\n\n/**\n * Converts a {@link number} into a {@link PrefixedHexString}\n * @param {number} i\n * @return {PrefixedHexString}\n */\nexport const intToHex = (i: number): PrefixedHexString => {\n  if (!Number.isSafeInteger(i) || i < 0) {\n    throw new Error(`Received an invalid integer type: ${i}`)\n  }\n  return `0x${i.toString(16)}`\n}\n\n/**\n * Converts an {@link number} to a {@link Uint8Array}\n * @param {Number} i\n * @return {Uint8Array}\n */\nexport const intToBytes = (i: number): Uint8Array => {\n  const hex = intToHex(i)\n  return hexToBytes(hex)\n}\n\n/**\n * Converts a {@link bigint} to a {@link Uint8Array}\n *  * @param {bigint} num the bigint to convert\n * @returns {Uint8Array}\n */\nexport const bigIntToBytes = (num: bigint, littleEndian = false): Uint8Array => {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  const bytes = toBytes('0x' + padToEven(num.toString(16)))\n\n  return littleEndian ? bytes.reverse() : bytes\n}\n\n/**\n * Returns a Uint8Array filled with 0s.\n * @param {number} bytes the number of bytes of the Uint8Array\n * @return {Uint8Array}\n */\nexport const zeros = (bytes: number): Uint8Array => {\n  return new Uint8Array(bytes)\n}\n\n/**\n * Pads a `Uint8Array` with zeros till it has `length` bytes.\n * Truncates the beginning or end of input if its length exceeds `length`.\n * @param {Uint8Array} msg the value to pad\n * @param {number} length the number of bytes the output should be\n * @param {boolean} right whether to start padding form the left or right\n * @return {Uint8Array}\n */\nconst setLength = (msg: Uint8Array, length: number, right: boolean): Uint8Array => {\n  if (right) {\n    if (msg.length < length) {\n      return new Uint8Array([...msg, ...zeros(length - msg.length)])\n    }\n    return msg.subarray(0, length)\n  } else {\n    if (msg.length < length) {\n      return new Uint8Array([...zeros(length - msg.length), ...msg])\n    }\n    return msg.subarray(-length)\n  }\n}\n\n/**\n * Left Pads a `Uint8Array` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param {Uint8Array} msg the value to pad\n * @param {number} length the number of bytes the output should be\n * @return {Uint8Array}\n */\nexport const setLengthLeft = (msg: Uint8Array, length: number): Uint8Array => {\n  assertIsBytes(msg)\n  return setLength(msg, length, false)\n}\n\n/**\n * Right Pads a `Uint8Array` with trailing zeros till it has `length` bytes.\n * it truncates the end if it exceeds.\n * @param {Uint8Array} msg the value to pad\n * @param {number} length the number of bytes the output should be\n * @return {Uint8Array}\n */\nexport const setLengthRight = (msg: Uint8Array, length: number): Uint8Array => {\n  assertIsBytes(msg)\n  return setLength(msg, length, true)\n}\n\n/**\n * Trims leading zeros from a `Uint8Array`, `number[]` or PrefixedHexString`.\n * @param {Uint8Array|number[]|PrefixedHexString} a\n * @return {Uint8Array|number[]|PrefixedHexString}\n */\nconst stripZeros = <\n  T extends Uint8Array | number[] | PrefixedHexString = Uint8Array | number[] | PrefixedHexString\n>(\n  a: T\n): T => {\n  let first = a[0]\n  while (a.length > 0 && first.toString() === '0') {\n    a = a.slice(1) as T\n    first = a[0]\n  }\n  return a\n}\n\n/**\n * Trims leading zeros from a `Uint8Array`.\n * @param {Uint8Array} a\n * @return {Uint8Array}\n */\nexport const unpadBytes = (a: Uint8Array): Uint8Array => {\n  assertIsBytes(a)\n  return stripZeros(a)\n}\n\n/**\n * Trims leading zeros from an `Array` (of numbers).\n * @param  {number[]} a\n * @return {number[]}\n */\nexport const unpadArray = (a: number[]): number[] => {\n  assertIsArray(a)\n  return stripZeros(a)\n}\n\n/**\n * Trims leading zeros from a `PrefixedHexString`.\n * @param {PrefixedHexString} a\n * @return {PrefixedHexString}\n */\nexport const unpadHex = (a: string): PrefixedHexString => {\n  assertIsHexString(a)\n  a = stripHexPrefix(a)\n  return '0x' + stripZeros(a)\n}\n\nexport type ToBytesInputTypes =\n  | PrefixedHexString\n  | number\n  | bigint\n  | Uint8Array\n  | number[]\n  | TransformabletoBytes\n  | null\n  | undefined\n\n/**\n * Attempts to turn a value into a `Uint8Array`.\n * Inputs supported: `Buffer`, `Uint8Array`, `String` (hex-prefixed), `Number`, null/undefined, `BigInt` and other objects\n * with a `toArray()` or `toBytes()` method.\n * @param {ToBytesInputTypes} v the value\n * @return {Uint8Array}\n */\n\nexport const toBytes = (v: ToBytesInputTypes): Uint8Array => {\n  if (v === null || v === undefined) {\n    return new Uint8Array()\n  }\n\n  if (Array.isArray(v) || v instanceof Uint8Array) {\n    return Uint8Array.from(v)\n  }\n\n  if (typeof v === 'string') {\n    if (!isHexString(v)) {\n      throw new Error(\n        `Cannot convert string to Uint8Array. toBytes only supports 0x-prefixed hex strings and this string was given: ${v}`\n      )\n    }\n    return hexToBytes(v)\n  }\n\n  if (typeof v === 'number') {\n    return intToBytes(v)\n  }\n\n  if (typeof v === 'bigint') {\n    if (v < BIGINT_0) {\n      throw new Error(`Cannot convert negative bigint to Uint8Array. Given: ${v}`)\n    }\n    let n = v.toString(16)\n    if (n.length % 2) n = '0' + n\n    return unprefixedHexToBytes(n)\n  }\n\n  if (v.toBytes !== undefined) {\n    // converts a `TransformableToBytes` object to a Uint8Array\n    return v.toBytes()\n  }\n\n  throw new Error('invalid type')\n}\n\n/**\n * Interprets a `Uint8Array` as a signed integer and returns a `BigInt`. Assumes 256-bit numbers.\n * @param {Uint8Array} num Signed integer value\n * @returns {bigint}\n */\nexport const fromSigned = (num: Uint8Array): bigint => {\n  return BigInt.asIntN(256, bytesToBigInt(num))\n}\n\n/**\n * Converts a `BigInt` to an unsigned integer and returns it as a `Uint8Array`. Assumes 256-bit numbers.\n * @param {bigint} num\n * @returns {Uint8Array}\n */\nexport const toUnsigned = (num: bigint): Uint8Array => {\n  return bigIntToBytes(BigInt.asUintN(256, num))\n}\n\n/**\n * Adds \"0x\" to a given `string` if it does not already start with \"0x\".\n * @param {string} str\n * @return {PrefixedHexString}\n */\nexport const addHexPrefix = (str: string): PrefixedHexString => {\n  if (typeof str !== 'string') {\n    return str\n  }\n\n  return isHexPrefixed(str) ? str : '0x' + str\n}\n\n/**\n * Shortens a string  or Uint8Array's hex string representation to maxLength (default 50).\n *\n * Examples:\n *\n * Input:  '657468657265756d000000000000000000000000000000000000000000000000'\n * Output: '657468657265756d0000000000000000000000000000000000â€¦'\n * @param {Uint8Array | string} bytes\n * @param {number} maxLength\n * @return {string}\n */\nexport const short = (bytes: Uint8Array | string, maxLength: number = 50): string => {\n  const byteStr = bytes instanceof Uint8Array ? bytesToHex(bytes) : bytes\n  const len = byteStr.slice(0, 2) === '0x' ? maxLength + 2 : maxLength\n  if (byteStr.length <= len) {\n    return byteStr\n  }\n  return byteStr.slice(0, len) + 'â€¦'\n}\n\n/**\n * Checks provided Uint8Array for leading zeroes and throws if found.\n *\n * Examples:\n *\n * Valid values: 0x1, 0x, 0x01, 0x1234\n * Invalid values: 0x0, 0x00, 0x001, 0x0001\n *\n * Note: This method is useful for validating that RLP encoded integers comply with the rule that all\n * integer values encoded to RLP must be in the most compact form and contain no leading zero bytes\n * @param values An object containing string keys and Uint8Array values\n * @throws if any provided value is found to have leading zero bytes\n */\nexport const validateNoLeadingZeroes = (values: { [key: string]: Uint8Array | undefined }) => {\n  for (const [k, v] of Object.entries(values)) {\n    if (v !== undefined && v.length > 0 && v[0] === 0) {\n      throw new Error(`${k} cannot have leading zeroes, received: ${bytesToHex(v)}`)\n    }\n  }\n}\n\n/**\n * Converts a {@link bigint} to a `0x` prefixed hex string\n * @param {bigint} num the bigint to convert\n * @returns {PrefixedHexString}\n */\nexport const bigIntToHex = (num: bigint): PrefixedHexString => {\n  return '0x' + num.toString(16)\n}\n\n/**\n * Convert value from bigint to an unpadded Uint8Array\n * (useful for RLP transport)\n * @param {bigint} value the bigint to convert\n * @returns {Uint8Array}\n */\nexport const bigIntToUnpaddedBytes = (value: bigint): Uint8Array => {\n  return unpadBytes(bigIntToBytes(value))\n}\n\n/**\n * Convert value from number to an unpadded Uint8Array\n * (useful for RLP transport)\n * @param {number} value the bigint to convert\n * @returns {Uint8Array}\n */\nexport const intToUnpaddedBytes = (value: number): Uint8Array => {\n  return unpadBytes(intToBytes(value))\n}\n\n/**\n * Compares two Uint8Arrays and returns a number indicating their order in a sorted array.\n *\n * @param {Uint8Array} value1 - The first Uint8Array to compare.\n * @param {Uint8Array} value2 - The second Uint8Array to compare.\n * @returns {number} A positive number if value1 is larger than value2,\n *                   A negative number if value1 is smaller than value2,\n *                   or 0 if value1 and value2 are equal.\n */\nexport const compareBytes = (value1: Uint8Array, value2: Uint8Array): number => {\n  const bigIntValue1 = bytesToBigInt(value1)\n  const bigIntValue2 = bytesToBigInt(value2)\n  return bigIntValue1 > bigIntValue2 ? 1 : bigIntValue1 < bigIntValue2 ? -1 : 0\n}\n\n/**\n * Generates a Uint8Array of random bytes of specified length.\n *\n * @param {number} length - The length of the Uint8Array.\n * @returns {Uint8Array} A Uint8Array of random bytes of specified length.\n */\nexport const randomBytes = (length: number): Uint8Array => {\n  return getRandomBytesSync(length)\n}\n\n/**\n * This mirrors the functionality of the `ethereum-cryptography` export except\n * it skips the check to validate that every element of `arrays` is indead a `uint8Array`\n * Can give small performance gains on large arrays\n * @param {Uint8Array[]} arrays an array of Uint8Arrays\n * @returns {Uint8Array} one Uint8Array with all the elements of the original set\n * works like `Buffer.concat`\n */\nexport const concatBytes = (...arrays: Uint8Array[]): Uint8Array => {\n  if (arrays.length === 1) return arrays[0]\n  const length = arrays.reduce((a, arr) => a + arr.length, 0)\n  const result = new Uint8Array(length)\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i]\n    result.set(arr, pad)\n    pad += arr.length\n  }\n  return result\n}\n\n/**\n * @notice Convert a Uint8Array to a 32-bit integer\n * @param {Uint8Array} bytes The input Uint8Array from which to read the 32-bit integer.\n * @param {boolean} littleEndian True for little-endian, undefined or false for big-endian.\n * @return {number} The 32-bit integer read from the input Uint8Array.\n */\nexport function bytesToInt32(bytes: Uint8Array, littleEndian: boolean = false): number {\n  if (bytes.length < 4) {\n    bytes = setLength(bytes, 4, littleEndian)\n  }\n  const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n  return dataView.getUint32(0, littleEndian)\n}\n\n/**\n * @notice Convert a Uint8Array to a 64-bit bigint\n * @param {Uint8Array} bytes The input Uint8Array from which to read the 64-bit bigint.\n * @param {boolean} littleEndian True for little-endian, undefined or false for big-endian.\n * @return {bigint} The 64-bit bigint read from the input Uint8Array.\n */\nexport function bytesToBigInt64(bytes: Uint8Array, littleEndian: boolean = false): bigint {\n  if (bytes.length < 8) {\n    bytes = setLength(bytes, 8, littleEndian)\n  }\n  const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n  return dataView.getBigUint64(0, littleEndian)\n}\n\n/**\n * @notice Convert a 32-bit integer to a Uint8Array.\n * @param {number} value The 32-bit integer to convert.\n * @param {boolean} littleEndian True for little-endian, undefined or false for big-endian.\n * @return {Uint8Array} A Uint8Array of length 4 containing the integer.\n */\nexport function int32ToBytes(value: number, littleEndian: boolean = false): Uint8Array {\n  const buffer = new ArrayBuffer(4)\n  const dataView = new DataView(buffer)\n  dataView.setUint32(0, value, littleEndian)\n  return new Uint8Array(buffer)\n}\n\n/**\n * @notice Convert a 64-bit bigint to a Uint8Array.\n * @param {bigint} value The 64-bit bigint to convert.\n * @param {boolean} littleEndian True for little-endian, undefined or false for big-endian.\n * @return {Uint8Array} A Uint8Array of length 8 containing the bigint.\n */\nexport function bigInt64ToBytes(value: bigint, littleEndian: boolean = false): Uint8Array {\n  const buffer = new ArrayBuffer(8)\n  const dataView = new DataView(buffer)\n  dataView.setBigUint64(0, value, littleEndian)\n  return new Uint8Array(buffer)\n}\n\nexport function equalsBytes(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) {\n    return false\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function bytesToUtf8(data: Uint8Array): string {\n  if (!(data instanceof Uint8Array)) {\n    throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`)\n  }\n  return new TextDecoder().decode(data)\n}\n\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`)\n  return new Uint8Array(new TextEncoder().encode(str)) // https://bugzil.la/1681809\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}