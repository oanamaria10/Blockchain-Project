{"ast":null,"code":"'use strict';\n\nconst Readable = require('./readable');\nconst {\n  InvalidArgumentError,\n  RequestAbortedError\n} = require('../core/errors');\nconst util = require('../core/util');\nconst {\n  getResolveErrorBodyCallback\n} = require('./util');\nconst {\n  AsyncResource\n} = require('async_hooks');\nconst {\n  addSignal,\n  removeSignal\n} = require('./abort-signal');\nclass RequestHandler extends AsyncResource {\n  constructor(opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts');\n    }\n    const {\n      signal,\n      method,\n      opaque,\n      body,\n      onInfo,\n      responseHeaders,\n      throwOnError,\n      highWaterMark\n    } = opts;\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback');\n      }\n      if (highWaterMark && (typeof highWaterMark !== 'number' || highWaterMark < 0)) {\n        throw new InvalidArgumentError('invalid highWaterMark');\n      }\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');\n      }\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method');\n      }\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback');\n      }\n      super('UNDICI_REQUEST');\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err);\n      }\n      throw err;\n    }\n    this.responseHeaders = responseHeaders || null;\n    this.opaque = opaque || null;\n    this.callback = callback;\n    this.res = null;\n    this.abort = null;\n    this.body = body;\n    this.trailers = {};\n    this.context = null;\n    this.onInfo = onInfo || null;\n    this.throwOnError = throwOnError;\n    this.highWaterMark = highWaterMark;\n    if (util.isStream(body)) {\n      body.on('error', err => {\n        this.onError(err);\n      });\n    }\n    addSignal(this, signal);\n  }\n  onConnect(abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError();\n    }\n    this.abort = abort;\n    this.context = context;\n  }\n  onHeaders(statusCode, rawHeaders, resume, statusMessage) {\n    const {\n      callback,\n      opaque,\n      abort,\n      context,\n      responseHeaders,\n      highWaterMark\n    } = this;\n    const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        this.onInfo({\n          statusCode,\n          headers\n        });\n      }\n      return;\n    }\n    const parsedHeaders = responseHeaders === 'raw' ? util.parseHeaders(rawHeaders) : headers;\n    const contentType = parsedHeaders['content-type'];\n    const body = new Readable({\n      resume,\n      abort,\n      contentType,\n      highWaterMark\n    });\n    this.callback = null;\n    this.res = body;\n    if (callback !== null) {\n      if (this.throwOnError && statusCode >= 400) {\n        this.runInAsyncScope(getResolveErrorBodyCallback, null, {\n          callback,\n          body,\n          contentType,\n          statusCode,\n          statusMessage,\n          headers\n        });\n      } else {\n        this.runInAsyncScope(callback, null, null, {\n          statusCode,\n          headers,\n          trailers: this.trailers,\n          opaque,\n          body,\n          context\n        });\n      }\n    }\n  }\n  onData(chunk) {\n    const {\n      res\n    } = this;\n    return res.push(chunk);\n  }\n  onComplete(trailers) {\n    const {\n      res\n    } = this;\n    removeSignal(this);\n    util.parseHeaders(trailers, this.trailers);\n    res.push(null);\n  }\n  onError(err) {\n    const {\n      res,\n      callback,\n      body,\n      opaque\n    } = this;\n    removeSignal(this);\n    if (callback) {\n      // TODO: Does this need queueMicrotask?\n      this.callback = null;\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, {\n          opaque\n        });\n      });\n    }\n    if (res) {\n      this.res = null;\n      // Ensure all queued handlers are invoked before destroying res.\n      queueMicrotask(() => {\n        util.destroy(res, err);\n      });\n    }\n    if (body) {\n      this.body = null;\n      util.destroy(body, err);\n    }\n  }\n}\nfunction request(opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      request.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data);\n      });\n    });\n  }\n  try {\n    this.dispatch(opts, new RequestHandler(opts, callback));\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err;\n    }\n    const opaque = opts && opts.opaque;\n    queueMicrotask(() => callback(err, {\n      opaque\n    }));\n  }\n}\nmodule.exports = request;\nmodule.exports.RequestHandler = RequestHandler;","map":{"version":3,"names":["Readable","require","InvalidArgumentError","RequestAbortedError","util","getResolveErrorBodyCallback","AsyncResource","addSignal","removeSignal","RequestHandler","constructor","opts","callback","signal","method","opaque","body","onInfo","responseHeaders","throwOnError","highWaterMark","on","addEventListener","err","isStream","destroy","nop","res","abort","trailers","context","onError","onConnect","onHeaders","statusCode","rawHeaders","resume","statusMessage","headers","parseRawHeaders","parseHeaders","parsedHeaders","contentType","runInAsyncScope","onData","chunk","push","onComplete","queueMicrotask","request","undefined","Promise","resolve","reject","call","data","dispatch","module","exports"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/undici/lib/api/api-request.js"],"sourcesContent":["'use strict'\n\nconst Readable = require('./readable')\nconst {\n  InvalidArgumentError,\n  RequestAbortedError\n} = require('../core/errors')\nconst util = require('../core/util')\nconst { getResolveErrorBodyCallback } = require('./util')\nconst { AsyncResource } = require('async_hooks')\nconst { addSignal, removeSignal } = require('./abort-signal')\n\nclass RequestHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback')\n      }\n\n      if (highWaterMark && (typeof highWaterMark !== 'number' || highWaterMark < 0)) {\n        throw new InvalidArgumentError('invalid highWaterMark')\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method')\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback')\n      }\n\n      super('UNDICI_REQUEST')\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err)\n      }\n      throw err\n    }\n\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.callback = callback\n    this.res = null\n    this.abort = null\n    this.body = body\n    this.trailers = {}\n    this.context = null\n    this.onInfo = onInfo || null\n    this.throwOnError = throwOnError\n    this.highWaterMark = highWaterMark\n\n    if (util.isStream(body)) {\n      body.on('error', (err) => {\n        this.onError(err)\n      })\n    }\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError()\n    }\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this\n\n    const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        this.onInfo({ statusCode, headers })\n      }\n      return\n    }\n\n    const parsedHeaders = responseHeaders === 'raw' ? util.parseHeaders(rawHeaders) : headers\n    const contentType = parsedHeaders['content-type']\n    const body = new Readable({ resume, abort, contentType, highWaterMark })\n\n    this.callback = null\n    this.res = body\n    if (callback !== null) {\n      if (this.throwOnError && statusCode >= 400) {\n        this.runInAsyncScope(getResolveErrorBodyCallback, null,\n          { callback, body, contentType, statusCode, statusMessage, headers }\n        )\n      } else {\n        this.runInAsyncScope(callback, null, null, {\n          statusCode,\n          headers,\n          trailers: this.trailers,\n          opaque,\n          body,\n          context\n        })\n      }\n    }\n  }\n\n  onData (chunk) {\n    const { res } = this\n    return res.push(chunk)\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n\n    removeSignal(this)\n\n    util.parseHeaders(trailers, this.trailers)\n\n    res.push(null)\n  }\n\n  onError (err) {\n    const { res, callback, body, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      // TODO: Does this need queueMicrotask?\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n\n    if (res) {\n      this.res = null\n      // Ensure all queued handlers are invoked before destroying res.\n      queueMicrotask(() => {\n        util.destroy(res, err)\n      })\n    }\n\n    if (body) {\n      this.body = null\n      util.destroy(body, err)\n    }\n  }\n}\n\nfunction request (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      request.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    this.dispatch(opts, new RequestHandler(opts, callback))\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts && opts.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = request\nmodule.exports.RequestHandler = RequestHandler\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}