{"ast":null,"code":"'use strict';\n\nconst {\n  redirectStatusSet,\n  referrerPolicySet: referrerPolicyTokens,\n  badPortsSet\n} = require('./constants');\nconst {\n  getGlobalOrigin\n} = require('./global');\nconst {\n  performance\n} = require('perf_hooks');\nconst {\n  isBlobLike,\n  toUSVString,\n  ReadableStreamFrom\n} = require('../core/util');\nconst assert = require('assert');\nconst {\n  isUint8Array\n} = require('util/types');\n\n// https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable\n/** @type {import('crypto')|undefined} */\nlet crypto;\ntry {\n  crypto = require('crypto');\n} catch {}\nfunction responseURL(response) {\n  // https://fetch.spec.whatwg.org/#responses\n  // A response has an associated URL. It is a pointer to the last URL\n  // in response’s URL list and null if response’s URL list is empty.\n  const urlList = response.urlList;\n  const length = urlList.length;\n  return length === 0 ? null : urlList[length - 1].toString();\n}\n\n// https://fetch.spec.whatwg.org/#concept-response-location-url\nfunction responseLocationURL(response, requestFragment) {\n  // 1. If response’s status is not a redirect status, then return null.\n  if (!redirectStatusSet.has(response.status)) {\n    return null;\n  }\n\n  // 2. Let location be the result of extracting header list values given\n  // `Location` and response’s header list.\n  let location = response.headersList.get('location');\n\n  // 3. If location is a header value, then set location to the result of\n  //    parsing location with response’s URL.\n  if (location !== null && isValidHeaderValue(location)) {\n    location = new URL(location, responseURL(response));\n  }\n\n  // 4. If location is a URL whose fragment is null, then set location’s\n  // fragment to requestFragment.\n  if (location && !location.hash) {\n    location.hash = requestFragment;\n  }\n\n  // 5. Return location.\n  return location;\n}\n\n/** @returns {URL} */\nfunction requestCurrentURL(request) {\n  return request.urlList[request.urlList.length - 1];\n}\nfunction requestBadPort(request) {\n  // 1. Let url be request’s current URL.\n  const url = requestCurrentURL(request);\n\n  // 2. If url’s scheme is an HTTP(S) scheme and url’s port is a bad port,\n  // then return blocked.\n  if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {\n    return 'blocked';\n  }\n\n  // 3. Return allowed.\n  return 'allowed';\n}\nfunction isErrorLike(object) {\n  return object instanceof Error || object?.constructor?.name === 'Error' || object?.constructor?.name === 'DOMException';\n}\n\n// Check whether |statusText| is a ByteString and\n// matches the Reason-Phrase token production.\n// RFC 2616: https://tools.ietf.org/html/rfc2616\n// RFC 7230: https://tools.ietf.org/html/rfc7230\n// \"reason-phrase = *( HTAB / SP / VCHAR / obs-text )\"\n// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116\nfunction isValidReasonPhrase(statusText) {\n  for (let i = 0; i < statusText.length; ++i) {\n    const c = statusText.charCodeAt(i);\n    if (!(c === 0x09 ||\n    // HTAB\n    c >= 0x20 && c <= 0x7e ||\n    // SP / VCHAR\n    c >= 0x80 && c <= 0xff\n    // obs-text\n    )) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @see https://tools.ietf.org/html/rfc7230#section-3.2.6\n * @param {number} c\n */\nfunction isTokenCharCode(c) {\n  switch (c) {\n    case 0x22:\n    case 0x28:\n    case 0x29:\n    case 0x2c:\n    case 0x2f:\n    case 0x3a:\n    case 0x3b:\n    case 0x3c:\n    case 0x3d:\n    case 0x3e:\n    case 0x3f:\n    case 0x40:\n    case 0x5b:\n    case 0x5c:\n    case 0x5d:\n    case 0x7b:\n    case 0x7d:\n      // DQUOTE and \"(),/:;<=>?@[\\]{}\"\n      return false;\n    default:\n      // VCHAR %x21-7E\n      return c >= 0x21 && c <= 0x7e;\n  }\n}\n\n/**\n * @param {string} characters\n */\nfunction isValidHTTPToken(characters) {\n  if (characters.length === 0) {\n    return false;\n  }\n  for (let i = 0; i < characters.length; ++i) {\n    if (!isTokenCharCode(characters.charCodeAt(i))) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-name\n * @param {string} potentialValue\n */\nfunction isValidHeaderName(potentialValue) {\n  return isValidHTTPToken(potentialValue);\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-value\n * @param {string} potentialValue\n */\nfunction isValidHeaderValue(potentialValue) {\n  // - Has no leading or trailing HTTP tab or space bytes.\n  // - Contains no 0x00 (NUL) or HTTP newline bytes.\n  if (potentialValue.startsWith('\\t') || potentialValue.startsWith(' ') || potentialValue.endsWith('\\t') || potentialValue.endsWith(' ')) {\n    return false;\n  }\n  if (potentialValue.includes('\\0') || potentialValue.includes('\\r') || potentialValue.includes('\\n')) {\n    return false;\n  }\n  return true;\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect\nfunction setRequestReferrerPolicyOnRedirect(request, actualResponse) {\n  //  Given a request request and a response actualResponse, this algorithm\n  //  updates request’s referrer policy according to the Referrer-Policy\n  //  header (if any) in actualResponse.\n\n  // 1. Let policy be the result of executing § 8.1 Parse a referrer policy\n  // from a Referrer-Policy header on actualResponse.\n\n  // 8.1 Parse a referrer policy from a Referrer-Policy header\n  // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy` and response’s header list.\n  const {\n    headersList\n  } = actualResponse;\n  // 2. Let policy be the empty string.\n  // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty string, then set policy to token.\n  // 4. Return policy.\n  const policyHeader = (headersList.get('referrer-policy') ?? '').split(',');\n\n  // Note: As the referrer-policy can contain multiple policies\n  // separated by comma, we need to loop through all of them\n  // and pick the first valid one.\n  // Ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy#specify_a_fallback_policy\n  let policy = '';\n  if (policyHeader.length > 0) {\n    // The right-most policy takes precedence.\n    // The left-most policy is the fallback.\n    for (let i = policyHeader.length; i !== 0; i--) {\n      const token = policyHeader[i - 1].trim();\n      if (referrerPolicyTokens.has(token)) {\n        policy = token;\n        break;\n      }\n    }\n  }\n\n  // 2. If policy is not the empty string, then set request’s referrer policy to policy.\n  if (policy !== '') {\n    request.referrerPolicy = policy;\n  }\n}\n\n// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check\nfunction crossOriginResourcePolicyCheck() {\n  // TODO\n  return 'allowed';\n}\n\n// https://fetch.spec.whatwg.org/#concept-cors-check\nfunction corsCheck() {\n  // TODO\n  return 'success';\n}\n\n// https://fetch.spec.whatwg.org/#concept-tao-check\nfunction TAOCheck() {\n  // TODO\n  return 'success';\n}\nfunction appendFetchMetadata(httpRequest) {\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header\n\n  //  1. Assert: r’s url is a potentially trustworthy URL.\n  //  TODO\n\n  //  2. Let header be a Structured Header whose value is a token.\n  let header = null;\n\n  //  3. Set header’s value to r’s mode.\n  header = httpRequest.mode;\n\n  //  4. Set a structured field value `Sec-Fetch-Mode`/header in r’s header list.\n  httpRequest.headersList.set('sec-fetch-mode', header);\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header\n  //  TODO\n}\n\n// https://fetch.spec.whatwg.org/#append-a-request-origin-header\nfunction appendRequestOriginHeader(request) {\n  // 1. Let serializedOrigin be the result of byte-serializing a request origin with request.\n  let serializedOrigin = request.origin;\n\n  // 2. If request’s response tainting is \"cors\" or request’s mode is \"websocket\", then append (`Origin`, serializedOrigin) to request’s header list.\n  if (request.responseTainting === 'cors' || request.mode === 'websocket') {\n    if (serializedOrigin) {\n      request.headersList.append('origin', serializedOrigin);\n    }\n\n    // 3. Otherwise, if request’s method is neither `GET` nor `HEAD`, then:\n  } else if (request.method !== 'GET' && request.method !== 'HEAD') {\n    // 1. Switch on request’s referrer policy:\n    switch (request.referrerPolicy) {\n      case 'no-referrer':\n        // Set serializedOrigin to `null`.\n        serializedOrigin = null;\n        break;\n      case 'no-referrer-when-downgrade':\n      case 'strict-origin':\n      case 'strict-origin-when-cross-origin':\n        // If request’s origin is a tuple origin, its scheme is \"https\", and request’s current URL’s scheme is not \"https\", then set serializedOrigin to `null`.\n        if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {\n          serializedOrigin = null;\n        }\n        break;\n      case 'same-origin':\n        // If request’s origin is not same origin with request’s current URL’s origin, then set serializedOrigin to `null`.\n        if (!sameOrigin(request, requestCurrentURL(request))) {\n          serializedOrigin = null;\n        }\n        break;\n      default:\n      // Do nothing.\n    }\n    if (serializedOrigin) {\n      // 2. Append (`Origin`, serializedOrigin) to request’s header list.\n      request.headersList.append('origin', serializedOrigin);\n    }\n  }\n}\nfunction coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {\n  // TODO\n  return performance.now();\n}\n\n// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info\nfunction createOpaqueTimingInfo(timingInfo) {\n  return {\n    startTime: timingInfo.startTime ?? 0,\n    redirectStartTime: 0,\n    redirectEndTime: 0,\n    postRedirectStartTime: timingInfo.startTime ?? 0,\n    finalServiceWorkerStartTime: 0,\n    finalNetworkResponseStartTime: 0,\n    finalNetworkRequestStartTime: 0,\n    endTime: 0,\n    encodedBodySize: 0,\n    decodedBodySize: 0,\n    finalConnectionTimingInfo: null\n  };\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#policy-container\nfunction makePolicyContainer() {\n  // Note: the fetch spec doesn't make use of embedder policy or CSP list\n  return {\n    referrerPolicy: 'strict-origin-when-cross-origin'\n  };\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container\nfunction clonePolicyContainer(policyContainer) {\n  return {\n    referrerPolicy: policyContainer.referrerPolicy\n  };\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer\nfunction determineRequestsReferrer(request) {\n  // 1. Let policy be request's referrer policy.\n  const policy = request.referrerPolicy;\n\n  // Note: policy cannot (shouldn't) be null or an empty string.\n  assert(policy);\n\n  // 2. Let environment be request’s client.\n\n  let referrerSource = null;\n\n  // 3. Switch on request’s referrer:\n  if (request.referrer === 'client') {\n    // Note: node isn't a browser and doesn't implement document/iframes,\n    // so we bypass this step and replace it with our own.\n\n    const globalOrigin = getGlobalOrigin();\n    if (!globalOrigin || globalOrigin.origin === 'null') {\n      return 'no-referrer';\n    }\n\n    // note: we need to clone it as it's mutated\n    referrerSource = new URL(globalOrigin);\n  } else if (request.referrer instanceof URL) {\n    // Let referrerSource be request’s referrer.\n    referrerSource = request.referrer;\n  }\n\n  // 4. Let request’s referrerURL be the result of stripping referrerSource for\n  //    use as a referrer.\n  let referrerURL = stripURLForReferrer(referrerSource);\n\n  // 5. Let referrerOrigin be the result of stripping referrerSource for use as\n  //    a referrer, with the origin-only flag set to true.\n  const referrerOrigin = stripURLForReferrer(referrerSource, true);\n\n  // 6. If the result of serializing referrerURL is a string whose length is\n  //    greater than 4096, set referrerURL to referrerOrigin.\n  if (referrerURL.toString().length > 4096) {\n    referrerURL = referrerOrigin;\n  }\n  const areSameOrigin = sameOrigin(request, referrerURL);\n  const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);\n\n  // 8. Execute the switch statements corresponding to the value of policy:\n  switch (policy) {\n    case 'origin':\n      return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);\n    case 'unsafe-url':\n      return referrerURL;\n    case 'same-origin':\n      return areSameOrigin ? referrerOrigin : 'no-referrer';\n    case 'origin-when-cross-origin':\n      return areSameOrigin ? referrerURL : referrerOrigin;\n    case 'strict-origin-when-cross-origin':\n      {\n        const currentURL = requestCurrentURL(request);\n\n        // 1. If the origin of referrerURL and the origin of request’s current\n        //    URL are the same, then return referrerURL.\n        if (sameOrigin(referrerURL, currentURL)) {\n          return referrerURL;\n        }\n\n        // 2. If referrerURL is a potentially trustworthy URL and request’s\n        //    current URL is not a potentially trustworthy URL, then return no\n        //    referrer.\n        if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {\n          return 'no-referrer';\n        }\n\n        // 3. Return referrerOrigin.\n        return referrerOrigin;\n      }\n    case 'strict-origin': // eslint-disable-line\n    /**\n       * 1. If referrerURL is a potentially trustworthy URL and\n       * request’s current URL is not a potentially trustworthy URL,\n       * then return no referrer.\n       * 2. Return referrerOrigin\n      */\n    case 'no-referrer-when-downgrade': // eslint-disable-line\n    /**\n     * 1. If referrerURL is a potentially trustworthy URL and\n     * request’s current URL is not a potentially trustworthy URL,\n     * then return no referrer.\n     * 2. Return referrerOrigin\n    */\n\n    default:\n      // eslint-disable-line\n      return isNonPotentiallyTrustWorthy ? 'no-referrer' : referrerOrigin;\n  }\n}\n\n/**\n * @see https://w3c.github.io/webappsec-referrer-policy/#strip-url\n * @param {URL} url\n * @param {boolean|undefined} originOnly\n */\nfunction stripURLForReferrer(url, originOnly) {\n  // 1. Assert: url is a URL.\n  assert(url instanceof URL);\n\n  // 2. If url’s scheme is a local scheme, then return no referrer.\n  if (url.protocol === 'file:' || url.protocol === 'about:' || url.protocol === 'blank:') {\n    return 'no-referrer';\n  }\n\n  // 3. Set url’s username to the empty string.\n  url.username = '';\n\n  // 4. Set url’s password to the empty string.\n  url.password = '';\n\n  // 5. Set url’s fragment to null.\n  url.hash = '';\n\n  // 6. If the origin-only flag is true, then:\n  if (originOnly) {\n    // 1. Set url’s path to « the empty string ».\n    url.pathname = '';\n\n    // 2. Set url’s query to null.\n    url.search = '';\n  }\n\n  // 7. Return url.\n  return url;\n}\nfunction isURLPotentiallyTrustworthy(url) {\n  if (!(url instanceof URL)) {\n    return false;\n  }\n\n  // If child of about, return true\n  if (url.href === 'about:blank' || url.href === 'about:srcdoc') {\n    return true;\n  }\n\n  // If scheme is data, return true\n  if (url.protocol === 'data:') return true;\n\n  // If file, return true\n  if (url.protocol === 'file:') return true;\n  return isOriginPotentiallyTrustworthy(url.origin);\n  function isOriginPotentiallyTrustworthy(origin) {\n    // If origin is explicitly null, return false\n    if (origin == null || origin === 'null') return false;\n    const originAsURL = new URL(origin);\n\n    // If secure, return true\n    if (originAsURL.protocol === 'https:' || originAsURL.protocol === 'wss:') {\n      return true;\n    }\n\n    // If localhost or variants, return true\n    if (/^127(?:\\.[0-9]+){0,2}\\.[0-9]+$|^\\[(?:0*:)*?:?0*1\\]$/.test(originAsURL.hostname) || originAsURL.hostname === 'localhost' || originAsURL.hostname.includes('localhost.') || originAsURL.hostname.endsWith('.localhost')) {\n      return true;\n    }\n\n    // If any other, return false\n    return false;\n  }\n}\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist\n * @param {Uint8Array} bytes\n * @param {string} metadataList\n */\nfunction bytesMatch(bytes, metadataList) {\n  // If node is not built with OpenSSL support, we cannot check\n  // a request's integrity, so allow it by default (the spec will\n  // allow requests if an invalid hash is given, as precedence).\n  /* istanbul ignore if: only if node is built with --without-ssl */\n  if (crypto === undefined) {\n    return true;\n  }\n\n  // 1. Let parsedMetadata be the result of parsing metadataList.\n  const parsedMetadata = parseMetadata(metadataList);\n\n  // 2. If parsedMetadata is no metadata, return true.\n  if (parsedMetadata === 'no metadata') {\n    return true;\n  }\n\n  // 3. If parsedMetadata is the empty set, return true.\n  if (parsedMetadata.length === 0) {\n    return true;\n  }\n\n  // 4. Let metadata be the result of getting the strongest\n  //    metadata from parsedMetadata.\n  const list = parsedMetadata.sort((c, d) => d.algo.localeCompare(c.algo));\n  // get the strongest algorithm\n  const strongest = list[0].algo;\n  // get all entries that use the strongest algorithm; ignore weaker\n  const metadata = list.filter(item => item.algo === strongest);\n\n  // 5. For each item in metadata:\n  for (const item of metadata) {\n    // 1. Let algorithm be the alg component of item.\n    const algorithm = item.algo;\n\n    // 2. Let expectedValue be the val component of item.\n    let expectedValue = item.hash;\n\n    // See https://github.com/web-platform-tests/wpt/commit/e4c5cc7a5e48093220528dfdd1c4012dc3837a0e\n    // \"be liberal with padding\". This is annoying, and it's not even in the spec.\n\n    if (expectedValue.endsWith('==')) {\n      expectedValue = expectedValue.slice(0, -2);\n    }\n\n    // 3. Let actualValue be the result of applying algorithm to bytes.\n    let actualValue = crypto.createHash(algorithm).update(bytes).digest('base64');\n    if (actualValue.endsWith('==')) {\n      actualValue = actualValue.slice(0, -2);\n    }\n\n    // 4. If actualValue is a case-sensitive match for expectedValue,\n    //    return true.\n    if (actualValue === expectedValue) {\n      return true;\n    }\n    let actualBase64URL = crypto.createHash(algorithm).update(bytes).digest('base64url');\n    if (actualBase64URL.endsWith('==')) {\n      actualBase64URL = actualBase64URL.slice(0, -2);\n    }\n    if (actualBase64URL === expectedValue) {\n      return true;\n    }\n  }\n\n  // 6. Return false.\n  return false;\n}\n\n// https://w3c.github.io/webappsec-subresource-integrity/#grammardef-hash-with-options\n// https://www.w3.org/TR/CSP2/#source-list-syntax\n// https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1\nconst parseHashWithOptions = /((?<algo>sha256|sha384|sha512)-(?<hash>[A-z0-9+/]{1}.*={0,2}))( +[\\x21-\\x7e]?)?/i;\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n * @param {string} metadata\n */\nfunction parseMetadata(metadata) {\n  // 1. Let result be the empty set.\n  /** @type {{ algo: string, hash: string }[]} */\n  const result = [];\n\n  // 2. Let empty be equal to true.\n  let empty = true;\n  const supportedHashes = crypto.getHashes();\n\n  // 3. For each token returned by splitting metadata on spaces:\n  for (const token of metadata.split(' ')) {\n    // 1. Set empty to false.\n    empty = false;\n\n    // 2. Parse token as a hash-with-options.\n    const parsedToken = parseHashWithOptions.exec(token);\n\n    // 3. If token does not parse, continue to the next token.\n    if (parsedToken === null || parsedToken.groups === undefined) {\n      // Note: Chromium blocks the request at this point, but Firefox\n      // gives a warning that an invalid integrity was given. The\n      // correct behavior is to ignore these, and subsequently not\n      // check the integrity of the resource.\n      continue;\n    }\n\n    // 4. Let algorithm be the hash-algo component of token.\n    const algorithm = parsedToken.groups.algo;\n\n    // 5. If algorithm is a hash function recognized by the user\n    //    agent, add the parsed token to result.\n    if (supportedHashes.includes(algorithm.toLowerCase())) {\n      result.push(parsedToken.groups);\n    }\n  }\n\n  // 4. Return no metadata if empty is true, otherwise return result.\n  if (empty === true) {\n    return 'no metadata';\n  }\n  return result;\n}\n\n// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request\nfunction tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {\n  // TODO\n}\n\n/**\n * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}\n * @param {URL} A\n * @param {URL} B\n */\nfunction sameOrigin(A, B) {\n  // 1. If A and B are the same opaque origin, then return true.\n  if (A.origin === B.origin && A.origin === 'null') {\n    return true;\n  }\n\n  // 2. If A and B are both tuple origins and their schemes,\n  //    hosts, and port are identical, then return true.\n  if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {\n    return true;\n  }\n\n  // 3. Return false.\n  return false;\n}\nfunction createDeferredPromise() {\n  let res;\n  let rej;\n  const promise = new Promise((resolve, reject) => {\n    res = resolve;\n    rej = reject;\n  });\n  return {\n    promise,\n    resolve: res,\n    reject: rej\n  };\n}\nfunction isAborted(fetchParams) {\n  return fetchParams.controller.state === 'aborted';\n}\nfunction isCancelled(fetchParams) {\n  return fetchParams.controller.state === 'aborted' || fetchParams.controller.state === 'terminated';\n}\nconst normalizeMethodRecord = {\n  delete: 'DELETE',\n  DELETE: 'DELETE',\n  get: 'GET',\n  GET: 'GET',\n  head: 'HEAD',\n  HEAD: 'HEAD',\n  options: 'OPTIONS',\n  OPTIONS: 'OPTIONS',\n  post: 'POST',\n  POST: 'POST',\n  put: 'PUT',\n  PUT: 'PUT'\n};\n\n// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.\nObject.setPrototypeOf(normalizeMethodRecord, null);\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-method-normalize\n * @param {string} method\n */\nfunction normalizeMethod(method) {\n  return normalizeMethodRecord[method.toLowerCase()] ?? method;\n}\n\n// https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string\nfunction serializeJavascriptValueToJSONString(value) {\n  // 1. Let result be ? Call(%JSON.stringify%, undefined, « value »).\n  const result = JSON.stringify(value);\n\n  // 2. If result is undefined, then throw a TypeError.\n  if (result === undefined) {\n    throw new TypeError('Value is not JSON serializable');\n  }\n\n  // 3. Assert: result is a string.\n  assert(typeof result === 'string');\n\n  // 4. Return result.\n  return result;\n}\n\n// https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object\nconst esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));\n\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {() => unknown[]} iterator\n * @param {string} name name of the instance\n * @param {'key'|'value'|'key+value'} kind\n */\nfunction makeIterator(iterator, name, kind) {\n  const object = {\n    index: 0,\n    kind,\n    target: iterator\n  };\n  const i = {\n    next() {\n      // 1. Let interface be the interface for which the iterator prototype object exists.\n\n      // 2. Let thisValue be the this value.\n\n      // 3. Let object be ? ToObject(thisValue).\n\n      // 4. If object is a platform object, then perform a security\n      //    check, passing:\n\n      // 5. If object is not a default iterator object for interface,\n      //    then throw a TypeError.\n      if (Object.getPrototypeOf(this) !== i) {\n        throw new TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);\n      }\n\n      // 6. Let index be object’s index.\n      // 7. Let kind be object’s kind.\n      // 8. Let values be object’s target's value pairs to iterate over.\n      const {\n        index,\n        kind,\n        target\n      } = object;\n      const values = target();\n\n      // 9. Let len be the length of values.\n      const len = values.length;\n\n      // 10. If index is greater than or equal to len, then return\n      //     CreateIterResultObject(undefined, true).\n      if (index >= len) {\n        return {\n          value: undefined,\n          done: true\n        };\n      }\n\n      // 11. Let pair be the entry in values at index index.\n      const pair = values[index];\n\n      // 12. Set object’s index to index + 1.\n      object.index = index + 1;\n\n      // 13. Return the iterator result for pair and kind.\n      return iteratorResult(pair, kind);\n    },\n    // The class string of an iterator prototype object for a given interface is the\n    // result of concatenating the identifier of the interface and the string \" Iterator\".\n    [Symbol.toStringTag]: `${name} Iterator`\n  };\n\n  // The [[Prototype]] internal slot of an iterator prototype object must be %IteratorPrototype%.\n  Object.setPrototypeOf(i, esIteratorPrototype);\n  // esIteratorPrototype needs to be the prototype of i\n  // which is the prototype of an empty object. Yes, it's confusing.\n  return Object.setPrototypeOf({}, i);\n}\n\n// https://webidl.spec.whatwg.org/#iterator-result\nfunction iteratorResult(pair, kind) {\n  let result;\n\n  // 1. Let result be a value determined by the value of kind:\n  switch (kind) {\n    case 'key':\n      {\n        // 1. Let idlKey be pair’s key.\n        // 2. Let key be the result of converting idlKey to an\n        //    ECMAScript value.\n        // 3. result is key.\n        result = pair[0];\n        break;\n      }\n    case 'value':\n      {\n        // 1. Let idlValue be pair’s value.\n        // 2. Let value be the result of converting idlValue to\n        //    an ECMAScript value.\n        // 3. result is value.\n        result = pair[1];\n        break;\n      }\n    case 'key+value':\n      {\n        // 1. Let idlKey be pair’s key.\n        // 2. Let idlValue be pair’s value.\n        // 3. Let key be the result of converting idlKey to an\n        //    ECMAScript value.\n        // 4. Let value be the result of converting idlValue to\n        //    an ECMAScript value.\n        // 5. Let array be ! ArrayCreate(2).\n        // 6. Call ! CreateDataProperty(array, \"0\", key).\n        // 7. Call ! CreateDataProperty(array, \"1\", value).\n        // 8. result is array.\n        result = pair;\n        break;\n      }\n  }\n\n  // 2. Return CreateIterResultObject(result, false).\n  return {\n    value: result,\n    done: false\n  };\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#body-fully-read\n */\nasync function fullyReadBody(body, processBody, processBodyError) {\n  // 1. If taskDestination is null, then set taskDestination to\n  //    the result of starting a new parallel queue.\n\n  // 2. Let successSteps given a byte sequence bytes be to queue a\n  //    fetch task to run processBody given bytes, with taskDestination.\n  const successSteps = processBody;\n\n  // 3. Let errorSteps be to queue a fetch task to run processBodyError,\n  //    with taskDestination.\n  const errorSteps = processBodyError;\n\n  // 4. Let reader be the result of getting a reader for body’s stream.\n  //    If that threw an exception, then run errorSteps with that\n  //    exception and return.\n  let reader;\n  try {\n    reader = body.stream.getReader();\n  } catch (e) {\n    errorSteps(e);\n    return;\n  }\n\n  // 5. Read all bytes from reader, given successSteps and errorSteps.\n  try {\n    const result = await readAllBytes(reader);\n    successSteps(result);\n  } catch (e) {\n    errorSteps(e);\n  }\n}\n\n/** @type {ReadableStream} */\nlet ReadableStream = globalThis.ReadableStream;\nfunction isReadableStreamLike(stream) {\n  if (!ReadableStream) {\n    ReadableStream = require('stream/web').ReadableStream;\n  }\n  return stream instanceof ReadableStream || stream[Symbol.toStringTag] === 'ReadableStream' && typeof stream.tee === 'function';\n}\nconst MAXIMUM_ARGUMENT_LENGTH = 65535;\n\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-decode\n * @param {number[]|Uint8Array} input\n */\nfunction isomorphicDecode(input) {\n  // 1. To isomorphic decode a byte sequence input, return a string whose code point\n  //    length is equal to input’s length and whose code points have the same values\n  //    as the values of input’s bytes, in the same order.\n\n  if (input.length < MAXIMUM_ARGUMENT_LENGTH) {\n    return String.fromCharCode(...input);\n  }\n  return input.reduce((previous, current) => previous + String.fromCharCode(current), '');\n}\n\n/**\n * @param {ReadableStreamController<Uint8Array>} controller\n */\nfunction readableStreamClose(controller) {\n  try {\n    controller.close();\n  } catch (err) {\n    // TODO: add comment explaining why this error occurs.\n    if (!err.message.includes('Controller is already closed')) {\n      throw err;\n    }\n  }\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-encode\n * @param {string} input\n */\nfunction isomorphicEncode(input) {\n  // 1. Assert: input contains no code points greater than U+00FF.\n  for (let i = 0; i < input.length; i++) {\n    assert(input.charCodeAt(i) <= 0xFF);\n  }\n\n  // 2. Return a byte sequence whose length is equal to input’s code\n  //    point length and whose bytes have the same values as the\n  //    values of input’s code points, in the same order\n  return input;\n}\n\n/**\n * @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes\n * @see https://streams.spec.whatwg.org/#read-loop\n * @param {ReadableStreamDefaultReader} reader\n */\nasync function readAllBytes(reader) {\n  const bytes = [];\n  let byteLength = 0;\n  while (true) {\n    const {\n      done,\n      value: chunk\n    } = await reader.read();\n    if (done) {\n      // 1. Call successSteps with bytes.\n      return Buffer.concat(bytes, byteLength);\n    }\n\n    // 1. If chunk is not a Uint8Array object, call failureSteps\n    //    with a TypeError and abort these steps.\n    if (!isUint8Array(chunk)) {\n      throw new TypeError('Received non-Uint8Array chunk');\n    }\n\n    // 2. Append the bytes represented by chunk to bytes.\n    bytes.push(chunk);\n    byteLength += chunk.length;\n\n    // 3. Read-loop given reader, bytes, successSteps, and failureSteps.\n  }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#is-local\n * @param {URL} url\n */\nfunction urlIsLocal(url) {\n  assert('protocol' in url); // ensure it's a url object\n\n  const protocol = url.protocol;\n  return protocol === 'about:' || protocol === 'blob:' || protocol === 'data:';\n}\n\n/**\n * @param {string|URL} url\n */\nfunction urlHasHttpsScheme(url) {\n  if (typeof url === 'string') {\n    return url.startsWith('https:');\n  }\n  return url.protocol === 'https:';\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-scheme\n * @param {URL} url\n */\nfunction urlIsHttpHttpsScheme(url) {\n  assert('protocol' in url); // ensure it's a url object\n\n  const protocol = url.protocol;\n  return protocol === 'http:' || protocol === 'https:';\n}\n\n/**\n * Fetch supports node >= 16.8.0, but Object.hasOwn was added in v16.9.0.\n */\nconst hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));\nmodule.exports = {\n  isAborted,\n  isCancelled,\n  createDeferredPromise,\n  ReadableStreamFrom,\n  toUSVString,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  coarsenedSharedCurrentTime,\n  determineRequestsReferrer,\n  makePolicyContainer,\n  clonePolicyContainer,\n  appendFetchMetadata,\n  appendRequestOriginHeader,\n  TAOCheck,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  createOpaqueTimingInfo,\n  setRequestReferrerPolicyOnRedirect,\n  isValidHTTPToken,\n  requestBadPort,\n  requestCurrentURL,\n  responseURL,\n  responseLocationURL,\n  isBlobLike,\n  isURLPotentiallyTrustworthy,\n  isValidReasonPhrase,\n  sameOrigin,\n  normalizeMethod,\n  serializeJavascriptValueToJSONString,\n  makeIterator,\n  isValidHeaderName,\n  isValidHeaderValue,\n  hasOwn,\n  isErrorLike,\n  fullyReadBody,\n  bytesMatch,\n  isReadableStreamLike,\n  readableStreamClose,\n  isomorphicEncode,\n  isomorphicDecode,\n  urlIsLocal,\n  urlHasHttpsScheme,\n  urlIsHttpHttpsScheme,\n  readAllBytes,\n  normalizeMethodRecord\n};","map":{"version":3,"names":["redirectStatusSet","referrerPolicySet","referrerPolicyTokens","badPortsSet","require","getGlobalOrigin","performance","isBlobLike","toUSVString","ReadableStreamFrom","assert","isUint8Array","crypto","responseURL","response","urlList","length","toString","responseLocationURL","requestFragment","has","status","location","headersList","get","isValidHeaderValue","URL","hash","requestCurrentURL","request","requestBadPort","url","urlIsHttpHttpsScheme","port","isErrorLike","object","Error","constructor","name","isValidReasonPhrase","statusText","i","c","charCodeAt","isTokenCharCode","isValidHTTPToken","characters","isValidHeaderName","potentialValue","startsWith","endsWith","includes","setRequestReferrerPolicyOnRedirect","actualResponse","policyHeader","split","policy","token","trim","referrerPolicy","crossOriginResourcePolicyCheck","corsCheck","TAOCheck","appendFetchMetadata","httpRequest","header","mode","set","appendRequestOriginHeader","serializedOrigin","origin","responseTainting","append","method","urlHasHttpsScheme","sameOrigin","coarsenedSharedCurrentTime","crossOriginIsolatedCapability","now","createOpaqueTimingInfo","timingInfo","startTime","redirectStartTime","redirectEndTime","postRedirectStartTime","finalServiceWorkerStartTime","finalNetworkResponseStartTime","finalNetworkRequestStartTime","endTime","encodedBodySize","decodedBodySize","finalConnectionTimingInfo","makePolicyContainer","clonePolicyContainer","policyContainer","determineRequestsReferrer","referrerSource","referrer","globalOrigin","referrerURL","stripURLForReferrer","referrerOrigin","areSameOrigin","isNonPotentiallyTrustWorthy","isURLPotentiallyTrustworthy","currentURL","originOnly","protocol","username","password","pathname","search","href","isOriginPotentiallyTrustworthy","originAsURL","test","hostname","bytesMatch","bytes","metadataList","undefined","parsedMetadata","parseMetadata","list","sort","d","algo","localeCompare","strongest","metadata","filter","item","algorithm","expectedValue","slice","actualValue","createHash","update","digest","actualBase64URL","parseHashWithOptions","result","empty","supportedHashes","getHashes","parsedToken","exec","groups","toLowerCase","push","tryUpgradeRequestToAPotentiallyTrustworthyURL","A","B","createDeferredPromise","res","rej","promise","Promise","resolve","reject","isAborted","fetchParams","controller","state","isCancelled","normalizeMethodRecord","delete","DELETE","GET","head","HEAD","options","OPTIONS","post","POST","put","PUT","Object","setPrototypeOf","normalizeMethod","serializeJavascriptValueToJSONString","value","JSON","stringify","TypeError","esIteratorPrototype","getPrototypeOf","Symbol","iterator","makeIterator","kind","index","target","next","values","len","done","pair","iteratorResult","toStringTag","fullyReadBody","body","processBody","processBodyError","successSteps","errorSteps","reader","stream","getReader","e","readAllBytes","ReadableStream","globalThis","isReadableStreamLike","tee","MAXIMUM_ARGUMENT_LENGTH","isomorphicDecode","input","String","fromCharCode","reduce","previous","current","readableStreamClose","close","err","message","isomorphicEncode","byteLength","chunk","read","Buffer","concat","urlIsLocal","hasOwn","dict","key","prototype","hasOwnProperty","call","module","exports"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/undici/lib/fetch/util.js"],"sourcesContent":["'use strict'\n\nconst { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = require('./constants')\nconst { getGlobalOrigin } = require('./global')\nconst { performance } = require('perf_hooks')\nconst { isBlobLike, toUSVString, ReadableStreamFrom } = require('../core/util')\nconst assert = require('assert')\nconst { isUint8Array } = require('util/types')\n\n// https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable\n/** @type {import('crypto')|undefined} */\nlet crypto\n\ntry {\n  crypto = require('crypto')\n} catch {\n\n}\n\nfunction responseURL (response) {\n  // https://fetch.spec.whatwg.org/#responses\n  // A response has an associated URL. It is a pointer to the last URL\n  // in response’s URL list and null if response’s URL list is empty.\n  const urlList = response.urlList\n  const length = urlList.length\n  return length === 0 ? null : urlList[length - 1].toString()\n}\n\n// https://fetch.spec.whatwg.org/#concept-response-location-url\nfunction responseLocationURL (response, requestFragment) {\n  // 1. If response’s status is not a redirect status, then return null.\n  if (!redirectStatusSet.has(response.status)) {\n    return null\n  }\n\n  // 2. Let location be the result of extracting header list values given\n  // `Location` and response’s header list.\n  let location = response.headersList.get('location')\n\n  // 3. If location is a header value, then set location to the result of\n  //    parsing location with response’s URL.\n  if (location !== null && isValidHeaderValue(location)) {\n    location = new URL(location, responseURL(response))\n  }\n\n  // 4. If location is a URL whose fragment is null, then set location’s\n  // fragment to requestFragment.\n  if (location && !location.hash) {\n    location.hash = requestFragment\n  }\n\n  // 5. Return location.\n  return location\n}\n\n/** @returns {URL} */\nfunction requestCurrentURL (request) {\n  return request.urlList[request.urlList.length - 1]\n}\n\nfunction requestBadPort (request) {\n  // 1. Let url be request’s current URL.\n  const url = requestCurrentURL(request)\n\n  // 2. If url’s scheme is an HTTP(S) scheme and url’s port is a bad port,\n  // then return blocked.\n  if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {\n    return 'blocked'\n  }\n\n  // 3. Return allowed.\n  return 'allowed'\n}\n\nfunction isErrorLike (object) {\n  return object instanceof Error || (\n    object?.constructor?.name === 'Error' ||\n    object?.constructor?.name === 'DOMException'\n  )\n}\n\n// Check whether |statusText| is a ByteString and\n// matches the Reason-Phrase token production.\n// RFC 2616: https://tools.ietf.org/html/rfc2616\n// RFC 7230: https://tools.ietf.org/html/rfc7230\n// \"reason-phrase = *( HTAB / SP / VCHAR / obs-text )\"\n// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116\nfunction isValidReasonPhrase (statusText) {\n  for (let i = 0; i < statusText.length; ++i) {\n    const c = statusText.charCodeAt(i)\n    if (\n      !(\n        (\n          c === 0x09 || // HTAB\n          (c >= 0x20 && c <= 0x7e) || // SP / VCHAR\n          (c >= 0x80 && c <= 0xff)\n        ) // obs-text\n      )\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * @see https://tools.ietf.org/html/rfc7230#section-3.2.6\n * @param {number} c\n */\nfunction isTokenCharCode (c) {\n  switch (c) {\n    case 0x22:\n    case 0x28:\n    case 0x29:\n    case 0x2c:\n    case 0x2f:\n    case 0x3a:\n    case 0x3b:\n    case 0x3c:\n    case 0x3d:\n    case 0x3e:\n    case 0x3f:\n    case 0x40:\n    case 0x5b:\n    case 0x5c:\n    case 0x5d:\n    case 0x7b:\n    case 0x7d:\n      // DQUOTE and \"(),/:;<=>?@[\\]{}\"\n      return false\n    default:\n      // VCHAR %x21-7E\n      return c >= 0x21 && c <= 0x7e\n  }\n}\n\n/**\n * @param {string} characters\n */\nfunction isValidHTTPToken (characters) {\n  if (characters.length === 0) {\n    return false\n  }\n  for (let i = 0; i < characters.length; ++i) {\n    if (!isTokenCharCode(characters.charCodeAt(i))) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-name\n * @param {string} potentialValue\n */\nfunction isValidHeaderName (potentialValue) {\n  return isValidHTTPToken(potentialValue)\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-value\n * @param {string} potentialValue\n */\nfunction isValidHeaderValue (potentialValue) {\n  // - Has no leading or trailing HTTP tab or space bytes.\n  // - Contains no 0x00 (NUL) or HTTP newline bytes.\n  if (\n    potentialValue.startsWith('\\t') ||\n    potentialValue.startsWith(' ') ||\n    potentialValue.endsWith('\\t') ||\n    potentialValue.endsWith(' ')\n  ) {\n    return false\n  }\n\n  if (\n    potentialValue.includes('\\0') ||\n    potentialValue.includes('\\r') ||\n    potentialValue.includes('\\n')\n  ) {\n    return false\n  }\n\n  return true\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect\nfunction setRequestReferrerPolicyOnRedirect (request, actualResponse) {\n  //  Given a request request and a response actualResponse, this algorithm\n  //  updates request’s referrer policy according to the Referrer-Policy\n  //  header (if any) in actualResponse.\n\n  // 1. Let policy be the result of executing § 8.1 Parse a referrer policy\n  // from a Referrer-Policy header on actualResponse.\n\n  // 8.1 Parse a referrer policy from a Referrer-Policy header\n  // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy` and response’s header list.\n  const { headersList } = actualResponse\n  // 2. Let policy be the empty string.\n  // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty string, then set policy to token.\n  // 4. Return policy.\n  const policyHeader = (headersList.get('referrer-policy') ?? '').split(',')\n\n  // Note: As the referrer-policy can contain multiple policies\n  // separated by comma, we need to loop through all of them\n  // and pick the first valid one.\n  // Ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy#specify_a_fallback_policy\n  let policy = ''\n  if (policyHeader.length > 0) {\n    // The right-most policy takes precedence.\n    // The left-most policy is the fallback.\n    for (let i = policyHeader.length; i !== 0; i--) {\n      const token = policyHeader[i - 1].trim()\n      if (referrerPolicyTokens.has(token)) {\n        policy = token\n        break\n      }\n    }\n  }\n\n  // 2. If policy is not the empty string, then set request’s referrer policy to policy.\n  if (policy !== '') {\n    request.referrerPolicy = policy\n  }\n}\n\n// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check\nfunction crossOriginResourcePolicyCheck () {\n  // TODO\n  return 'allowed'\n}\n\n// https://fetch.spec.whatwg.org/#concept-cors-check\nfunction corsCheck () {\n  // TODO\n  return 'success'\n}\n\n// https://fetch.spec.whatwg.org/#concept-tao-check\nfunction TAOCheck () {\n  // TODO\n  return 'success'\n}\n\nfunction appendFetchMetadata (httpRequest) {\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header\n\n  //  1. Assert: r’s url is a potentially trustworthy URL.\n  //  TODO\n\n  //  2. Let header be a Structured Header whose value is a token.\n  let header = null\n\n  //  3. Set header’s value to r’s mode.\n  header = httpRequest.mode\n\n  //  4. Set a structured field value `Sec-Fetch-Mode`/header in r’s header list.\n  httpRequest.headersList.set('sec-fetch-mode', header)\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header\n  //  TODO\n}\n\n// https://fetch.spec.whatwg.org/#append-a-request-origin-header\nfunction appendRequestOriginHeader (request) {\n  // 1. Let serializedOrigin be the result of byte-serializing a request origin with request.\n  let serializedOrigin = request.origin\n\n  // 2. If request’s response tainting is \"cors\" or request’s mode is \"websocket\", then append (`Origin`, serializedOrigin) to request’s header list.\n  if (request.responseTainting === 'cors' || request.mode === 'websocket') {\n    if (serializedOrigin) {\n      request.headersList.append('origin', serializedOrigin)\n    }\n\n  // 3. Otherwise, if request’s method is neither `GET` nor `HEAD`, then:\n  } else if (request.method !== 'GET' && request.method !== 'HEAD') {\n    // 1. Switch on request’s referrer policy:\n    switch (request.referrerPolicy) {\n      case 'no-referrer':\n        // Set serializedOrigin to `null`.\n        serializedOrigin = null\n        break\n      case 'no-referrer-when-downgrade':\n      case 'strict-origin':\n      case 'strict-origin-when-cross-origin':\n        // If request’s origin is a tuple origin, its scheme is \"https\", and request’s current URL’s scheme is not \"https\", then set serializedOrigin to `null`.\n        if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      case 'same-origin':\n        // If request’s origin is not same origin with request’s current URL’s origin, then set serializedOrigin to `null`.\n        if (!sameOrigin(request, requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      default:\n        // Do nothing.\n    }\n\n    if (serializedOrigin) {\n      // 2. Append (`Origin`, serializedOrigin) to request’s header list.\n      request.headersList.append('origin', serializedOrigin)\n    }\n  }\n}\n\nfunction coarsenedSharedCurrentTime (crossOriginIsolatedCapability) {\n  // TODO\n  return performance.now()\n}\n\n// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info\nfunction createOpaqueTimingInfo (timingInfo) {\n  return {\n    startTime: timingInfo.startTime ?? 0,\n    redirectStartTime: 0,\n    redirectEndTime: 0,\n    postRedirectStartTime: timingInfo.startTime ?? 0,\n    finalServiceWorkerStartTime: 0,\n    finalNetworkResponseStartTime: 0,\n    finalNetworkRequestStartTime: 0,\n    endTime: 0,\n    encodedBodySize: 0,\n    decodedBodySize: 0,\n    finalConnectionTimingInfo: null\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#policy-container\nfunction makePolicyContainer () {\n  // Note: the fetch spec doesn't make use of embedder policy or CSP list\n  return {\n    referrerPolicy: 'strict-origin-when-cross-origin'\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container\nfunction clonePolicyContainer (policyContainer) {\n  return {\n    referrerPolicy: policyContainer.referrerPolicy\n  }\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer\nfunction determineRequestsReferrer (request) {\n  // 1. Let policy be request's referrer policy.\n  const policy = request.referrerPolicy\n\n  // Note: policy cannot (shouldn't) be null or an empty string.\n  assert(policy)\n\n  // 2. Let environment be request’s client.\n\n  let referrerSource = null\n\n  // 3. Switch on request’s referrer:\n  if (request.referrer === 'client') {\n    // Note: node isn't a browser and doesn't implement document/iframes,\n    // so we bypass this step and replace it with our own.\n\n    const globalOrigin = getGlobalOrigin()\n\n    if (!globalOrigin || globalOrigin.origin === 'null') {\n      return 'no-referrer'\n    }\n\n    // note: we need to clone it as it's mutated\n    referrerSource = new URL(globalOrigin)\n  } else if (request.referrer instanceof URL) {\n    // Let referrerSource be request’s referrer.\n    referrerSource = request.referrer\n  }\n\n  // 4. Let request’s referrerURL be the result of stripping referrerSource for\n  //    use as a referrer.\n  let referrerURL = stripURLForReferrer(referrerSource)\n\n  // 5. Let referrerOrigin be the result of stripping referrerSource for use as\n  //    a referrer, with the origin-only flag set to true.\n  const referrerOrigin = stripURLForReferrer(referrerSource, true)\n\n  // 6. If the result of serializing referrerURL is a string whose length is\n  //    greater than 4096, set referrerURL to referrerOrigin.\n  if (referrerURL.toString().length > 4096) {\n    referrerURL = referrerOrigin\n  }\n\n  const areSameOrigin = sameOrigin(request, referrerURL)\n  const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) &&\n    !isURLPotentiallyTrustworthy(request.url)\n\n  // 8. Execute the switch statements corresponding to the value of policy:\n  switch (policy) {\n    case 'origin': return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true)\n    case 'unsafe-url': return referrerURL\n    case 'same-origin':\n      return areSameOrigin ? referrerOrigin : 'no-referrer'\n    case 'origin-when-cross-origin':\n      return areSameOrigin ? referrerURL : referrerOrigin\n    case 'strict-origin-when-cross-origin': {\n      const currentURL = requestCurrentURL(request)\n\n      // 1. If the origin of referrerURL and the origin of request’s current\n      //    URL are the same, then return referrerURL.\n      if (sameOrigin(referrerURL, currentURL)) {\n        return referrerURL\n      }\n\n      // 2. If referrerURL is a potentially trustworthy URL and request’s\n      //    current URL is not a potentially trustworthy URL, then return no\n      //    referrer.\n      if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {\n        return 'no-referrer'\n      }\n\n      // 3. Return referrerOrigin.\n      return referrerOrigin\n    }\n    case 'strict-origin': // eslint-disable-line\n      /**\n         * 1. If referrerURL is a potentially trustworthy URL and\n         * request’s current URL is not a potentially trustworthy URL,\n         * then return no referrer.\n         * 2. Return referrerOrigin\n        */\n    case 'no-referrer-when-downgrade': // eslint-disable-line\n      /**\n       * 1. If referrerURL is a potentially trustworthy URL and\n       * request’s current URL is not a potentially trustworthy URL,\n       * then return no referrer.\n       * 2. Return referrerOrigin\n      */\n\n    default: // eslint-disable-line\n      return isNonPotentiallyTrustWorthy ? 'no-referrer' : referrerOrigin\n  }\n}\n\n/**\n * @see https://w3c.github.io/webappsec-referrer-policy/#strip-url\n * @param {URL} url\n * @param {boolean|undefined} originOnly\n */\nfunction stripURLForReferrer (url, originOnly) {\n  // 1. Assert: url is a URL.\n  assert(url instanceof URL)\n\n  // 2. If url’s scheme is a local scheme, then return no referrer.\n  if (url.protocol === 'file:' || url.protocol === 'about:' || url.protocol === 'blank:') {\n    return 'no-referrer'\n  }\n\n  // 3. Set url’s username to the empty string.\n  url.username = ''\n\n  // 4. Set url’s password to the empty string.\n  url.password = ''\n\n  // 5. Set url’s fragment to null.\n  url.hash = ''\n\n  // 6. If the origin-only flag is true, then:\n  if (originOnly) {\n    // 1. Set url’s path to « the empty string ».\n    url.pathname = ''\n\n    // 2. Set url’s query to null.\n    url.search = ''\n  }\n\n  // 7. Return url.\n  return url\n}\n\nfunction isURLPotentiallyTrustworthy (url) {\n  if (!(url instanceof URL)) {\n    return false\n  }\n\n  // If child of about, return true\n  if (url.href === 'about:blank' || url.href === 'about:srcdoc') {\n    return true\n  }\n\n  // If scheme is data, return true\n  if (url.protocol === 'data:') return true\n\n  // If file, return true\n  if (url.protocol === 'file:') return true\n\n  return isOriginPotentiallyTrustworthy(url.origin)\n\n  function isOriginPotentiallyTrustworthy (origin) {\n    // If origin is explicitly null, return false\n    if (origin == null || origin === 'null') return false\n\n    const originAsURL = new URL(origin)\n\n    // If secure, return true\n    if (originAsURL.protocol === 'https:' || originAsURL.protocol === 'wss:') {\n      return true\n    }\n\n    // If localhost or variants, return true\n    if (/^127(?:\\.[0-9]+){0,2}\\.[0-9]+$|^\\[(?:0*:)*?:?0*1\\]$/.test(originAsURL.hostname) ||\n     (originAsURL.hostname === 'localhost' || originAsURL.hostname.includes('localhost.')) ||\n     (originAsURL.hostname.endsWith('.localhost'))) {\n      return true\n    }\n\n    // If any other, return false\n    return false\n  }\n}\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist\n * @param {Uint8Array} bytes\n * @param {string} metadataList\n */\nfunction bytesMatch (bytes, metadataList) {\n  // If node is not built with OpenSSL support, we cannot check\n  // a request's integrity, so allow it by default (the spec will\n  // allow requests if an invalid hash is given, as precedence).\n  /* istanbul ignore if: only if node is built with --without-ssl */\n  if (crypto === undefined) {\n    return true\n  }\n\n  // 1. Let parsedMetadata be the result of parsing metadataList.\n  const parsedMetadata = parseMetadata(metadataList)\n\n  // 2. If parsedMetadata is no metadata, return true.\n  if (parsedMetadata === 'no metadata') {\n    return true\n  }\n\n  // 3. If parsedMetadata is the empty set, return true.\n  if (parsedMetadata.length === 0) {\n    return true\n  }\n\n  // 4. Let metadata be the result of getting the strongest\n  //    metadata from parsedMetadata.\n  const list = parsedMetadata.sort((c, d) => d.algo.localeCompare(c.algo))\n  // get the strongest algorithm\n  const strongest = list[0].algo\n  // get all entries that use the strongest algorithm; ignore weaker\n  const metadata = list.filter((item) => item.algo === strongest)\n\n  // 5. For each item in metadata:\n  for (const item of metadata) {\n    // 1. Let algorithm be the alg component of item.\n    const algorithm = item.algo\n\n    // 2. Let expectedValue be the val component of item.\n    let expectedValue = item.hash\n\n    // See https://github.com/web-platform-tests/wpt/commit/e4c5cc7a5e48093220528dfdd1c4012dc3837a0e\n    // \"be liberal with padding\". This is annoying, and it's not even in the spec.\n\n    if (expectedValue.endsWith('==')) {\n      expectedValue = expectedValue.slice(0, -2)\n    }\n\n    // 3. Let actualValue be the result of applying algorithm to bytes.\n    let actualValue = crypto.createHash(algorithm).update(bytes).digest('base64')\n\n    if (actualValue.endsWith('==')) {\n      actualValue = actualValue.slice(0, -2)\n    }\n\n    // 4. If actualValue is a case-sensitive match for expectedValue,\n    //    return true.\n    if (actualValue === expectedValue) {\n      return true\n    }\n\n    let actualBase64URL = crypto.createHash(algorithm).update(bytes).digest('base64url')\n\n    if (actualBase64URL.endsWith('==')) {\n      actualBase64URL = actualBase64URL.slice(0, -2)\n    }\n\n    if (actualBase64URL === expectedValue) {\n      return true\n    }\n  }\n\n  // 6. Return false.\n  return false\n}\n\n// https://w3c.github.io/webappsec-subresource-integrity/#grammardef-hash-with-options\n// https://www.w3.org/TR/CSP2/#source-list-syntax\n// https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1\nconst parseHashWithOptions = /((?<algo>sha256|sha384|sha512)-(?<hash>[A-z0-9+/]{1}.*={0,2}))( +[\\x21-\\x7e]?)?/i\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n * @param {string} metadata\n */\nfunction parseMetadata (metadata) {\n  // 1. Let result be the empty set.\n  /** @type {{ algo: string, hash: string }[]} */\n  const result = []\n\n  // 2. Let empty be equal to true.\n  let empty = true\n\n  const supportedHashes = crypto.getHashes()\n\n  // 3. For each token returned by splitting metadata on spaces:\n  for (const token of metadata.split(' ')) {\n    // 1. Set empty to false.\n    empty = false\n\n    // 2. Parse token as a hash-with-options.\n    const parsedToken = parseHashWithOptions.exec(token)\n\n    // 3. If token does not parse, continue to the next token.\n    if (parsedToken === null || parsedToken.groups === undefined) {\n      // Note: Chromium blocks the request at this point, but Firefox\n      // gives a warning that an invalid integrity was given. The\n      // correct behavior is to ignore these, and subsequently not\n      // check the integrity of the resource.\n      continue\n    }\n\n    // 4. Let algorithm be the hash-algo component of token.\n    const algorithm = parsedToken.groups.algo\n\n    // 5. If algorithm is a hash function recognized by the user\n    //    agent, add the parsed token to result.\n    if (supportedHashes.includes(algorithm.toLowerCase())) {\n      result.push(parsedToken.groups)\n    }\n  }\n\n  // 4. Return no metadata if empty is true, otherwise return result.\n  if (empty === true) {\n    return 'no metadata'\n  }\n\n  return result\n}\n\n// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request\nfunction tryUpgradeRequestToAPotentiallyTrustworthyURL (request) {\n  // TODO\n}\n\n/**\n * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}\n * @param {URL} A\n * @param {URL} B\n */\nfunction sameOrigin (A, B) {\n  // 1. If A and B are the same opaque origin, then return true.\n  if (A.origin === B.origin && A.origin === 'null') {\n    return true\n  }\n\n  // 2. If A and B are both tuple origins and their schemes,\n  //    hosts, and port are identical, then return true.\n  if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {\n    return true\n  }\n\n  // 3. Return false.\n  return false\n}\n\nfunction createDeferredPromise () {\n  let res\n  let rej\n  const promise = new Promise((resolve, reject) => {\n    res = resolve\n    rej = reject\n  })\n\n  return { promise, resolve: res, reject: rej }\n}\n\nfunction isAborted (fetchParams) {\n  return fetchParams.controller.state === 'aborted'\n}\n\nfunction isCancelled (fetchParams) {\n  return fetchParams.controller.state === 'aborted' ||\n    fetchParams.controller.state === 'terminated'\n}\n\nconst normalizeMethodRecord = {\n  delete: 'DELETE',\n  DELETE: 'DELETE',\n  get: 'GET',\n  GET: 'GET',\n  head: 'HEAD',\n  HEAD: 'HEAD',\n  options: 'OPTIONS',\n  OPTIONS: 'OPTIONS',\n  post: 'POST',\n  POST: 'POST',\n  put: 'PUT',\n  PUT: 'PUT'\n}\n\n// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.\nObject.setPrototypeOf(normalizeMethodRecord, null)\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-method-normalize\n * @param {string} method\n */\nfunction normalizeMethod (method) {\n  return normalizeMethodRecord[method.toLowerCase()] ?? method\n}\n\n// https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string\nfunction serializeJavascriptValueToJSONString (value) {\n  // 1. Let result be ? Call(%JSON.stringify%, undefined, « value »).\n  const result = JSON.stringify(value)\n\n  // 2. If result is undefined, then throw a TypeError.\n  if (result === undefined) {\n    throw new TypeError('Value is not JSON serializable')\n  }\n\n  // 3. Assert: result is a string.\n  assert(typeof result === 'string')\n\n  // 4. Return result.\n  return result\n}\n\n// https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object\nconst esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()))\n\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {() => unknown[]} iterator\n * @param {string} name name of the instance\n * @param {'key'|'value'|'key+value'} kind\n */\nfunction makeIterator (iterator, name, kind) {\n  const object = {\n    index: 0,\n    kind,\n    target: iterator\n  }\n\n  const i = {\n    next () {\n      // 1. Let interface be the interface for which the iterator prototype object exists.\n\n      // 2. Let thisValue be the this value.\n\n      // 3. Let object be ? ToObject(thisValue).\n\n      // 4. If object is a platform object, then perform a security\n      //    check, passing:\n\n      // 5. If object is not a default iterator object for interface,\n      //    then throw a TypeError.\n      if (Object.getPrototypeOf(this) !== i) {\n        throw new TypeError(\n          `'next' called on an object that does not implement interface ${name} Iterator.`\n        )\n      }\n\n      // 6. Let index be object’s index.\n      // 7. Let kind be object’s kind.\n      // 8. Let values be object’s target's value pairs to iterate over.\n      const { index, kind, target } = object\n      const values = target()\n\n      // 9. Let len be the length of values.\n      const len = values.length\n\n      // 10. If index is greater than or equal to len, then return\n      //     CreateIterResultObject(undefined, true).\n      if (index >= len) {\n        return { value: undefined, done: true }\n      }\n\n      // 11. Let pair be the entry in values at index index.\n      const pair = values[index]\n\n      // 12. Set object’s index to index + 1.\n      object.index = index + 1\n\n      // 13. Return the iterator result for pair and kind.\n      return iteratorResult(pair, kind)\n    },\n    // The class string of an iterator prototype object for a given interface is the\n    // result of concatenating the identifier of the interface and the string \" Iterator\".\n    [Symbol.toStringTag]: `${name} Iterator`\n  }\n\n  // The [[Prototype]] internal slot of an iterator prototype object must be %IteratorPrototype%.\n  Object.setPrototypeOf(i, esIteratorPrototype)\n  // esIteratorPrototype needs to be the prototype of i\n  // which is the prototype of an empty object. Yes, it's confusing.\n  return Object.setPrototypeOf({}, i)\n}\n\n// https://webidl.spec.whatwg.org/#iterator-result\nfunction iteratorResult (pair, kind) {\n  let result\n\n  // 1. Let result be a value determined by the value of kind:\n  switch (kind) {\n    case 'key': {\n      // 1. Let idlKey be pair’s key.\n      // 2. Let key be the result of converting idlKey to an\n      //    ECMAScript value.\n      // 3. result is key.\n      result = pair[0]\n      break\n    }\n    case 'value': {\n      // 1. Let idlValue be pair’s value.\n      // 2. Let value be the result of converting idlValue to\n      //    an ECMAScript value.\n      // 3. result is value.\n      result = pair[1]\n      break\n    }\n    case 'key+value': {\n      // 1. Let idlKey be pair’s key.\n      // 2. Let idlValue be pair’s value.\n      // 3. Let key be the result of converting idlKey to an\n      //    ECMAScript value.\n      // 4. Let value be the result of converting idlValue to\n      //    an ECMAScript value.\n      // 5. Let array be ! ArrayCreate(2).\n      // 6. Call ! CreateDataProperty(array, \"0\", key).\n      // 7. Call ! CreateDataProperty(array, \"1\", value).\n      // 8. result is array.\n      result = pair\n      break\n    }\n  }\n\n  // 2. Return CreateIterResultObject(result, false).\n  return { value: result, done: false }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#body-fully-read\n */\nasync function fullyReadBody (body, processBody, processBodyError) {\n  // 1. If taskDestination is null, then set taskDestination to\n  //    the result of starting a new parallel queue.\n\n  // 2. Let successSteps given a byte sequence bytes be to queue a\n  //    fetch task to run processBody given bytes, with taskDestination.\n  const successSteps = processBody\n\n  // 3. Let errorSteps be to queue a fetch task to run processBodyError,\n  //    with taskDestination.\n  const errorSteps = processBodyError\n\n  // 4. Let reader be the result of getting a reader for body’s stream.\n  //    If that threw an exception, then run errorSteps with that\n  //    exception and return.\n  let reader\n\n  try {\n    reader = body.stream.getReader()\n  } catch (e) {\n    errorSteps(e)\n    return\n  }\n\n  // 5. Read all bytes from reader, given successSteps and errorSteps.\n  try {\n    const result = await readAllBytes(reader)\n    successSteps(result)\n  } catch (e) {\n    errorSteps(e)\n  }\n}\n\n/** @type {ReadableStream} */\nlet ReadableStream = globalThis.ReadableStream\n\nfunction isReadableStreamLike (stream) {\n  if (!ReadableStream) {\n    ReadableStream = require('stream/web').ReadableStream\n  }\n\n  return stream instanceof ReadableStream || (\n    stream[Symbol.toStringTag] === 'ReadableStream' &&\n    typeof stream.tee === 'function'\n  )\n}\n\nconst MAXIMUM_ARGUMENT_LENGTH = 65535\n\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-decode\n * @param {number[]|Uint8Array} input\n */\nfunction isomorphicDecode (input) {\n  // 1. To isomorphic decode a byte sequence input, return a string whose code point\n  //    length is equal to input’s length and whose code points have the same values\n  //    as the values of input’s bytes, in the same order.\n\n  if (input.length < MAXIMUM_ARGUMENT_LENGTH) {\n    return String.fromCharCode(...input)\n  }\n\n  return input.reduce((previous, current) => previous + String.fromCharCode(current), '')\n}\n\n/**\n * @param {ReadableStreamController<Uint8Array>} controller\n */\nfunction readableStreamClose (controller) {\n  try {\n    controller.close()\n  } catch (err) {\n    // TODO: add comment explaining why this error occurs.\n    if (!err.message.includes('Controller is already closed')) {\n      throw err\n    }\n  }\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-encode\n * @param {string} input\n */\nfunction isomorphicEncode (input) {\n  // 1. Assert: input contains no code points greater than U+00FF.\n  for (let i = 0; i < input.length; i++) {\n    assert(input.charCodeAt(i) <= 0xFF)\n  }\n\n  // 2. Return a byte sequence whose length is equal to input’s code\n  //    point length and whose bytes have the same values as the\n  //    values of input’s code points, in the same order\n  return input\n}\n\n/**\n * @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes\n * @see https://streams.spec.whatwg.org/#read-loop\n * @param {ReadableStreamDefaultReader} reader\n */\nasync function readAllBytes (reader) {\n  const bytes = []\n  let byteLength = 0\n\n  while (true) {\n    const { done, value: chunk } = await reader.read()\n\n    if (done) {\n      // 1. Call successSteps with bytes.\n      return Buffer.concat(bytes, byteLength)\n    }\n\n    // 1. If chunk is not a Uint8Array object, call failureSteps\n    //    with a TypeError and abort these steps.\n    if (!isUint8Array(chunk)) {\n      throw new TypeError('Received non-Uint8Array chunk')\n    }\n\n    // 2. Append the bytes represented by chunk to bytes.\n    bytes.push(chunk)\n    byteLength += chunk.length\n\n    // 3. Read-loop given reader, bytes, successSteps, and failureSteps.\n  }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#is-local\n * @param {URL} url\n */\nfunction urlIsLocal (url) {\n  assert('protocol' in url) // ensure it's a url object\n\n  const protocol = url.protocol\n\n  return protocol === 'about:' || protocol === 'blob:' || protocol === 'data:'\n}\n\n/**\n * @param {string|URL} url\n */\nfunction urlHasHttpsScheme (url) {\n  if (typeof url === 'string') {\n    return url.startsWith('https:')\n  }\n\n  return url.protocol === 'https:'\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-scheme\n * @param {URL} url\n */\nfunction urlIsHttpHttpsScheme (url) {\n  assert('protocol' in url) // ensure it's a url object\n\n  const protocol = url.protocol\n\n  return protocol === 'http:' || protocol === 'https:'\n}\n\n/**\n * Fetch supports node >= 16.8.0, but Object.hasOwn was added in v16.9.0.\n */\nconst hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key))\n\nmodule.exports = {\n  isAborted,\n  isCancelled,\n  createDeferredPromise,\n  ReadableStreamFrom,\n  toUSVString,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  coarsenedSharedCurrentTime,\n  determineRequestsReferrer,\n  makePolicyContainer,\n  clonePolicyContainer,\n  appendFetchMetadata,\n  appendRequestOriginHeader,\n  TAOCheck,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  createOpaqueTimingInfo,\n  setRequestReferrerPolicyOnRedirect,\n  isValidHTTPToken,\n  requestBadPort,\n  requestCurrentURL,\n  responseURL,\n  responseLocationURL,\n  isBlobLike,\n  isURLPotentiallyTrustworthy,\n  isValidReasonPhrase,\n  sameOrigin,\n  normalizeMethod,\n  serializeJavascriptValueToJSONString,\n  makeIterator,\n  isValidHeaderName,\n  isValidHeaderValue,\n  hasOwn,\n  isErrorLike,\n  fullyReadBody,\n  bytesMatch,\n  isReadableStreamLike,\n  readableStreamClose,\n  isomorphicEncode,\n  isomorphicDecode,\n  urlIsLocal,\n  urlHasHttpsScheme,\n  urlIsHttpHttpsScheme,\n  readAllBytes,\n  normalizeMethodRecord\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}