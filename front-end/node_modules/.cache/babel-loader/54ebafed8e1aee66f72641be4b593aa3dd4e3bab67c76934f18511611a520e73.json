{"ast":null,"code":"'use strict';\n\nconst {\n  Writable\n} = require('stream');\nconst diagnosticsChannel = require('diagnostics_channel');\nconst {\n  parserStates,\n  opcodes,\n  states,\n  emptyBuffer\n} = require('./constants');\nconst {\n  kReadyState,\n  kSentClose,\n  kResponse,\n  kReceivedClose\n} = require('./symbols');\nconst {\n  isValidStatusCode,\n  failWebsocketConnection,\n  websocketMessageReceived\n} = require('./util');\nconst {\n  WebsocketFrameSend\n} = require('./frame');\n\n// This code was influenced by ws released under the MIT license.\n// Copyright (c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n// Copyright (c) 2013 Arnout Kazemier and contributors\n// Copyright (c) 2016 Luigi Pinca and contributors\n\nconst channels = {};\nchannels.ping = diagnosticsChannel.channel('undici:websocket:ping');\nchannels.pong = diagnosticsChannel.channel('undici:websocket:pong');\nclass ByteParser extends Writable {\n  #buffers = [];\n  #byteOffset = 0;\n  #state = parserStates.INFO;\n  #info = {};\n  #fragments = [];\n  constructor(ws) {\n    super();\n    this.ws = ws;\n  }\n\n  /**\n   * @param {Buffer} chunk\n   * @param {() => void} callback\n   */\n  _write(chunk, _, callback) {\n    this.#buffers.push(chunk);\n    this.#byteOffset += chunk.length;\n    this.run(callback);\n  }\n\n  /**\n   * Runs whenever a new chunk is received.\n   * Callback is called whenever there are no more chunks buffering,\n   * or not enough bytes are buffered to parse.\n   */\n  run(callback) {\n    while (true) {\n      if (this.#state === parserStates.INFO) {\n        // If there aren't enough bytes to parse the payload length, etc.\n        if (this.#byteOffset < 2) {\n          return callback();\n        }\n        const buffer = this.consume(2);\n        this.#info.fin = (buffer[0] & 0x80) !== 0;\n        this.#info.opcode = buffer[0] & 0x0F;\n\n        // If we receive a fragmented message, we use the type of the first\n        // frame to parse the full message as binary/text, when it's terminated\n        this.#info.originalOpcode ??= this.#info.opcode;\n        this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes.CONTINUATION;\n        if (this.#info.fragmented && this.#info.opcode !== opcodes.BINARY && this.#info.opcode !== opcodes.TEXT) {\n          // Only text and binary frames can be fragmented\n          failWebsocketConnection(this.ws, 'Invalid frame type was fragmented.');\n          return;\n        }\n        const payloadLength = buffer[1] & 0x7F;\n        if (payloadLength <= 125) {\n          this.#info.payloadLength = payloadLength;\n          this.#state = parserStates.READ_DATA;\n        } else if (payloadLength === 126) {\n          this.#state = parserStates.PAYLOADLENGTH_16;\n        } else if (payloadLength === 127) {\n          this.#state = parserStates.PAYLOADLENGTH_64;\n        }\n        if (this.#info.fragmented && payloadLength > 125) {\n          // A fragmented frame can't be fragmented itself\n          failWebsocketConnection(this.ws, 'Fragmented frame exceeded 125 bytes.');\n          return;\n        } else if ((this.#info.opcode === opcodes.PING || this.#info.opcode === opcodes.PONG || this.#info.opcode === opcodes.CLOSE) && payloadLength > 125) {\n          // Control frames can have a payload length of 125 bytes MAX\n          failWebsocketConnection(this.ws, 'Payload length for control frame exceeded 125 bytes.');\n          return;\n        } else if (this.#info.opcode === opcodes.CLOSE) {\n          if (payloadLength === 1) {\n            failWebsocketConnection(this.ws, 'Received close frame with a 1-byte body.');\n            return;\n          }\n          const body = this.consume(payloadLength);\n          this.#info.closeInfo = this.parseCloseBody(false, body);\n          if (!this.ws[kSentClose]) {\n            // If an endpoint receives a Close frame and did not previously send a\n            // Close frame, the endpoint MUST send a Close frame in response.  (When\n            // sending a Close frame in response, the endpoint typically echos the\n            // status code it received.)\n            const body = Buffer.allocUnsafe(2);\n            body.writeUInt16BE(this.#info.closeInfo.code, 0);\n            const closeFrame = new WebsocketFrameSend(body);\n            this.ws[kResponse].socket.write(closeFrame.createFrame(opcodes.CLOSE), err => {\n              if (!err) {\n                this.ws[kSentClose] = true;\n              }\n            });\n          }\n\n          // Upon either sending or receiving a Close control frame, it is said\n          // that _The WebSocket Closing Handshake is Started_ and that the\n          // WebSocket connection is in the CLOSING state.\n          this.ws[kReadyState] = states.CLOSING;\n          this.ws[kReceivedClose] = true;\n          this.end();\n          return;\n        } else if (this.#info.opcode === opcodes.PING) {\n          // Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in\n          // response, unless it already received a Close frame.\n          // A Pong frame sent in response to a Ping frame must have identical\n          // \"Application data\"\n\n          const body = this.consume(payloadLength);\n          if (!this.ws[kReceivedClose]) {\n            const frame = new WebsocketFrameSend(body);\n            this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));\n            if (channels.ping.hasSubscribers) {\n              channels.ping.publish({\n                payload: body\n              });\n            }\n          }\n          this.#state = parserStates.INFO;\n          if (this.#byteOffset > 0) {\n            continue;\n          } else {\n            callback();\n            return;\n          }\n        } else if (this.#info.opcode === opcodes.PONG) {\n          // A Pong frame MAY be sent unsolicited.  This serves as a\n          // unidirectional heartbeat.  A response to an unsolicited Pong frame is\n          // not expected.\n\n          const body = this.consume(payloadLength);\n          if (channels.pong.hasSubscribers) {\n            channels.pong.publish({\n              payload: body\n            });\n          }\n          if (this.#byteOffset > 0) {\n            continue;\n          } else {\n            callback();\n            return;\n          }\n        }\n      } else if (this.#state === parserStates.PAYLOADLENGTH_16) {\n        if (this.#byteOffset < 2) {\n          return callback();\n        }\n        const buffer = this.consume(2);\n        this.#info.payloadLength = buffer.readUInt16BE(0);\n        this.#state = parserStates.READ_DATA;\n      } else if (this.#state === parserStates.PAYLOADLENGTH_64) {\n        if (this.#byteOffset < 8) {\n          return callback();\n        }\n        const buffer = this.consume(8);\n        const upper = buffer.readUInt32BE(0);\n\n        // 2^31 is the maxinimum bytes an arraybuffer can contain\n        // on 32-bit systems. Although, on 64-bit systems, this is\n        // 2^53-1 bytes.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_array_length\n        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/common/globals.h;drc=1946212ac0100668f14eb9e2843bdd846e510a1e;bpv=1;bpt=1;l=1275\n        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/js-array-buffer.h;l=34;drc=1946212ac0100668f14eb9e2843bdd846e510a1e\n        if (upper > 2 ** 31 - 1) {\n          failWebsocketConnection(this.ws, 'Received payload length > 2^31 bytes.');\n          return;\n        }\n        const lower = buffer.readUInt32BE(4);\n        this.#info.payloadLength = (upper << 8) + lower;\n        this.#state = parserStates.READ_DATA;\n      } else if (this.#state === parserStates.READ_DATA) {\n        if (this.#byteOffset < this.#info.payloadLength) {\n          // If there is still more data in this chunk that needs to be read\n          return callback();\n        } else if (this.#byteOffset >= this.#info.payloadLength) {\n          // If the server sent multiple frames in a single chunk\n\n          const body = this.consume(this.#info.payloadLength);\n          this.#fragments.push(body);\n\n          // If the frame is unfragmented, or a fragmented frame was terminated,\n          // a message was received\n          if (!this.#info.fragmented || this.#info.fin && this.#info.opcode === opcodes.CONTINUATION) {\n            const fullMessage = Buffer.concat(this.#fragments);\n            websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage);\n            this.#info = {};\n            this.#fragments.length = 0;\n          }\n          this.#state = parserStates.INFO;\n        }\n      }\n      if (this.#byteOffset > 0) {\n        continue;\n      } else {\n        callback();\n        break;\n      }\n    }\n  }\n\n  /**\n   * Take n bytes from the buffered Buffers\n   * @param {number} n\n   * @returns {Buffer|null}\n   */\n  consume(n) {\n    if (n > this.#byteOffset) {\n      return null;\n    } else if (n === 0) {\n      return emptyBuffer;\n    }\n    if (this.#buffers[0].length === n) {\n      this.#byteOffset -= this.#buffers[0].length;\n      return this.#buffers.shift();\n    }\n    const buffer = Buffer.allocUnsafe(n);\n    let offset = 0;\n    while (offset !== n) {\n      const next = this.#buffers[0];\n      const {\n        length\n      } = next;\n      if (length + offset === n) {\n        buffer.set(this.#buffers.shift(), offset);\n        break;\n      } else if (length + offset > n) {\n        buffer.set(next.subarray(0, n - offset), offset);\n        this.#buffers[0] = next.subarray(n - offset);\n        break;\n      } else {\n        buffer.set(this.#buffers.shift(), offset);\n        offset += next.length;\n      }\n    }\n    this.#byteOffset -= n;\n    return buffer;\n  }\n  parseCloseBody(onlyCode, data) {\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.5\n    /** @type {number|undefined} */\n    let code;\n    if (data.length >= 2) {\n      // _The WebSocket Connection Close Code_ is\n      // defined as the status code (Section 7.4) contained in the first Close\n      // control frame received by the application\n      code = data.readUInt16BE(0);\n    }\n    if (onlyCode) {\n      if (!isValidStatusCode(code)) {\n        return null;\n      }\n      return {\n        code\n      };\n    }\n\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.6\n    /** @type {Buffer} */\n    let reason = data.subarray(2);\n\n    // Remove BOM\n    if (reason[0] === 0xEF && reason[1] === 0xBB && reason[2] === 0xBF) {\n      reason = reason.subarray(3);\n    }\n    if (code !== undefined && !isValidStatusCode(code)) {\n      return null;\n    }\n    try {\n      // TODO: optimize this\n      reason = new TextDecoder('utf-8', {\n        fatal: true\n      }).decode(reason);\n    } catch {\n      return null;\n    }\n    return {\n      code,\n      reason\n    };\n  }\n  get closingInfo() {\n    return this.#info.closeInfo;\n  }\n}\nmodule.exports = {\n  ByteParser\n};","map":{"version":3,"names":["Writable","require","diagnosticsChannel","parserStates","opcodes","states","emptyBuffer","kReadyState","kSentClose","kResponse","kReceivedClose","isValidStatusCode","failWebsocketConnection","websocketMessageReceived","WebsocketFrameSend","channels","ping","channel","pong","ByteParser","buffers","byteOffset","state","INFO","info","fragments","constructor","ws","_write","chunk","_","callback","push","length","run","buffer","consume","fin","opcode","originalOpcode","fragmented","CONTINUATION","BINARY","TEXT","payloadLength","READ_DATA","PAYLOADLENGTH_16","PAYLOADLENGTH_64","PING","PONG","CLOSE","body","closeInfo","parseCloseBody","Buffer","allocUnsafe","writeUInt16BE","code","closeFrame","socket","write","createFrame","err","CLOSING","end","frame","hasSubscribers","publish","payload","readUInt16BE","upper","readUInt32BE","lower","fullMessage","concat","n","shift","offset","next","set","subarray","onlyCode","data","reason","undefined","TextDecoder","fatal","decode","closingInfo","module","exports"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/undici/lib/websocket/receiver.js"],"sourcesContent":["'use strict'\n\nconst { Writable } = require('stream')\nconst diagnosticsChannel = require('diagnostics_channel')\nconst { parserStates, opcodes, states, emptyBuffer } = require('./constants')\nconst { kReadyState, kSentClose, kResponse, kReceivedClose } = require('./symbols')\nconst { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = require('./util')\nconst { WebsocketFrameSend } = require('./frame')\n\n// This code was influenced by ws released under the MIT license.\n// Copyright (c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n// Copyright (c) 2013 Arnout Kazemier and contributors\n// Copyright (c) 2016 Luigi Pinca and contributors\n\nconst channels = {}\nchannels.ping = diagnosticsChannel.channel('undici:websocket:ping')\nchannels.pong = diagnosticsChannel.channel('undici:websocket:pong')\n\nclass ByteParser extends Writable {\n  #buffers = []\n  #byteOffset = 0\n\n  #state = parserStates.INFO\n\n  #info = {}\n  #fragments = []\n\n  constructor (ws) {\n    super()\n\n    this.ws = ws\n  }\n\n  /**\n   * @param {Buffer} chunk\n   * @param {() => void} callback\n   */\n  _write (chunk, _, callback) {\n    this.#buffers.push(chunk)\n    this.#byteOffset += chunk.length\n\n    this.run(callback)\n  }\n\n  /**\n   * Runs whenever a new chunk is received.\n   * Callback is called whenever there are no more chunks buffering,\n   * or not enough bytes are buffered to parse.\n   */\n  run (callback) {\n    while (true) {\n      if (this.#state === parserStates.INFO) {\n        // If there aren't enough bytes to parse the payload length, etc.\n        if (this.#byteOffset < 2) {\n          return callback()\n        }\n\n        const buffer = this.consume(2)\n\n        this.#info.fin = (buffer[0] & 0x80) !== 0\n        this.#info.opcode = buffer[0] & 0x0F\n\n        // If we receive a fragmented message, we use the type of the first\n        // frame to parse the full message as binary/text, when it's terminated\n        this.#info.originalOpcode ??= this.#info.opcode\n\n        this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes.CONTINUATION\n\n        if (this.#info.fragmented && this.#info.opcode !== opcodes.BINARY && this.#info.opcode !== opcodes.TEXT) {\n          // Only text and binary frames can be fragmented\n          failWebsocketConnection(this.ws, 'Invalid frame type was fragmented.')\n          return\n        }\n\n        const payloadLength = buffer[1] & 0x7F\n\n        if (payloadLength <= 125) {\n          this.#info.payloadLength = payloadLength\n          this.#state = parserStates.READ_DATA\n        } else if (payloadLength === 126) {\n          this.#state = parserStates.PAYLOADLENGTH_16\n        } else if (payloadLength === 127) {\n          this.#state = parserStates.PAYLOADLENGTH_64\n        }\n\n        if (this.#info.fragmented && payloadLength > 125) {\n          // A fragmented frame can't be fragmented itself\n          failWebsocketConnection(this.ws, 'Fragmented frame exceeded 125 bytes.')\n          return\n        } else if (\n          (this.#info.opcode === opcodes.PING ||\n            this.#info.opcode === opcodes.PONG ||\n            this.#info.opcode === opcodes.CLOSE) &&\n          payloadLength > 125\n        ) {\n          // Control frames can have a payload length of 125 bytes MAX\n          failWebsocketConnection(this.ws, 'Payload length for control frame exceeded 125 bytes.')\n          return\n        } else if (this.#info.opcode === opcodes.CLOSE) {\n          if (payloadLength === 1) {\n            failWebsocketConnection(this.ws, 'Received close frame with a 1-byte body.')\n            return\n          }\n\n          const body = this.consume(payloadLength)\n\n          this.#info.closeInfo = this.parseCloseBody(false, body)\n\n          if (!this.ws[kSentClose]) {\n            // If an endpoint receives a Close frame and did not previously send a\n            // Close frame, the endpoint MUST send a Close frame in response.  (When\n            // sending a Close frame in response, the endpoint typically echos the\n            // status code it received.)\n            const body = Buffer.allocUnsafe(2)\n            body.writeUInt16BE(this.#info.closeInfo.code, 0)\n            const closeFrame = new WebsocketFrameSend(body)\n\n            this.ws[kResponse].socket.write(\n              closeFrame.createFrame(opcodes.CLOSE),\n              (err) => {\n                if (!err) {\n                  this.ws[kSentClose] = true\n                }\n              }\n            )\n          }\n\n          // Upon either sending or receiving a Close control frame, it is said\n          // that _The WebSocket Closing Handshake is Started_ and that the\n          // WebSocket connection is in the CLOSING state.\n          this.ws[kReadyState] = states.CLOSING\n          this.ws[kReceivedClose] = true\n\n          this.end()\n\n          return\n        } else if (this.#info.opcode === opcodes.PING) {\n          // Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in\n          // response, unless it already received a Close frame.\n          // A Pong frame sent in response to a Ping frame must have identical\n          // \"Application data\"\n\n          const body = this.consume(payloadLength)\n\n          if (!this.ws[kReceivedClose]) {\n            const frame = new WebsocketFrameSend(body)\n\n            this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG))\n\n            if (channels.ping.hasSubscribers) {\n              channels.ping.publish({\n                payload: body\n              })\n            }\n          }\n\n          this.#state = parserStates.INFO\n\n          if (this.#byteOffset > 0) {\n            continue\n          } else {\n            callback()\n            return\n          }\n        } else if (this.#info.opcode === opcodes.PONG) {\n          // A Pong frame MAY be sent unsolicited.  This serves as a\n          // unidirectional heartbeat.  A response to an unsolicited Pong frame is\n          // not expected.\n\n          const body = this.consume(payloadLength)\n\n          if (channels.pong.hasSubscribers) {\n            channels.pong.publish({\n              payload: body\n            })\n          }\n\n          if (this.#byteOffset > 0) {\n            continue\n          } else {\n            callback()\n            return\n          }\n        }\n      } else if (this.#state === parserStates.PAYLOADLENGTH_16) {\n        if (this.#byteOffset < 2) {\n          return callback()\n        }\n\n        const buffer = this.consume(2)\n\n        this.#info.payloadLength = buffer.readUInt16BE(0)\n        this.#state = parserStates.READ_DATA\n      } else if (this.#state === parserStates.PAYLOADLENGTH_64) {\n        if (this.#byteOffset < 8) {\n          return callback()\n        }\n\n        const buffer = this.consume(8)\n        const upper = buffer.readUInt32BE(0)\n\n        // 2^31 is the maxinimum bytes an arraybuffer can contain\n        // on 32-bit systems. Although, on 64-bit systems, this is\n        // 2^53-1 bytes.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_array_length\n        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/common/globals.h;drc=1946212ac0100668f14eb9e2843bdd846e510a1e;bpv=1;bpt=1;l=1275\n        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/js-array-buffer.h;l=34;drc=1946212ac0100668f14eb9e2843bdd846e510a1e\n        if (upper > 2 ** 31 - 1) {\n          failWebsocketConnection(this.ws, 'Received payload length > 2^31 bytes.')\n          return\n        }\n\n        const lower = buffer.readUInt32BE(4)\n\n        this.#info.payloadLength = (upper << 8) + lower\n        this.#state = parserStates.READ_DATA\n      } else if (this.#state === parserStates.READ_DATA) {\n        if (this.#byteOffset < this.#info.payloadLength) {\n          // If there is still more data in this chunk that needs to be read\n          return callback()\n        } else if (this.#byteOffset >= this.#info.payloadLength) {\n          // If the server sent multiple frames in a single chunk\n\n          const body = this.consume(this.#info.payloadLength)\n\n          this.#fragments.push(body)\n\n          // If the frame is unfragmented, or a fragmented frame was terminated,\n          // a message was received\n          if (!this.#info.fragmented || (this.#info.fin && this.#info.opcode === opcodes.CONTINUATION)) {\n            const fullMessage = Buffer.concat(this.#fragments)\n\n            websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage)\n\n            this.#info = {}\n            this.#fragments.length = 0\n          }\n\n          this.#state = parserStates.INFO\n        }\n      }\n\n      if (this.#byteOffset > 0) {\n        continue\n      } else {\n        callback()\n        break\n      }\n    }\n  }\n\n  /**\n   * Take n bytes from the buffered Buffers\n   * @param {number} n\n   * @returns {Buffer|null}\n   */\n  consume (n) {\n    if (n > this.#byteOffset) {\n      return null\n    } else if (n === 0) {\n      return emptyBuffer\n    }\n\n    if (this.#buffers[0].length === n) {\n      this.#byteOffset -= this.#buffers[0].length\n      return this.#buffers.shift()\n    }\n\n    const buffer = Buffer.allocUnsafe(n)\n    let offset = 0\n\n    while (offset !== n) {\n      const next = this.#buffers[0]\n      const { length } = next\n\n      if (length + offset === n) {\n        buffer.set(this.#buffers.shift(), offset)\n        break\n      } else if (length + offset > n) {\n        buffer.set(next.subarray(0, n - offset), offset)\n        this.#buffers[0] = next.subarray(n - offset)\n        break\n      } else {\n        buffer.set(this.#buffers.shift(), offset)\n        offset += next.length\n      }\n    }\n\n    this.#byteOffset -= n\n\n    return buffer\n  }\n\n  parseCloseBody (onlyCode, data) {\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.5\n    /** @type {number|undefined} */\n    let code\n\n    if (data.length >= 2) {\n      // _The WebSocket Connection Close Code_ is\n      // defined as the status code (Section 7.4) contained in the first Close\n      // control frame received by the application\n      code = data.readUInt16BE(0)\n    }\n\n    if (onlyCode) {\n      if (!isValidStatusCode(code)) {\n        return null\n      }\n\n      return { code }\n    }\n\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.6\n    /** @type {Buffer} */\n    let reason = data.subarray(2)\n\n    // Remove BOM\n    if (reason[0] === 0xEF && reason[1] === 0xBB && reason[2] === 0xBF) {\n      reason = reason.subarray(3)\n    }\n\n    if (code !== undefined && !isValidStatusCode(code)) {\n      return null\n    }\n\n    try {\n      // TODO: optimize this\n      reason = new TextDecoder('utf-8', { fatal: true }).decode(reason)\n    } catch {\n      return null\n    }\n\n    return { code, reason }\n  }\n\n  get closingInfo () {\n    return this.#info.closeInfo\n  }\n}\n\nmodule.exports = {\n  ByteParser\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}