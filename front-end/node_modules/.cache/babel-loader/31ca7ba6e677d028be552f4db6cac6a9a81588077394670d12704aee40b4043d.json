{"ast":null,"code":"import * as Schema from './type.js';\nimport { ok, Failure } from '../result.js';\nexport * from './type.js';\nexport { ok };\n/**\n * @abstract\n * @template [T=unknown]\n * @template [I=unknown]\n * @template [Settings=void]\n * @extends {Schema.Base<T, I, Settings>}\n * @implements {Schema.Schema<T, I>}\n */\nexport class API {\n  /**\n   * @param {Settings} settings\n   */\n  constructor(settings) {\n    /** @protected */\n    this.settings = settings;\n  }\n  toString() {\n    return `new ${this.constructor.name}()`;\n  }\n  /**\n   * @abstract\n   * @param {I} input\n   * @param {Settings} settings\n   * @returns {Schema.ReadResult<T>}\n   */\n  /* c8 ignore next 3 */\n  readWith(input, settings) {\n    throw new Error(`Abstract method readWith must be implemented by subclass`);\n  }\n  /**\n   * @param {I} input\n   * @returns {Schema.ReadResult<T>}\n   */\n  read(input) {\n    return this.readWith(input, this.settings);\n  }\n\n  /**\n   * @param {unknown} value\n   * @returns {value is T}\n   */\n  is(value) {\n    return !this.read( /** @type {I} */value)?.error;\n  }\n\n  /**\n   * @param {unknown} value\n   * @return {T}\n   */\n  from(value) {\n    const result = this.read( /** @type {I} */value);\n    if (result.error) {\n      throw result.error;\n    } else {\n      return result.ok;\n    }\n  }\n\n  /**\n   * @returns {Schema.Schema<T|undefined, I>}\n   */\n  optional() {\n    return optional(this);\n  }\n\n  /**\n   * @returns {Schema.Schema<T|null, I>}\n   */\n  nullable() {\n    return nullable(this);\n  }\n\n  /**\n   * @returns {Schema.Schema<T[], I>}\n   */\n  array() {\n    return array(this);\n  }\n  /**\n   * @template U\n   * @param {Schema.Reader<U, I>} schema\n   * @returns {Schema.Schema<T | U, I>}\n   */\n\n  or(schema) {\n    return or(this, schema);\n  }\n\n  /**\n   * @template U\n   * @param {Schema.Reader<U, I>} schema\n   * @returns {Schema.Schema<T & U, I>}\n   */\n  and(schema) {\n    return and(this, schema);\n  }\n\n  /**\n   * @template {T} U\n   * @param {Schema.Reader<U, T>} schema\n   * @returns {Schema.Schema<U, I>}\n   */\n  refine(schema) {\n    return refine(this, schema);\n  }\n\n  /**\n   * @template {string} Kind\n   * @param {Kind} [kind]\n   * @returns {Schema.Schema<Schema.Branded<T, Kind>, I>}\n   */\n  brand(kind) {\n    return /** @type {Schema.Schema<Schema.Branded<T, Kind>, I>} */this;\n  }\n\n  /**\n   * @param {Schema.NotUndefined<T>} value\n   * @returns {Schema.DefaultSchema<Schema.NotUndefined<T>, I>}\n   */\n  default(value) {\n    // ⚠️ this.from will throw if wrong default is provided\n    const fallback = this.from(value);\n    // we also check that fallback is not undefined because that is the point\n    // of having a fallback\n    if (fallback === undefined) {\n      throw new Error(`Value of type undefined is not a valid default`);\n    }\n    const schema = new Default({\n      reader: ( /** @type {Schema.Reader<T, I>} */this),\n      value: ( /** @type {Schema.NotUndefined<T>} */fallback)\n    });\n    return /** @type {Schema.DefaultSchema<Schema.NotUndefined<T>, I>} */(\n      schema\n    );\n  }\n}\n\n/**\n * @template [I=unknown]\n * @extends {API<never, I>}\n * @implements {Schema.Schema<never, I>}\n */\nclass Never extends API {\n  toString() {\n    return 'never()';\n  }\n  /**\n   * @param {I} input\n   * @returns {Schema.ReadResult<never>}\n   */\n  read(input) {\n    return typeError({\n      expect: 'never',\n      actual: input\n    });\n  }\n}\n\n/**\n * @template [I=unknown]\n * @returns {Schema.Schema<never, I>}\n */\nexport const never = () => new Never();\n\n/**\n * @template [I=unknown]\n * @extends API<unknown, I, void>\n * @implements {Schema.Schema<unknown, I>}\n */\nclass Unknown extends API {\n  /**\n   * @param {I} input\n   */\n  read(input) {\n    return /** @type {Schema.ReadResult<unknown>}*/{\n      ok: input\n    };\n  }\n  toString() {\n    return 'unknown()';\n  }\n}\n\n/**\n * @template [I=unknown]\n * @returns {Schema.Schema<unknown, I>}\n */\nexport const unknown = () => new Unknown();\n\n/**\n * @template O\n * @template [I=unknown]\n * @extends {API<null|O, I, Schema.Reader<O, I>>}\n * @implements {Schema.Schema<null|O, I>}\n */\nclass Nullable extends API {\n  /**\n   * @param {I} input\n   * @param {Schema.Reader<O, I>} reader\n   */\n  readWith(input, reader) {\n    const result = reader.read(input);\n    if (result.error) {\n      return input === null ? {\n        ok: null\n      } : {\n        error: new UnionError({\n          causes: [result.error, typeError({\n            expect: 'null',\n            actual: input\n          }).error]\n        })\n      };\n    } else {\n      return result;\n    }\n  }\n  toString() {\n    return `${this.settings}.nullable()`;\n  }\n}\n\n/**\n * @template O\n * @template [I=unknown]\n * @param {Schema.Reader<O, I>} schema\n * @returns {Schema.Schema<O|null, I>}\n */\nexport const nullable = schema => new Nullable(schema);\n\n/**\n * @template O\n * @template [I=unknown]\n * @extends {API<O|undefined, I, Schema.Reader<O, I>>}\n * @implements {Schema.Schema<O|undefined, I>}\n */\nclass Optional extends API {\n  optional() {\n    return this;\n  }\n  /**\n   * @param {I} input\n   * @param {Schema.Reader<O, I>} reader\n   * @returns {Schema.ReadResult<O|undefined>}\n   */\n  readWith(input, reader) {\n    const result = reader.read(input);\n    return result.error && input === undefined ? {\n      ok: undefined\n    } : result;\n  }\n  toString() {\n    return `${this.settings}.optional()`;\n  }\n}\n\n/**\n * @template {unknown} O\n * @template [I=unknown]\n * @extends {API<O, I, {reader:Schema.Reader<O, I>, value:O & Schema.NotUndefined<O>}>}\n * @implements {Schema.DefaultSchema<O, I>}\n */\nclass Default extends API {\n  /**\n   * @returns {Schema.DefaultSchema<O & Schema.NotUndefined<O>, I>}\n   */\n  optional() {\n    // Short circuit here as we there is no point in wrapping this in optional.\n    return /** @type {Schema.DefaultSchema<O & Schema.NotUndefined<O>, I>} */(\n      this\n    );\n  }\n  /**\n   * @param {I} input\n   * @param {object} options\n   * @param {Schema.Reader<O|undefined, I>} options.reader\n   * @param {O} options.value\n   * @returns {Schema.ReadResult<O>}\n   */\n  readWith(input, {\n    reader,\n    value\n  }) {\n    if (input === undefined) {\n      return /** @type {Schema.ReadResult<O>} */{\n        ok: value\n      };\n    } else {\n      const result = reader.read(input);\n      return result.error ? result : result.ok !== undefined ?\n      // We just checked that result.ok is not undefined but still needs\n      // reassurance\n      /** @type {Schema.ReadResult<O>} */\n      result : {\n        ok: value\n      };\n    }\n  }\n  toString() {\n    return `${this.settings.reader}.default(${JSON.stringify(this.settings.value)})`;\n  }\n  get value() {\n    return this.settings.value;\n  }\n}\n\n/**\n * @template O\n * @template [I=unknown]\n * @param {Schema.Reader<O, I>} schema\n * @returns {Schema.Schema<O|undefined, I>}\n */\nexport const optional = schema => new Optional(schema);\n\n/**\n * @template O\n * @template [I=unknown]\n * @extends {API<O[], I, Schema.Reader<O, I>>}\n * @implements {Schema.ArraySchema<O, I>}\n */\nclass ArrayOf extends API {\n  /**\n   * @param {I} input\n   * @param {Schema.Reader<O, I>} schema\n   */\n  readWith(input, schema) {\n    if (!Array.isArray(input)) {\n      return typeError({\n        expect: 'array',\n        actual: input\n      });\n    }\n    /** @type {O[]} */\n    const results = [];\n    for (const [index, value] of input.entries()) {\n      const result = schema.read(value);\n      if (result.error) {\n        return memberError({\n          at: index,\n          cause: result.error\n        });\n      } else {\n        results.push(result.ok);\n      }\n    }\n    return {\n      ok: results\n    };\n  }\n  get element() {\n    return this.settings;\n  }\n  toString() {\n    return `array(${this.element})`;\n  }\n}\n\n/**\n * @template O\n * @template [I=unknown]\n * @param {Schema.Reader<O, I>} schema\n * @returns {Schema.ArraySchema<O, I>}\n */\nexport const array = schema => new ArrayOf(schema);\n\n/**\n * @template {Schema.Reader<unknown, I>} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @extends {API<Schema.InferTuple<U>, I, U>}\n * @implements {Schema.Schema<Schema.InferTuple<U>, I>}\n */\nclass Tuple extends API {\n  /**\n   * @param {I} input\n   * @param {U} shape\n   * @returns {Schema.ReadResult<Schema.InferTuple<U>>}\n   */\n  readWith(input, shape) {\n    if (!Array.isArray(input)) {\n      return typeError({\n        expect: 'array',\n        actual: input\n      });\n    }\n    if (input.length !== this.shape.length) {\n      return error(`Array must contain exactly ${this.shape.length} elements`);\n    }\n    const results = [];\n    for (const [index, reader] of shape.entries()) {\n      const result = reader.read(input[index]);\n      if (result.error) {\n        return memberError({\n          at: index,\n          cause: result.error\n        });\n      } else {\n        results[index] = result.ok;\n      }\n    }\n    return {\n      ok: ( /** @type {Schema.InferTuple<U>} */results)\n    };\n  }\n\n  /** @type {U} */\n  get shape() {\n    return this.settings;\n  }\n  toString() {\n    return `tuple([${this.shape.map(reader => reader.toString()).join(', ')}])`;\n  }\n}\n\n/**\n * @template {Schema.Reader<unknown, I>} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @param {U} shape\n * @returns {Schema.Schema<Schema.InferTuple<U>, I>}\n */\nexport const tuple = shape => new Tuple(shape);\n\n/**\n * @template V\n * @template {string} K\n * @template [I=unknown]\n * @extends {API<Schema.Dictionary<K, V>, I, { key: Schema.Reader<K, string>, value: Schema.Reader<V, I> }>}\n * @implements {Schema.DictionarySchema<V, K, I>}\n */\nclass Dictionary extends API {\n  /**\n   * @param {I} input\n   * @param {object} schema\n   * @param {Schema.Reader<K, string>} schema.key\n   * @param {Schema.Reader<V, I>} schema.value\n   */\n  readWith(input, {\n    key,\n    value\n  }) {\n    if (typeof input != 'object' || input === null || Array.isArray(input)) {\n      return typeError({\n        expect: 'dictionary',\n        actual: input\n      });\n    }\n    const dict = /** @type {Schema.Dictionary<K, V>} */{};\n    for (const [k, v] of Object.entries(input)) {\n      const keyResult = key.read(k);\n      if (keyResult.error) {\n        return memberError({\n          at: k,\n          cause: keyResult.error\n        });\n      }\n      const valueResult = value.read(v);\n      if (valueResult.error) {\n        return memberError({\n          at: k,\n          cause: valueResult.error\n        });\n      }\n\n      // skip undefined because they mess up CBOR and are generally useless.\n      if (valueResult.ok !== undefined) {\n        dict[keyResult.ok] = valueResult.ok;\n      }\n    }\n    return {\n      ok: dict\n    };\n  }\n  get key() {\n    return this.settings.key;\n  }\n  get value() {\n    return this.settings.value;\n  }\n  partial() {\n    const {\n      key,\n      value\n    } = this.settings;\n    return new Dictionary({\n      key,\n      value: optional(value)\n    });\n  }\n  toString() {\n    return `dictionary(${this.settings})`;\n  }\n}\n\n/**\n * @template {string} K\n * @template {unknown} V\n * @template [I=unknown]\n * @param {object} shape\n * @param {Schema.Reader<V, I>} shape.value\n * @param {Schema.Reader<K, string>} [shape.key]\n * @returns {Schema.DictionarySchema<V, K, I>}\n */\nexport const dictionary = ({\n  value,\n  key\n}) => new Dictionary({\n  value,\n  key: key || ( /** @type {Schema.Reader<K, string>} */string())\n});\n\n/**\n * @template {[unknown, ...unknown[]]} T\n * @template [I=unknown]\n * @extends {API<T[number], I, {type: string, variants:Set<T[number]>}>}\n * @implements {Schema.Schema<T[number], I>}\n */\nclass Enum extends API {\n  /**\n   * @param {I} input\n   * @param {{type:string, variants:Set<T[number]>}} settings\n   * @returns {Schema.ReadResult<T[number]>}\n   */\n  readWith(input, {\n    variants,\n    type\n  }) {\n    if (variants.has(input)) {\n      return /** @type {Schema.ReadResult<T[number]>} */{\n        ok: input\n      };\n    } else {\n      return typeError({\n        expect: type,\n        actual: input\n      });\n    }\n  }\n  toString() {\n    return this.settings.type;\n  }\n}\n\n/**\n * @template {string} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @param {U} variants\n * @returns {Schema.Schema<U[number], I>}\n */\nconst createEnum = variants => new Enum({\n  type: variants.join('|'),\n  variants: new Set(variants)\n});\nexport { createEnum as enum };\n\n/**\n * @template {Schema.Reader<unknown, I>} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @extends {API<Schema.InferUnion<U>, I, U>}\n * @implements {Schema.Schema<Schema.InferUnion<U>, I>}\n */\nclass Union extends API {\n  /**\n   * @param {I} input\n   * @param {U} variants\n   */\n  readWith(input, variants) {\n    const causes = [];\n    for (const reader of variants) {\n      const result = reader.read(input);\n      if (result.error) {\n        causes.push(result.error);\n      } else {\n        return /** @type {Schema.ReadResult<Schema.InferUnion<U>>} */result;\n      }\n    }\n    return {\n      error: new UnionError({\n        causes\n      })\n    };\n  }\n  get variants() {\n    return this.settings;\n  }\n  toString() {\n    return `union([${this.variants.map(type => type.toString()).join(', ')}])`;\n  }\n}\n\n/**\n * @template {Schema.Reader<unknown, I>} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @param {U} variants\n * @returns {Schema.Schema<Schema.InferUnion<U>, I>}\n */\nconst union = variants => new Union(variants);\n\n/**\n * @template T, U\n * @template [I=unknown]\n * @param {Schema.Reader<T, I>} left\n * @param {Schema.Reader<U, I>} right\n * @returns {Schema.Schema<T|U, I>}\n */\nexport const or = (left, right) => union([left, right]);\n\n/**\n * @template {Schema.Reader<unknown, I>} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @extends {API<Schema.InferIntersection<U>, I, U>}\n * @implements {Schema.Schema<Schema.InferIntersection<U>, I>}\n */\nclass Intersection extends API {\n  /**\n   * @param {I} input\n   * @param {U} schemas\n   * @returns {Schema.ReadResult<Schema.InferIntersection<U>>}\n   */\n  readWith(input, schemas) {\n    const causes = [];\n    for (const schema of schemas) {\n      const result = schema.read(input);\n      if (result.error) {\n        causes.push(result.error);\n      }\n    }\n    return causes.length > 0 ? {\n      error: new IntersectionError({\n        causes\n      })\n    } : ( /** @type {Schema.ReadResult<Schema.InferIntersection<U>>} */{\n      ok: input\n    });\n  }\n  toString() {\n    return `intersection([${this.settings.map(type => type.toString()).join(',')}])`;\n  }\n}\n\n/**\n * @template {Schema.Reader<unknown, I>} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @param {U} variants\n * @returns {Schema.Schema<Schema.InferIntersection<U>, I>}\n */\nexport const intersection = variants => new Intersection(variants);\n\n/**\n * @template T, U\n * @template [I=unknown]\n * @param {Schema.Reader<T, I>} left\n * @param {Schema.Reader<U, I>} right\n * @returns {Schema.Schema<T & U, I>}\n */\nexport const and = (left, right) => intersection([left, right]);\n\n/**\n * @template [I=unknown]\n * @extends {API<boolean, I>}\n */\nclass Boolean extends API {\n  /**\n   * @param {I} input\n   */\n  readWith(input) {\n    switch (input) {\n      case true:\n      case false:\n        return {\n          ok: ( /** @type {boolean} */input)\n        };\n      default:\n        return typeError({\n          expect: 'boolean',\n          actual: input\n        });\n    }\n  }\n  toString() {\n    return `boolean()`;\n  }\n}\n\n/** @type {Schema.Schema<boolean, unknown>} */\nconst anyBoolean = new Boolean();\nexport const boolean = () => anyBoolean;\n\n/**\n * @template {number} [O=number]\n * @template [I=unknown]\n * @template [Settings=void]\n * @extends {API<O, I, Settings>}\n * @implements {Schema.NumberSchema<O, I>}\n */\nclass UnknownNumber extends API {\n  /**\n   * @param {number} n\n   */\n  greaterThan(n) {\n    return this.refine(greaterThan(n));\n  }\n  /**\n   * @param {number} n\n   */\n  lessThan(n) {\n    return this.refine(lessThan(n));\n  }\n\n  /**\n   * @template {O} U\n   * @param {Schema.Reader<U, O>} schema\n   * @returns {Schema.NumberSchema<U, I>}\n   */\n  refine(schema) {\n    return new RefinedNumber({\n      base: this,\n      schema\n    });\n  }\n}\n\n/**\n * @template [I=unknown]\n * @extends {UnknownNumber<number, I>}\n * @implements {Schema.NumberSchema<number, I>}\n */\nclass AnyNumber extends UnknownNumber {\n  /**\n   * @param {I} input\n   * @returns {Schema.ReadResult<number>}\n   */\n  readWith(input) {\n    return typeof input === 'number' ? {\n      ok: input\n    } : typeError({\n      expect: 'number',\n      actual: input\n    });\n  }\n  toString() {\n    return `number()`;\n  }\n}\n\n/** @type {Schema.NumberSchema<number, unknown>} */\nconst anyNumber = new AnyNumber();\nexport const number = () => anyNumber;\n\n/**\n * @template {number} [T=number]\n * @template {T} [O=T]\n * @template [I=unknown]\n * @extends {UnknownNumber<O, I, {base:Schema.Reader<T, I>, schema:Schema.Reader<O, T>}>}\n * @implements {Schema.NumberSchema<O, I>}\n */\nclass RefinedNumber extends UnknownNumber {\n  /**\n   * @param {I} input\n   * @param {{base:Schema.Reader<T, I>, schema:Schema.Reader<O, T>}} settings\n   * @returns {Schema.ReadResult<O>}\n   */\n  readWith(input, {\n    base,\n    schema\n  }) {\n    const result = base.read(input);\n    return result.error ? result : schema.read(result.ok);\n  }\n  toString() {\n    return `${this.settings.base}.refine(${this.settings.schema})`;\n  }\n}\n\n/**\n * @template {number} T\n * @extends {API<T, T, number>}\n */\nclass LessThan extends API {\n  /**\n   * @param {T} input\n   * @param {number} number\n   * @returns {Schema.ReadResult<T>}\n   */\n  readWith(input, number) {\n    if (input < number) {\n      return {\n        ok: input\n      };\n    } else {\n      return error(`Expected ${input} < ${number}`);\n    }\n  }\n  toString() {\n    return `lessThan(${this.settings})`;\n  }\n}\n\n/**\n * @template {number} T\n * @param {number} n\n * @returns {Schema.Schema<T, T>}\n */\nexport const lessThan = n => new LessThan(n);\n\n/**\n * @template {number} T\n * @extends {API<T, T, number>}\n */\nclass GreaterThan extends API {\n  /**\n   * @param {T} input\n   * @param {number} number\n   * @returns {Schema.ReadResult<T>}\n   */\n  readWith(input, number) {\n    if (input > number) {\n      return {\n        ok: input\n      };\n    } else {\n      return error(`Expected ${input} > ${number}`);\n    }\n  }\n  toString() {\n    return `greaterThan(${this.settings})`;\n  }\n}\n\n/**\n * @template {number} T\n * @param {number} n\n * @returns {Schema.Schema<T, T>}\n */\nexport const greaterThan = n => new GreaterThan(n);\nconst Integer = {\n  /**\n   * @param {number} input\n   * @returns {Schema.ReadResult<Schema.Integer>}\n   */\n  read(input) {\n    return Number.isInteger(input) ? {\n      ok: ( /** @type {Schema.Integer} */input)\n    } : typeError({\n      expect: 'integer',\n      actual: input\n    });\n  },\n  toString() {\n    return `Integer`;\n  }\n};\nconst anyInteger = anyNumber.refine(Integer);\nexport const integer = () => anyInteger;\nconst MAX_UINT64 = 2n ** 64n - 1n;\n\n/**\n * @template {bigint} [O=Schema.Uint64]\n * @template [I=unknown]\n * @extends {API<O, I, void>}\n * @implements {Schema.Schema<O, I>}\n */\nclass Uint64Schema extends API {\n  /**\n   * @param {I} input\n   * @returns {Schema.ReadResult<O>}\n   */\n  read(input) {\n    switch (typeof input) {\n      case 'bigint':\n        return input > MAX_UINT64 ? error(`Integer is too big for uint64, ${input} > ${MAX_UINT64}`) : input < 0 ? error(`Negative integer can not be represented as uint64, ${input} < ${0}`) : {\n          ok: ( /** @type {I & O} */input)\n        };\n      case 'number':\n        return !Number.isInteger(input) ? typeError({\n          expect: 'uint64',\n          actual: input\n        }) : input < 0 ? error(`Negative integer can not be represented as uint64, ${input} < ${0}`) : {\n          ok: ( /** @type {O} */BigInt(input))\n        };\n      default:\n        return typeError({\n          expect: 'uint64',\n          actual: input\n        });\n    }\n  }\n  toString() {\n    return `uint64`;\n  }\n}\n\n/** @type {Schema.Schema<Schema.Uint64, unknown>} */\nconst Uint64 = new Uint64Schema();\n\n/**\n * Creates a schema for {@link Schema.Uint64} values represented as  a`bigint`.\n *\n * ⚠️ Please note that while IPLD in principal considers the range of integers\n * to be infinite n practice, many libraries / codecs may choose to implement\n * things in such a way that numbers may have limited sizes.\n *\n * So please use this with caution and always ensure that used codecs do support\n * uint64.\n */\nexport const uint64 = () => Uint64;\nconst Float = {\n  /**\n   * @param {number} number\n   * @returns {Schema.ReadResult<Schema.Float>}\n   */\n  read(number) {\n    return Number.isFinite(number) ? {\n      ok: ( /** @type {Schema.Float} */number)\n    } : typeError({\n      expect: 'Float',\n      actual: number\n    });\n  },\n  toString() {\n    return 'Float';\n  }\n};\nconst anyFloat = anyNumber.refine(Float);\nexport const float = () => anyFloat;\n\n/**\n * @template {string} [O=string]\n * @template [I=unknown]\n * @template [Settings=void]\n * @extends {API<O, I, Settings>}\n */\nclass UnknownString extends API {\n  /**\n   * @template {O|unknown} U\n   * @param {Schema.Reader<U, O>} schema\n   * @returns {Schema.StringSchema<O & U, I>}\n   */\n  refine(schema) {\n    const other = /** @type {Schema.Reader<U, O>} */schema;\n    const rest = new RefinedString({\n      base: this,\n      schema: other\n    });\n    return /** @type {Schema.StringSchema<O & U, I>} */rest;\n  }\n  /**\n   * @template {string} Prefix\n   * @param {Prefix} prefix\n   */\n  startsWith(prefix) {\n    return this.refine(startsWith(prefix));\n  }\n  /**\n   * @template {string} Suffix\n   * @param {Suffix} suffix\n   */\n  endsWith(suffix) {\n    return this.refine(endsWith(suffix));\n  }\n  toString() {\n    return `string()`;\n  }\n}\n\n/**\n * @template O\n * @template {string} [T=string]\n * @template [I=unknown]\n * @extends {UnknownString<T & O, I, {base:Schema.Reader<T, I>, schema:Schema.Reader<O, T>}>}\n * @implements {Schema.StringSchema<O & T, I>}\n */\nclass RefinedString extends UnknownString {\n  /**\n   * @param {I} input\n   * @param {{base:Schema.Reader<T, I>, schema:Schema.Reader<O, T>}} settings\n   * @returns {Schema.ReadResult<T & O>}\n   */\n  readWith(input, {\n    base,\n    schema\n  }) {\n    const result = base.read(input);\n    return result.error ? result : ( /** @type {Schema.ReadResult<T & O>} */schema.read(result.ok));\n  }\n  toString() {\n    return `${this.settings.base}.refine(${this.settings.schema})`;\n  }\n}\n\n/**\n * @template [I=unknown]\n * @extends {UnknownString<string, I>}\n * @implements {Schema.StringSchema<string, I>}\n */\nclass AnyString extends UnknownString {\n  /**\n   * @param {I} input\n   * @returns {Schema.ReadResult<string>}\n   */\n  readWith(input) {\n    return typeof input === 'string' ? {\n      ok: input\n    } : typeError({\n      expect: 'string',\n      actual: input\n    });\n  }\n}\n\n/** @type {Schema.StringSchema<string, unknown>} */\nconst anyString = new AnyString();\nexport const string = () => anyString;\n\n/**\n * @template [I=unknown]\n * @extends {API<Uint8Array, I, void>}\n */\nclass BytesSchema extends API {\n  /**\n   * @param {I} input\n   * @returns {Schema.ReadResult<Uint8Array>}\n   */\n  readWith(input) {\n    if (input instanceof Uint8Array) {\n      return {\n        ok: input\n      };\n    } else {\n      return typeError({\n        expect: 'Uint8Array',\n        actual: input\n      });\n    }\n  }\n}\n\n/** @type {Schema.Schema<Uint8Array, unknown>} */\nexport const Bytes = new BytesSchema();\nexport const bytes = () => Bytes;\n\n/**\n * @template {string} Prefix\n * @template {string} Body\n * @extends {API<Body & `${Prefix}${Body}`, Body, Prefix>}\n * @implements {Schema.Schema<Body & `${Prefix}${Body}`, Body>}\n */\nclass StartsWith extends API {\n  /**\n   * @param {Body} input\n   * @param {Prefix} prefix\n   */\n  readWith(input, prefix) {\n    const result = input.startsWith(prefix) ? ( /** @type {Schema.ReadResult<Body & `${Prefix}${Body}`>} */{\n      ok: input\n    }) : error(`Expect string to start with \"${prefix}\" instead got \"${input}\"`);\n    return result;\n  }\n  get prefix() {\n    return this.settings;\n  }\n  toString() {\n    return `startsWith(\"${this.prefix}\")`;\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {string} Body\n * @param {Prefix} prefix\n * @returns {Schema.Schema<`${Prefix}${string}`, string>}\n */\nexport const startsWith = prefix => new StartsWith(prefix);\n\n/**\n * @template {string} Suffix\n * @template {string} Body\n * @extends {API<Body & `${Body}${Suffix}`, Body, Suffix>}\n */\nclass EndsWith extends API {\n  /**\n   * @param {Body} input\n   * @param {Suffix} suffix\n   */\n  readWith(input, suffix) {\n    return input.endsWith(suffix) ? ( /** @type {Schema.ReadResult<Body & `${Body}${Suffix}`>} */{\n      ok: input\n    }) : error(`Expect string to end with \"${suffix}\" instead got \"${input}\"`);\n  }\n  get suffix() {\n    return this.settings;\n  }\n  toString() {\n    return `endsWith(\"${this.suffix}\")`;\n  }\n}\n\n/**\n * @template {string} Suffix\n * @param {Suffix} suffix\n * @returns {Schema.Schema<`${string}${Suffix}`, string>}\n */\nexport const endsWith = suffix => new EndsWith(suffix);\n\n/**\n * @template T\n * @template {T} U\n * @template [I=unknown]\n * @extends {API<U, I, { base: Schema.Reader<T, I>, schema: Schema.Reader<U, T> }>}\n * @implements {Schema.Schema<U, I>}\n */\n\nclass Refine extends API {\n  /**\n   * @param {I} input\n   * @param {{ base: Schema.Reader<T, I>, schema: Schema.Reader<U, T> }} settings\n   */\n  readWith(input, {\n    base,\n    schema\n  }) {\n    const result = base.read(input);\n    return result.error ? result : schema.read(result.ok);\n  }\n  toString() {\n    return `${this.settings.base}.refine(${this.settings.schema})`;\n  }\n}\n\n/**\n * @template T\n * @template {T} U\n * @template [I=unknown]\n * @param {Schema.Reader<T, I>} base\n * @param {Schema.Reader<U, T>} schema\n * @returns {Schema.Schema<U, I>}\n */\nexport const refine = (base, schema) => new Refine({\n  base,\n  schema\n});\n\n/**\n * @template {null|boolean|string|number} T\n * @template [I=unknown]\n * @extends {API<T, I, T>}\n * @implements {Schema.LiteralSchema<T, I>}\n */\nclass Literal extends API {\n  /**\n   * @param {I} input\n   * @param {T} expect\n   * @returns {Schema.ReadResult<T>}\n   */\n  readWith(input, expect) {\n    return input !== ( /** @type {unknown} */expect) ? {\n      error: new LiteralError({\n        expect,\n        actual: input\n      })\n    } : {\n      ok: expect\n    };\n  }\n  get value() {\n    return /** @type {Exclude<T, undefined>} */this.settings;\n  }\n  /**\n   * @template {Schema.NotUndefined<T>} U\n   * @param {U} value\n   */\n  default(value = ( /** @type {U} */this.value)) {\n    return super.default(value);\n  }\n  toString() {\n    return `literal(${toString(this.value)})`;\n  }\n}\n\n/**\n * @template {null|boolean|string|number} T\n * @template [I=unknown]\n * @param {T} value\n * @returns {Schema.LiteralSchema<T, I>}\n */\nexport const literal = value => new Literal(value);\n\n/**\n * @template {{[key:string]: Schema.Reader}} U\n * @template [I=unknown]\n * @extends {API<Schema.InferStruct<U>, I, U>}\n */\nclass Struct extends API {\n  /**\n   * @param {I} input\n   * @param {U} shape\n   * @returns {Schema.ReadResult<Schema.InferStruct<U>>}\n   */\n  readWith(input, shape) {\n    if (typeof input != 'object' || input === null || Array.isArray(input)) {\n      return typeError({\n        expect: 'object',\n        actual: input\n      });\n    }\n    const source = /** @type {{[K in keyof U]: unknown}} */input;\n    const struct = /** @type {{[K in keyof U]: Schema.Infer<U[K]>}} */{};\n    const entries = /** @type {{[K in keyof U]: [K & string, U[K]]}[keyof U][]} */\n    Object.entries(shape);\n    for (const [at, reader] of entries) {\n      const result = reader.read(source[at]);\n      if (result.error) {\n        return memberError({\n          at,\n          cause: result.error\n        });\n      }\n      // skip undefined because they mess up CBOR and are generally useless.\n      else if (result.ok !== undefined) {\n        struct[at] = /** @type {Schema.Infer<U[typeof at]>} */result.ok;\n      }\n    }\n    return {\n      ok: struct\n    };\n  }\n\n  /**\n   * @returns {Schema.MapRepresentation<Partial<Schema.InferStruct<U>>> & Schema.StructSchema}\n   */\n  partial() {\n    return new Struct(Object.fromEntries(Object.entries(this.shape).map(([key, value]) => [key, optional(value)])));\n  }\n\n  /** @type {U} */\n  get shape() {\n    // @ts-ignore - We declared `settings` private but we access it here\n    return this.settings;\n  }\n  toString() {\n    return [`struct({ `, ...Object.entries(this.shape).map(([key, schema]) => `${key}: ${schema}`).join(', '), ` })`].join('');\n  }\n\n  /**\n   * @param {Schema.InferStructSource<U>} data\n   */\n  create(data) {\n    return this.from(data || {});\n  }\n\n  /**\n   * @template {{[key:string]: Schema.Reader}} E\n   * @param {E} extension\n   * @returns {Schema.StructSchema<U & E, I>}\n   */\n  extend(extension) {\n    return new Struct({\n      ...this.shape,\n      ...extension\n    });\n  }\n}\n\n/**\n * @template {null|boolean|string|number} T\n * @template {{[key:string]: T|Schema.Reader}} U\n * @template {{[K in keyof U]: U[K] extends Schema.Reader ? U[K] : Schema.LiteralSchema<U[K] & T>}} V\n * @template [I=unknown]\n * @param {U} fields\n * @returns {Schema.StructSchema<V, I>}\n */\nexport const struct = fields => {\n  const shape = /** @type {{[K in keyof U]: Schema.Reader<unknown, unknown>}} */{};\n  /** @type {[keyof U & string, T|Schema.Reader][]} */\n  const entries = Object.entries(fields);\n  for (const [key, field] of entries) {\n    switch (typeof field) {\n      case 'number':\n      case 'string':\n      case 'boolean':\n        shape[key] = literal(field);\n        break;\n      case 'object':\n        shape[key] = field === null ? literal(null) : field;\n        break;\n      default:\n        throw new Error(`Invalid struct field \"${key}\", expected schema or literal, instead got ${typeof field}`);\n    }\n  }\n  return new Struct( /** @type {V} */shape);\n};\n\n/**\n * @template {Schema.VariantChoices} U\n * @template [I=unknown]\n * @extends {API<Schema.InferVariant<U>, I, U>}\n * @implements {Schema.VariantSchema<U, I>}\n */\nclass Variant extends API {\n  /**\n   * @param {I} input\n   * @param {U} variants\n   * @returns {Schema.ReadResult<Schema.InferVariant<U>>}\n   */\n  readWith(input, variants) {\n    if (typeof input != 'object' || input === null || Array.isArray(input)) {\n      return typeError({\n        expect: 'object',\n        actual: input\n      });\n    }\n    const keys = /** @type {Array<keyof input & keyof variants & string>} */\n    Object.keys(input);\n    const [key] = keys.length === 1 ? keys : [];\n    const reader = key ? variants[key] : undefined;\n    if (reader) {\n      const result = reader.read(input[key]);\n      return result.error ? memberError({\n        at: key,\n        cause: result.error\n      }) : {\n        ok: ( /** @type {Schema.InferVariant<U>} */{\n          [key]: result.ok\n        })\n      };\n    } else if (variants._) {\n      const result = variants._.read(input);\n      return result.error ? result : {\n        ok: ( /** @type {Schema.InferVariant<U>} */{\n          _: result.ok\n        })\n      };\n    } else if (key) {\n      return error(`Expected an object with one of the these keys: ${Object.keys(variants).sort().join(', ')} instead got object with key ${key}`);\n    } else {\n      return error('Expected an object with a single key instead got object with keys ' + keys.sort().join(', '));\n    }\n  }\n\n  /**\n   * @template [E=never]\n   * @param {I} input\n   * @param {E} [fallback]\n   */\n  match(input, fallback) {\n    const result = this.read(input);\n    if (result.error) {\n      if (fallback !== undefined) {\n        return [null, fallback];\n      } else {\n        throw result.error;\n      }\n    } else {\n      const [key] = Object.keys(result.ok);\n      const value = result.ok[key];\n      return /** @type {any} */[key, value];\n    }\n  }\n\n  /**\n   * @template {Schema.InferVariant<U>} O\n   * @param {O} source\n   * @returns {O}\n   */\n  create(source) {\n    return /** @type {O} */this.from(source);\n  }\n}\n\n/**\n * Defines a schema for the `Variant` type. It takes an object where\n * keys denote branches of the variant and values are schemas for the values of\n * those branches. The schema will only match objects with a single key and\n * value that matches the schema for that key. If the object has more than one\n * key or the key does not match any of the keys in the schema then the schema\n * will fail.\n *\n * The `_` branch is a special case. If such branch is present then it will be\n * used as a fallback for any object that does not match any of the variant\n * branches. The `_` branch will be used even if the object has more than one\n * key. Unlike other branches the `_` branch will receive the entire object as\n * input and not just the value of the key. Usually the `_` branch can be set\n * to `Schema.unknown` or `Schema.dictionary` to facilitate exhaustive matching.\n *\n * @example\n * ```ts\n * const Shape = Variant({\n *    circle: Schema.struct({ radius: Schema.integer() }),\n *    rectangle: Schema.struct({ width: Schema.integer(), height: Schema.integer() })\n * })\n *\n * const demo = (input:unknown) => {\n *   const [kind, value] = Schema.match(input)\n *   switch (kind) {\n *     case \"circle\":\n *       return `Circle with radius ${shape.radius}`\n *     case \"rectangle\":\n *       return `Rectangle with width ${shape.width} and height ${shape.height}`\n *    }\n * }\n *\n * const ExhaustiveShape = Variant({\n *   circle: Schema.struct({ radius: Schema.integer() }),\n *   rectangle: Schema.struct({ width: Schema.integer(), height: Schema.integer() }),\n *  _: Schema.dictionary({ value: Schema.unknown() })\n * })\n *\n * const exhastiveDemo = (input:unknown) => {\n *   const [kind, value] = Schema.match(input)\n *   switch (kind) {\n *     case \"circle\":\n *       return `Circle with radius ${shape.radius}`\n *     case \"rectangle\":\n *       return `Rectangle with width ${shape.width} and height ${shape.height}`\n *     case: \"_\":\n *       return `Unknown shape ${JSON.stringify(value)}`\n *    }\n * }\n * ```\n *\n * @template {Schema.VariantChoices} Choices\n * @template [In=unknown]\n * @param {Choices} variants\n * @returns {Schema.VariantSchema<Choices, In>}\n */\nexport const variant = variants => new Variant(variants);\n\n/**\n * @param {string} message\n * @returns {{error: Schema.Error, ok?: undefined}}\n */\nexport const error = message => ({\n  error: new SchemaError(message)\n});\nclass SchemaError extends Failure {\n  get name() {\n    return 'SchemaError';\n  }\n  /* c8 ignore next 3 */\n  describe() {\n    return this.name;\n  }\n}\nclass TypeError extends SchemaError {\n  /**\n   * @param {{expect:string, actual:unknown}} data\n   */\n  constructor({\n    expect,\n    actual\n  }) {\n    super();\n    this.expect = expect;\n    this.actual = actual;\n  }\n  get name() {\n    return 'TypeError';\n  }\n  describe() {\n    return `Expected value of type ${this.expect} instead got ${toString(this.actual)}`;\n  }\n}\n\n/**\n * @param {object} data\n * @param {string} data.expect\n * @param {unknown} data.actual\n * @returns {{ error: Schema.Error }}\n */\nexport const typeError = data => ({\n  error: new TypeError(data)\n});\n\n/**\n *\n * @param {unknown} value\n */\nexport const toString = value => {\n  const type = typeof value;\n  switch (type) {\n    case 'boolean':\n    case 'string':\n      return JSON.stringify(value);\n    // if these types we do not want JSON.stringify as it may mess things up\n    // eg turn NaN and Infinity to null\n    case 'bigint':\n      return `${value}n`;\n    case 'number':\n    case 'symbol':\n    case 'undefined':\n      return String(value);\n    case 'object':\n      return value === null ? 'null' : Array.isArray(value) ? 'array' : Symbol.toStringTag in ( /** @type {object} */value) ? value[Symbol.toStringTag] : 'object';\n    default:\n      return type;\n  }\n};\nclass LiteralError extends SchemaError {\n  /**\n   * @param {{\n   * expect:string|number|boolean|null\n   * actual:unknown\n   * }} data\n   */\n  constructor({\n    expect,\n    actual\n  }) {\n    super();\n    this.expect = expect;\n    this.actual = actual;\n  }\n  get name() {\n    return 'LiteralError';\n  }\n  describe() {\n    return `Expected literal ${toString(this.expect)} instead got ${toString(this.actual)}`;\n  }\n}\nclass ElementError extends SchemaError {\n  /**\n   * @param {{at:number, cause:Schema.Error}} data\n   */\n  constructor({\n    at,\n    cause\n  }) {\n    super();\n    this.at = at;\n    this.cause = cause;\n  }\n  get name() {\n    return 'ElementError';\n  }\n  describe() {\n    return [`Array contains invalid element at ${this.at}:`, li(this.cause.message)].join('\\n');\n  }\n}\nclass FieldError extends SchemaError {\n  /**\n   * @param {{at:string, cause:Schema.Error}} data\n   */\n  constructor({\n    at,\n    cause\n  }) {\n    super();\n    this.at = at;\n    this.cause = cause;\n  }\n  get name() {\n    return 'FieldError';\n  }\n  describe() {\n    return [`Object contains invalid field \"${this.at}\":`, li(this.cause.message)].join('\\n');\n  }\n}\n\n/**\n * @param {object} options\n * @param {string|number} options.at\n * @param {Schema.Error} options.cause\n * @returns {{error: Schema.Error}}\n */\nexport const memberError = ({\n  at,\n  cause\n}) => typeof at === 'string' ? {\n  error: new FieldError({\n    at,\n    cause\n  })\n} : {\n  error: new ElementError({\n    at,\n    cause\n  })\n};\nclass UnionError extends SchemaError {\n  /**\n   * @param {{causes: Schema.Error[]}} data\n   */\n  constructor({\n    causes\n  }) {\n    super();\n    this.causes = causes;\n  }\n  get name() {\n    return 'UnionError';\n  }\n  describe() {\n    const {\n      causes\n    } = this;\n    return [`Value does not match any type of the union:`, ...causes.map(cause => li(cause.message))].join('\\n');\n  }\n}\nclass IntersectionError extends SchemaError {\n  /**\n   * @param {{causes: Schema.Error[]}} data\n   */\n  constructor({\n    causes\n  }) {\n    super();\n    this.causes = causes;\n  }\n  get name() {\n    return 'IntersectionError';\n  }\n  describe() {\n    const {\n      causes\n    } = this;\n    return [`Value does not match following types of the intersection:`, ...causes.map(cause => li(cause.message))].join('\\n');\n  }\n}\n\n/**\n * @param {string} message\n */\nconst indent = (message, indent = '  ') => `${indent}${message.split('\\n').join(`\\n${indent}`)}`;\n\n/**\n * @param {string} message\n */\nconst li = message => indent(`- ${message}`);","map":{"version":3,"names":["Schema","ok","Failure","API","constructor","settings","toString","name","readWith","input","Error","read","is","value","error","from","result","optional","nullable","array","or","schema","and","refine","brand","kind","default","fallback","undefined","Default","reader","Never","typeError","expect","actual","never","Unknown","unknown","Nullable","UnionError","causes","Optional","JSON","stringify","ArrayOf","Array","isArray","results","index","entries","memberError","at","cause","push","element","Tuple","shape","length","map","join","tuple","Dictionary","key","dict","k","v","Object","keyResult","valueResult","partial","dictionary","string","Enum","variants","type","has","createEnum","Set","enum","Union","union","left","right","Intersection","schemas","IntersectionError","intersection","Boolean","anyBoolean","boolean","UnknownNumber","greaterThan","n","lessThan","RefinedNumber","base","AnyNumber","anyNumber","number","LessThan","GreaterThan","Integer","Number","isInteger","anyInteger","integer","MAX_UINT64","Uint64Schema","BigInt","Uint64","uint64","Float","isFinite","anyFloat","float","UnknownString","other","rest","RefinedString","startsWith","prefix","endsWith","suffix","AnyString","anyString","BytesSchema","Uint8Array","Bytes","bytes","StartsWith","EndsWith","Refine","Literal","LiteralError","literal","Struct","source","struct","fromEntries","create","data","extend","extension","fields","field","Variant","keys","_","sort","match","variant","message","SchemaError","describe","TypeError","String","Symbol","toStringTag","ElementError","li","FieldError","indent","split"],"sources":["C:/FACULTATE/Proiect/node_modules/@ucanto/core/src/schema/schema.js"],"sourcesContent":["import * as Schema from './type.js'\nimport { ok, Failure } from '../result.js'\nexport * from './type.js'\n\nexport { ok }\n/**\n * @abstract\n * @template [T=unknown]\n * @template [I=unknown]\n * @template [Settings=void]\n * @extends {Schema.Base<T, I, Settings>}\n * @implements {Schema.Schema<T, I>}\n */\nexport class API {\n  /**\n   * @param {Settings} settings\n   */\n  constructor(settings) {\n    /** @protected */\n    this.settings = settings\n  }\n\n  toString() {\n    return `new ${this.constructor.name}()`\n  }\n  /**\n   * @abstract\n   * @param {I} input\n   * @param {Settings} settings\n   * @returns {Schema.ReadResult<T>}\n   */\n  /* c8 ignore next 3 */\n  readWith(input, settings) {\n    throw new Error(`Abstract method readWith must be implemented by subclass`)\n  }\n  /**\n   * @param {I} input\n   * @returns {Schema.ReadResult<T>}\n   */\n  read(input) {\n    return this.readWith(input, this.settings)\n  }\n\n  /**\n   * @param {unknown} value\n   * @returns {value is T}\n   */\n  is(value) {\n    return !this.read(/** @type {I} */ (value))?.error\n  }\n\n  /**\n   * @param {unknown} value\n   * @return {T}\n   */\n  from(value) {\n    const result = this.read(/** @type {I} */ (value))\n    if (result.error) {\n      throw result.error\n    } else {\n      return result.ok\n    }\n  }\n\n  /**\n   * @returns {Schema.Schema<T|undefined, I>}\n   */\n  optional() {\n    return optional(this)\n  }\n\n  /**\n   * @returns {Schema.Schema<T|null, I>}\n   */\n  nullable() {\n    return nullable(this)\n  }\n\n  /**\n   * @returns {Schema.Schema<T[], I>}\n   */\n  array() {\n    return array(this)\n  }\n  /**\n   * @template U\n   * @param {Schema.Reader<U, I>} schema\n   * @returns {Schema.Schema<T | U, I>}\n   */\n\n  or(schema) {\n    return or(this, schema)\n  }\n\n  /**\n   * @template U\n   * @param {Schema.Reader<U, I>} schema\n   * @returns {Schema.Schema<T & U, I>}\n   */\n  and(schema) {\n    return and(this, schema)\n  }\n\n  /**\n   * @template {T} U\n   * @param {Schema.Reader<U, T>} schema\n   * @returns {Schema.Schema<U, I>}\n   */\n  refine(schema) {\n    return refine(this, schema)\n  }\n\n  /**\n   * @template {string} Kind\n   * @param {Kind} [kind]\n   * @returns {Schema.Schema<Schema.Branded<T, Kind>, I>}\n   */\n  brand(kind) {\n    return /** @type {Schema.Schema<Schema.Branded<T, Kind>, I>} */ (this)\n  }\n\n  /**\n   * @param {Schema.NotUndefined<T>} value\n   * @returns {Schema.DefaultSchema<Schema.NotUndefined<T>, I>}\n   */\n  default(value) {\n    // ⚠️ this.from will throw if wrong default is provided\n    const fallback = this.from(value)\n    // we also check that fallback is not undefined because that is the point\n    // of having a fallback\n    if (fallback === undefined) {\n      throw new Error(`Value of type undefined is not a valid default`)\n    }\n\n    const schema = new Default({\n      reader: /** @type {Schema.Reader<T, I>} */ (this),\n      value: /** @type {Schema.NotUndefined<T>} */ (fallback),\n    })\n\n    return /** @type {Schema.DefaultSchema<Schema.NotUndefined<T>, I>} */ (\n      schema\n    )\n  }\n}\n\n/**\n * @template [I=unknown]\n * @extends {API<never, I>}\n * @implements {Schema.Schema<never, I>}\n */\nclass Never extends API {\n  toString() {\n    return 'never()'\n  }\n  /**\n   * @param {I} input\n   * @returns {Schema.ReadResult<never>}\n   */\n  read(input) {\n    return typeError({ expect: 'never', actual: input })\n  }\n}\n\n/**\n * @template [I=unknown]\n * @returns {Schema.Schema<never, I>}\n */\nexport const never = () => new Never()\n\n/**\n * @template [I=unknown]\n * @extends API<unknown, I, void>\n * @implements {Schema.Schema<unknown, I>}\n */\nclass Unknown extends API {\n  /**\n   * @param {I} input\n   */\n  read(input) {\n    return /** @type {Schema.ReadResult<unknown>}*/ ({ ok: input })\n  }\n  toString() {\n    return 'unknown()'\n  }\n}\n\n/**\n * @template [I=unknown]\n * @returns {Schema.Schema<unknown, I>}\n */\nexport const unknown = () => new Unknown()\n\n/**\n * @template O\n * @template [I=unknown]\n * @extends {API<null|O, I, Schema.Reader<O, I>>}\n * @implements {Schema.Schema<null|O, I>}\n */\nclass Nullable extends API {\n  /**\n   * @param {I} input\n   * @param {Schema.Reader<O, I>} reader\n   */\n  readWith(input, reader) {\n    const result = reader.read(input)\n    if (result.error) {\n      return input === null\n        ? { ok: null }\n        : {\n            error: new UnionError({\n              causes: [\n                result.error,\n                typeError({ expect: 'null', actual: input }).error,\n              ],\n            }),\n          }\n    } else {\n      return result\n    }\n  }\n  toString() {\n    return `${this.settings}.nullable()`\n  }\n}\n\n/**\n * @template O\n * @template [I=unknown]\n * @param {Schema.Reader<O, I>} schema\n * @returns {Schema.Schema<O|null, I>}\n */\nexport const nullable = schema => new Nullable(schema)\n\n/**\n * @template O\n * @template [I=unknown]\n * @extends {API<O|undefined, I, Schema.Reader<O, I>>}\n * @implements {Schema.Schema<O|undefined, I>}\n */\nclass Optional extends API {\n  optional() {\n    return this\n  }\n  /**\n   * @param {I} input\n   * @param {Schema.Reader<O, I>} reader\n   * @returns {Schema.ReadResult<O|undefined>}\n   */\n  readWith(input, reader) {\n    const result = reader.read(input)\n    return result.error && input === undefined ? { ok: undefined } : result\n  }\n  toString() {\n    return `${this.settings}.optional()`\n  }\n}\n\n/**\n * @template {unknown} O\n * @template [I=unknown]\n * @extends {API<O, I, {reader:Schema.Reader<O, I>, value:O & Schema.NotUndefined<O>}>}\n * @implements {Schema.DefaultSchema<O, I>}\n */\nclass Default extends API {\n  /**\n   * @returns {Schema.DefaultSchema<O & Schema.NotUndefined<O>, I>}\n   */\n  optional() {\n    // Short circuit here as we there is no point in wrapping this in optional.\n    return /** @type {Schema.DefaultSchema<O & Schema.NotUndefined<O>, I>} */ (\n      this\n    )\n  }\n  /**\n   * @param {I} input\n   * @param {object} options\n   * @param {Schema.Reader<O|undefined, I>} options.reader\n   * @param {O} options.value\n   * @returns {Schema.ReadResult<O>}\n   */\n  readWith(input, { reader, value }) {\n    if (input === undefined) {\n      return /** @type {Schema.ReadResult<O>} */ ({ ok: value })\n    } else {\n      const result = reader.read(input)\n\n      return result.error\n        ? result\n        : result.ok !== undefined\n        ? // We just checked that result.ok is not undefined but still needs\n          // reassurance\n          /** @type {Schema.ReadResult<O>} */ (result)\n        : { ok: value }\n    }\n  }\n  toString() {\n    return `${this.settings.reader}.default(${JSON.stringify(\n      this.settings.value\n    )})`\n  }\n\n  get value() {\n    return this.settings.value\n  }\n}\n\n/**\n * @template O\n * @template [I=unknown]\n * @param {Schema.Reader<O, I>} schema\n * @returns {Schema.Schema<O|undefined, I>}\n */\nexport const optional = schema => new Optional(schema)\n\n/**\n * @template O\n * @template [I=unknown]\n * @extends {API<O[], I, Schema.Reader<O, I>>}\n * @implements {Schema.ArraySchema<O, I>}\n */\nclass ArrayOf extends API {\n  /**\n   * @param {I} input\n   * @param {Schema.Reader<O, I>} schema\n   */\n  readWith(input, schema) {\n    if (!Array.isArray(input)) {\n      return typeError({ expect: 'array', actual: input })\n    }\n    /** @type {O[]} */\n    const results = []\n    for (const [index, value] of input.entries()) {\n      const result = schema.read(value)\n      if (result.error) {\n        return memberError({ at: index, cause: result.error })\n      } else {\n        results.push(result.ok)\n      }\n    }\n    return { ok: results }\n  }\n  get element() {\n    return this.settings\n  }\n  toString() {\n    return `array(${this.element})`\n  }\n}\n\n/**\n * @template O\n * @template [I=unknown]\n * @param {Schema.Reader<O, I>} schema\n * @returns {Schema.ArraySchema<O, I>}\n */\nexport const array = schema => new ArrayOf(schema)\n\n/**\n * @template {Schema.Reader<unknown, I>} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @extends {API<Schema.InferTuple<U>, I, U>}\n * @implements {Schema.Schema<Schema.InferTuple<U>, I>}\n */\nclass Tuple extends API {\n  /**\n   * @param {I} input\n   * @param {U} shape\n   * @returns {Schema.ReadResult<Schema.InferTuple<U>>}\n   */\n  readWith(input, shape) {\n    if (!Array.isArray(input)) {\n      return typeError({ expect: 'array', actual: input })\n    }\n    if (input.length !== this.shape.length) {\n      return error(`Array must contain exactly ${this.shape.length} elements`)\n    }\n\n    const results = []\n    for (const [index, reader] of shape.entries()) {\n      const result = reader.read(input[index])\n      if (result.error) {\n        return memberError({ at: index, cause: result.error })\n      } else {\n        results[index] = result.ok\n      }\n    }\n\n    return { ok: /** @type {Schema.InferTuple<U>} */ (results) }\n  }\n\n  /** @type {U} */\n  get shape() {\n    return this.settings\n  }\n\n  toString() {\n    return `tuple([${this.shape.map(reader => reader.toString()).join(', ')}])`\n  }\n}\n\n/**\n * @template {Schema.Reader<unknown, I>} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @param {U} shape\n * @returns {Schema.Schema<Schema.InferTuple<U>, I>}\n */\nexport const tuple = shape => new Tuple(shape)\n\n/**\n * @template V\n * @template {string} K\n * @template [I=unknown]\n * @extends {API<Schema.Dictionary<K, V>, I, { key: Schema.Reader<K, string>, value: Schema.Reader<V, I> }>}\n * @implements {Schema.DictionarySchema<V, K, I>}\n */\nclass Dictionary extends API {\n  /**\n   * @param {I} input\n   * @param {object} schema\n   * @param {Schema.Reader<K, string>} schema.key\n   * @param {Schema.Reader<V, I>} schema.value\n   */\n  readWith(input, { key, value }) {\n    if (typeof input != 'object' || input === null || Array.isArray(input)) {\n      return typeError({\n        expect: 'dictionary',\n        actual: input,\n      })\n    }\n\n    const dict = /** @type {Schema.Dictionary<K, V>} */ ({})\n\n    for (const [k, v] of Object.entries(input)) {\n      const keyResult = key.read(k)\n      if (keyResult.error) {\n        return memberError({ at: k, cause: keyResult.error })\n      }\n\n      const valueResult = value.read(v)\n      if (valueResult.error) {\n        return memberError({ at: k, cause: valueResult.error })\n      }\n\n      // skip undefined because they mess up CBOR and are generally useless.\n      if (valueResult.ok !== undefined) {\n        dict[keyResult.ok] = valueResult.ok\n      }\n    }\n\n    return { ok: dict }\n  }\n  get key() {\n    return this.settings.key\n  }\n  get value() {\n    return this.settings.value\n  }\n\n  partial() {\n    const { key, value } = this.settings\n    return new Dictionary({\n      key,\n      value: optional(value),\n    })\n  }\n  toString() {\n    return `dictionary(${this.settings})`\n  }\n}\n\n/**\n * @template {string} K\n * @template {unknown} V\n * @template [I=unknown]\n * @param {object} shape\n * @param {Schema.Reader<V, I>} shape.value\n * @param {Schema.Reader<K, string>} [shape.key]\n * @returns {Schema.DictionarySchema<V, K, I>}\n */\nexport const dictionary = ({ value, key }) =>\n  new Dictionary({\n    value,\n    key: key || /** @type {Schema.Reader<K, string>} */ (string()),\n  })\n\n/**\n * @template {[unknown, ...unknown[]]} T\n * @template [I=unknown]\n * @extends {API<T[number], I, {type: string, variants:Set<T[number]>}>}\n * @implements {Schema.Schema<T[number], I>}\n */\nclass Enum extends API {\n  /**\n   * @param {I} input\n   * @param {{type:string, variants:Set<T[number]>}} settings\n   * @returns {Schema.ReadResult<T[number]>}\n   */\n  readWith(input, { variants, type }) {\n    if (variants.has(input)) {\n      return /** @type {Schema.ReadResult<T[number]>} */ ({ ok: input })\n    } else {\n      return typeError({ expect: type, actual: input })\n    }\n  }\n  toString() {\n    return this.settings.type\n  }\n}\n\n/**\n * @template {string} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @param {U} variants\n * @returns {Schema.Schema<U[number], I>}\n */\nconst createEnum = variants =>\n  new Enum({\n    type: variants.join('|'),\n    variants: new Set(variants),\n  })\nexport { createEnum as enum }\n\n/**\n * @template {Schema.Reader<unknown, I>} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @extends {API<Schema.InferUnion<U>, I, U>}\n * @implements {Schema.Schema<Schema.InferUnion<U>, I>}\n */\nclass Union extends API {\n  /**\n   * @param {I} input\n   * @param {U} variants\n   */\n  readWith(input, variants) {\n    const causes = []\n    for (const reader of variants) {\n      const result = reader.read(input)\n      if (result.error) {\n        causes.push(result.error)\n      } else {\n        return /** @type {Schema.ReadResult<Schema.InferUnion<U>>} */ (result)\n      }\n    }\n    return { error: new UnionError({ causes }) }\n  }\n\n  get variants() {\n    return this.settings\n  }\n  toString() {\n    return `union([${this.variants.map(type => type.toString()).join(', ')}])`\n  }\n}\n\n/**\n * @template {Schema.Reader<unknown, I>} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @param {U} variants\n * @returns {Schema.Schema<Schema.InferUnion<U>, I>}\n */\nconst union = variants => new Union(variants)\n\n/**\n * @template T, U\n * @template [I=unknown]\n * @param {Schema.Reader<T, I>} left\n * @param {Schema.Reader<U, I>} right\n * @returns {Schema.Schema<T|U, I>}\n */\nexport const or = (left, right) => union([left, right])\n\n/**\n * @template {Schema.Reader<unknown, I>} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @extends {API<Schema.InferIntersection<U>, I, U>}\n * @implements {Schema.Schema<Schema.InferIntersection<U>, I>}\n */\nclass Intersection extends API {\n  /**\n   * @param {I} input\n   * @param {U} schemas\n   * @returns {Schema.ReadResult<Schema.InferIntersection<U>>}\n   */\n  readWith(input, schemas) {\n    const causes = []\n    for (const schema of schemas) {\n      const result = schema.read(input)\n      if (result.error) {\n        causes.push(result.error)\n      }\n    }\n\n    return causes.length > 0\n      ? { error: new IntersectionError({ causes }) }\n      : /** @type {Schema.ReadResult<Schema.InferIntersection<U>>} */ ({\n          ok: input,\n        })\n  }\n  toString() {\n    return `intersection([${this.settings\n      .map(type => type.toString())\n      .join(',')}])`\n  }\n}\n\n/**\n * @template {Schema.Reader<unknown, I>} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @param {U} variants\n * @returns {Schema.Schema<Schema.InferIntersection<U>, I>}\n */\nexport const intersection = variants => new Intersection(variants)\n\n/**\n * @template T, U\n * @template [I=unknown]\n * @param {Schema.Reader<T, I>} left\n * @param {Schema.Reader<U, I>} right\n * @returns {Schema.Schema<T & U, I>}\n */\nexport const and = (left, right) => intersection([left, right])\n\n/**\n * @template [I=unknown]\n * @extends {API<boolean, I>}\n */\nclass Boolean extends API {\n  /**\n   * @param {I} input\n   */\n  readWith(input) {\n    switch (input) {\n      case true:\n      case false:\n        return { ok: /** @type {boolean} */ (input) }\n      default:\n        return typeError({\n          expect: 'boolean',\n          actual: input,\n        })\n    }\n  }\n\n  toString() {\n    return `boolean()`\n  }\n}\n\n/** @type {Schema.Schema<boolean, unknown>} */\nconst anyBoolean = new Boolean()\n\nexport const boolean = () => anyBoolean\n\n/**\n * @template {number} [O=number]\n * @template [I=unknown]\n * @template [Settings=void]\n * @extends {API<O, I, Settings>}\n * @implements {Schema.NumberSchema<O, I>}\n */\nclass UnknownNumber extends API {\n  /**\n   * @param {number} n\n   */\n  greaterThan(n) {\n    return this.refine(greaterThan(n))\n  }\n  /**\n   * @param {number} n\n   */\n  lessThan(n) {\n    return this.refine(lessThan(n))\n  }\n\n  /**\n   * @template {O} U\n   * @param {Schema.Reader<U, O>} schema\n   * @returns {Schema.NumberSchema<U, I>}\n   */\n  refine(schema) {\n    return new RefinedNumber({ base: this, schema })\n  }\n}\n\n/**\n * @template [I=unknown]\n * @extends {UnknownNumber<number, I>}\n * @implements {Schema.NumberSchema<number, I>}\n */\nclass AnyNumber extends UnknownNumber {\n  /**\n   * @param {I} input\n   * @returns {Schema.ReadResult<number>}\n   */\n  readWith(input) {\n    return typeof input === 'number'\n      ? { ok: input }\n      : typeError({ expect: 'number', actual: input })\n  }\n  toString() {\n    return `number()`\n  }\n}\n\n/** @type {Schema.NumberSchema<number, unknown>} */\nconst anyNumber = new AnyNumber()\nexport const number = () => anyNumber\n\n/**\n * @template {number} [T=number]\n * @template {T} [O=T]\n * @template [I=unknown]\n * @extends {UnknownNumber<O, I, {base:Schema.Reader<T, I>, schema:Schema.Reader<O, T>}>}\n * @implements {Schema.NumberSchema<O, I>}\n */\nclass RefinedNumber extends UnknownNumber {\n  /**\n   * @param {I} input\n   * @param {{base:Schema.Reader<T, I>, schema:Schema.Reader<O, T>}} settings\n   * @returns {Schema.ReadResult<O>}\n   */\n  readWith(input, { base, schema }) {\n    const result = base.read(input)\n    return result.error ? result : schema.read(result.ok)\n  }\n  toString() {\n    return `${this.settings.base}.refine(${this.settings.schema})`\n  }\n}\n\n/**\n * @template {number} T\n * @extends {API<T, T, number>}\n */\nclass LessThan extends API {\n  /**\n   * @param {T} input\n   * @param {number} number\n   * @returns {Schema.ReadResult<T>}\n   */\n  readWith(input, number) {\n    if (input < number) {\n      return { ok: input }\n    } else {\n      return error(`Expected ${input} < ${number}`)\n    }\n  }\n  toString() {\n    return `lessThan(${this.settings})`\n  }\n}\n\n/**\n * @template {number} T\n * @param {number} n\n * @returns {Schema.Schema<T, T>}\n */\nexport const lessThan = n => new LessThan(n)\n\n/**\n * @template {number} T\n * @extends {API<T, T, number>}\n */\nclass GreaterThan extends API {\n  /**\n   * @param {T} input\n   * @param {number} number\n   * @returns {Schema.ReadResult<T>}\n   */\n  readWith(input, number) {\n    if (input > number) {\n      return { ok: input }\n    } else {\n      return error(`Expected ${input} > ${number}`)\n    }\n  }\n  toString() {\n    return `greaterThan(${this.settings})`\n  }\n}\n\n/**\n * @template {number} T\n * @param {number} n\n * @returns {Schema.Schema<T, T>}\n */\nexport const greaterThan = n => new GreaterThan(n)\n\nconst Integer = {\n  /**\n   * @param {number} input\n   * @returns {Schema.ReadResult<Schema.Integer>}\n   */\n  read(input) {\n    return Number.isInteger(input)\n      ? { ok: /** @type {Schema.Integer} */ (input) }\n      : typeError({\n          expect: 'integer',\n          actual: input,\n        })\n  },\n  toString() {\n    return `Integer`\n  },\n}\n\nconst anyInteger = anyNumber.refine(Integer)\nexport const integer = () => anyInteger\n\nconst MAX_UINT64 = 2n ** 64n - 1n\n\n/**\n * @template {bigint} [O=Schema.Uint64]\n * @template [I=unknown]\n * @extends {API<O, I, void>}\n * @implements {Schema.Schema<O, I>}\n */\nclass Uint64Schema extends API {\n  /**\n   * @param {I} input\n   * @returns {Schema.ReadResult<O>}\n   */\n  read(input) {\n    switch (typeof input) {\n      case 'bigint':\n        return input > MAX_UINT64\n          ? error(`Integer is too big for uint64, ${input} > ${MAX_UINT64}`)\n          : input < 0\n          ? error(\n              `Negative integer can not be represented as uint64, ${input} < ${0}`\n            )\n          : { ok: /** @type {I & O} */ (input) }\n\n      case 'number':\n        return !Number.isInteger(input)\n          ? typeError({\n              expect: 'uint64',\n              actual: input,\n            })\n          : input < 0\n          ? error(\n              `Negative integer can not be represented as uint64, ${input} < ${0}`\n            )\n          : { ok: /** @type {O} */ (BigInt(input)) }\n\n      default:\n        return typeError({\n          expect: 'uint64',\n          actual: input,\n        })\n    }\n  }\n\n  toString() {\n    return `uint64`\n  }\n}\n\n/** @type {Schema.Schema<Schema.Uint64, unknown>} */\nconst Uint64 = new Uint64Schema()\n\n/**\n * Creates a schema for {@link Schema.Uint64} values represented as  a`bigint`.\n *\n * ⚠️ Please note that while IPLD in principal considers the range of integers\n * to be infinite n practice, many libraries / codecs may choose to implement\n * things in such a way that numbers may have limited sizes.\n *\n * So please use this with caution and always ensure that used codecs do support\n * uint64.\n */\nexport const uint64 = () => Uint64\n\nconst Float = {\n  /**\n   * @param {number} number\n   * @returns {Schema.ReadResult<Schema.Float>}\n   */\n  read(number) {\n    return Number.isFinite(number)\n      ? { ok: /** @type {Schema.Float} */ (number) }\n      : typeError({\n          expect: 'Float',\n          actual: number,\n        })\n  },\n  toString() {\n    return 'Float'\n  },\n}\n\nconst anyFloat = anyNumber.refine(Float)\nexport const float = () => anyFloat\n\n/**\n * @template {string} [O=string]\n * @template [I=unknown]\n * @template [Settings=void]\n * @extends {API<O, I, Settings>}\n */\nclass UnknownString extends API {\n  /**\n   * @template {O|unknown} U\n   * @param {Schema.Reader<U, O>} schema\n   * @returns {Schema.StringSchema<O & U, I>}\n   */\n  refine(schema) {\n    const other = /** @type {Schema.Reader<U, O>} */ (schema)\n    const rest = new RefinedString({\n      base: this,\n      schema: other,\n    })\n\n    return /** @type {Schema.StringSchema<O & U, I>} */ (rest)\n  }\n  /**\n   * @template {string} Prefix\n   * @param {Prefix} prefix\n   */\n  startsWith(prefix) {\n    return this.refine(startsWith(prefix))\n  }\n  /**\n   * @template {string} Suffix\n   * @param {Suffix} suffix\n   */\n  endsWith(suffix) {\n    return this.refine(endsWith(suffix))\n  }\n  toString() {\n    return `string()`\n  }\n}\n\n/**\n * @template O\n * @template {string} [T=string]\n * @template [I=unknown]\n * @extends {UnknownString<T & O, I, {base:Schema.Reader<T, I>, schema:Schema.Reader<O, T>}>}\n * @implements {Schema.StringSchema<O & T, I>}\n */\nclass RefinedString extends UnknownString {\n  /**\n   * @param {I} input\n   * @param {{base:Schema.Reader<T, I>, schema:Schema.Reader<O, T>}} settings\n   * @returns {Schema.ReadResult<T & O>}\n   */\n  readWith(input, { base, schema }) {\n    const result = base.read(input)\n    return result.error\n      ? result\n      : /** @type {Schema.ReadResult<T & O>} */ (schema.read(result.ok))\n  }\n  toString() {\n    return `${this.settings.base}.refine(${this.settings.schema})`\n  }\n}\n\n/**\n * @template [I=unknown]\n * @extends {UnknownString<string, I>}\n * @implements {Schema.StringSchema<string, I>}\n */\nclass AnyString extends UnknownString {\n  /**\n   * @param {I} input\n   * @returns {Schema.ReadResult<string>}\n   */\n  readWith(input) {\n    return typeof input === 'string'\n      ? { ok: input }\n      : typeError({ expect: 'string', actual: input })\n  }\n}\n\n/** @type {Schema.StringSchema<string, unknown>} */\nconst anyString = new AnyString()\nexport const string = () => anyString\n\n/**\n * @template [I=unknown]\n * @extends {API<Uint8Array, I, void>}\n */\nclass BytesSchema extends API {\n  /**\n   * @param {I} input\n   * @returns {Schema.ReadResult<Uint8Array>}\n   */\n  readWith(input) {\n    if (input instanceof Uint8Array) {\n      return { ok: input }\n    } else {\n      return typeError({ expect: 'Uint8Array', actual: input })\n    }\n  }\n}\n\n/** @type {Schema.Schema<Uint8Array, unknown>} */\nexport const Bytes = new BytesSchema()\nexport const bytes = () => Bytes\n\n/**\n * @template {string} Prefix\n * @template {string} Body\n * @extends {API<Body & `${Prefix}${Body}`, Body, Prefix>}\n * @implements {Schema.Schema<Body & `${Prefix}${Body}`, Body>}\n */\nclass StartsWith extends API {\n  /**\n   * @param {Body} input\n   * @param {Prefix} prefix\n   */\n  readWith(input, prefix) {\n    const result = input.startsWith(prefix)\n      ? /** @type {Schema.ReadResult<Body & `${Prefix}${Body}`>} */ ({\n          ok: input,\n        })\n      : error(`Expect string to start with \"${prefix}\" instead got \"${input}\"`)\n\n    return result\n  }\n  get prefix() {\n    return this.settings\n  }\n  toString() {\n    return `startsWith(\"${this.prefix}\")`\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {string} Body\n * @param {Prefix} prefix\n * @returns {Schema.Schema<`${Prefix}${string}`, string>}\n */\nexport const startsWith = prefix => new StartsWith(prefix)\n\n/**\n * @template {string} Suffix\n * @template {string} Body\n * @extends {API<Body & `${Body}${Suffix}`, Body, Suffix>}\n */\nclass EndsWith extends API {\n  /**\n   * @param {Body} input\n   * @param {Suffix} suffix\n   */\n  readWith(input, suffix) {\n    return input.endsWith(suffix)\n      ? /** @type {Schema.ReadResult<Body & `${Body}${Suffix}`>} */ ({\n          ok: input,\n        })\n      : error(`Expect string to end with \"${suffix}\" instead got \"${input}\"`)\n  }\n  get suffix() {\n    return this.settings\n  }\n  toString() {\n    return `endsWith(\"${this.suffix}\")`\n  }\n}\n\n/**\n * @template {string} Suffix\n * @param {Suffix} suffix\n * @returns {Schema.Schema<`${string}${Suffix}`, string>}\n */\nexport const endsWith = suffix => new EndsWith(suffix)\n\n/**\n * @template T\n * @template {T} U\n * @template [I=unknown]\n * @extends {API<U, I, { base: Schema.Reader<T, I>, schema: Schema.Reader<U, T> }>}\n * @implements {Schema.Schema<U, I>}\n */\n\nclass Refine extends API {\n  /**\n   * @param {I} input\n   * @param {{ base: Schema.Reader<T, I>, schema: Schema.Reader<U, T> }} settings\n   */\n  readWith(input, { base, schema }) {\n    const result = base.read(input)\n    return result.error ? result : schema.read(result.ok)\n  }\n  toString() {\n    return `${this.settings.base}.refine(${this.settings.schema})`\n  }\n}\n\n/**\n * @template T\n * @template {T} U\n * @template [I=unknown]\n * @param {Schema.Reader<T, I>} base\n * @param {Schema.Reader<U, T>} schema\n * @returns {Schema.Schema<U, I>}\n */\nexport const refine = (base, schema) => new Refine({ base, schema })\n\n/**\n * @template {null|boolean|string|number} T\n * @template [I=unknown]\n * @extends {API<T, I, T>}\n * @implements {Schema.LiteralSchema<T, I>}\n */\nclass Literal extends API {\n  /**\n   * @param {I} input\n   * @param {T} expect\n   * @returns {Schema.ReadResult<T>}\n   */\n  readWith(input, expect) {\n    return input !== /** @type {unknown} */ (expect)\n      ? { error: new LiteralError({ expect, actual: input }) }\n      : { ok: expect }\n  }\n  get value() {\n    return /** @type {Exclude<T, undefined>} */ (this.settings)\n  }\n  /**\n   * @template {Schema.NotUndefined<T>} U\n   * @param {U} value\n   */\n  default(value = /** @type {U} */ (this.value)) {\n    return super.default(value)\n  }\n  toString() {\n    return `literal(${toString(this.value)})`\n  }\n}\n\n/**\n * @template {null|boolean|string|number} T\n * @template [I=unknown]\n * @param {T} value\n * @returns {Schema.LiteralSchema<T, I>}\n */\nexport const literal = value => new Literal(value)\n\n/**\n * @template {{[key:string]: Schema.Reader}} U\n * @template [I=unknown]\n * @extends {API<Schema.InferStruct<U>, I, U>}\n */\nclass Struct extends API {\n  /**\n   * @param {I} input\n   * @param {U} shape\n   * @returns {Schema.ReadResult<Schema.InferStruct<U>>}\n   */\n  readWith(input, shape) {\n    if (typeof input != 'object' || input === null || Array.isArray(input)) {\n      return typeError({\n        expect: 'object',\n        actual: input,\n      })\n    }\n\n    const source = /** @type {{[K in keyof U]: unknown}} */ (input)\n\n    const struct = /** @type {{[K in keyof U]: Schema.Infer<U[K]>}} */ ({})\n    const entries =\n      /** @type {{[K in keyof U]: [K & string, U[K]]}[keyof U][]} */ (\n        Object.entries(shape)\n      )\n\n    for (const [at, reader] of entries) {\n      const result = reader.read(source[at])\n      if (result.error) {\n        return memberError({ at, cause: result.error })\n      }\n      // skip undefined because they mess up CBOR and are generally useless.\n      else if (result.ok !== undefined) {\n        struct[at] = /** @type {Schema.Infer<U[typeof at]>} */ (result.ok)\n      }\n    }\n\n    return { ok: struct }\n  }\n\n  /**\n   * @returns {Schema.MapRepresentation<Partial<Schema.InferStruct<U>>> & Schema.StructSchema}\n   */\n  partial() {\n    return new Struct(\n      Object.fromEntries(\n        Object.entries(this.shape).map(([key, value]) => [key, optional(value)])\n      )\n    )\n  }\n\n  /** @type {U} */\n  get shape() {\n    // @ts-ignore - We declared `settings` private but we access it here\n    return this.settings\n  }\n\n  toString() {\n    return [\n      `struct({ `,\n      ...Object.entries(this.shape)\n        .map(([key, schema]) => `${key}: ${schema}`)\n        .join(', '),\n      ` })`,\n    ].join('')\n  }\n\n  /**\n   * @param {Schema.InferStructSource<U>} data\n   */\n  create(data) {\n    return this.from(data || {})\n  }\n\n  /**\n   * @template {{[key:string]: Schema.Reader}} E\n   * @param {E} extension\n   * @returns {Schema.StructSchema<U & E, I>}\n   */\n  extend(extension) {\n    return new Struct({ ...this.shape, ...extension })\n  }\n}\n\n/**\n * @template {null|boolean|string|number} T\n * @template {{[key:string]: T|Schema.Reader}} U\n * @template {{[K in keyof U]: U[K] extends Schema.Reader ? U[K] : Schema.LiteralSchema<U[K] & T>}} V\n * @template [I=unknown]\n * @param {U} fields\n * @returns {Schema.StructSchema<V, I>}\n */\nexport const struct = fields => {\n  const shape =\n    /** @type {{[K in keyof U]: Schema.Reader<unknown, unknown>}} */ ({})\n  /** @type {[keyof U & string, T|Schema.Reader][]} */\n  const entries = Object.entries(fields)\n\n  for (const [key, field] of entries) {\n    switch (typeof field) {\n      case 'number':\n      case 'string':\n      case 'boolean':\n        shape[key] = literal(field)\n        break\n      case 'object':\n        shape[key] = field === null ? literal(null) : field\n        break\n      default:\n        throw new Error(\n          `Invalid struct field \"${key}\", expected schema or literal, instead got ${typeof field}`\n        )\n    }\n  }\n\n  return new Struct(/** @type {V} */ (shape))\n}\n\n/**\n * @template {Schema.VariantChoices} U\n * @template [I=unknown]\n * @extends {API<Schema.InferVariant<U>, I, U>}\n * @implements {Schema.VariantSchema<U, I>}\n */\nclass Variant extends API {\n  /**\n   * @param {I} input\n   * @param {U} variants\n   * @returns {Schema.ReadResult<Schema.InferVariant<U>>}\n   */\n  readWith(input, variants) {\n    if (typeof input != 'object' || input === null || Array.isArray(input)) {\n      return typeError({\n        expect: 'object',\n        actual: input,\n      })\n    }\n\n    const keys = /** @type {Array<keyof input & keyof variants & string>} */ (\n      Object.keys(input)\n    )\n\n    const [key] = keys.length === 1 ? keys : []\n    const reader = key ? variants[key] : undefined\n\n    if (reader) {\n      const result = reader.read(input[key])\n      return result.error\n        ? memberError({ at: key, cause: result.error })\n        : { ok: /** @type {Schema.InferVariant<U>} */ ({ [key]: result.ok }) }\n    } else if (variants._) {\n      const result = variants._.read(input)\n      return result.error\n        ? result\n        : { ok: /** @type {Schema.InferVariant<U>} */ ({ _: result.ok }) }\n    } else if (key) {\n      return error(\n        `Expected an object with one of the these keys: ${Object.keys(variants)\n          .sort()\n          .join(', ')} instead got object with key ${key}`\n      )\n    } else {\n      return error(\n        'Expected an object with a single key instead got object with keys ' +\n          keys.sort().join(', ')\n      )\n    }\n  }\n\n  /**\n   * @template [E=never]\n   * @param {I} input\n   * @param {E} [fallback]\n   */\n  match(input, fallback) {\n    const result = this.read(input)\n    if (result.error) {\n      if (fallback !== undefined) {\n        return [null, fallback]\n      } else {\n        throw result.error\n      }\n    } else {\n      const [key] = Object.keys(result.ok)\n      const value = result.ok[key]\n      return /** @type {any} */ ([key, value])\n    }\n  }\n\n  /**\n   * @template {Schema.InferVariant<U>} O\n   * @param {O} source\n   * @returns {O}\n   */\n  create(source) {\n    return /** @type {O} */ (this.from(source))\n  }\n}\n\n/**\n * Defines a schema for the `Variant` type. It takes an object where\n * keys denote branches of the variant and values are schemas for the values of\n * those branches. The schema will only match objects with a single key and\n * value that matches the schema for that key. If the object has more than one\n * key or the key does not match any of the keys in the schema then the schema\n * will fail.\n *\n * The `_` branch is a special case. If such branch is present then it will be\n * used as a fallback for any object that does not match any of the variant\n * branches. The `_` branch will be used even if the object has more than one\n * key. Unlike other branches the `_` branch will receive the entire object as\n * input and not just the value of the key. Usually the `_` branch can be set\n * to `Schema.unknown` or `Schema.dictionary` to facilitate exhaustive matching.\n *\n * @example\n * ```ts\n * const Shape = Variant({\n *    circle: Schema.struct({ radius: Schema.integer() }),\n *    rectangle: Schema.struct({ width: Schema.integer(), height: Schema.integer() })\n * })\n *\n * const demo = (input:unknown) => {\n *   const [kind, value] = Schema.match(input)\n *   switch (kind) {\n *     case \"circle\":\n *       return `Circle with radius ${shape.radius}`\n *     case \"rectangle\":\n *       return `Rectangle with width ${shape.width} and height ${shape.height}`\n *    }\n * }\n *\n * const ExhaustiveShape = Variant({\n *   circle: Schema.struct({ radius: Schema.integer() }),\n *   rectangle: Schema.struct({ width: Schema.integer(), height: Schema.integer() }),\n *  _: Schema.dictionary({ value: Schema.unknown() })\n * })\n *\n * const exhastiveDemo = (input:unknown) => {\n *   const [kind, value] = Schema.match(input)\n *   switch (kind) {\n *     case \"circle\":\n *       return `Circle with radius ${shape.radius}`\n *     case \"rectangle\":\n *       return `Rectangle with width ${shape.width} and height ${shape.height}`\n *     case: \"_\":\n *       return `Unknown shape ${JSON.stringify(value)}`\n *    }\n * }\n * ```\n *\n * @template {Schema.VariantChoices} Choices\n * @template [In=unknown]\n * @param {Choices} variants\n * @returns {Schema.VariantSchema<Choices, In>}\n */\nexport const variant = variants => new Variant(variants)\n\n/**\n * @param {string} message\n * @returns {{error: Schema.Error, ok?: undefined}}\n */\nexport const error = message => ({ error: new SchemaError(message) })\n\nclass SchemaError extends Failure {\n  get name() {\n    return 'SchemaError'\n  }\n  /* c8 ignore next 3 */\n  describe() {\n    return this.name\n  }\n}\n\nclass TypeError extends SchemaError {\n  /**\n   * @param {{expect:string, actual:unknown}} data\n   */\n  constructor({ expect, actual }) {\n    super()\n    this.expect = expect\n    this.actual = actual\n  }\n  get name() {\n    return 'TypeError'\n  }\n  describe() {\n    return `Expected value of type ${this.expect} instead got ${toString(\n      this.actual\n    )}`\n  }\n}\n\n/**\n * @param {object} data\n * @param {string} data.expect\n * @param {unknown} data.actual\n * @returns {{ error: Schema.Error }}\n */\nexport const typeError = data => ({ error: new TypeError(data) })\n\n/**\n *\n * @param {unknown} value\n */\nexport const toString = value => {\n  const type = typeof value\n  switch (type) {\n    case 'boolean':\n    case 'string':\n      return JSON.stringify(value)\n    // if these types we do not want JSON.stringify as it may mess things up\n    // eg turn NaN and Infinity to null\n    case 'bigint':\n      return `${value}n`\n    case 'number':\n    case 'symbol':\n    case 'undefined':\n      return String(value)\n    case 'object':\n      return value === null\n        ? 'null'\n        : Array.isArray(value)\n        ? 'array'\n        : Symbol.toStringTag in /** @type {object} */ (value)\n        ? value[Symbol.toStringTag]\n        : 'object'\n    default:\n      return type\n  }\n}\n\nclass LiteralError extends SchemaError {\n  /**\n   * @param {{\n   * expect:string|number|boolean|null\n   * actual:unknown\n   * }} data\n   */\n  constructor({ expect, actual }) {\n    super()\n    this.expect = expect\n    this.actual = actual\n  }\n  get name() {\n    return 'LiteralError'\n  }\n  describe() {\n    return `Expected literal ${toString(this.expect)} instead got ${toString(\n      this.actual\n    )}`\n  }\n}\n\nclass ElementError extends SchemaError {\n  /**\n   * @param {{at:number, cause:Schema.Error}} data\n   */\n  constructor({ at, cause }) {\n    super()\n    this.at = at\n    this.cause = cause\n  }\n  get name() {\n    return 'ElementError'\n  }\n  describe() {\n    return [\n      `Array contains invalid element at ${this.at}:`,\n      li(this.cause.message),\n    ].join('\\n')\n  }\n}\n\nclass FieldError extends SchemaError {\n  /**\n   * @param {{at:string, cause:Schema.Error}} data\n   */\n  constructor({ at, cause }) {\n    super()\n    this.at = at\n    this.cause = cause\n  }\n  get name() {\n    return 'FieldError'\n  }\n  describe() {\n    return [\n      `Object contains invalid field \"${this.at}\":`,\n      li(this.cause.message),\n    ].join('\\n')\n  }\n}\n\n/**\n * @param {object} options\n * @param {string|number} options.at\n * @param {Schema.Error} options.cause\n * @returns {{error: Schema.Error}}\n */\nexport const memberError = ({ at, cause }) =>\n  typeof at === 'string'\n    ? { error: new FieldError({ at, cause }) }\n    : { error: new ElementError({ at, cause }) }\n\nclass UnionError extends SchemaError {\n  /**\n   * @param {{causes: Schema.Error[]}} data\n   */\n  constructor({ causes }) {\n    super()\n    this.causes = causes\n  }\n  get name() {\n    return 'UnionError'\n  }\n  describe() {\n    const { causes } = this\n    return [\n      `Value does not match any type of the union:`,\n      ...causes.map(cause => li(cause.message)),\n    ].join('\\n')\n  }\n}\n\nclass IntersectionError extends SchemaError {\n  /**\n   * @param {{causes: Schema.Error[]}} data\n   */\n  constructor({ causes }) {\n    super()\n    this.causes = causes\n  }\n  get name() {\n    return 'IntersectionError'\n  }\n  describe() {\n    const { causes } = this\n    return [\n      `Value does not match following types of the intersection:`,\n      ...causes.map(cause => li(cause.message)),\n    ].join('\\n')\n  }\n}\n\n/**\n * @param {string} message\n */\nconst indent = (message, indent = '  ') =>\n  `${indent}${message.split('\\n').join(`\\n${indent}`)}`\n\n/**\n * @param {string} message\n */\nconst li = message => indent(`- ${message}`)\n"],"mappings":"AAAA,OAAO,KAAKA,MAAM,MAAM,WAAW;AACnC,SAASC,EAAE,EAAEC,OAAO,QAAQ,cAAc;AAC1C,cAAc,WAAW;AAEzB,SAASD,EAAE;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAME,GAAG,CAAC;EACf;AACF;AACA;EACEC,WAAWA,CAACC,QAAQ,EAAE;IACpB;IACA,IAAI,CAACA,QAAQ,GAAGA,QAAQ;EAC1B;EAEAC,QAAQA,CAAA,EAAG;IACT,OAAQ,OAAM,IAAI,CAACF,WAAW,CAACG,IAAK,IAAG;EACzC;EACA;AACF;AACA;AACA;AACA;AACA;EACE;EACAC,QAAQA,CAACC,KAAK,EAAEJ,QAAQ,EAAE;IACxB,MAAM,IAAIK,KAAK,CAAE,0DAAyD,CAAC;EAC7E;EACA;AACF;AACA;AACA;EACEC,IAAIA,CAACF,KAAK,EAAE;IACV,OAAO,IAAI,CAACD,QAAQ,CAACC,KAAK,EAAE,IAAI,CAACJ,QAAQ,CAAC;EAC5C;;EAEA;AACF;AACA;AACA;EACEO,EAAEA,CAACC,KAAK,EAAE;IACR,OAAO,CAAC,IAAI,CAACF,IAAI,EAAC,gBAAkBE,KAAM,CAAC,EAAEC,KAAK;EACpD;;EAEA;AACF;AACA;AACA;EACEC,IAAIA,CAACF,KAAK,EAAE;IACV,MAAMG,MAAM,GAAG,IAAI,CAACL,IAAI,EAAC,gBAAkBE,KAAM,CAAC;IAClD,IAAIG,MAAM,CAACF,KAAK,EAAE;MAChB,MAAME,MAAM,CAACF,KAAK;IACpB,CAAC,MAAM;MACL,OAAOE,MAAM,CAACf,EAAE;IAClB;EACF;;EAEA;AACF;AACA;EACEgB,QAAQA,CAAA,EAAG;IACT,OAAOA,QAAQ,CAAC,IAAI,CAAC;EACvB;;EAEA;AACF;AACA;EACEC,QAAQA,CAAA,EAAG;IACT,OAAOA,QAAQ,CAAC,IAAI,CAAC;EACvB;;EAEA;AACF;AACA;EACEC,KAAKA,CAAA,EAAG;IACN,OAAOA,KAAK,CAAC,IAAI,CAAC;EACpB;EACA;AACF;AACA;AACA;AACA;;EAEEC,EAAEA,CAACC,MAAM,EAAE;IACT,OAAOD,EAAE,CAAC,IAAI,EAAEC,MAAM,CAAC;EACzB;;EAEA;AACF;AACA;AACA;AACA;EACEC,GAAGA,CAACD,MAAM,EAAE;IACV,OAAOC,GAAG,CAAC,IAAI,EAAED,MAAM,CAAC;EAC1B;;EAEA;AACF;AACA;AACA;AACA;EACEE,MAAMA,CAACF,MAAM,EAAE;IACb,OAAOE,MAAM,CAAC,IAAI,EAAEF,MAAM,CAAC;EAC7B;;EAEA;AACF;AACA;AACA;AACA;EACEG,KAAKA,CAACC,IAAI,EAAE;IACV,OAAO,wDAA0D,IAAI;EACvE;;EAEA;AACF;AACA;AACA;EACEC,OAAOA,CAACb,KAAK,EAAE;IACb;IACA,MAAMc,QAAQ,GAAG,IAAI,CAACZ,IAAI,CAACF,KAAK,CAAC;IACjC;IACA;IACA,IAAIc,QAAQ,KAAKC,SAAS,EAAE;MAC1B,MAAM,IAAIlB,KAAK,CAAE,gDAA+C,CAAC;IACnE;IAEA,MAAMW,MAAM,GAAG,IAAIQ,OAAO,CAAC;MACzBC,MAAM,IAAE,kCAAoC,IAAI,CAAC;MACjDjB,KAAK,IAAE,qCAAuCc,QAAQ;IACxD,CAAC,CAAC;IAEF,OAAO;MACLN;IAAM;EAEV;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAMU,KAAK,SAAS5B,GAAG,CAAC;EACtBG,QAAQA,CAAA,EAAG;IACT,OAAO,SAAS;EAClB;EACA;AACF;AACA;AACA;EACEK,IAAIA,CAACF,KAAK,EAAE;IACV,OAAOuB,SAAS,CAAC;MAAEC,MAAM,EAAE,OAAO;MAAEC,MAAM,EAAEzB;IAAM,CAAC,CAAC;EACtD;AACF;;AAEA;AACA;AACA;AACA;AACA,OAAO,MAAM0B,KAAK,GAAGA,CAAA,KAAM,IAAIJ,KAAK,CAAC,CAAC;;AAEtC;AACA;AACA;AACA;AACA;AACA,MAAMK,OAAO,SAASjC,GAAG,CAAC;EACxB;AACF;AACA;EACEQ,IAAIA,CAACF,KAAK,EAAE;IACV,OAAO,wCAA0C;MAAER,EAAE,EAAEQ;IAAM,CAAC;EAChE;EACAH,QAAQA,CAAA,EAAG;IACT,OAAO,WAAW;EACpB;AACF;;AAEA;AACA;AACA;AACA;AACA,OAAO,MAAM+B,OAAO,GAAGA,CAAA,KAAM,IAAID,OAAO,CAAC,CAAC;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,QAAQ,SAASnC,GAAG,CAAC;EACzB;AACF;AACA;AACA;EACEK,QAAQA,CAACC,KAAK,EAAEqB,MAAM,EAAE;IACtB,MAAMd,MAAM,GAAGc,MAAM,CAACnB,IAAI,CAACF,KAAK,CAAC;IACjC,IAAIO,MAAM,CAACF,KAAK,EAAE;MAChB,OAAOL,KAAK,KAAK,IAAI,GACjB;QAAER,EAAE,EAAE;MAAK,CAAC,GACZ;QACEa,KAAK,EAAE,IAAIyB,UAAU,CAAC;UACpBC,MAAM,EAAE,CACNxB,MAAM,CAACF,KAAK,EACZkB,SAAS,CAAC;YAAEC,MAAM,EAAE,MAAM;YAAEC,MAAM,EAAEzB;UAAM,CAAC,CAAC,CAACK,KAAK;QAEtD,CAAC;MACH,CAAC;IACP,CAAC,MAAM;MACL,OAAOE,MAAM;IACf;EACF;EACAV,QAAQA,CAAA,EAAG;IACT,OAAQ,GAAE,IAAI,CAACD,QAAS,aAAY;EACtC;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMa,QAAQ,GAAGG,MAAM,IAAI,IAAIiB,QAAQ,CAACjB,MAAM,CAAC;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA,MAAMoB,QAAQ,SAAStC,GAAG,CAAC;EACzBc,QAAQA,CAAA,EAAG;IACT,OAAO,IAAI;EACb;EACA;AACF;AACA;AACA;AACA;EACET,QAAQA,CAACC,KAAK,EAAEqB,MAAM,EAAE;IACtB,MAAMd,MAAM,GAAGc,MAAM,CAACnB,IAAI,CAACF,KAAK,CAAC;IACjC,OAAOO,MAAM,CAACF,KAAK,IAAIL,KAAK,KAAKmB,SAAS,GAAG;MAAE3B,EAAE,EAAE2B;IAAU,CAAC,GAAGZ,MAAM;EACzE;EACAV,QAAQA,CAAA,EAAG;IACT,OAAQ,GAAE,IAAI,CAACD,QAAS,aAAY;EACtC;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMwB,OAAO,SAAS1B,GAAG,CAAC;EACxB;AACF;AACA;EACEc,QAAQA,CAAA,EAAG;IACT;IACA,OAAO;MACL;IAAI;EAER;EACA;AACF;AACA;AACA;AACA;AACA;AACA;EACET,QAAQA,CAACC,KAAK,EAAE;IAAEqB,MAAM;IAAEjB;EAAM,CAAC,EAAE;IACjC,IAAIJ,KAAK,KAAKmB,SAAS,EAAE;MACvB,OAAO,mCAAqC;QAAE3B,EAAE,EAAEY;MAAM,CAAC;IAC3D,CAAC,MAAM;MACL,MAAMG,MAAM,GAAGc,MAAM,CAACnB,IAAI,CAACF,KAAK,CAAC;MAEjC,OAAOO,MAAM,CAACF,KAAK,GACfE,MAAM,GACNA,MAAM,CAACf,EAAE,KAAK2B,SAAS;MACvB;MACA;MACA;MAAqCZ,MAAM,GAC3C;QAAEf,EAAE,EAAEY;MAAM,CAAC;IACnB;EACF;EACAP,QAAQA,CAAA,EAAG;IACT,OAAQ,GAAE,IAAI,CAACD,QAAQ,CAACyB,MAAO,YAAWY,IAAI,CAACC,SAAS,CACtD,IAAI,CAACtC,QAAQ,CAACQ,KAChB,CAAE,GAAE;EACN;EAEA,IAAIA,KAAKA,CAAA,EAAG;IACV,OAAO,IAAI,CAACR,QAAQ,CAACQ,KAAK;EAC5B;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMI,QAAQ,GAAGI,MAAM,IAAI,IAAIoB,QAAQ,CAACpB,MAAM,CAAC;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA,MAAMuB,OAAO,SAASzC,GAAG,CAAC;EACxB;AACF;AACA;AACA;EACEK,QAAQA,CAACC,KAAK,EAAEY,MAAM,EAAE;IACtB,IAAI,CAACwB,KAAK,CAACC,OAAO,CAACrC,KAAK,CAAC,EAAE;MACzB,OAAOuB,SAAS,CAAC;QAAEC,MAAM,EAAE,OAAO;QAAEC,MAAM,EAAEzB;MAAM,CAAC,CAAC;IACtD;IACA;IACA,MAAMsC,OAAO,GAAG,EAAE;IAClB,KAAK,MAAM,CAACC,KAAK,EAAEnC,KAAK,CAAC,IAAIJ,KAAK,CAACwC,OAAO,CAAC,CAAC,EAAE;MAC5C,MAAMjC,MAAM,GAAGK,MAAM,CAACV,IAAI,CAACE,KAAK,CAAC;MACjC,IAAIG,MAAM,CAACF,KAAK,EAAE;QAChB,OAAOoC,WAAW,CAAC;UAAEC,EAAE,EAAEH,KAAK;UAAEI,KAAK,EAAEpC,MAAM,CAACF;QAAM,CAAC,CAAC;MACxD,CAAC,MAAM;QACLiC,OAAO,CAACM,IAAI,CAACrC,MAAM,CAACf,EAAE,CAAC;MACzB;IACF;IACA,OAAO;MAAEA,EAAE,EAAE8C;IAAQ,CAAC;EACxB;EACA,IAAIO,OAAOA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACjD,QAAQ;EACtB;EACAC,QAAQA,CAAA,EAAG;IACT,OAAQ,SAAQ,IAAI,CAACgD,OAAQ,GAAE;EACjC;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMnC,KAAK,GAAGE,MAAM,IAAI,IAAIuB,OAAO,CAACvB,MAAM,CAAC;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMkC,KAAK,SAASpD,GAAG,CAAC;EACtB;AACF;AACA;AACA;AACA;EACEK,QAAQA,CAACC,KAAK,EAAE+C,KAAK,EAAE;IACrB,IAAI,CAACX,KAAK,CAACC,OAAO,CAACrC,KAAK,CAAC,EAAE;MACzB,OAAOuB,SAAS,CAAC;QAAEC,MAAM,EAAE,OAAO;QAAEC,MAAM,EAAEzB;MAAM,CAAC,CAAC;IACtD;IACA,IAAIA,KAAK,CAACgD,MAAM,KAAK,IAAI,CAACD,KAAK,CAACC,MAAM,EAAE;MACtC,OAAO3C,KAAK,CAAE,8BAA6B,IAAI,CAAC0C,KAAK,CAACC,MAAO,WAAU,CAAC;IAC1E;IAEA,MAAMV,OAAO,GAAG,EAAE;IAClB,KAAK,MAAM,CAACC,KAAK,EAAElB,MAAM,CAAC,IAAI0B,KAAK,CAACP,OAAO,CAAC,CAAC,EAAE;MAC7C,MAAMjC,MAAM,GAAGc,MAAM,CAACnB,IAAI,CAACF,KAAK,CAACuC,KAAK,CAAC,CAAC;MACxC,IAAIhC,MAAM,CAACF,KAAK,EAAE;QAChB,OAAOoC,WAAW,CAAC;UAAEC,EAAE,EAAEH,KAAK;UAAEI,KAAK,EAAEpC,MAAM,CAACF;QAAM,CAAC,CAAC;MACxD,CAAC,MAAM;QACLiC,OAAO,CAACC,KAAK,CAAC,GAAGhC,MAAM,CAACf,EAAE;MAC5B;IACF;IAEA,OAAO;MAAEA,EAAE,IAAE,mCAAqC8C,OAAO;IAAE,CAAC;EAC9D;;EAEA;EACA,IAAIS,KAAKA,CAAA,EAAG;IACV,OAAO,IAAI,CAACnD,QAAQ;EACtB;EAEAC,QAAQA,CAAA,EAAG;IACT,OAAQ,UAAS,IAAI,CAACkD,KAAK,CAACE,GAAG,CAAC5B,MAAM,IAAIA,MAAM,CAACxB,QAAQ,CAAC,CAAC,CAAC,CAACqD,IAAI,CAAC,IAAI,CAAE,IAAG;EAC7E;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,KAAK,GAAGJ,KAAK,IAAI,IAAID,KAAK,CAACC,KAAK,CAAC;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMK,UAAU,SAAS1D,GAAG,CAAC;EAC3B;AACF;AACA;AACA;AACA;AACA;EACEK,QAAQA,CAACC,KAAK,EAAE;IAAEqD,GAAG;IAAEjD;EAAM,CAAC,EAAE;IAC9B,IAAI,OAAOJ,KAAK,IAAI,QAAQ,IAAIA,KAAK,KAAK,IAAI,IAAIoC,KAAK,CAACC,OAAO,CAACrC,KAAK,CAAC,EAAE;MACtE,OAAOuB,SAAS,CAAC;QACfC,MAAM,EAAE,YAAY;QACpBC,MAAM,EAAEzB;MACV,CAAC,CAAC;IACJ;IAEA,MAAMsD,IAAI,GAAG,sCAAwC,CAAC,CAAE;IAExD,KAAK,MAAM,CAACC,CAAC,EAAEC,CAAC,CAAC,IAAIC,MAAM,CAACjB,OAAO,CAACxC,KAAK,CAAC,EAAE;MAC1C,MAAM0D,SAAS,GAAGL,GAAG,CAACnD,IAAI,CAACqD,CAAC,CAAC;MAC7B,IAAIG,SAAS,CAACrD,KAAK,EAAE;QACnB,OAAOoC,WAAW,CAAC;UAAEC,EAAE,EAAEa,CAAC;UAAEZ,KAAK,EAAEe,SAAS,CAACrD;QAAM,CAAC,CAAC;MACvD;MAEA,MAAMsD,WAAW,GAAGvD,KAAK,CAACF,IAAI,CAACsD,CAAC,CAAC;MACjC,IAAIG,WAAW,CAACtD,KAAK,EAAE;QACrB,OAAOoC,WAAW,CAAC;UAAEC,EAAE,EAAEa,CAAC;UAAEZ,KAAK,EAAEgB,WAAW,CAACtD;QAAM,CAAC,CAAC;MACzD;;MAEA;MACA,IAAIsD,WAAW,CAACnE,EAAE,KAAK2B,SAAS,EAAE;QAChCmC,IAAI,CAACI,SAAS,CAAClE,EAAE,CAAC,GAAGmE,WAAW,CAACnE,EAAE;MACrC;IACF;IAEA,OAAO;MAAEA,EAAE,EAAE8D;IAAK,CAAC;EACrB;EACA,IAAID,GAAGA,CAAA,EAAG;IACR,OAAO,IAAI,CAACzD,QAAQ,CAACyD,GAAG;EAC1B;EACA,IAAIjD,KAAKA,CAAA,EAAG;IACV,OAAO,IAAI,CAACR,QAAQ,CAACQ,KAAK;EAC5B;EAEAwD,OAAOA,CAAA,EAAG;IACR,MAAM;MAAEP,GAAG;MAAEjD;IAAM,CAAC,GAAG,IAAI,CAACR,QAAQ;IACpC,OAAO,IAAIwD,UAAU,CAAC;MACpBC,GAAG;MACHjD,KAAK,EAAEI,QAAQ,CAACJ,KAAK;IACvB,CAAC,CAAC;EACJ;EACAP,QAAQA,CAAA,EAAG;IACT,OAAQ,cAAa,IAAI,CAACD,QAAS,GAAE;EACvC;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMiE,UAAU,GAAGA,CAAC;EAAEzD,KAAK;EAAEiD;AAAI,CAAC,KACvC,IAAID,UAAU,CAAC;EACbhD,KAAK;EACLiD,GAAG,EAAEA,GAAG,MAAI,uCAAyCS,MAAM,CAAC,CAAC;AAC/D,CAAC,CAAC;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,IAAI,SAASrE,GAAG,CAAC;EACrB;AACF;AACA;AACA;AACA;EACEK,QAAQA,CAACC,KAAK,EAAE;IAAEgE,QAAQ;IAAEC;EAAK,CAAC,EAAE;IAClC,IAAID,QAAQ,CAACE,GAAG,CAAClE,KAAK,CAAC,EAAE;MACvB,OAAO,2CAA6C;QAAER,EAAE,EAAEQ;MAAM,CAAC;IACnE,CAAC,MAAM;MACL,OAAOuB,SAAS,CAAC;QAAEC,MAAM,EAAEyC,IAAI;QAAExC,MAAM,EAAEzB;MAAM,CAAC,CAAC;IACnD;EACF;EACAH,QAAQA,CAAA,EAAG;IACT,OAAO,IAAI,CAACD,QAAQ,CAACqE,IAAI;EAC3B;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,UAAU,GAAGH,QAAQ,IACzB,IAAID,IAAI,CAAC;EACPE,IAAI,EAAED,QAAQ,CAACd,IAAI,CAAC,GAAG,CAAC;EACxBc,QAAQ,EAAE,IAAII,GAAG,CAACJ,QAAQ;AAC5B,CAAC,CAAC;AACJ,SAASG,UAAU,IAAIE,IAAI;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,KAAK,SAAS5E,GAAG,CAAC;EACtB;AACF;AACA;AACA;EACEK,QAAQA,CAACC,KAAK,EAAEgE,QAAQ,EAAE;IACxB,MAAMjC,MAAM,GAAG,EAAE;IACjB,KAAK,MAAMV,MAAM,IAAI2C,QAAQ,EAAE;MAC7B,MAAMzD,MAAM,GAAGc,MAAM,CAACnB,IAAI,CAACF,KAAK,CAAC;MACjC,IAAIO,MAAM,CAACF,KAAK,EAAE;QAChB0B,MAAM,CAACa,IAAI,CAACrC,MAAM,CAACF,KAAK,CAAC;MAC3B,CAAC,MAAM;QACL,OAAO,sDAAwDE,MAAM;MACvE;IACF;IACA,OAAO;MAAEF,KAAK,EAAE,IAAIyB,UAAU,CAAC;QAAEC;MAAO,CAAC;IAAE,CAAC;EAC9C;EAEA,IAAIiC,QAAQA,CAAA,EAAG;IACb,OAAO,IAAI,CAACpE,QAAQ;EACtB;EACAC,QAAQA,CAAA,EAAG;IACT,OAAQ,UAAS,IAAI,CAACmE,QAAQ,CAACf,GAAG,CAACgB,IAAI,IAAIA,IAAI,CAACpE,QAAQ,CAAC,CAAC,CAAC,CAACqD,IAAI,CAAC,IAAI,CAAE,IAAG;EAC5E;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMqB,KAAK,GAAGP,QAAQ,IAAI,IAAIM,KAAK,CAACN,QAAQ,CAAC;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMrD,EAAE,GAAGA,CAAC6D,IAAI,EAAEC,KAAK,KAAKF,KAAK,CAAC,CAACC,IAAI,EAAEC,KAAK,CAAC,CAAC;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,YAAY,SAAShF,GAAG,CAAC;EAC7B;AACF;AACA;AACA;AACA;EACEK,QAAQA,CAACC,KAAK,EAAE2E,OAAO,EAAE;IACvB,MAAM5C,MAAM,GAAG,EAAE;IACjB,KAAK,MAAMnB,MAAM,IAAI+D,OAAO,EAAE;MAC5B,MAAMpE,MAAM,GAAGK,MAAM,CAACV,IAAI,CAACF,KAAK,CAAC;MACjC,IAAIO,MAAM,CAACF,KAAK,EAAE;QAChB0B,MAAM,CAACa,IAAI,CAACrC,MAAM,CAACF,KAAK,CAAC;MAC3B;IACF;IAEA,OAAO0B,MAAM,CAACiB,MAAM,GAAG,CAAC,GACpB;MAAE3C,KAAK,EAAE,IAAIuE,iBAAiB,CAAC;QAAE7C;MAAO,CAAC;IAAE,CAAC,KAC5C,6DAA+D;MAC7DvC,EAAE,EAAEQ;IACN,CAAC,CAAC;EACR;EACAH,QAAQA,CAAA,EAAG;IACT,OAAQ,iBAAgB,IAAI,CAACD,QAAQ,CAClCqD,GAAG,CAACgB,IAAI,IAAIA,IAAI,CAACpE,QAAQ,CAAC,CAAC,CAAC,CAC5BqD,IAAI,CAAC,GAAG,CAAE,IAAG;EAClB;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAM2B,YAAY,GAAGb,QAAQ,IAAI,IAAIU,YAAY,CAACV,QAAQ,CAAC;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMnD,GAAG,GAAGA,CAAC2D,IAAI,EAAEC,KAAK,KAAKI,YAAY,CAAC,CAACL,IAAI,EAAEC,KAAK,CAAC,CAAC;;AAE/D;AACA;AACA;AACA;AACA,MAAMK,OAAO,SAASpF,GAAG,CAAC;EACxB;AACF;AACA;EACEK,QAAQA,CAACC,KAAK,EAAE;IACd,QAAQA,KAAK;MACX,KAAK,IAAI;MACT,KAAK,KAAK;QACR,OAAO;UAAER,EAAE,IAAE,sBAAwBQ,KAAK;QAAE,CAAC;MAC/C;QACE,OAAOuB,SAAS,CAAC;UACfC,MAAM,EAAE,SAAS;UACjBC,MAAM,EAAEzB;QACV,CAAC,CAAC;IACN;EACF;EAEAH,QAAQA,CAAA,EAAG;IACT,OAAQ,WAAU;EACpB;AACF;;AAEA;AACA,MAAMkF,UAAU,GAAG,IAAID,OAAO,CAAC,CAAC;AAEhC,OAAO,MAAME,OAAO,GAAGA,CAAA,KAAMD,UAAU;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,aAAa,SAASvF,GAAG,CAAC;EAC9B;AACF;AACA;EACEwF,WAAWA,CAACC,CAAC,EAAE;IACb,OAAO,IAAI,CAACrE,MAAM,CAACoE,WAAW,CAACC,CAAC,CAAC,CAAC;EACpC;EACA;AACF;AACA;EACEC,QAAQA,CAACD,CAAC,EAAE;IACV,OAAO,IAAI,CAACrE,MAAM,CAACsE,QAAQ,CAACD,CAAC,CAAC,CAAC;EACjC;;EAEA;AACF;AACA;AACA;AACA;EACErE,MAAMA,CAACF,MAAM,EAAE;IACb,OAAO,IAAIyE,aAAa,CAAC;MAAEC,IAAI,EAAE,IAAI;MAAE1E;IAAO,CAAC,CAAC;EAClD;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM2E,SAAS,SAASN,aAAa,CAAC;EACpC;AACF;AACA;AACA;EACElF,QAAQA,CAACC,KAAK,EAAE;IACd,OAAO,OAAOA,KAAK,KAAK,QAAQ,GAC5B;MAAER,EAAE,EAAEQ;IAAM,CAAC,GACbuB,SAAS,CAAC;MAAEC,MAAM,EAAE,QAAQ;MAAEC,MAAM,EAAEzB;IAAM,CAAC,CAAC;EACpD;EACAH,QAAQA,CAAA,EAAG;IACT,OAAQ,UAAS;EACnB;AACF;;AAEA;AACA,MAAM2F,SAAS,GAAG,IAAID,SAAS,CAAC,CAAC;AACjC,OAAO,MAAME,MAAM,GAAGA,CAAA,KAAMD,SAAS;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMH,aAAa,SAASJ,aAAa,CAAC;EACxC;AACF;AACA;AACA;AACA;EACElF,QAAQA,CAACC,KAAK,EAAE;IAAEsF,IAAI;IAAE1E;EAAO,CAAC,EAAE;IAChC,MAAML,MAAM,GAAG+E,IAAI,CAACpF,IAAI,CAACF,KAAK,CAAC;IAC/B,OAAOO,MAAM,CAACF,KAAK,GAAGE,MAAM,GAAGK,MAAM,CAACV,IAAI,CAACK,MAAM,CAACf,EAAE,CAAC;EACvD;EACAK,QAAQA,CAAA,EAAG;IACT,OAAQ,GAAE,IAAI,CAACD,QAAQ,CAAC0F,IAAK,WAAU,IAAI,CAAC1F,QAAQ,CAACgB,MAAO,GAAE;EAChE;AACF;;AAEA;AACA;AACA;AACA;AACA,MAAM8E,QAAQ,SAAShG,GAAG,CAAC;EACzB;AACF;AACA;AACA;AACA;EACEK,QAAQA,CAACC,KAAK,EAAEyF,MAAM,EAAE;IACtB,IAAIzF,KAAK,GAAGyF,MAAM,EAAE;MAClB,OAAO;QAAEjG,EAAE,EAAEQ;MAAM,CAAC;IACtB,CAAC,MAAM;MACL,OAAOK,KAAK,CAAE,YAAWL,KAAM,MAAKyF,MAAO,EAAC,CAAC;IAC/C;EACF;EACA5F,QAAQA,CAAA,EAAG;IACT,OAAQ,YAAW,IAAI,CAACD,QAAS,GAAE;EACrC;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMwF,QAAQ,GAAGD,CAAC,IAAI,IAAIO,QAAQ,CAACP,CAAC,CAAC;;AAE5C;AACA;AACA;AACA;AACA,MAAMQ,WAAW,SAASjG,GAAG,CAAC;EAC5B;AACF;AACA;AACA;AACA;EACEK,QAAQA,CAACC,KAAK,EAAEyF,MAAM,EAAE;IACtB,IAAIzF,KAAK,GAAGyF,MAAM,EAAE;MAClB,OAAO;QAAEjG,EAAE,EAAEQ;MAAM,CAAC;IACtB,CAAC,MAAM;MACL,OAAOK,KAAK,CAAE,YAAWL,KAAM,MAAKyF,MAAO,EAAC,CAAC;IAC/C;EACF;EACA5F,QAAQA,CAAA,EAAG;IACT,OAAQ,eAAc,IAAI,CAACD,QAAS,GAAE;EACxC;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMsF,WAAW,GAAGC,CAAC,IAAI,IAAIQ,WAAW,CAACR,CAAC,CAAC;AAElD,MAAMS,OAAO,GAAG;EACd;AACF;AACA;AACA;EACE1F,IAAIA,CAACF,KAAK,EAAE;IACV,OAAO6F,MAAM,CAACC,SAAS,CAAC9F,KAAK,CAAC,GAC1B;MAAER,EAAE,IAAE,6BAA+BQ,KAAK;IAAE,CAAC,GAC7CuB,SAAS,CAAC;MACRC,MAAM,EAAE,SAAS;MACjBC,MAAM,EAAEzB;IACV,CAAC,CAAC;EACR,CAAC;EACDH,QAAQA,CAAA,EAAG;IACT,OAAQ,SAAQ;EAClB;AACF,CAAC;AAED,MAAMkG,UAAU,GAAGP,SAAS,CAAC1E,MAAM,CAAC8E,OAAO,CAAC;AAC5C,OAAO,MAAMI,OAAO,GAAGA,CAAA,KAAMD,UAAU;AAEvC,MAAME,UAAU,GAAG,EAAE,IAAI,GAAG,GAAG,EAAE;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,YAAY,SAASxG,GAAG,CAAC;EAC7B;AACF;AACA;AACA;EACEQ,IAAIA,CAACF,KAAK,EAAE;IACV,QAAQ,OAAOA,KAAK;MAClB,KAAK,QAAQ;QACX,OAAOA,KAAK,GAAGiG,UAAU,GACrB5F,KAAK,CAAE,kCAAiCL,KAAM,MAAKiG,UAAW,EAAC,CAAC,GAChEjG,KAAK,GAAG,CAAC,GACTK,KAAK,CACF,sDAAqDL,KAAM,MAAK,CAAE,EACrE,CAAC,GACD;UAAER,EAAE,IAAE,oBAAsBQ,KAAK;QAAE,CAAC;MAE1C,KAAK,QAAQ;QACX,OAAO,CAAC6F,MAAM,CAACC,SAAS,CAAC9F,KAAK,CAAC,GAC3BuB,SAAS,CAAC;UACRC,MAAM,EAAE,QAAQ;UAChBC,MAAM,EAAEzB;QACV,CAAC,CAAC,GACFA,KAAK,GAAG,CAAC,GACTK,KAAK,CACF,sDAAqDL,KAAM,MAAK,CAAE,EACrE,CAAC,GACD;UAAER,EAAE,IAAE,gBAAkB2G,MAAM,CAACnG,KAAK,CAAC;QAAE,CAAC;MAE9C;QACE,OAAOuB,SAAS,CAAC;UACfC,MAAM,EAAE,QAAQ;UAChBC,MAAM,EAAEzB;QACV,CAAC,CAAC;IACN;EACF;EAEAH,QAAQA,CAAA,EAAG;IACT,OAAQ,QAAO;EACjB;AACF;;AAEA;AACA,MAAMuG,MAAM,GAAG,IAAIF,YAAY,CAAC,CAAC;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMG,MAAM,GAAGA,CAAA,KAAMD,MAAM;AAElC,MAAME,KAAK,GAAG;EACZ;AACF;AACA;AACA;EACEpG,IAAIA,CAACuF,MAAM,EAAE;IACX,OAAOI,MAAM,CAACU,QAAQ,CAACd,MAAM,CAAC,GAC1B;MAAEjG,EAAE,IAAE,2BAA6BiG,MAAM;IAAE,CAAC,GAC5ClE,SAAS,CAAC;MACRC,MAAM,EAAE,OAAO;MACfC,MAAM,EAAEgE;IACV,CAAC,CAAC;EACR,CAAC;EACD5F,QAAQA,CAAA,EAAG;IACT,OAAO,OAAO;EAChB;AACF,CAAC;AAED,MAAM2G,QAAQ,GAAGhB,SAAS,CAAC1E,MAAM,CAACwF,KAAK,CAAC;AACxC,OAAO,MAAMG,KAAK,GAAGA,CAAA,KAAMD,QAAQ;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,aAAa,SAAShH,GAAG,CAAC;EAC9B;AACF;AACA;AACA;AACA;EACEoB,MAAMA,CAACF,MAAM,EAAE;IACb,MAAM+F,KAAK,GAAG,kCAAoC/F,MAAO;IACzD,MAAMgG,IAAI,GAAG,IAAIC,aAAa,CAAC;MAC7BvB,IAAI,EAAE,IAAI;MACV1E,MAAM,EAAE+F;IACV,CAAC,CAAC;IAEF,OAAO,4CAA8CC,IAAI;EAC3D;EACA;AACF;AACA;AACA;EACEE,UAAUA,CAACC,MAAM,EAAE;IACjB,OAAO,IAAI,CAACjG,MAAM,CAACgG,UAAU,CAACC,MAAM,CAAC,CAAC;EACxC;EACA;AACF;AACA;AACA;EACEC,QAAQA,CAACC,MAAM,EAAE;IACf,OAAO,IAAI,CAACnG,MAAM,CAACkG,QAAQ,CAACC,MAAM,CAAC,CAAC;EACtC;EACApH,QAAQA,CAAA,EAAG;IACT,OAAQ,UAAS;EACnB;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMgH,aAAa,SAASH,aAAa,CAAC;EACxC;AACF;AACA;AACA;AACA;EACE3G,QAAQA,CAACC,KAAK,EAAE;IAAEsF,IAAI;IAAE1E;EAAO,CAAC,EAAE;IAChC,MAAML,MAAM,GAAG+E,IAAI,CAACpF,IAAI,CAACF,KAAK,CAAC;IAC/B,OAAOO,MAAM,CAACF,KAAK,GACfE,MAAM,KACN,uCAAyCK,MAAM,CAACV,IAAI,CAACK,MAAM,CAACf,EAAE,CAAC,CAAC;EACtE;EACAK,QAAQA,CAAA,EAAG;IACT,OAAQ,GAAE,IAAI,CAACD,QAAQ,CAAC0F,IAAK,WAAU,IAAI,CAAC1F,QAAQ,CAACgB,MAAO,GAAE;EAChE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAMsG,SAAS,SAASR,aAAa,CAAC;EACpC;AACF;AACA;AACA;EACE3G,QAAQA,CAACC,KAAK,EAAE;IACd,OAAO,OAAOA,KAAK,KAAK,QAAQ,GAC5B;MAAER,EAAE,EAAEQ;IAAM,CAAC,GACbuB,SAAS,CAAC;MAAEC,MAAM,EAAE,QAAQ;MAAEC,MAAM,EAAEzB;IAAM,CAAC,CAAC;EACpD;AACF;;AAEA;AACA,MAAMmH,SAAS,GAAG,IAAID,SAAS,CAAC,CAAC;AACjC,OAAO,MAAMpD,MAAM,GAAGA,CAAA,KAAMqD,SAAS;;AAErC;AACA;AACA;AACA;AACA,MAAMC,WAAW,SAAS1H,GAAG,CAAC;EAC5B;AACF;AACA;AACA;EACEK,QAAQA,CAACC,KAAK,EAAE;IACd,IAAIA,KAAK,YAAYqH,UAAU,EAAE;MAC/B,OAAO;QAAE7H,EAAE,EAAEQ;MAAM,CAAC;IACtB,CAAC,MAAM;MACL,OAAOuB,SAAS,CAAC;QAAEC,MAAM,EAAE,YAAY;QAAEC,MAAM,EAAEzB;MAAM,CAAC,CAAC;IAC3D;EACF;AACF;;AAEA;AACA,OAAO,MAAMsH,KAAK,GAAG,IAAIF,WAAW,CAAC,CAAC;AACtC,OAAO,MAAMG,KAAK,GAAGA,CAAA,KAAMD,KAAK;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,UAAU,SAAS9H,GAAG,CAAC;EAC3B;AACF;AACA;AACA;EACEK,QAAQA,CAACC,KAAK,EAAE+G,MAAM,EAAE;IACtB,MAAMxG,MAAM,GAAGP,KAAK,CAAC8G,UAAU,CAACC,MAAM,CAAC,KACnC,2DAA6D;MAC3DvH,EAAE,EAAEQ;IACN,CAAC,IACDK,KAAK,CAAE,gCAA+B0G,MAAO,kBAAiB/G,KAAM,GAAE,CAAC;IAE3E,OAAOO,MAAM;EACf;EACA,IAAIwG,MAAMA,CAAA,EAAG;IACX,OAAO,IAAI,CAACnH,QAAQ;EACtB;EACAC,QAAQA,CAAA,EAAG;IACT,OAAQ,eAAc,IAAI,CAACkH,MAAO,IAAG;EACvC;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMD,UAAU,GAAGC,MAAM,IAAI,IAAIS,UAAU,CAACT,MAAM,CAAC;;AAE1D;AACA;AACA;AACA;AACA;AACA,MAAMU,QAAQ,SAAS/H,GAAG,CAAC;EACzB;AACF;AACA;AACA;EACEK,QAAQA,CAACC,KAAK,EAAEiH,MAAM,EAAE;IACtB,OAAOjH,KAAK,CAACgH,QAAQ,CAACC,MAAM,CAAC,KACzB,2DAA6D;MAC3DzH,EAAE,EAAEQ;IACN,CAAC,IACDK,KAAK,CAAE,8BAA6B4G,MAAO,kBAAiBjH,KAAM,GAAE,CAAC;EAC3E;EACA,IAAIiH,MAAMA,CAAA,EAAG;IACX,OAAO,IAAI,CAACrH,QAAQ;EACtB;EACAC,QAAQA,CAAA,EAAG;IACT,OAAQ,aAAY,IAAI,CAACoH,MAAO,IAAG;EACrC;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMD,QAAQ,GAAGC,MAAM,IAAI,IAAIQ,QAAQ,CAACR,MAAM,CAAC;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMS,MAAM,SAAShI,GAAG,CAAC;EACvB;AACF;AACA;AACA;EACEK,QAAQA,CAACC,KAAK,EAAE;IAAEsF,IAAI;IAAE1E;EAAO,CAAC,EAAE;IAChC,MAAML,MAAM,GAAG+E,IAAI,CAACpF,IAAI,CAACF,KAAK,CAAC;IAC/B,OAAOO,MAAM,CAACF,KAAK,GAAGE,MAAM,GAAGK,MAAM,CAACV,IAAI,CAACK,MAAM,CAACf,EAAE,CAAC;EACvD;EACAK,QAAQA,CAAA,EAAG;IACT,OAAQ,GAAE,IAAI,CAACD,QAAQ,CAAC0F,IAAK,WAAU,IAAI,CAAC1F,QAAQ,CAACgB,MAAO,GAAE;EAChE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAME,MAAM,GAAGA,CAACwE,IAAI,EAAE1E,MAAM,KAAK,IAAI8G,MAAM,CAAC;EAAEpC,IAAI;EAAE1E;AAAO,CAAC,CAAC;;AAEpE;AACA;AACA;AACA;AACA;AACA;AACA,MAAM+G,OAAO,SAASjI,GAAG,CAAC;EACxB;AACF;AACA;AACA;AACA;EACEK,QAAQA,CAACC,KAAK,EAAEwB,MAAM,EAAE;IACtB,OAAOxB,KAAK,OAAK,sBAAwBwB,MAAM,CAAC,GAC5C;MAAEnB,KAAK,EAAE,IAAIuH,YAAY,CAAC;QAAEpG,MAAM;QAAEC,MAAM,EAAEzB;MAAM,CAAC;IAAE,CAAC,GACtD;MAAER,EAAE,EAAEgC;IAAO,CAAC;EACpB;EACA,IAAIpB,KAAKA,CAAA,EAAG;IACV,OAAO,oCAAsC,IAAI,CAACR,QAAQ;EAC5D;EACA;AACF;AACA;AACA;EACEqB,OAAOA,CAACb,KAAK,KAAG,gBAAkB,IAAI,CAACA,KAAK,CAAC,EAAE;IAC7C,OAAO,KAAK,CAACa,OAAO,CAACb,KAAK,CAAC;EAC7B;EACAP,QAAQA,CAAA,EAAG;IACT,OAAQ,WAAUA,QAAQ,CAAC,IAAI,CAACO,KAAK,CAAE,GAAE;EAC3C;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMyH,OAAO,GAAGzH,KAAK,IAAI,IAAIuH,OAAO,CAACvH,KAAK,CAAC;;AAElD;AACA;AACA;AACA;AACA;AACA,MAAM0H,MAAM,SAASpI,GAAG,CAAC;EACvB;AACF;AACA;AACA;AACA;EACEK,QAAQA,CAACC,KAAK,EAAE+C,KAAK,EAAE;IACrB,IAAI,OAAO/C,KAAK,IAAI,QAAQ,IAAIA,KAAK,KAAK,IAAI,IAAIoC,KAAK,CAACC,OAAO,CAACrC,KAAK,CAAC,EAAE;MACtE,OAAOuB,SAAS,CAAC;QACfC,MAAM,EAAE,QAAQ;QAChBC,MAAM,EAAEzB;MACV,CAAC,CAAC;IACJ;IAEA,MAAM+H,MAAM,GAAG,wCAA0C/H,KAAM;IAE/D,MAAMgI,MAAM,GAAG,mDAAqD,CAAC,CAAE;IACvE,MAAMxF,OAAO,GACX;IACEiB,MAAM,CAACjB,OAAO,CAACO,KAAK,CACrB;IAEH,KAAK,MAAM,CAACL,EAAE,EAAErB,MAAM,CAAC,IAAImB,OAAO,EAAE;MAClC,MAAMjC,MAAM,GAAGc,MAAM,CAACnB,IAAI,CAAC6H,MAAM,CAACrF,EAAE,CAAC,CAAC;MACtC,IAAInC,MAAM,CAACF,KAAK,EAAE;QAChB,OAAOoC,WAAW,CAAC;UAAEC,EAAE;UAAEC,KAAK,EAAEpC,MAAM,CAACF;QAAM,CAAC,CAAC;MACjD;MACA;MAAA,KACK,IAAIE,MAAM,CAACf,EAAE,KAAK2B,SAAS,EAAE;QAChC6G,MAAM,CAACtF,EAAE,CAAC,GAAG,yCAA2CnC,MAAM,CAACf,EAAG;MACpE;IACF;IAEA,OAAO;MAAEA,EAAE,EAAEwI;IAAO,CAAC;EACvB;;EAEA;AACF;AACA;EACEpE,OAAOA,CAAA,EAAG;IACR,OAAO,IAAIkE,MAAM,CACfrE,MAAM,CAACwE,WAAW,CAChBxE,MAAM,CAACjB,OAAO,CAAC,IAAI,CAACO,KAAK,CAAC,CAACE,GAAG,CAAC,CAAC,CAACI,GAAG,EAAEjD,KAAK,CAAC,KAAK,CAACiD,GAAG,EAAE7C,QAAQ,CAACJ,KAAK,CAAC,CAAC,CACzE,CACF,CAAC;EACH;;EAEA;EACA,IAAI2C,KAAKA,CAAA,EAAG;IACV;IACA,OAAO,IAAI,CAACnD,QAAQ;EACtB;EAEAC,QAAQA,CAAA,EAAG;IACT,OAAO,CACJ,WAAU,EACX,GAAG4D,MAAM,CAACjB,OAAO,CAAC,IAAI,CAACO,KAAK,CAAC,CAC1BE,GAAG,CAAC,CAAC,CAACI,GAAG,EAAEzC,MAAM,CAAC,KAAM,GAAEyC,GAAI,KAAIzC,MAAO,EAAC,CAAC,CAC3CsC,IAAI,CAAC,IAAI,CAAC,EACZ,KAAI,CACN,CAACA,IAAI,CAAC,EAAE,CAAC;EACZ;;EAEA;AACF;AACA;EACEgF,MAAMA,CAACC,IAAI,EAAE;IACX,OAAO,IAAI,CAAC7H,IAAI,CAAC6H,IAAI,IAAI,CAAC,CAAC,CAAC;EAC9B;;EAEA;AACF;AACA;AACA;AACA;EACEC,MAAMA,CAACC,SAAS,EAAE;IAChB,OAAO,IAAIP,MAAM,CAAC;MAAE,GAAG,IAAI,CAAC/E,KAAK;MAAE,GAAGsF;IAAU,CAAC,CAAC;EACpD;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAML,MAAM,GAAGM,MAAM,IAAI;EAC9B,MAAMvF,KAAK,GACT,gEAAkE,CAAC,CAAE;EACvE;EACA,MAAMP,OAAO,GAAGiB,MAAM,CAACjB,OAAO,CAAC8F,MAAM,CAAC;EAEtC,KAAK,MAAM,CAACjF,GAAG,EAAEkF,KAAK,CAAC,IAAI/F,OAAO,EAAE;IAClC,QAAQ,OAAO+F,KAAK;MAClB,KAAK,QAAQ;MACb,KAAK,QAAQ;MACb,KAAK,SAAS;QACZxF,KAAK,CAACM,GAAG,CAAC,GAAGwE,OAAO,CAACU,KAAK,CAAC;QAC3B;MACF,KAAK,QAAQ;QACXxF,KAAK,CAACM,GAAG,CAAC,GAAGkF,KAAK,KAAK,IAAI,GAAGV,OAAO,CAAC,IAAI,CAAC,GAAGU,KAAK;QACnD;MACF;QACE,MAAM,IAAItI,KAAK,CACZ,yBAAwBoD,GAAI,8CAA6C,OAAOkF,KAAM,EACzF,CAAC;IACL;EACF;EAEA,OAAO,IAAIT,MAAM,EAAC,gBAAkB/E,KAAM,CAAC;AAC7C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMyF,OAAO,SAAS9I,GAAG,CAAC;EACxB;AACF;AACA;AACA;AACA;EACEK,QAAQA,CAACC,KAAK,EAAEgE,QAAQ,EAAE;IACxB,IAAI,OAAOhE,KAAK,IAAI,QAAQ,IAAIA,KAAK,KAAK,IAAI,IAAIoC,KAAK,CAACC,OAAO,CAACrC,KAAK,CAAC,EAAE;MACtE,OAAOuB,SAAS,CAAC;QACfC,MAAM,EAAE,QAAQ;QAChBC,MAAM,EAAEzB;MACV,CAAC,CAAC;IACJ;IAEA,MAAMyI,IAAI,GAAG;IACXhF,MAAM,CAACgF,IAAI,CAACzI,KAAK,CAClB;IAED,MAAM,CAACqD,GAAG,CAAC,GAAGoF,IAAI,CAACzF,MAAM,KAAK,CAAC,GAAGyF,IAAI,GAAG,EAAE;IAC3C,MAAMpH,MAAM,GAAGgC,GAAG,GAAGW,QAAQ,CAACX,GAAG,CAAC,GAAGlC,SAAS;IAE9C,IAAIE,MAAM,EAAE;MACV,MAAMd,MAAM,GAAGc,MAAM,CAACnB,IAAI,CAACF,KAAK,CAACqD,GAAG,CAAC,CAAC;MACtC,OAAO9C,MAAM,CAACF,KAAK,GACfoC,WAAW,CAAC;QAAEC,EAAE,EAAEW,GAAG;QAAEV,KAAK,EAAEpC,MAAM,CAACF;MAAM,CAAC,CAAC,GAC7C;QAAEb,EAAE,IAAE,qCAAuC;UAAE,CAAC6D,GAAG,GAAG9C,MAAM,CAACf;QAAG,CAAC;MAAE,CAAC;IAC1E,CAAC,MAAM,IAAIwE,QAAQ,CAAC0E,CAAC,EAAE;MACrB,MAAMnI,MAAM,GAAGyD,QAAQ,CAAC0E,CAAC,CAACxI,IAAI,CAACF,KAAK,CAAC;MACrC,OAAOO,MAAM,CAACF,KAAK,GACfE,MAAM,GACN;QAAEf,EAAE,IAAE,qCAAuC;UAAEkJ,CAAC,EAAEnI,MAAM,CAACf;QAAG,CAAC;MAAE,CAAC;IACtE,CAAC,MAAM,IAAI6D,GAAG,EAAE;MACd,OAAOhD,KAAK,CACT,kDAAiDoD,MAAM,CAACgF,IAAI,CAACzE,QAAQ,CAAC,CACpE2E,IAAI,CAAC,CAAC,CACNzF,IAAI,CAAC,IAAI,CAAE,gCAA+BG,GAAI,EACnD,CAAC;IACH,CAAC,MAAM;MACL,OAAOhD,KAAK,CACV,oEAAoE,GAClEoI,IAAI,CAACE,IAAI,CAAC,CAAC,CAACzF,IAAI,CAAC,IAAI,CACzB,CAAC;IACH;EACF;;EAEA;AACF;AACA;AACA;AACA;EACE0F,KAAKA,CAAC5I,KAAK,EAAEkB,QAAQ,EAAE;IACrB,MAAMX,MAAM,GAAG,IAAI,CAACL,IAAI,CAACF,KAAK,CAAC;IAC/B,IAAIO,MAAM,CAACF,KAAK,EAAE;MAChB,IAAIa,QAAQ,KAAKC,SAAS,EAAE;QAC1B,OAAO,CAAC,IAAI,EAAED,QAAQ,CAAC;MACzB,CAAC,MAAM;QACL,MAAMX,MAAM,CAACF,KAAK;MACpB;IACF,CAAC,MAAM;MACL,MAAM,CAACgD,GAAG,CAAC,GAAGI,MAAM,CAACgF,IAAI,CAAClI,MAAM,CAACf,EAAE,CAAC;MACpC,MAAMY,KAAK,GAAGG,MAAM,CAACf,EAAE,CAAC6D,GAAG,CAAC;MAC5B,OAAO,kBAAoB,CAACA,GAAG,EAAEjD,KAAK,CAAC;IACzC;EACF;;EAEA;AACF;AACA;AACA;AACA;EACE8H,MAAMA,CAACH,MAAM,EAAE;IACb,OAAO,gBAAkB,IAAI,CAACzH,IAAI,CAACyH,MAAM,CAAC;EAC5C;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMc,OAAO,GAAG7E,QAAQ,IAAI,IAAIwE,OAAO,CAACxE,QAAQ,CAAC;;AAExD;AACA;AACA;AACA;AACA,OAAO,MAAM3D,KAAK,GAAGyI,OAAO,KAAK;EAAEzI,KAAK,EAAE,IAAI0I,WAAW,CAACD,OAAO;AAAE,CAAC,CAAC;AAErE,MAAMC,WAAW,SAAStJ,OAAO,CAAC;EAChC,IAAIK,IAAIA,CAAA,EAAG;IACT,OAAO,aAAa;EACtB;EACA;EACAkJ,QAAQA,CAAA,EAAG;IACT,OAAO,IAAI,CAAClJ,IAAI;EAClB;AACF;AAEA,MAAMmJ,SAAS,SAASF,WAAW,CAAC;EAClC;AACF;AACA;EACEpJ,WAAWA,CAAC;IAAE6B,MAAM;IAAEC;EAAO,CAAC,EAAE;IAC9B,KAAK,CAAC,CAAC;IACP,IAAI,CAACD,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,MAAM,GAAGA,MAAM;EACtB;EACA,IAAI3B,IAAIA,CAAA,EAAG;IACT,OAAO,WAAW;EACpB;EACAkJ,QAAQA,CAAA,EAAG;IACT,OAAQ,0BAAyB,IAAI,CAACxH,MAAO,gBAAe3B,QAAQ,CAClE,IAAI,CAAC4B,MACP,CAAE,EAAC;EACL;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMF,SAAS,GAAG4G,IAAI,KAAK;EAAE9H,KAAK,EAAE,IAAI4I,SAAS,CAACd,IAAI;AAAE,CAAC,CAAC;;AAEjE;AACA;AACA;AACA;AACA,OAAO,MAAMtI,QAAQ,GAAGO,KAAK,IAAI;EAC/B,MAAM6D,IAAI,GAAG,OAAO7D,KAAK;EACzB,QAAQ6D,IAAI;IACV,KAAK,SAAS;IACd,KAAK,QAAQ;MACX,OAAOhC,IAAI,CAACC,SAAS,CAAC9B,KAAK,CAAC;IAC9B;IACA;IACA,KAAK,QAAQ;MACX,OAAQ,GAAEA,KAAM,GAAE;IACpB,KAAK,QAAQ;IACb,KAAK,QAAQ;IACb,KAAK,WAAW;MACd,OAAO8I,MAAM,CAAC9I,KAAK,CAAC;IACtB,KAAK,QAAQ;MACX,OAAOA,KAAK,KAAK,IAAI,GACjB,MAAM,GACNgC,KAAK,CAACC,OAAO,CAACjC,KAAK,CAAC,GACpB,OAAO,GACP+I,MAAM,CAACC,WAAW,MAAI,qBAAuBhJ,KAAK,CAAC,GACnDA,KAAK,CAAC+I,MAAM,CAACC,WAAW,CAAC,GACzB,QAAQ;IACd;MACE,OAAOnF,IAAI;EACf;AACF,CAAC;AAED,MAAM2D,YAAY,SAASmB,WAAW,CAAC;EACrC;AACF;AACA;AACA;AACA;AACA;EACEpJ,WAAWA,CAAC;IAAE6B,MAAM;IAAEC;EAAO,CAAC,EAAE;IAC9B,KAAK,CAAC,CAAC;IACP,IAAI,CAACD,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,MAAM,GAAGA,MAAM;EACtB;EACA,IAAI3B,IAAIA,CAAA,EAAG;IACT,OAAO,cAAc;EACvB;EACAkJ,QAAQA,CAAA,EAAG;IACT,OAAQ,oBAAmBnJ,QAAQ,CAAC,IAAI,CAAC2B,MAAM,CAAE,gBAAe3B,QAAQ,CACtE,IAAI,CAAC4B,MACP,CAAE,EAAC;EACL;AACF;AAEA,MAAM4H,YAAY,SAASN,WAAW,CAAC;EACrC;AACF;AACA;EACEpJ,WAAWA,CAAC;IAAE+C,EAAE;IAAEC;EAAM,CAAC,EAAE;IACzB,KAAK,CAAC,CAAC;IACP,IAAI,CAACD,EAAE,GAAGA,EAAE;IACZ,IAAI,CAACC,KAAK,GAAGA,KAAK;EACpB;EACA,IAAI7C,IAAIA,CAAA,EAAG;IACT,OAAO,cAAc;EACvB;EACAkJ,QAAQA,CAAA,EAAG;IACT,OAAO,CACJ,qCAAoC,IAAI,CAACtG,EAAG,GAAE,EAC/C4G,EAAE,CAAC,IAAI,CAAC3G,KAAK,CAACmG,OAAO,CAAC,CACvB,CAAC5F,IAAI,CAAC,IAAI,CAAC;EACd;AACF;AAEA,MAAMqG,UAAU,SAASR,WAAW,CAAC;EACnC;AACF;AACA;EACEpJ,WAAWA,CAAC;IAAE+C,EAAE;IAAEC;EAAM,CAAC,EAAE;IACzB,KAAK,CAAC,CAAC;IACP,IAAI,CAACD,EAAE,GAAGA,EAAE;IACZ,IAAI,CAACC,KAAK,GAAGA,KAAK;EACpB;EACA,IAAI7C,IAAIA,CAAA,EAAG;IACT,OAAO,YAAY;EACrB;EACAkJ,QAAQA,CAAA,EAAG;IACT,OAAO,CACJ,kCAAiC,IAAI,CAACtG,EAAG,IAAG,EAC7C4G,EAAE,CAAC,IAAI,CAAC3G,KAAK,CAACmG,OAAO,CAAC,CACvB,CAAC5F,IAAI,CAAC,IAAI,CAAC;EACd;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMT,WAAW,GAAGA,CAAC;EAAEC,EAAE;EAAEC;AAAM,CAAC,KACvC,OAAOD,EAAE,KAAK,QAAQ,GAClB;EAAErC,KAAK,EAAE,IAAIkJ,UAAU,CAAC;IAAE7G,EAAE;IAAEC;EAAM,CAAC;AAAE,CAAC,GACxC;EAAEtC,KAAK,EAAE,IAAIgJ,YAAY,CAAC;IAAE3G,EAAE;IAAEC;EAAM,CAAC;AAAE,CAAC;AAEhD,MAAMb,UAAU,SAASiH,WAAW,CAAC;EACnC;AACF;AACA;EACEpJ,WAAWA,CAAC;IAAEoC;EAAO,CAAC,EAAE;IACtB,KAAK,CAAC,CAAC;IACP,IAAI,CAACA,MAAM,GAAGA,MAAM;EACtB;EACA,IAAIjC,IAAIA,CAAA,EAAG;IACT,OAAO,YAAY;EACrB;EACAkJ,QAAQA,CAAA,EAAG;IACT,MAAM;MAAEjH;IAAO,CAAC,GAAG,IAAI;IACvB,OAAO,CACJ,6CAA4C,EAC7C,GAAGA,MAAM,CAACkB,GAAG,CAACN,KAAK,IAAI2G,EAAE,CAAC3G,KAAK,CAACmG,OAAO,CAAC,CAAC,CAC1C,CAAC5F,IAAI,CAAC,IAAI,CAAC;EACd;AACF;AAEA,MAAM0B,iBAAiB,SAASmE,WAAW,CAAC;EAC1C;AACF;AACA;EACEpJ,WAAWA,CAAC;IAAEoC;EAAO,CAAC,EAAE;IACtB,KAAK,CAAC,CAAC;IACP,IAAI,CAACA,MAAM,GAAGA,MAAM;EACtB;EACA,IAAIjC,IAAIA,CAAA,EAAG;IACT,OAAO,mBAAmB;EAC5B;EACAkJ,QAAQA,CAAA,EAAG;IACT,MAAM;MAAEjH;IAAO,CAAC,GAAG,IAAI;IACvB,OAAO,CACJ,2DAA0D,EAC3D,GAAGA,MAAM,CAACkB,GAAG,CAACN,KAAK,IAAI2G,EAAE,CAAC3G,KAAK,CAACmG,OAAO,CAAC,CAAC,CAC1C,CAAC5F,IAAI,CAAC,IAAI,CAAC;EACd;AACF;;AAEA;AACA;AACA;AACA,MAAMsG,MAAM,GAAGA,CAACV,OAAO,EAAEU,MAAM,GAAG,IAAI,KACnC,GAAEA,MAAO,GAAEV,OAAO,CAACW,KAAK,CAAC,IAAI,CAAC,CAACvG,IAAI,CAAE,KAAIsG,MAAO,EAAC,CAAE,EAAC;;AAEvD;AACA;AACA;AACA,MAAMF,EAAE,GAAGR,OAAO,IAAIU,MAAM,CAAE,KAAIV,OAAQ,EAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}