{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MultiProcessMutex = void 0;\n/* eslint-disable @nomicfoundation/hardhat-internal-rules/only-hardhat-error */\nconst debug_1 = __importDefault(require(\"debug\"));\nconst node_fs_1 = __importDefault(require(\"node:fs\"));\nconst node_path_1 = __importDefault(require(\"node:path\"));\nconst node_os_1 = __importDefault(require(\"node:os\"));\n// Logic explanation: the fs.writeFile function, when used with the wx+ flag, performs an atomic operation to create a file.\n// If multiple processes try to create the same file simultaneously, only one will succeed.\n// This logic can be utilized to implement a mutex.\n// ATTENTION: in the current implementation, there's still a risk of two processes running simultaneously.\n// For example, if processA has locked the mutex and is running, processB will wait.\n// During this wait, processB continuously checks the elapsed time since the mutex lock file was created.\n// If an excessive amount of time has passed, processB will assume ownership of the mutex to avoid stale locks.\n// However, there's a possibility that processB might take ownership because the mutex creation file is outdated, even though processA is still running\n// For more info check the Nomic Notion page (internal link).\nconst log = (0, debug_1.default)(\"hardhat:util:multi-process-mutex\");\nconst DEFAULT_MAX_MUTEX_LIFESPAN_IN_MS = 60000;\nconst MUTEX_LOOP_WAITING_TIME_IN_MS = 100;\nclass MultiProcessMutex {\n  constructor(mutexName, maxMutexLifespanInMs) {\n    log(`Creating mutex with name '${mutexName}'`);\n    this._mutexFilePath = node_path_1.default.join(node_os_1.default.tmpdir(), `${mutexName}.txt`);\n    this._mutexLifespanInMs = maxMutexLifespanInMs ?? DEFAULT_MAX_MUTEX_LIFESPAN_IN_MS;\n  }\n  async use(f) {\n    log(`Starting mutex process with mutex file '${this._mutexFilePath}'`);\n    while (true) {\n      if (await this._tryToAcquireMutex()) {\n        // Mutex has been acquired\n        return this._executeFunctionAndReleaseMutex(f);\n      }\n      // Mutex not acquired\n      if (this._isMutexFileTooOld()) {\n        // If the mutex file is too old, it likely indicates a stale lock, so the file should be removed\n        log(`Current mutex file is too old, removing it at path '${this._mutexFilePath}'`);\n        this._deleteMutexFile();\n      } else {\n        // wait\n        await this._waitMs();\n      }\n    }\n  }\n  async _tryToAcquireMutex() {\n    try {\n      // Create a file only if it does not exist\n      node_fs_1.default.writeFileSync(this._mutexFilePath, \"\", {\n        flag: \"wx+\"\n      });\n      return true;\n    } catch (error) {\n      if (error.code === \"EEXIST\") {\n        // File already exists, so the mutex is already acquired\n        return false;\n      }\n      throw error;\n    }\n  }\n  async _executeFunctionAndReleaseMutex(f) {\n    log(`Mutex acquired at path '${this._mutexFilePath}'`);\n    try {\n      const res = await f();\n      // Release the mutex\n      log(`Mutex released at path '${this._mutexFilePath}'`);\n      this._deleteMutexFile();\n      log(`Mutex released at path '${this._mutexFilePath}'`);\n      return res;\n    } catch (error) {\n      // Catch any error to avoid stale locks.\n      // Remove the mutex file and re-throw the error\n      this._deleteMutexFile();\n      throw error;\n    }\n  }\n  _isMutexFileTooOld() {\n    let fileStat;\n    try {\n      fileStat = node_fs_1.default.statSync(this._mutexFilePath);\n    } catch (error) {\n      if (error.code === \"ENOENT\") {\n        // The file might have been deleted by another process while this function was trying to access it.\n        return false;\n      }\n      throw error;\n    }\n    const now = new Date();\n    const fileDate = new Date(fileStat.ctime);\n    const diff = now.getTime() - fileDate.getTime();\n    return diff > this._mutexLifespanInMs;\n  }\n  _deleteMutexFile() {\n    try {\n      log(`Deleting mutex file at path '${this._mutexFilePath}'`);\n      node_fs_1.default.unlinkSync(this._mutexFilePath);\n    } catch (error) {\n      if (error.code === \"ENOENT\") {\n        // The file might have been deleted by another process while this function was trying to access it.\n        return;\n      }\n      throw error;\n    }\n  }\n  async _waitMs() {\n    return new Promise(resolve => setTimeout(resolve, MUTEX_LOOP_WAITING_TIME_IN_MS));\n  }\n}\nexports.MultiProcessMutex = MultiProcessMutex;","map":{"version":3,"names":["debug_1","__importDefault","require","node_fs_1","node_path_1","node_os_1","log","default","DEFAULT_MAX_MUTEX_LIFESPAN_IN_MS","MUTEX_LOOP_WAITING_TIME_IN_MS","MultiProcessMutex","constructor","mutexName","maxMutexLifespanInMs","_mutexFilePath","join","tmpdir","_mutexLifespanInMs","use","f","_tryToAcquireMutex","_executeFunctionAndReleaseMutex","_isMutexFileTooOld","_deleteMutexFile","_waitMs","writeFileSync","flag","error","code","res","fileStat","statSync","now","Date","fileDate","ctime","diff","getTime","unlinkSync","Promise","resolve","setTimeout","exports"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\internal\\util\\multi-process-mutex.ts"],"sourcesContent":["/* eslint-disable @nomicfoundation/hardhat-internal-rules/only-hardhat-error */\nimport debug from \"debug\";\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport os from \"node:os\";\n\n// Logic explanation: the fs.writeFile function, when used with the wx+ flag, performs an atomic operation to create a file.\n// If multiple processes try to create the same file simultaneously, only one will succeed.\n// This logic can be utilized to implement a mutex.\n// ATTENTION: in the current implementation, there's still a risk of two processes running simultaneously.\n// For example, if processA has locked the mutex and is running, processB will wait.\n// During this wait, processB continuously checks the elapsed time since the mutex lock file was created.\n// If an excessive amount of time has passed, processB will assume ownership of the mutex to avoid stale locks.\n// However, there's a possibility that processB might take ownership because the mutex creation file is outdated, even though processA is still running\n// For more info check the Nomic Notion page (internal link).\n\nconst log = debug(\"hardhat:util:multi-process-mutex\");\nconst DEFAULT_MAX_MUTEX_LIFESPAN_IN_MS = 60000;\nconst MUTEX_LOOP_WAITING_TIME_IN_MS = 100;\n\nexport class MultiProcessMutex {\n  private _mutexFilePath: string;\n  private _mutexLifespanInMs: number;\n\n  constructor(mutexName: string, maxMutexLifespanInMs?: number) {\n    log(`Creating mutex with name '${mutexName}'`);\n\n    this._mutexFilePath = path.join(os.tmpdir(), `${mutexName}.txt`);\n    this._mutexLifespanInMs =\n      maxMutexLifespanInMs ?? DEFAULT_MAX_MUTEX_LIFESPAN_IN_MS;\n  }\n\n  public async use<T>(f: () => Promise<T>): Promise<T> {\n    log(`Starting mutex process with mutex file '${this._mutexFilePath}'`);\n\n    while (true) {\n      if (await this._tryToAcquireMutex()) {\n        // Mutex has been acquired\n        return this._executeFunctionAndReleaseMutex(f);\n      }\n\n      // Mutex not acquired\n      if (this._isMutexFileTooOld()) {\n        // If the mutex file is too old, it likely indicates a stale lock, so the file should be removed\n        log(\n          `Current mutex file is too old, removing it at path '${this._mutexFilePath}'`\n        );\n        this._deleteMutexFile();\n      } else {\n        // wait\n        await this._waitMs();\n      }\n    }\n  }\n\n  private async _tryToAcquireMutex() {\n    try {\n      // Create a file only if it does not exist\n      fs.writeFileSync(this._mutexFilePath, \"\", { flag: \"wx+\" });\n      return true;\n    } catch (error: any) {\n      if (error.code === \"EEXIST\") {\n        // File already exists, so the mutex is already acquired\n        return false;\n      }\n\n      throw error;\n    }\n  }\n\n  private async _executeFunctionAndReleaseMutex<T>(\n    f: () => Promise<T>\n  ): Promise<T> {\n    log(`Mutex acquired at path '${this._mutexFilePath}'`);\n\n    try {\n      const res = await f();\n\n      // Release the mutex\n      log(`Mutex released at path '${this._mutexFilePath}'`);\n      this._deleteMutexFile();\n\n      log(`Mutex released at path '${this._mutexFilePath}'`);\n\n      return res;\n    } catch (error: any) {\n      // Catch any error to avoid stale locks.\n      // Remove the mutex file and re-throw the error\n      this._deleteMutexFile();\n      throw error;\n    }\n  }\n\n  private _isMutexFileTooOld(): boolean {\n    let fileStat;\n    try {\n      fileStat = fs.statSync(this._mutexFilePath);\n    } catch (error: any) {\n      if (error.code === \"ENOENT\") {\n        // The file might have been deleted by another process while this function was trying to access it.\n        return false;\n      }\n\n      throw error;\n    }\n\n    const now = new Date();\n    const fileDate = new Date(fileStat.ctime);\n    const diff = now.getTime() - fileDate.getTime();\n\n    return diff > this._mutexLifespanInMs;\n  }\n\n  private _deleteMutexFile() {\n    try {\n      log(`Deleting mutex file at path '${this._mutexFilePath}'`);\n      fs.unlinkSync(this._mutexFilePath);\n    } catch (error: any) {\n      if (error.code === \"ENOENT\") {\n        // The file might have been deleted by another process while this function was trying to access it.\n        return;\n      }\n\n      throw error;\n    }\n  }\n\n  private async _waitMs() {\n    return new Promise((resolve) =>\n      setTimeout(resolve, MUTEX_LOOP_WAITING_TIME_IN_MS)\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}