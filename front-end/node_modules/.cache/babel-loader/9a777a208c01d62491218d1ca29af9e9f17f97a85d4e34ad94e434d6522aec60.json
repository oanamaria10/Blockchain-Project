{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findDistance = exports.parseName = exports.parseFullyQualifiedName = exports.isFullyQualifiedName = exports.getFullyQualifiedName = void 0;\nconst errors_1 = require(\"../internal/core/errors\");\nconst errors_list_1 = require(\"../internal/core/errors-list\");\n/**\n * Returns a fully qualified name from a sourceName and contractName.\n */\nfunction getFullyQualifiedName(sourceName, contractName) {\n  return `${sourceName}:${contractName}`;\n}\nexports.getFullyQualifiedName = getFullyQualifiedName;\n/**\n * Returns true if a name is fully qualified, and not just a bare contract name.\n */\nfunction isFullyQualifiedName(name) {\n  return name.includes(\":\");\n}\nexports.isFullyQualifiedName = isFullyQualifiedName;\n/**\n * Parses a fully qualified name.\n *\n * @param fullyQualifiedName It MUST be a fully qualified name.\n * @throws {HardhatError} If the name is not fully qualified.\n */\nfunction parseFullyQualifiedName(fullyQualifiedName) {\n  const {\n    sourceName,\n    contractName\n  } = parseName(fullyQualifiedName);\n  if (sourceName === undefined) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.CONTRACT_NAMES.INVALID_FULLY_QUALIFIED_NAME, {\n      name: fullyQualifiedName\n    });\n  }\n  return {\n    sourceName,\n    contractName\n  };\n}\nexports.parseFullyQualifiedName = parseFullyQualifiedName;\n/**\n * Parses a name, which can be a bare contract name, or a fully qualified name.\n */\nfunction parseName(name) {\n  const parts = name.split(\":\");\n  if (parts.length === 1) {\n    return {\n      contractName: parts[0]\n    };\n  }\n  const contractName = parts[parts.length - 1];\n  const sourceName = parts.slice(0, parts.length - 1).join(\":\");\n  return {\n    sourceName,\n    contractName\n  };\n}\nexports.parseName = parseName;\n/**\n * Returns the edit-distance between two given strings using Levenshtein distance.\n *\n * @param a First string being compared\n * @param b Second string being compared\n * @returns distance between the two strings (lower number == more similar)\n * @see https://github.com/gustf/js-levenshtein\n * @license MIT - https://github.com/gustf/js-levenshtein/blob/master/LICENSE\n */\nfunction findDistance(a, b) {\n  function _min(_d0, _d1, _d2, _bx, _ay) {\n    return _d0 < _d1 || _d2 < _d1 ? _d0 > _d2 ? _d2 + 1 : _d0 + 1 : _bx === _ay ? _d1 : _d1 + 1;\n  }\n  if (a === b) {\n    return 0;\n  }\n  if (a.length > b.length) {\n    [a, b] = [b, a];\n  }\n  let la = a.length;\n  let lb = b.length;\n  while (la > 0 && a.charCodeAt(la - 1) === b.charCodeAt(lb - 1)) {\n    la--;\n    lb--;\n  }\n  let offset = 0;\n  while (offset < la && a.charCodeAt(offset) === b.charCodeAt(offset)) {\n    offset++;\n  }\n  la -= offset;\n  lb -= offset;\n  if (la === 0 || lb < 3) {\n    return lb;\n  }\n  let x = 0;\n  let y;\n  let d0;\n  let d1;\n  let d2;\n  let d3;\n  let dd = 0; // typescript gets angry if we don't assign here\n  let dy;\n  let ay;\n  let bx0;\n  let bx1;\n  let bx2;\n  let bx3;\n  const vector = [];\n  for (y = 0; y < la; y++) {\n    vector.push(y + 1);\n    vector.push(a.charCodeAt(offset + y));\n  }\n  const len = vector.length - 1;\n  for (; x < lb - 3;) {\n    bx0 = b.charCodeAt(offset + (d0 = x));\n    bx1 = b.charCodeAt(offset + (d1 = x + 1));\n    bx2 = b.charCodeAt(offset + (d2 = x + 2));\n    bx3 = b.charCodeAt(offset + (d3 = x + 3));\n    dd = x += 4;\n    for (y = 0; y < len; y += 2) {\n      dy = vector[y];\n      ay = vector[y + 1];\n      d0 = _min(dy, d0, d1, bx0, ay);\n      d1 = _min(d0, d1, d2, bx1, ay);\n      d2 = _min(d1, d2, d3, bx2, ay);\n      dd = _min(d2, d3, dd, bx3, ay);\n      vector[y] = dd;\n      d3 = d2;\n      d2 = d1;\n      d1 = d0;\n      d0 = dy;\n    }\n  }\n  for (; x < lb;) {\n    bx0 = b.charCodeAt(offset + (d0 = x));\n    dd = ++x;\n    for (y = 0; y < len; y += 2) {\n      dy = vector[y];\n      vector[y] = dd = _min(dy, d0, dd, bx0, vector[y + 1]);\n      d0 = dy;\n    }\n  }\n  return dd;\n}\nexports.findDistance = findDistance;","map":{"version":3,"names":["errors_1","require","errors_list_1","getFullyQualifiedName","sourceName","contractName","exports","isFullyQualifiedName","name","includes","parseFullyQualifiedName","fullyQualifiedName","parseName","undefined","HardhatError","ERRORS","CONTRACT_NAMES","INVALID_FULLY_QUALIFIED_NAME","parts","split","length","slice","join","findDistance","a","b","_min","_d0","_d1","_d2","_bx","_ay","la","lb","charCodeAt","offset","x","y","d0","d1","d2","d3","dd","dy","ay","bx0","bx1","bx2","bx3","vector","push","len"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\utils\\contract-names.ts"],"sourcesContent":["import { HardhatError } from \"../internal/core/errors\";\nimport { ERRORS } from \"../internal/core/errors-list\";\n\n/**\n * Returns a fully qualified name from a sourceName and contractName.\n */\nexport function getFullyQualifiedName(\n  sourceName: string,\n  contractName: string\n): string {\n  return `${sourceName}:${contractName}`;\n}\n\n/**\n * Returns true if a name is fully qualified, and not just a bare contract name.\n */\nexport function isFullyQualifiedName(name: string): boolean {\n  return name.includes(\":\");\n}\n\n/**\n * Parses a fully qualified name.\n *\n * @param fullyQualifiedName It MUST be a fully qualified name.\n * @throws {HardhatError} If the name is not fully qualified.\n */\nexport function parseFullyQualifiedName(fullyQualifiedName: string): {\n  sourceName: string;\n  contractName: string;\n} {\n  const { sourceName, contractName } = parseName(fullyQualifiedName);\n\n  if (sourceName === undefined) {\n    throw new HardhatError(ERRORS.CONTRACT_NAMES.INVALID_FULLY_QUALIFIED_NAME, {\n      name: fullyQualifiedName,\n    });\n  }\n\n  return { sourceName, contractName };\n}\n\n/**\n * Parses a name, which can be a bare contract name, or a fully qualified name.\n */\nexport function parseName(name: string): {\n  sourceName?: string;\n  contractName: string;\n} {\n  const parts = name.split(\":\");\n\n  if (parts.length === 1) {\n    return { contractName: parts[0] };\n  }\n\n  const contractName = parts[parts.length - 1];\n  const sourceName = parts.slice(0, parts.length - 1).join(\":\");\n\n  return { sourceName, contractName };\n}\n\n/**\n * Returns the edit-distance between two given strings using Levenshtein distance.\n *\n * @param a First string being compared\n * @param b Second string being compared\n * @returns distance between the two strings (lower number == more similar)\n * @see https://github.com/gustf/js-levenshtein\n * @license MIT - https://github.com/gustf/js-levenshtein/blob/master/LICENSE\n */\nexport function findDistance(a: string, b: string): number {\n  function _min(\n    _d0: number,\n    _d1: number,\n    _d2: number,\n    _bx: number,\n    _ay: number\n  ): number {\n    return _d0 < _d1 || _d2 < _d1\n      ? _d0 > _d2\n        ? _d2 + 1\n        : _d0 + 1\n      : _bx === _ay\n      ? _d1\n      : _d1 + 1;\n  }\n\n  if (a === b) {\n    return 0;\n  }\n\n  if (a.length > b.length) {\n    [a, b] = [b, a];\n  }\n\n  let la = a.length;\n  let lb = b.length;\n\n  while (la > 0 && a.charCodeAt(la - 1) === b.charCodeAt(lb - 1)) {\n    la--;\n    lb--;\n  }\n\n  let offset = 0;\n\n  while (offset < la && a.charCodeAt(offset) === b.charCodeAt(offset)) {\n    offset++;\n  }\n\n  la -= offset;\n  lb -= offset;\n\n  if (la === 0 || lb < 3) {\n    return lb;\n  }\n\n  let x = 0;\n  let y: number;\n  let d0: number;\n  let d1: number;\n  let d2: number;\n  let d3: number;\n  let dd: number = 0; // typescript gets angry if we don't assign here\n  let dy: number;\n  let ay: number;\n  let bx0: number;\n  let bx1: number;\n  let bx2: number;\n  let bx3: number;\n\n  const vector = [];\n\n  for (y = 0; y < la; y++) {\n    vector.push(y + 1);\n    vector.push(a.charCodeAt(offset + y));\n  }\n\n  const len = vector.length - 1;\n\n  for (; x < lb - 3; ) {\n    bx0 = b.charCodeAt(offset + (d0 = x));\n    bx1 = b.charCodeAt(offset + (d1 = x + 1));\n    bx2 = b.charCodeAt(offset + (d2 = x + 2));\n    bx3 = b.charCodeAt(offset + (d3 = x + 3));\n    dd = x += 4;\n    for (y = 0; y < len; y += 2) {\n      dy = vector[y];\n      ay = vector[y + 1];\n      d0 = _min(dy, d0, d1, bx0, ay);\n      d1 = _min(d0, d1, d2, bx1, ay);\n      d2 = _min(d1, d2, d3, bx2, ay);\n      dd = _min(d2, d3, dd, bx3, ay);\n      vector[y] = dd;\n      d3 = d2;\n      d2 = d1;\n      d1 = d0;\n      d0 = dy;\n    }\n  }\n\n  for (; x < lb; ) {\n    bx0 = b.charCodeAt(offset + (d0 = x));\n    dd = ++x;\n    for (y = 0; y < len; y += 2) {\n      dy = vector[y];\n      vector[y] = dd = _min(dy, d0, dd, bx0, vector[y + 1]);\n      d0 = dy;\n    }\n  }\n\n  return dd;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}