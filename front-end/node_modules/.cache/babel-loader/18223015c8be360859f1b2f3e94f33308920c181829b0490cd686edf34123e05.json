{"ast":null,"code":"/**\n *  The available providers should suffice for most developers purposes,\n *  but the [[AbstractProvider]] class has many features which enable\n *  sub-classing it for specific purposes.\n *\n *  @_section: api/providers/abstract-provider: Subclassing Provider  [abstract-provider]\n */\n// @TODO\n// Event coalescence\n//   When we register an event with an async value (e.g. address is a Signer\n//   or ENS name), we need to add it immeidately for the Event API, but also\n//   need time to resolve the address. Upon resolving the address, we need to\n//   migrate the listener to the static event. We also need to maintain a map\n//   of Signer/ENS name to address so we can sync respond to listenerCount.\nimport { getAddress, resolveAddress } from \"../address/index.js\";\nimport { ZeroAddress } from \"../constants/index.js\";\nimport { Contract } from \"../contract/index.js\";\nimport { namehash } from \"../hash/index.js\";\nimport { Transaction } from \"../transaction/index.js\";\nimport { concat, dataLength, dataSlice, hexlify, isHexString, getBigInt, getBytes, getNumber, isCallException, isError, makeError, assert, assertArgument, FetchRequest, toBeArray, toQuantity, defineProperties, EventPayload, resolveProperties, toUtf8String } from \"../utils/index.js\";\nimport { EnsResolver } from \"./ens-resolver.js\";\nimport { formatBlock, formatLog, formatTransactionReceipt, formatTransactionResponse } from \"./format.js\";\nimport { Network } from \"./network.js\";\nimport { copyRequest, Block, FeeData, Log, TransactionReceipt, TransactionResponse } from \"./provider.js\";\nimport { PollingBlockSubscriber, PollingBlockTagSubscriber, PollingEventSubscriber, PollingOrphanSubscriber, PollingTransactionSubscriber } from \"./subscriber-polling.js\";\n// Constants\nconst BN_2 = BigInt(2);\nconst MAX_CCIP_REDIRECTS = 10;\nfunction isPromise(value) {\n  return value && typeof value.then === \"function\";\n}\nfunction getTag(prefix, value) {\n  return prefix + \":\" + JSON.stringify(value, (k, v) => {\n    if (v == null) {\n      return \"null\";\n    }\n    if (typeof v === \"bigint\") {\n      return `bigint:${v.toString()}`;\n    }\n    if (typeof v === \"string\") {\n      return v.toLowerCase();\n    }\n    // Sort object keys\n    if (typeof v === \"object\" && !Array.isArray(v)) {\n      const keys = Object.keys(v);\n      keys.sort();\n      return keys.reduce((accum, key) => {\n        accum[key] = v[key];\n        return accum;\n      }, {});\n    }\n    return v;\n  });\n}\n/**\n *  An **UnmanagedSubscriber** is useful for events which do not require\n *  any additional management, such as ``\"debug\"`` which only requires\n *  emit in synchronous event loop triggered calls.\n */\nexport class UnmanagedSubscriber {\n  /**\n   *  The name fof the event.\n   */\n  name;\n  /**\n   *  Create a new UnmanagedSubscriber with %%name%%.\n   */\n  constructor(name) {\n    defineProperties(this, {\n      name\n    });\n  }\n  start() {}\n  stop() {}\n  pause(dropWhilePaused) {}\n  resume() {}\n}\nfunction copy(value) {\n  return JSON.parse(JSON.stringify(value));\n}\nfunction concisify(items) {\n  items = Array.from(new Set(items).values());\n  items.sort();\n  return items;\n}\nasync function getSubscription(_event, provider) {\n  if (_event == null) {\n    throw new Error(\"invalid event\");\n  }\n  // Normalize topic array info an EventFilter\n  if (Array.isArray(_event)) {\n    _event = {\n      topics: _event\n    };\n  }\n  if (typeof _event === \"string\") {\n    switch (_event) {\n      case \"block\":\n      case \"debug\":\n      case \"error\":\n      case \"finalized\":\n      case \"network\":\n      case \"pending\":\n      case \"safe\":\n        {\n          return {\n            type: _event,\n            tag: _event\n          };\n        }\n    }\n  }\n  if (isHexString(_event, 32)) {\n    const hash = _event.toLowerCase();\n    return {\n      type: \"transaction\",\n      tag: getTag(\"tx\", {\n        hash\n      }),\n      hash\n    };\n  }\n  if (_event.orphan) {\n    const event = _event;\n    // @TODO: Should lowercase and whatnot things here instead of copy...\n    return {\n      type: \"orphan\",\n      tag: getTag(\"orphan\", event),\n      filter: copy(event)\n    };\n  }\n  if (_event.address || _event.topics) {\n    const event = _event;\n    const filter = {\n      topics: (event.topics || []).map(t => {\n        if (t == null) {\n          return null;\n        }\n        if (Array.isArray(t)) {\n          return concisify(t.map(t => t.toLowerCase()));\n        }\n        return t.toLowerCase();\n      })\n    };\n    if (event.address) {\n      const addresses = [];\n      const promises = [];\n      const addAddress = addr => {\n        if (isHexString(addr)) {\n          addresses.push(addr);\n        } else {\n          promises.push((async () => {\n            addresses.push(await resolveAddress(addr, provider));\n          })());\n        }\n      };\n      if (Array.isArray(event.address)) {\n        event.address.forEach(addAddress);\n      } else {\n        addAddress(event.address);\n      }\n      if (promises.length) {\n        await Promise.all(promises);\n      }\n      filter.address = concisify(addresses.map(a => a.toLowerCase()));\n    }\n    return {\n      filter,\n      tag: getTag(\"event\", filter),\n      type: \"event\"\n    };\n  }\n  assertArgument(false, \"unknown ProviderEvent\", \"event\", _event);\n}\nfunction getTime() {\n  return new Date().getTime();\n}\nconst defaultOptions = {\n  cacheTimeout: 250,\n  pollingInterval: 4000\n};\n/**\n *  An **AbstractProvider** provides a base class for other sub-classes to\n *  implement the [[Provider]] API by normalizing input arguments and\n *  formatting output results as well as tracking events for consistent\n *  behaviour on an eventually-consistent network.\n */\nexport class AbstractProvider {\n  #subs;\n  #plugins;\n  // null=unpaused, true=paused+dropWhilePaused, false=paused\n  #pausedState;\n  #destroyed;\n  #networkPromise;\n  #anyNetwork;\n  #performCache;\n  // The most recent block number if running an event or -1 if no \"block\" event\n  #lastBlockNumber;\n  #nextTimer;\n  #timers;\n  #disableCcipRead;\n  #options;\n  /**\n   *  Create a new **AbstractProvider** connected to %%network%%, or\n   *  use the various network detection capabilities to discover the\n   *  [[Network]] if necessary.\n   */\n  constructor(_network, options) {\n    this.#options = Object.assign({}, defaultOptions, options || {});\n    if (_network === \"any\") {\n      this.#anyNetwork = true;\n      this.#networkPromise = null;\n    } else if (_network) {\n      const network = Network.from(_network);\n      this.#anyNetwork = false;\n      this.#networkPromise = Promise.resolve(network);\n      setTimeout(() => {\n        this.emit(\"network\", network, null);\n      }, 0);\n    } else {\n      this.#anyNetwork = false;\n      this.#networkPromise = null;\n    }\n    this.#lastBlockNumber = -1;\n    this.#performCache = new Map();\n    this.#subs = new Map();\n    this.#plugins = new Map();\n    this.#pausedState = null;\n    this.#destroyed = false;\n    this.#nextTimer = 1;\n    this.#timers = new Map();\n    this.#disableCcipRead = false;\n  }\n  get pollingInterval() {\n    return this.#options.pollingInterval;\n  }\n  /**\n   *  Returns ``this``, to allow an **AbstractProvider** to implement\n   *  the [[ContractRunner]] interface.\n   */\n  get provider() {\n    return this;\n  }\n  /**\n   *  Returns all the registered plug-ins.\n   */\n  get plugins() {\n    return Array.from(this.#plugins.values());\n  }\n  /**\n   *  Attach a new plug-in.\n   */\n  attachPlugin(plugin) {\n    if (this.#plugins.get(plugin.name)) {\n      throw new Error(`cannot replace existing plugin: ${plugin.name} `);\n    }\n    this.#plugins.set(plugin.name, plugin.connect(this));\n    return this;\n  }\n  /**\n   *  Get a plugin by name.\n   */\n  getPlugin(name) {\n    return this.#plugins.get(name) || null;\n  }\n  /**\n   *  Prevent any CCIP-read operation, regardless of whether requested\n   *  in a [[call]] using ``enableCcipRead``.\n   */\n  get disableCcipRead() {\n    return this.#disableCcipRead;\n  }\n  set disableCcipRead(value) {\n    this.#disableCcipRead = !!value;\n  }\n  // Shares multiple identical requests made during the same 250ms\n  async #perform(req) {\n    const timeout = this.#options.cacheTimeout;\n    // Caching disabled\n    if (timeout < 0) {\n      return await this._perform(req);\n    }\n    // Create a tag\n    const tag = getTag(req.method, req);\n    let perform = this.#performCache.get(tag);\n    if (!perform) {\n      perform = this._perform(req);\n      this.#performCache.set(tag, perform);\n      setTimeout(() => {\n        if (this.#performCache.get(tag) === perform) {\n          this.#performCache.delete(tag);\n        }\n      }, timeout);\n    }\n    return await perform;\n  }\n  /**\n   *  Resolves to the data for executing the CCIP-read operations.\n   */\n  async ccipReadFetch(tx, calldata, urls) {\n    if (this.disableCcipRead || urls.length === 0 || tx.to == null) {\n      return null;\n    }\n    const sender = tx.to.toLowerCase();\n    const data = calldata.toLowerCase();\n    const errorMessages = [];\n    for (let i = 0; i < urls.length; i++) {\n      const url = urls[i];\n      // URL expansion\n      const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n      // If no {data} is present, use POST; otherwise GET\n      //const json: string | null = (url.indexOf(\"{data}\") >= 0) ? null: JSON.stringify({ data, sender });\n      //const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\n      //    value.status = response.statusCode;\n      //    return value;\n      //});\n      const request = new FetchRequest(href);\n      if (url.indexOf(\"{data}\") === -1) {\n        request.body = {\n          data,\n          sender\n        };\n      }\n      this.emit(\"debug\", {\n        action: \"sendCcipReadFetchRequest\",\n        request,\n        index: i,\n        urls\n      });\n      let errorMessage = \"unknown error\";\n      // Fetch the resource...\n      let resp;\n      try {\n        resp = await request.send();\n      } catch (error) {\n        // ...low-level fetch error (missing host, bad SSL, etc.),\n        // so try next URL\n        errorMessages.push(error.message);\n        this.emit(\"debug\", {\n          action: \"receiveCcipReadFetchError\",\n          request,\n          result: {\n            error\n          }\n        });\n        continue;\n      }\n      try {\n        const result = resp.bodyJson;\n        if (result.data) {\n          this.emit(\"debug\", {\n            action: \"receiveCcipReadFetchResult\",\n            request,\n            result\n          });\n          return result.data;\n        }\n        if (result.message) {\n          errorMessage = result.message;\n        }\n        this.emit(\"debug\", {\n          action: \"receiveCcipReadFetchError\",\n          request,\n          result\n        });\n      } catch (error) {}\n      // 4xx indicates the result is not present; stop\n      assert(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, \"OFFCHAIN_FAULT\", {\n        reason: \"404_MISSING_RESOURCE\",\n        transaction: tx,\n        info: {\n          url,\n          errorMessage\n        }\n      });\n      // 5xx indicates server issue; try the next url\n      errorMessages.push(errorMessage);\n    }\n    assert(false, `error encountered during CCIP fetch: ${errorMessages.map(m => JSON.stringify(m)).join(\", \")}`, \"OFFCHAIN_FAULT\", {\n      reason: \"500_SERVER_ERROR\",\n      transaction: tx,\n      info: {\n        urls,\n        errorMessages\n      }\n    });\n  }\n  /**\n   *  Provides the opportunity for a sub-class to wrap a block before\n   *  returning it, to add additional properties or an alternate\n   *  sub-class of [[Block]].\n   */\n  _wrapBlock(value, network) {\n    return new Block(formatBlock(value), this);\n  }\n  /**\n   *  Provides the opportunity for a sub-class to wrap a log before\n   *  returning it, to add additional properties or an alternate\n   *  sub-class of [[Log]].\n   */\n  _wrapLog(value, network) {\n    return new Log(formatLog(value), this);\n  }\n  /**\n   *  Provides the opportunity for a sub-class to wrap a transaction\n   *  receipt before returning it, to add additional properties or an\n   *  alternate sub-class of [[TransactionReceipt]].\n   */\n  _wrapTransactionReceipt(value, network) {\n    return new TransactionReceipt(formatTransactionReceipt(value), this);\n  }\n  /**\n   *  Provides the opportunity for a sub-class to wrap a transaction\n   *  response before returning it, to add additional properties or an\n   *  alternate sub-class of [[TransactionResponse]].\n   */\n  _wrapTransactionResponse(tx, network) {\n    return new TransactionResponse(formatTransactionResponse(tx), this);\n  }\n  /**\n   *  Resolves to the Network, forcing a network detection using whatever\n   *  technique the sub-class requires.\n   *\n   *  Sub-classes **must** override this.\n   */\n  _detectNetwork() {\n    assert(false, \"sub-classes must implement this\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"_detectNetwork\"\n    });\n  }\n  /**\n   *  Sub-classes should use this to perform all built-in operations. All\n   *  methods sanitizes and normalizes the values passed into this.\n   *\n   *  Sub-classes **must** override this.\n   */\n  async _perform(req) {\n    assert(false, `unsupported method: ${req.method}`, \"UNSUPPORTED_OPERATION\", {\n      operation: req.method,\n      info: req\n    });\n  }\n  // State\n  async getBlockNumber() {\n    const blockNumber = getNumber(await this.#perform({\n      method: \"getBlockNumber\"\n    }), \"%response\");\n    if (this.#lastBlockNumber >= 0) {\n      this.#lastBlockNumber = blockNumber;\n    }\n    return blockNumber;\n  }\n  /**\n   *  Returns or resolves to the address for %%address%%, resolving ENS\n   *  names and [[Addressable]] objects and returning if already an\n   *  address.\n   */\n  _getAddress(address) {\n    return resolveAddress(address, this);\n  }\n  /**\n   *  Returns or resolves to a valid block tag for %%blockTag%%, resolving\n   *  negative values and returning if already a valid block tag.\n   */\n  _getBlockTag(blockTag) {\n    if (blockTag == null) {\n      return \"latest\";\n    }\n    switch (blockTag) {\n      case \"earliest\":\n        return \"0x0\";\n      case \"finalized\":\n      case \"latest\":\n      case \"pending\":\n      case \"safe\":\n        return blockTag;\n    }\n    if (isHexString(blockTag)) {\n      if (isHexString(blockTag, 32)) {\n        return blockTag;\n      }\n      return toQuantity(blockTag);\n    }\n    if (typeof blockTag === \"bigint\") {\n      blockTag = getNumber(blockTag, \"blockTag\");\n    }\n    if (typeof blockTag === \"number\") {\n      if (blockTag >= 0) {\n        return toQuantity(blockTag);\n      }\n      if (this.#lastBlockNumber >= 0) {\n        return toQuantity(this.#lastBlockNumber + blockTag);\n      }\n      return this.getBlockNumber().then(b => toQuantity(b + blockTag));\n    }\n    assertArgument(false, \"invalid blockTag\", \"blockTag\", blockTag);\n  }\n  /**\n   *  Returns or resolves to a filter for %%filter%%, resolving any ENS\n   *  names or [[Addressable]] object and returning if already a valid\n   *  filter.\n   */\n  _getFilter(filter) {\n    // Create a canonical representation of the topics\n    const topics = (filter.topics || []).map(t => {\n      if (t == null) {\n        return null;\n      }\n      if (Array.isArray(t)) {\n        return concisify(t.map(t => t.toLowerCase()));\n      }\n      return t.toLowerCase();\n    });\n    const blockHash = \"blockHash\" in filter ? filter.blockHash : undefined;\n    const resolve = (_address, fromBlock, toBlock) => {\n      let address = undefined;\n      switch (_address.length) {\n        case 0:\n          break;\n        case 1:\n          address = _address[0];\n          break;\n        default:\n          _address.sort();\n          address = _address;\n      }\n      if (blockHash) {\n        if (fromBlock != null || toBlock != null) {\n          throw new Error(\"invalid filter\");\n        }\n      }\n      const filter = {};\n      if (address) {\n        filter.address = address;\n      }\n      if (topics.length) {\n        filter.topics = topics;\n      }\n      if (fromBlock) {\n        filter.fromBlock = fromBlock;\n      }\n      if (toBlock) {\n        filter.toBlock = toBlock;\n      }\n      if (blockHash) {\n        filter.blockHash = blockHash;\n      }\n      return filter;\n    };\n    // Addresses could be async (ENS names or Addressables)\n    let address = [];\n    if (filter.address) {\n      if (Array.isArray(filter.address)) {\n        for (const addr of filter.address) {\n          address.push(this._getAddress(addr));\n        }\n      } else {\n        address.push(this._getAddress(filter.address));\n      }\n    }\n    let fromBlock = undefined;\n    if (\"fromBlock\" in filter) {\n      fromBlock = this._getBlockTag(filter.fromBlock);\n    }\n    let toBlock = undefined;\n    if (\"toBlock\" in filter) {\n      toBlock = this._getBlockTag(filter.toBlock);\n    }\n    if (address.filter(a => typeof a !== \"string\").length || fromBlock != null && typeof fromBlock !== \"string\" || toBlock != null && typeof toBlock !== \"string\") {\n      return Promise.all([Promise.all(address), fromBlock, toBlock]).then(result => {\n        return resolve(result[0], result[1], result[2]);\n      });\n    }\n    return resolve(address, fromBlock, toBlock);\n  }\n  /**\n   *  Returns or resolves to a transaction for %%request%%, resolving\n   *  any ENS names or [[Addressable]] and returning if already a valid\n   *  transaction.\n   */\n  _getTransactionRequest(_request) {\n    const request = copyRequest(_request);\n    const promises = [];\n    [\"to\", \"from\"].forEach(key => {\n      if (request[key] == null) {\n        return;\n      }\n      const addr = resolveAddress(request[key], this);\n      if (isPromise(addr)) {\n        promises.push(async function () {\n          request[key] = await addr;\n        }());\n      } else {\n        request[key] = addr;\n      }\n    });\n    if (request.blockTag != null) {\n      const blockTag = this._getBlockTag(request.blockTag);\n      if (isPromise(blockTag)) {\n        promises.push(async function () {\n          request.blockTag = await blockTag;\n        }());\n      } else {\n        request.blockTag = blockTag;\n      }\n    }\n    if (promises.length) {\n      return async function () {\n        await Promise.all(promises);\n        return request;\n      }();\n    }\n    return request;\n  }\n  async getNetwork() {\n    // No explicit network was set and this is our first time\n    if (this.#networkPromise == null) {\n      // Detect the current network (shared with all calls)\n      const detectNetwork = (async () => {\n        try {\n          const network = await this._detectNetwork();\n          this.emit(\"network\", network, null);\n          return network;\n        } catch (error) {\n          if (this.#networkPromise === detectNetwork) {\n            this.#networkPromise = null;\n          }\n          throw error;\n        }\n      })();\n      this.#networkPromise = detectNetwork;\n      return (await detectNetwork).clone();\n    }\n    const networkPromise = this.#networkPromise;\n    const [expected, actual] = await Promise.all([networkPromise, this._detectNetwork() // The actual connected network\n    ]);\n    if (expected.chainId !== actual.chainId) {\n      if (this.#anyNetwork) {\n        // The \"any\" network can change, so notify listeners\n        this.emit(\"network\", actual, expected);\n        // Update the network if something else hasn't already changed it\n        if (this.#networkPromise === networkPromise) {\n          this.#networkPromise = Promise.resolve(actual);\n        }\n      } else {\n        // Otherwise, we do not allow changes to the underlying network\n        assert(false, `network changed: ${expected.chainId} => ${actual.chainId} `, \"NETWORK_ERROR\", {\n          event: \"changed\"\n        });\n      }\n    }\n    return expected.clone();\n  }\n  async getFeeData() {\n    const network = await this.getNetwork();\n    const getFeeDataFunc = async () => {\n      const {\n        _block,\n        gasPrice,\n        priorityFee\n      } = await resolveProperties({\n        _block: this.#getBlock(\"latest\", false),\n        gasPrice: (async () => {\n          try {\n            const value = await this.#perform({\n              method: \"getGasPrice\"\n            });\n            return getBigInt(value, \"%response\");\n          } catch (error) {}\n          return null;\n        })(),\n        priorityFee: (async () => {\n          try {\n            const value = await this.#perform({\n              method: \"getPriorityFee\"\n            });\n            return getBigInt(value, \"%response\");\n          } catch (error) {}\n          return null;\n        })()\n      });\n      let maxFeePerGas = null;\n      let maxPriorityFeePerGas = null;\n      // These are the recommended EIP-1559 heuristics for fee data\n      const block = this._wrapBlock(_block, network);\n      if (block && block.baseFeePerGas) {\n        maxPriorityFeePerGas = priorityFee != null ? priorityFee : BigInt(\"1000000000\");\n        maxFeePerGas = block.baseFeePerGas * BN_2 + maxPriorityFeePerGas;\n      }\n      return new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);\n    };\n    // Check for a FeeDataNetWorkPlugin\n    const plugin = network.getPlugin(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");\n    if (plugin) {\n      const req = new FetchRequest(plugin.url);\n      const feeData = await plugin.processFunc(getFeeDataFunc, this, req);\n      return new FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);\n    }\n    return await getFeeDataFunc();\n  }\n  async estimateGas(_tx) {\n    let tx = this._getTransactionRequest(_tx);\n    if (isPromise(tx)) {\n      tx = await tx;\n    }\n    return getBigInt(await this.#perform({\n      method: \"estimateGas\",\n      transaction: tx\n    }), \"%response\");\n  }\n  async #call(tx, blockTag, attempt) {\n    assert(attempt < MAX_CCIP_REDIRECTS, \"CCIP read exceeded maximum redirections\", \"OFFCHAIN_FAULT\", {\n      reason: \"TOO_MANY_REDIRECTS\",\n      transaction: Object.assign({}, tx, {\n        blockTag,\n        enableCcipRead: true\n      })\n    });\n    // This came in as a PerformActionTransaction, so to/from are safe; we can cast\n    const transaction = copyRequest(tx);\n    try {\n      return hexlify(await this._perform({\n        method: \"call\",\n        transaction,\n        blockTag\n      }));\n    } catch (error) {\n      // CCIP Read OffchainLookup\n      if (!this.disableCcipRead && isCallException(error) && error.data && attempt >= 0 && blockTag === \"latest\" && transaction.to != null && dataSlice(error.data, 0, 4) === \"0x556f1830\") {\n        const data = error.data;\n        const txSender = await resolveAddress(transaction.to, this);\n        // Parse the CCIP Read Arguments\n        let ccipArgs;\n        try {\n          ccipArgs = parseOffchainLookup(dataSlice(error.data, 4));\n        } catch (error) {\n          assert(false, error.message, \"OFFCHAIN_FAULT\", {\n            reason: \"BAD_DATA\",\n            transaction,\n            info: {\n              data\n            }\n          });\n        }\n        // Check the sender of the OffchainLookup matches the transaction\n        assert(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), \"CCIP Read sender mismatch\", \"CALL_EXCEPTION\", {\n          action: \"call\",\n          data,\n          reason: \"OffchainLookup\",\n          transaction: transaction,\n          invocation: null,\n          revert: {\n            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n            name: \"OffchainLookup\",\n            args: ccipArgs.errorArgs\n          }\n        });\n        const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);\n        assert(ccipResult != null, \"CCIP Read failed to fetch data\", \"OFFCHAIN_FAULT\", {\n          reason: \"FETCH_FAILED\",\n          transaction,\n          info: {\n            data: error.data,\n            errorArgs: ccipArgs.errorArgs\n          }\n        });\n        const tx = {\n          to: txSender,\n          data: concat([ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])])\n        };\n        this.emit(\"debug\", {\n          action: \"sendCcipReadCall\",\n          transaction: tx\n        });\n        try {\n          const result = await this.#call(tx, blockTag, attempt + 1);\n          this.emit(\"debug\", {\n            action: \"receiveCcipReadCallResult\",\n            transaction: Object.assign({}, tx),\n            result\n          });\n          return result;\n        } catch (error) {\n          this.emit(\"debug\", {\n            action: \"receiveCcipReadCallError\",\n            transaction: Object.assign({}, tx),\n            error\n          });\n          throw error;\n        }\n      }\n      throw error;\n    }\n  }\n  async #checkNetwork(promise) {\n    const {\n      value\n    } = await resolveProperties({\n      network: this.getNetwork(),\n      value: promise\n    });\n    return value;\n  }\n  async call(_tx) {\n    const {\n      tx,\n      blockTag\n    } = await resolveProperties({\n      tx: this._getTransactionRequest(_tx),\n      blockTag: this._getBlockTag(_tx.blockTag)\n    });\n    return await this.#checkNetwork(this.#call(tx, blockTag, _tx.enableCcipRead ? 0 : -1));\n  }\n  // Account\n  async #getAccountValue(request, _address, _blockTag) {\n    let address = this._getAddress(_address);\n    let blockTag = this._getBlockTag(_blockTag);\n    if (typeof address !== \"string\" || typeof blockTag !== \"string\") {\n      [address, blockTag] = await Promise.all([address, blockTag]);\n    }\n    return await this.#checkNetwork(this.#perform(Object.assign(request, {\n      address,\n      blockTag\n    })));\n  }\n  async getBalance(address, blockTag) {\n    return getBigInt(await this.#getAccountValue({\n      method: \"getBalance\"\n    }, address, blockTag), \"%response\");\n  }\n  async getTransactionCount(address, blockTag) {\n    return getNumber(await this.#getAccountValue({\n      method: \"getTransactionCount\"\n    }, address, blockTag), \"%response\");\n  }\n  async getCode(address, blockTag) {\n    return hexlify(await this.#getAccountValue({\n      method: \"getCode\"\n    }, address, blockTag));\n  }\n  async getStorage(address, _position, blockTag) {\n    const position = getBigInt(_position, \"position\");\n    return hexlify(await this.#getAccountValue({\n      method: \"getStorage\",\n      position\n    }, address, blockTag));\n  }\n  // Write\n  async broadcastTransaction(signedTx) {\n    const {\n      blockNumber,\n      hash,\n      network\n    } = await resolveProperties({\n      blockNumber: this.getBlockNumber(),\n      hash: this._perform({\n        method: \"broadcastTransaction\",\n        signedTransaction: signedTx\n      }),\n      network: this.getNetwork()\n    });\n    const tx = Transaction.from(signedTx);\n    if (tx.hash !== hash) {\n      throw new Error(\"@TODO: the returned hash did not match\");\n    }\n    return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);\n  }\n  async #getBlock(block, includeTransactions) {\n    // @TODO: Add CustomBlockPlugin check\n    if (isHexString(block, 32)) {\n      return await this.#perform({\n        method: \"getBlock\",\n        blockHash: block,\n        includeTransactions\n      });\n    }\n    let blockTag = this._getBlockTag(block);\n    if (typeof blockTag !== \"string\") {\n      blockTag = await blockTag;\n    }\n    return await this.#perform({\n      method: \"getBlock\",\n      blockTag,\n      includeTransactions\n    });\n  }\n  // Queries\n  async getBlock(block, prefetchTxs) {\n    const {\n      network,\n      params\n    } = await resolveProperties({\n      network: this.getNetwork(),\n      params: this.#getBlock(block, !!prefetchTxs)\n    });\n    if (params == null) {\n      return null;\n    }\n    return this._wrapBlock(params, network);\n  }\n  async getTransaction(hash) {\n    const {\n      network,\n      params\n    } = await resolveProperties({\n      network: this.getNetwork(),\n      params: this.#perform({\n        method: \"getTransaction\",\n        hash\n      })\n    });\n    if (params == null) {\n      return null;\n    }\n    return this._wrapTransactionResponse(params, network);\n  }\n  async getTransactionReceipt(hash) {\n    const {\n      network,\n      params\n    } = await resolveProperties({\n      network: this.getNetwork(),\n      params: this.#perform({\n        method: \"getTransactionReceipt\",\n        hash\n      })\n    });\n    if (params == null) {\n      return null;\n    }\n    // Some backends did not backfill the effectiveGasPrice into old transactions\n    // in the receipt, so we look it up manually and inject it.\n    if (params.gasPrice == null && params.effectiveGasPrice == null) {\n      const tx = await this.#perform({\n        method: \"getTransaction\",\n        hash\n      });\n      if (tx == null) {\n        throw new Error(\"report this; could not find tx or effectiveGasPrice\");\n      }\n      params.effectiveGasPrice = tx.gasPrice;\n    }\n    return this._wrapTransactionReceipt(params, network);\n  }\n  async getTransactionResult(hash) {\n    const {\n      result\n    } = await resolveProperties({\n      network: this.getNetwork(),\n      result: this.#perform({\n        method: \"getTransactionResult\",\n        hash\n      })\n    });\n    if (result == null) {\n      return null;\n    }\n    return hexlify(result);\n  }\n  // Bloom-filter Queries\n  async getLogs(_filter) {\n    let filter = this._getFilter(_filter);\n    if (isPromise(filter)) {\n      filter = await filter;\n    }\n    const {\n      network,\n      params\n    } = await resolveProperties({\n      network: this.getNetwork(),\n      params: this.#perform({\n        method: \"getLogs\",\n        filter\n      })\n    });\n    return params.map(p => this._wrapLog(p, network));\n  }\n  // ENS\n  _getProvider(chainId) {\n    assert(false, \"provider cannot connect to target network\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"_getProvider()\"\n    });\n  }\n  async getResolver(name) {\n    return await EnsResolver.fromName(this, name);\n  }\n  async getAvatar(name) {\n    const resolver = await this.getResolver(name);\n    if (resolver) {\n      return await resolver.getAvatar();\n    }\n    return null;\n  }\n  async resolveName(name) {\n    const resolver = await this.getResolver(name);\n    if (resolver) {\n      return await resolver.getAddress();\n    }\n    return null;\n  }\n  async lookupAddress(address) {\n    address = getAddress(address);\n    const node = namehash(address.substring(2).toLowerCase() + \".addr.reverse\");\n    try {\n      const ensAddr = await EnsResolver.getEnsAddress(this);\n      const ensContract = new Contract(ensAddr, [\"function resolver(bytes32) view returns (address)\"], this);\n      const resolver = await ensContract.resolver(node);\n      if (resolver == null || resolver === ZeroAddress) {\n        return null;\n      }\n      const resolverContract = new Contract(resolver, [\"function name(bytes32) view returns (string)\"], this);\n      const name = await resolverContract.name(node);\n      // Failed forward resolution\n      const check = await this.resolveName(name);\n      if (check !== address) {\n        return null;\n      }\n      return name;\n    } catch (error) {\n      // No data was returned from the resolver\n      if (isError(error, \"BAD_DATA\") && error.value === \"0x\") {\n        return null;\n      }\n      // Something reerted\n      if (isError(error, \"CALL_EXCEPTION\")) {\n        return null;\n      }\n      throw error;\n    }\n    return null;\n  }\n  async waitForTransaction(hash, _confirms, timeout) {\n    const confirms = _confirms != null ? _confirms : 1;\n    if (confirms === 0) {\n      return this.getTransactionReceipt(hash);\n    }\n    return new Promise(async (resolve, reject) => {\n      let timer = null;\n      const listener = async blockNumber => {\n        try {\n          const receipt = await this.getTransactionReceipt(hash);\n          if (receipt != null) {\n            if (blockNumber - receipt.blockNumber + 1 >= confirms) {\n              resolve(receipt);\n              //this.off(\"block\", listener);\n              if (timer) {\n                clearTimeout(timer);\n                timer = null;\n              }\n              return;\n            }\n          }\n        } catch (error) {\n          console.log(\"EEE\", error);\n        }\n        this.once(\"block\", listener);\n      };\n      if (timeout != null) {\n        timer = setTimeout(() => {\n          if (timer == null) {\n            return;\n          }\n          timer = null;\n          this.off(\"block\", listener);\n          reject(makeError(\"timeout\", \"TIMEOUT\", {\n            reason: \"timeout\"\n          }));\n        }, timeout);\n      }\n      listener(await this.getBlockNumber());\n    });\n  }\n  async waitForBlock(blockTag) {\n    assert(false, \"not implemented yet\", \"NOT_IMPLEMENTED\", {\n      operation: \"waitForBlock\"\n    });\n  }\n  /**\n   *  Clear a timer created using the [[_setTimeout]] method.\n   */\n  _clearTimeout(timerId) {\n    const timer = this.#timers.get(timerId);\n    if (!timer) {\n      return;\n    }\n    if (timer.timer) {\n      clearTimeout(timer.timer);\n    }\n    this.#timers.delete(timerId);\n  }\n  /**\n   *  Create a timer that will execute %%func%% after at least %%timeout%%\n   *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute\n   *  in the next event loop.\n   *\n   *  [Pausing](AbstractProvider-paused) the provider will pause any\n   *  associated timers.\n   */\n  _setTimeout(_func, timeout) {\n    if (timeout == null) {\n      timeout = 0;\n    }\n    const timerId = this.#nextTimer++;\n    const func = () => {\n      this.#timers.delete(timerId);\n      _func();\n    };\n    if (this.paused) {\n      this.#timers.set(timerId, {\n        timer: null,\n        func,\n        time: timeout\n      });\n    } else {\n      const timer = setTimeout(func, timeout);\n      this.#timers.set(timerId, {\n        timer,\n        func,\n        time: getTime()\n      });\n    }\n    return timerId;\n  }\n  /**\n   *  Perform %%func%% on each subscriber.\n   */\n  _forEachSubscriber(func) {\n    for (const sub of this.#subs.values()) {\n      func(sub.subscriber);\n    }\n  }\n  /**\n   *  Sub-classes may override this to customize subscription\n   *  implementations.\n   */\n  _getSubscriber(sub) {\n    switch (sub.type) {\n      case \"debug\":\n      case \"error\":\n      case \"network\":\n        return new UnmanagedSubscriber(sub.type);\n      case \"block\":\n        {\n          const subscriber = new PollingBlockSubscriber(this);\n          subscriber.pollingInterval = this.pollingInterval;\n          return subscriber;\n        }\n      case \"safe\":\n      case \"finalized\":\n        return new PollingBlockTagSubscriber(this, sub.type);\n      case \"event\":\n        return new PollingEventSubscriber(this, sub.filter);\n      case \"transaction\":\n        return new PollingTransactionSubscriber(this, sub.hash);\n      case \"orphan\":\n        return new PollingOrphanSubscriber(this, sub.filter);\n    }\n    throw new Error(`unsupported event: ${sub.type}`);\n  }\n  /**\n   *  If a [[Subscriber]] fails and needs to replace itself, this\n   *  method may be used.\n   *\n   *  For example, this is used for providers when using the\n   *  ``eth_getFilterChanges`` method, which can return null if state\n   *  filters are not supported by the backend, allowing the Subscriber\n   *  to swap in a [[PollingEventSubscriber]].\n   */\n  _recoverSubscriber(oldSub, newSub) {\n    for (const sub of this.#subs.values()) {\n      if (sub.subscriber === oldSub) {\n        if (sub.started) {\n          sub.subscriber.stop();\n        }\n        sub.subscriber = newSub;\n        if (sub.started) {\n          newSub.start();\n        }\n        if (this.#pausedState != null) {\n          newSub.pause(this.#pausedState);\n        }\n        break;\n      }\n    }\n  }\n  async #hasSub(event, emitArgs) {\n    let sub = await getSubscription(event, this);\n    // This is a log that is removing an existing log; we actually want\n    // to emit an orphan event for the removed log\n    if (sub.type === \"event\" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {\n      sub = await getSubscription({\n        orphan: \"drop-log\",\n        log: emitArgs[0]\n      }, this);\n    }\n    return this.#subs.get(sub.tag) || null;\n  }\n  async #getSub(event) {\n    const subscription = await getSubscription(event, this);\n    // Prevent tampering with our tag in any subclass' _getSubscriber\n    const tag = subscription.tag;\n    let sub = this.#subs.get(tag);\n    if (!sub) {\n      const subscriber = this._getSubscriber(subscription);\n      const addressableMap = new WeakMap();\n      const nameMap = new Map();\n      sub = {\n        subscriber,\n        tag,\n        addressableMap,\n        nameMap,\n        started: false,\n        listeners: []\n      };\n      this.#subs.set(tag, sub);\n    }\n    return sub;\n  }\n  async on(event, listener) {\n    const sub = await this.#getSub(event);\n    sub.listeners.push({\n      listener,\n      once: false\n    });\n    if (!sub.started) {\n      sub.subscriber.start();\n      sub.started = true;\n      if (this.#pausedState != null) {\n        sub.subscriber.pause(this.#pausedState);\n      }\n    }\n    return this;\n  }\n  async once(event, listener) {\n    const sub = await this.#getSub(event);\n    sub.listeners.push({\n      listener,\n      once: true\n    });\n    if (!sub.started) {\n      sub.subscriber.start();\n      sub.started = true;\n      if (this.#pausedState != null) {\n        sub.subscriber.pause(this.#pausedState);\n      }\n    }\n    return this;\n  }\n  async emit(event, ...args) {\n    const sub = await this.#hasSub(event, args);\n    // If there is not subscription or if a recent emit removed\n    // the last of them (which also deleted the sub) do nothing\n    if (!sub || sub.listeners.length === 0) {\n      return false;\n    }\n    ;\n    const count = sub.listeners.length;\n    sub.listeners = sub.listeners.filter(({\n      listener,\n      once\n    }) => {\n      const payload = new EventPayload(this, once ? null : listener, event);\n      try {\n        listener.call(this, ...args, payload);\n      } catch (error) {}\n      return !once;\n    });\n    if (sub.listeners.length === 0) {\n      if (sub.started) {\n        sub.subscriber.stop();\n      }\n      this.#subs.delete(sub.tag);\n    }\n    return count > 0;\n  }\n  async listenerCount(event) {\n    if (event) {\n      const sub = await this.#hasSub(event);\n      if (!sub) {\n        return 0;\n      }\n      return sub.listeners.length;\n    }\n    let total = 0;\n    for (const {\n      listeners\n    } of this.#subs.values()) {\n      total += listeners.length;\n    }\n    return total;\n  }\n  async listeners(event) {\n    if (event) {\n      const sub = await this.#hasSub(event);\n      if (!sub) {\n        return [];\n      }\n      return sub.listeners.map(({\n        listener\n      }) => listener);\n    }\n    let result = [];\n    for (const {\n      listeners\n    } of this.#subs.values()) {\n      result = result.concat(listeners.map(({\n        listener\n      }) => listener));\n    }\n    return result;\n  }\n  async off(event, listener) {\n    const sub = await this.#hasSub(event);\n    if (!sub) {\n      return this;\n    }\n    if (listener) {\n      const index = sub.listeners.map(({\n        listener\n      }) => listener).indexOf(listener);\n      if (index >= 0) {\n        sub.listeners.splice(index, 1);\n      }\n    }\n    if (!listener || sub.listeners.length === 0) {\n      if (sub.started) {\n        sub.subscriber.stop();\n      }\n      this.#subs.delete(sub.tag);\n    }\n    return this;\n  }\n  async removeAllListeners(event) {\n    if (event) {\n      const {\n        tag,\n        started,\n        subscriber\n      } = await this.#getSub(event);\n      if (started) {\n        subscriber.stop();\n      }\n      this.#subs.delete(tag);\n    } else {\n      for (const [tag, {\n        started,\n        subscriber\n      }] of this.#subs) {\n        if (started) {\n          subscriber.stop();\n        }\n        this.#subs.delete(tag);\n      }\n    }\n    return this;\n  }\n  // Alias for \"on\"\n  async addListener(event, listener) {\n    return await this.on(event, listener);\n  }\n  // Alias for \"off\"\n  async removeListener(event, listener) {\n    return this.off(event, listener);\n  }\n  /**\n   *  If this provider has been destroyed using the [[destroy]] method.\n   *\n   *  Once destroyed, all resources are reclaimed, internal event loops\n   *  and timers are cleaned up and no further requests may be sent to\n   *  the provider.\n   */\n  get destroyed() {\n    return this.#destroyed;\n  }\n  /**\n   *  Sub-classes may use this to shutdown any sockets or release their\n   *  resources and reject any pending requests.\n   *\n   *  Sub-classes **must** call ``super.destroy()``.\n   */\n  destroy() {\n    // Stop all listeners\n    this.removeAllListeners();\n    // Shut down all tiemrs\n    for (const timerId of this.#timers.keys()) {\n      this._clearTimeout(timerId);\n    }\n    this.#destroyed = true;\n  }\n  /**\n   *  Whether the provider is currently paused.\n   *\n   *  A paused provider will not emit any events, and generally should\n   *  not make any requests to the network, but that is up to sub-classes\n   *  to manage.\n   *\n   *  Setting ``paused = true`` is identical to calling ``.pause(false)``,\n   *  which will buffer any events that occur while paused until the\n   *  provider is unpaused.\n   */\n  get paused() {\n    return this.#pausedState != null;\n  }\n  set paused(pause) {\n    if (!!pause === this.paused) {\n      return;\n    }\n    if (this.paused) {\n      this.resume();\n    } else {\n      this.pause(false);\n    }\n  }\n  /**\n   *  Pause the provider. If %%dropWhilePaused%%, any events that occur\n   *  while paused are dropped, otherwise all events will be emitted once\n   *  the provider is unpaused.\n   */\n  pause(dropWhilePaused) {\n    this.#lastBlockNumber = -1;\n    if (this.#pausedState != null) {\n      if (this.#pausedState == !!dropWhilePaused) {\n        return;\n      }\n      assert(false, \"cannot change pause type; resume first\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"pause\"\n      });\n    }\n    this._forEachSubscriber(s => s.pause(dropWhilePaused));\n    this.#pausedState = !!dropWhilePaused;\n    for (const timer of this.#timers.values()) {\n      // Clear the timer\n      if (timer.timer) {\n        clearTimeout(timer.timer);\n      }\n      // Remaining time needed for when we become unpaused\n      timer.time = getTime() - timer.time;\n    }\n  }\n  /**\n   *  Resume the provider.\n   */\n  resume() {\n    if (this.#pausedState == null) {\n      return;\n    }\n    this._forEachSubscriber(s => s.resume());\n    this.#pausedState = null;\n    for (const timer of this.#timers.values()) {\n      // Remaining time when we were paused\n      let timeout = timer.time;\n      if (timeout < 0) {\n        timeout = 0;\n      }\n      // Start time (in cause paused, so we con compute remaininf time)\n      timer.time = getTime();\n      // Start the timer\n      setTimeout(timer.func, timeout);\n    }\n  }\n}\nfunction _parseString(result, start) {\n  try {\n    const bytes = _parseBytes(result, start);\n    if (bytes) {\n      return toUtf8String(bytes);\n    }\n  } catch (error) {}\n  return null;\n}\nfunction _parseBytes(result, start) {\n  if (result === \"0x\") {\n    return null;\n  }\n  try {\n    const offset = getNumber(dataSlice(result, start, start + 32));\n    const length = getNumber(dataSlice(result, offset, offset + 32));\n    return dataSlice(result, offset + 32, offset + 32 + length);\n  } catch (error) {}\n  return null;\n}\nfunction numPad(value) {\n  const result = toBeArray(value);\n  if (result.length > 32) {\n    throw new Error(\"internal; should not happen\");\n  }\n  const padded = new Uint8Array(32);\n  padded.set(result, 32 - result.length);\n  return padded;\n}\nfunction bytesPad(value) {\n  if (value.length % 32 === 0) {\n    return value;\n  }\n  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n  result.set(value);\n  return result;\n}\nconst empty = new Uint8Array([]);\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas) {\n  const result = [];\n  let byteCount = 0;\n  // Add place-holders for pointers as we add items\n  for (let i = 0; i < datas.length; i++) {\n    result.push(empty);\n    byteCount += 32;\n  }\n  for (let i = 0; i < datas.length; i++) {\n    const data = getBytes(datas[i]);\n    // Update the bytes offset\n    result[i] = numPad(byteCount);\n    // The length and padded value of data\n    result.push(numPad(data.length));\n    result.push(bytesPad(data));\n    byteCount += 32 + Math.ceil(data.length / 32) * 32;\n  }\n  return concat(result);\n}\nconst zeros = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\nfunction parseOffchainLookup(data) {\n  const result = {\n    sender: \"\",\n    urls: [],\n    calldata: \"\",\n    selector: \"\",\n    extraData: \"\",\n    errorArgs: []\n  };\n  assert(dataLength(data) >= 5 * 32, \"insufficient OffchainLookup data\", \"OFFCHAIN_FAULT\", {\n    reason: \"insufficient OffchainLookup data\"\n  });\n  const sender = dataSlice(data, 0, 32);\n  assert(dataSlice(sender, 0, 12) === dataSlice(zeros, 0, 12), \"corrupt OffchainLookup sender\", \"OFFCHAIN_FAULT\", {\n    reason: \"corrupt OffchainLookup sender\"\n  });\n  result.sender = dataSlice(sender, 12);\n  // Read the URLs from the response\n  try {\n    const urls = [];\n    const urlsOffset = getNumber(dataSlice(data, 32, 64));\n    const urlsLength = getNumber(dataSlice(data, urlsOffset, urlsOffset + 32));\n    const urlsData = dataSlice(data, urlsOffset + 32);\n    for (let u = 0; u < urlsLength; u++) {\n      const url = _parseString(urlsData, u * 32);\n      if (url == null) {\n        throw new Error(\"abort\");\n      }\n      urls.push(url);\n    }\n    result.urls = urls;\n  } catch (error) {\n    assert(false, \"corrupt OffchainLookup urls\", \"OFFCHAIN_FAULT\", {\n      reason: \"corrupt OffchainLookup urls\"\n    });\n  }\n  // Get the CCIP calldata to forward\n  try {\n    const calldata = _parseBytes(data, 64);\n    if (calldata == null) {\n      throw new Error(\"abort\");\n    }\n    result.calldata = calldata;\n  } catch (error) {\n    assert(false, \"corrupt OffchainLookup calldata\", \"OFFCHAIN_FAULT\", {\n      reason: \"corrupt OffchainLookup calldata\"\n    });\n  }\n  // Get the callbackSelector (bytes4)\n  assert(dataSlice(data, 100, 128) === dataSlice(zeros, 0, 28), \"corrupt OffchainLookup callbaackSelector\", \"OFFCHAIN_FAULT\", {\n    reason: \"corrupt OffchainLookup callbaackSelector\"\n  });\n  result.selector = dataSlice(data, 96, 100);\n  // Get the extra data to send back to the contract as context\n  try {\n    const extraData = _parseBytes(data, 128);\n    if (extraData == null) {\n      throw new Error(\"abort\");\n    }\n    result.extraData = extraData;\n  } catch (error) {\n    assert(false, \"corrupt OffchainLookup extraData\", \"OFFCHAIN_FAULT\", {\n      reason: \"corrupt OffchainLookup extraData\"\n    });\n  }\n  result.errorArgs = \"sender,urls,calldata,selector,extraData\".split(/,/).map(k => result[k]);\n  return result;\n}","map":{"version":3,"names":["getAddress","resolveAddress","ZeroAddress","Contract","namehash","Transaction","concat","dataLength","dataSlice","hexlify","isHexString","getBigInt","getBytes","getNumber","isCallException","isError","makeError","assert","assertArgument","FetchRequest","toBeArray","toQuantity","defineProperties","EventPayload","resolveProperties","toUtf8String","EnsResolver","formatBlock","formatLog","formatTransactionReceipt","formatTransactionResponse","Network","copyRequest","Block","FeeData","Log","TransactionReceipt","TransactionResponse","PollingBlockSubscriber","PollingBlockTagSubscriber","PollingEventSubscriber","PollingOrphanSubscriber","PollingTransactionSubscriber","BN_2","BigInt","MAX_CCIP_REDIRECTS","isPromise","value","then","getTag","prefix","JSON","stringify","k","v","toString","toLowerCase","Array","isArray","keys","Object","sort","reduce","accum","key","UnmanagedSubscriber","name","constructor","start","stop","pause","dropWhilePaused","resume","copy","parse","concisify","items","from","Set","values","getSubscription","_event","provider","Error","topics","type","tag","hash","orphan","event","filter","address","map","t","addresses","promises","addAddress","addr","push","forEach","length","Promise","all","a","getTime","Date","defaultOptions","cacheTimeout","pollingInterval","AbstractProvider","subs","plugins","pausedState","destroyed","networkPromise","anyNetwork","performCache","lastBlockNumber","nextTimer","timers","disableCcipRead","options","_network","assign","network","resolve","setTimeout","emit","Map","attachPlugin","plugin","get","set","connect","getPlugin","perform","#perform","req","timeout","_perform","method","delete","ccipReadFetch","tx","calldata","urls","to","sender","data","errorMessages","i","url","href","replace","request","indexOf","body","action","index","errorMessage","resp","send","error","message","result","bodyJson","statusCode","reason","transaction","info","m","join","_wrapBlock","_wrapLog","_wrapTransactionReceipt","_wrapTransactionResponse","_detectNetwork","operation","getBlockNumber","blockNumber","_getAddress","_getBlockTag","blockTag","b","_getFilter","blockHash","undefined","_address","fromBlock","toBlock","_getTransactionRequest","_request","getNetwork","detectNetwork","clone","expected","actual","chainId","getFeeData","getFeeDataFunc","_block","gasPrice","priorityFee","getBlock","maxFeePerGas","maxPriorityFeePerGas","block","baseFeePerGas","feeData","processFunc","estimateGas","_tx","call","#call","attempt","enableCcipRead","txSender","ccipArgs","parseOffchainLookup","invocation","revert","signature","args","errorArgs","ccipResult","selector","encodeBytes","extraData","checkNetwork","#checkNetwork","promise","getAccountValue","#getAccountValue","_blockTag","getBalance","getTransactionCount","getCode","getStorage","_position","position","broadcastTransaction","signedTx","signedTransaction","replaceableTransaction","#getBlock","includeTransactions","prefetchTxs","params","getTransaction","getTransactionReceipt","effectiveGasPrice","getTransactionResult","getLogs","_filter","p","_getProvider","getResolver","fromName","getAvatar","resolver","resolveName","lookupAddress","node","substring","ensAddr","getEnsAddress","ensContract","resolverContract","check","waitForTransaction","_confirms","confirms","reject","timer","listener","receipt","clearTimeout","console","log","once","off","waitForBlock","_clearTimeout","timerId","_setTimeout","_func","func","paused","time","_forEachSubscriber","sub","subscriber","_getSubscriber","_recoverSubscriber","oldSub","newSub","started","hasSub","#hasSub","emitArgs","removed","getSub","#getSub","subscription","addressableMap","WeakMap","nameMap","listeners","on","count","payload","listenerCount","total","splice","removeAllListeners","addListener","removeListener","destroy","s","_parseString","bytes","_parseBytes","offset","numPad","padded","Uint8Array","bytesPad","Math","ceil","empty","datas","byteCount","zeros","urlsOffset","urlsLength","urlsData","u","split"],"sources":["C:/Users/Oana/Desktop/Blockchain/Blockchain-Project/node_modules/ethers/lib.esm/providers/abstract-provider.js"],"sourcesContent":["/**\n *  The available providers should suffice for most developers purposes,\n *  but the [[AbstractProvider]] class has many features which enable\n *  sub-classing it for specific purposes.\n *\n *  @_section: api/providers/abstract-provider: Subclassing Provider  [abstract-provider]\n */\n// @TODO\n// Event coalescence\n//   When we register an event with an async value (e.g. address is a Signer\n//   or ENS name), we need to add it immeidately for the Event API, but also\n//   need time to resolve the address. Upon resolving the address, we need to\n//   migrate the listener to the static event. We also need to maintain a map\n//   of Signer/ENS name to address so we can sync respond to listenerCount.\nimport { getAddress, resolveAddress } from \"../address/index.js\";\nimport { ZeroAddress } from \"../constants/index.js\";\nimport { Contract } from \"../contract/index.js\";\nimport { namehash } from \"../hash/index.js\";\nimport { Transaction } from \"../transaction/index.js\";\nimport { concat, dataLength, dataSlice, hexlify, isHexString, getBigInt, getBytes, getNumber, isCallException, isError, makeError, assert, assertArgument, FetchRequest, toBeArray, toQuantity, defineProperties, EventPayload, resolveProperties, toUtf8String } from \"../utils/index.js\";\nimport { EnsResolver } from \"./ens-resolver.js\";\nimport { formatBlock, formatLog, formatTransactionReceipt, formatTransactionResponse } from \"./format.js\";\nimport { Network } from \"./network.js\";\nimport { copyRequest, Block, FeeData, Log, TransactionReceipt, TransactionResponse } from \"./provider.js\";\nimport { PollingBlockSubscriber, PollingBlockTagSubscriber, PollingEventSubscriber, PollingOrphanSubscriber, PollingTransactionSubscriber } from \"./subscriber-polling.js\";\n// Constants\nconst BN_2 = BigInt(2);\nconst MAX_CCIP_REDIRECTS = 10;\nfunction isPromise(value) {\n    return (value && typeof (value.then) === \"function\");\n}\nfunction getTag(prefix, value) {\n    return prefix + \":\" + JSON.stringify(value, (k, v) => {\n        if (v == null) {\n            return \"null\";\n        }\n        if (typeof (v) === \"bigint\") {\n            return `bigint:${v.toString()}`;\n        }\n        if (typeof (v) === \"string\") {\n            return v.toLowerCase();\n        }\n        // Sort object keys\n        if (typeof (v) === \"object\" && !Array.isArray(v)) {\n            const keys = Object.keys(v);\n            keys.sort();\n            return keys.reduce((accum, key) => {\n                accum[key] = v[key];\n                return accum;\n            }, {});\n        }\n        return v;\n    });\n}\n/**\n *  An **UnmanagedSubscriber** is useful for events which do not require\n *  any additional management, such as ``\"debug\"`` which only requires\n *  emit in synchronous event loop triggered calls.\n */\nexport class UnmanagedSubscriber {\n    /**\n     *  The name fof the event.\n     */\n    name;\n    /**\n     *  Create a new UnmanagedSubscriber with %%name%%.\n     */\n    constructor(name) { defineProperties(this, { name }); }\n    start() { }\n    stop() { }\n    pause(dropWhilePaused) { }\n    resume() { }\n}\nfunction copy(value) {\n    return JSON.parse(JSON.stringify(value));\n}\nfunction concisify(items) {\n    items = Array.from((new Set(items)).values());\n    items.sort();\n    return items;\n}\nasync function getSubscription(_event, provider) {\n    if (_event == null) {\n        throw new Error(\"invalid event\");\n    }\n    // Normalize topic array info an EventFilter\n    if (Array.isArray(_event)) {\n        _event = { topics: _event };\n    }\n    if (typeof (_event) === \"string\") {\n        switch (_event) {\n            case \"block\":\n            case \"debug\":\n            case \"error\":\n            case \"finalized\":\n            case \"network\":\n            case \"pending\":\n            case \"safe\": {\n                return { type: _event, tag: _event };\n            }\n        }\n    }\n    if (isHexString(_event, 32)) {\n        const hash = _event.toLowerCase();\n        return { type: \"transaction\", tag: getTag(\"tx\", { hash }), hash };\n    }\n    if (_event.orphan) {\n        const event = _event;\n        // @TODO: Should lowercase and whatnot things here instead of copy...\n        return { type: \"orphan\", tag: getTag(\"orphan\", event), filter: copy(event) };\n    }\n    if ((_event.address || _event.topics)) {\n        const event = _event;\n        const filter = {\n            topics: ((event.topics || []).map((t) => {\n                if (t == null) {\n                    return null;\n                }\n                if (Array.isArray(t)) {\n                    return concisify(t.map((t) => t.toLowerCase()));\n                }\n                return t.toLowerCase();\n            }))\n        };\n        if (event.address) {\n            const addresses = [];\n            const promises = [];\n            const addAddress = (addr) => {\n                if (isHexString(addr)) {\n                    addresses.push(addr);\n                }\n                else {\n                    promises.push((async () => {\n                        addresses.push(await resolveAddress(addr, provider));\n                    })());\n                }\n            };\n            if (Array.isArray(event.address)) {\n                event.address.forEach(addAddress);\n            }\n            else {\n                addAddress(event.address);\n            }\n            if (promises.length) {\n                await Promise.all(promises);\n            }\n            filter.address = concisify(addresses.map((a) => a.toLowerCase()));\n        }\n        return { filter, tag: getTag(\"event\", filter), type: \"event\" };\n    }\n    assertArgument(false, \"unknown ProviderEvent\", \"event\", _event);\n}\nfunction getTime() { return (new Date()).getTime(); }\nconst defaultOptions = {\n    cacheTimeout: 250,\n    pollingInterval: 4000\n};\n/**\n *  An **AbstractProvider** provides a base class for other sub-classes to\n *  implement the [[Provider]] API by normalizing input arguments and\n *  formatting output results as well as tracking events for consistent\n *  behaviour on an eventually-consistent network.\n */\nexport class AbstractProvider {\n    #subs;\n    #plugins;\n    // null=unpaused, true=paused+dropWhilePaused, false=paused\n    #pausedState;\n    #destroyed;\n    #networkPromise;\n    #anyNetwork;\n    #performCache;\n    // The most recent block number if running an event or -1 if no \"block\" event\n    #lastBlockNumber;\n    #nextTimer;\n    #timers;\n    #disableCcipRead;\n    #options;\n    /**\n     *  Create a new **AbstractProvider** connected to %%network%%, or\n     *  use the various network detection capabilities to discover the\n     *  [[Network]] if necessary.\n     */\n    constructor(_network, options) {\n        this.#options = Object.assign({}, defaultOptions, options || {});\n        if (_network === \"any\") {\n            this.#anyNetwork = true;\n            this.#networkPromise = null;\n        }\n        else if (_network) {\n            const network = Network.from(_network);\n            this.#anyNetwork = false;\n            this.#networkPromise = Promise.resolve(network);\n            setTimeout(() => { this.emit(\"network\", network, null); }, 0);\n        }\n        else {\n            this.#anyNetwork = false;\n            this.#networkPromise = null;\n        }\n        this.#lastBlockNumber = -1;\n        this.#performCache = new Map();\n        this.#subs = new Map();\n        this.#plugins = new Map();\n        this.#pausedState = null;\n        this.#destroyed = false;\n        this.#nextTimer = 1;\n        this.#timers = new Map();\n        this.#disableCcipRead = false;\n    }\n    get pollingInterval() { return this.#options.pollingInterval; }\n    /**\n     *  Returns ``this``, to allow an **AbstractProvider** to implement\n     *  the [[ContractRunner]] interface.\n     */\n    get provider() { return this; }\n    /**\n     *  Returns all the registered plug-ins.\n     */\n    get plugins() {\n        return Array.from(this.#plugins.values());\n    }\n    /**\n     *  Attach a new plug-in.\n     */\n    attachPlugin(plugin) {\n        if (this.#plugins.get(plugin.name)) {\n            throw new Error(`cannot replace existing plugin: ${plugin.name} `);\n        }\n        this.#plugins.set(plugin.name, plugin.connect(this));\n        return this;\n    }\n    /**\n     *  Get a plugin by name.\n     */\n    getPlugin(name) {\n        return (this.#plugins.get(name)) || null;\n    }\n    /**\n     *  Prevent any CCIP-read operation, regardless of whether requested\n     *  in a [[call]] using ``enableCcipRead``.\n     */\n    get disableCcipRead() { return this.#disableCcipRead; }\n    set disableCcipRead(value) { this.#disableCcipRead = !!value; }\n    // Shares multiple identical requests made during the same 250ms\n    async #perform(req) {\n        const timeout = this.#options.cacheTimeout;\n        // Caching disabled\n        if (timeout < 0) {\n            return await this._perform(req);\n        }\n        // Create a tag\n        const tag = getTag(req.method, req);\n        let perform = this.#performCache.get(tag);\n        if (!perform) {\n            perform = this._perform(req);\n            this.#performCache.set(tag, perform);\n            setTimeout(() => {\n                if (this.#performCache.get(tag) === perform) {\n                    this.#performCache.delete(tag);\n                }\n            }, timeout);\n        }\n        return await perform;\n    }\n    /**\n     *  Resolves to the data for executing the CCIP-read operations.\n     */\n    async ccipReadFetch(tx, calldata, urls) {\n        if (this.disableCcipRead || urls.length === 0 || tx.to == null) {\n            return null;\n        }\n        const sender = tx.to.toLowerCase();\n        const data = calldata.toLowerCase();\n        const errorMessages = [];\n        for (let i = 0; i < urls.length; i++) {\n            const url = urls[i];\n            // URL expansion\n            const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n            // If no {data} is present, use POST; otherwise GET\n            //const json: string | null = (url.indexOf(\"{data}\") >= 0) ? null: JSON.stringify({ data, sender });\n            //const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\n            //    value.status = response.statusCode;\n            //    return value;\n            //});\n            const request = new FetchRequest(href);\n            if (url.indexOf(\"{data}\") === -1) {\n                request.body = { data, sender };\n            }\n            this.emit(\"debug\", { action: \"sendCcipReadFetchRequest\", request, index: i, urls });\n            let errorMessage = \"unknown error\";\n            // Fetch the resource...\n            let resp;\n            try {\n                resp = await request.send();\n            }\n            catch (error) {\n                // ...low-level fetch error (missing host, bad SSL, etc.),\n                // so try next URL\n                errorMessages.push(error.message);\n                this.emit(\"debug\", { action: \"receiveCcipReadFetchError\", request, result: { error } });\n                continue;\n            }\n            try {\n                const result = resp.bodyJson;\n                if (result.data) {\n                    this.emit(\"debug\", { action: \"receiveCcipReadFetchResult\", request, result });\n                    return result.data;\n                }\n                if (result.message) {\n                    errorMessage = result.message;\n                }\n                this.emit(\"debug\", { action: \"receiveCcipReadFetchError\", request, result });\n            }\n            catch (error) { }\n            // 4xx indicates the result is not present; stop\n            assert(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, \"OFFCHAIN_FAULT\", { reason: \"404_MISSING_RESOURCE\", transaction: tx, info: { url, errorMessage } });\n            // 5xx indicates server issue; try the next url\n            errorMessages.push(errorMessage);\n        }\n        assert(false, `error encountered during CCIP fetch: ${errorMessages.map((m) => JSON.stringify(m)).join(\", \")}`, \"OFFCHAIN_FAULT\", {\n            reason: \"500_SERVER_ERROR\",\n            transaction: tx, info: { urls, errorMessages }\n        });\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a block before\n     *  returning it, to add additional properties or an alternate\n     *  sub-class of [[Block]].\n     */\n    _wrapBlock(value, network) {\n        return new Block(formatBlock(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a log before\n     *  returning it, to add additional properties or an alternate\n     *  sub-class of [[Log]].\n     */\n    _wrapLog(value, network) {\n        return new Log(formatLog(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a transaction\n     *  receipt before returning it, to add additional properties or an\n     *  alternate sub-class of [[TransactionReceipt]].\n     */\n    _wrapTransactionReceipt(value, network) {\n        return new TransactionReceipt(formatTransactionReceipt(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a transaction\n     *  response before returning it, to add additional properties or an\n     *  alternate sub-class of [[TransactionResponse]].\n     */\n    _wrapTransactionResponse(tx, network) {\n        return new TransactionResponse(formatTransactionResponse(tx), this);\n    }\n    /**\n     *  Resolves to the Network, forcing a network detection using whatever\n     *  technique the sub-class requires.\n     *\n     *  Sub-classes **must** override this.\n     */\n    _detectNetwork() {\n        assert(false, \"sub-classes must implement this\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_detectNetwork\"\n        });\n    }\n    /**\n     *  Sub-classes should use this to perform all built-in operations. All\n     *  methods sanitizes and normalizes the values passed into this.\n     *\n     *  Sub-classes **must** override this.\n     */\n    async _perform(req) {\n        assert(false, `unsupported method: ${req.method}`, \"UNSUPPORTED_OPERATION\", {\n            operation: req.method,\n            info: req\n        });\n    }\n    // State\n    async getBlockNumber() {\n        const blockNumber = getNumber(await this.#perform({ method: \"getBlockNumber\" }), \"%response\");\n        if (this.#lastBlockNumber >= 0) {\n            this.#lastBlockNumber = blockNumber;\n        }\n        return blockNumber;\n    }\n    /**\n     *  Returns or resolves to the address for %%address%%, resolving ENS\n     *  names and [[Addressable]] objects and returning if already an\n     *  address.\n     */\n    _getAddress(address) {\n        return resolveAddress(address, this);\n    }\n    /**\n     *  Returns or resolves to a valid block tag for %%blockTag%%, resolving\n     *  negative values and returning if already a valid block tag.\n     */\n    _getBlockTag(blockTag) {\n        if (blockTag == null) {\n            return \"latest\";\n        }\n        switch (blockTag) {\n            case \"earliest\":\n                return \"0x0\";\n            case \"finalized\":\n            case \"latest\":\n            case \"pending\":\n            case \"safe\":\n                return blockTag;\n        }\n        if (isHexString(blockTag)) {\n            if (isHexString(blockTag, 32)) {\n                return blockTag;\n            }\n            return toQuantity(blockTag);\n        }\n        if (typeof (blockTag) === \"bigint\") {\n            blockTag = getNumber(blockTag, \"blockTag\");\n        }\n        if (typeof (blockTag) === \"number\") {\n            if (blockTag >= 0) {\n                return toQuantity(blockTag);\n            }\n            if (this.#lastBlockNumber >= 0) {\n                return toQuantity(this.#lastBlockNumber + blockTag);\n            }\n            return this.getBlockNumber().then((b) => toQuantity(b + blockTag));\n        }\n        assertArgument(false, \"invalid blockTag\", \"blockTag\", blockTag);\n    }\n    /**\n     *  Returns or resolves to a filter for %%filter%%, resolving any ENS\n     *  names or [[Addressable]] object and returning if already a valid\n     *  filter.\n     */\n    _getFilter(filter) {\n        // Create a canonical representation of the topics\n        const topics = (filter.topics || []).map((t) => {\n            if (t == null) {\n                return null;\n            }\n            if (Array.isArray(t)) {\n                return concisify(t.map((t) => t.toLowerCase()));\n            }\n            return t.toLowerCase();\n        });\n        const blockHash = (\"blockHash\" in filter) ? filter.blockHash : undefined;\n        const resolve = (_address, fromBlock, toBlock) => {\n            let address = undefined;\n            switch (_address.length) {\n                case 0: break;\n                case 1:\n                    address = _address[0];\n                    break;\n                default:\n                    _address.sort();\n                    address = _address;\n            }\n            if (blockHash) {\n                if (fromBlock != null || toBlock != null) {\n                    throw new Error(\"invalid filter\");\n                }\n            }\n            const filter = {};\n            if (address) {\n                filter.address = address;\n            }\n            if (topics.length) {\n                filter.topics = topics;\n            }\n            if (fromBlock) {\n                filter.fromBlock = fromBlock;\n            }\n            if (toBlock) {\n                filter.toBlock = toBlock;\n            }\n            if (blockHash) {\n                filter.blockHash = blockHash;\n            }\n            return filter;\n        };\n        // Addresses could be async (ENS names or Addressables)\n        let address = [];\n        if (filter.address) {\n            if (Array.isArray(filter.address)) {\n                for (const addr of filter.address) {\n                    address.push(this._getAddress(addr));\n                }\n            }\n            else {\n                address.push(this._getAddress(filter.address));\n            }\n        }\n        let fromBlock = undefined;\n        if (\"fromBlock\" in filter) {\n            fromBlock = this._getBlockTag(filter.fromBlock);\n        }\n        let toBlock = undefined;\n        if (\"toBlock\" in filter) {\n            toBlock = this._getBlockTag(filter.toBlock);\n        }\n        if (address.filter((a) => (typeof (a) !== \"string\")).length ||\n            (fromBlock != null && typeof (fromBlock) !== \"string\") ||\n            (toBlock != null && typeof (toBlock) !== \"string\")) {\n            return Promise.all([Promise.all(address), fromBlock, toBlock]).then((result) => {\n                return resolve(result[0], result[1], result[2]);\n            });\n        }\n        return resolve(address, fromBlock, toBlock);\n    }\n    /**\n     *  Returns or resolves to a transaction for %%request%%, resolving\n     *  any ENS names or [[Addressable]] and returning if already a valid\n     *  transaction.\n     */\n    _getTransactionRequest(_request) {\n        const request = copyRequest(_request);\n        const promises = [];\n        [\"to\", \"from\"].forEach((key) => {\n            if (request[key] == null) {\n                return;\n            }\n            const addr = resolveAddress(request[key], this);\n            if (isPromise(addr)) {\n                promises.push((async function () { request[key] = await addr; })());\n            }\n            else {\n                request[key] = addr;\n            }\n        });\n        if (request.blockTag != null) {\n            const blockTag = this._getBlockTag(request.blockTag);\n            if (isPromise(blockTag)) {\n                promises.push((async function () { request.blockTag = await blockTag; })());\n            }\n            else {\n                request.blockTag = blockTag;\n            }\n        }\n        if (promises.length) {\n            return (async function () {\n                await Promise.all(promises);\n                return request;\n            })();\n        }\n        return request;\n    }\n    async getNetwork() {\n        // No explicit network was set and this is our first time\n        if (this.#networkPromise == null) {\n            // Detect the current network (shared with all calls)\n            const detectNetwork = (async () => {\n                try {\n                    const network = await this._detectNetwork();\n                    this.emit(\"network\", network, null);\n                    return network;\n                }\n                catch (error) {\n                    if (this.#networkPromise === detectNetwork) {\n                        this.#networkPromise = null;\n                    }\n                    throw error;\n                }\n            })();\n            this.#networkPromise = detectNetwork;\n            return (await detectNetwork).clone();\n        }\n        const networkPromise = this.#networkPromise;\n        const [expected, actual] = await Promise.all([\n            networkPromise,\n            this._detectNetwork() // The actual connected network\n        ]);\n        if (expected.chainId !== actual.chainId) {\n            if (this.#anyNetwork) {\n                // The \"any\" network can change, so notify listeners\n                this.emit(\"network\", actual, expected);\n                // Update the network if something else hasn't already changed it\n                if (this.#networkPromise === networkPromise) {\n                    this.#networkPromise = Promise.resolve(actual);\n                }\n            }\n            else {\n                // Otherwise, we do not allow changes to the underlying network\n                assert(false, `network changed: ${expected.chainId} => ${actual.chainId} `, \"NETWORK_ERROR\", {\n                    event: \"changed\"\n                });\n            }\n        }\n        return expected.clone();\n    }\n    async getFeeData() {\n        const network = await this.getNetwork();\n        const getFeeDataFunc = async () => {\n            const { _block, gasPrice, priorityFee } = await resolveProperties({\n                _block: this.#getBlock(\"latest\", false),\n                gasPrice: ((async () => {\n                    try {\n                        const value = await this.#perform({ method: \"getGasPrice\" });\n                        return getBigInt(value, \"%response\");\n                    }\n                    catch (error) { }\n                    return null;\n                })()),\n                priorityFee: ((async () => {\n                    try {\n                        const value = await this.#perform({ method: \"getPriorityFee\" });\n                        return getBigInt(value, \"%response\");\n                    }\n                    catch (error) { }\n                    return null;\n                })())\n            });\n            let maxFeePerGas = null;\n            let maxPriorityFeePerGas = null;\n            // These are the recommended EIP-1559 heuristics for fee data\n            const block = this._wrapBlock(_block, network);\n            if (block && block.baseFeePerGas) {\n                maxPriorityFeePerGas = (priorityFee != null) ? priorityFee : BigInt(\"1000000000\");\n                maxFeePerGas = (block.baseFeePerGas * BN_2) + maxPriorityFeePerGas;\n            }\n            return new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);\n        };\n        // Check for a FeeDataNetWorkPlugin\n        const plugin = network.getPlugin(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");\n        if (plugin) {\n            const req = new FetchRequest(plugin.url);\n            const feeData = await plugin.processFunc(getFeeDataFunc, this, req);\n            return new FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);\n        }\n        return await getFeeDataFunc();\n    }\n    async estimateGas(_tx) {\n        let tx = this._getTransactionRequest(_tx);\n        if (isPromise(tx)) {\n            tx = await tx;\n        }\n        return getBigInt(await this.#perform({\n            method: \"estimateGas\", transaction: tx\n        }), \"%response\");\n    }\n    async #call(tx, blockTag, attempt) {\n        assert(attempt < MAX_CCIP_REDIRECTS, \"CCIP read exceeded maximum redirections\", \"OFFCHAIN_FAULT\", {\n            reason: \"TOO_MANY_REDIRECTS\",\n            transaction: Object.assign({}, tx, { blockTag, enableCcipRead: true })\n        });\n        // This came in as a PerformActionTransaction, so to/from are safe; we can cast\n        const transaction = copyRequest(tx);\n        try {\n            return hexlify(await this._perform({ method: \"call\", transaction, blockTag }));\n        }\n        catch (error) {\n            // CCIP Read OffchainLookup\n            if (!this.disableCcipRead && isCallException(error) && error.data && attempt >= 0 && blockTag === \"latest\" && transaction.to != null && dataSlice(error.data, 0, 4) === \"0x556f1830\") {\n                const data = error.data;\n                const txSender = await resolveAddress(transaction.to, this);\n                // Parse the CCIP Read Arguments\n                let ccipArgs;\n                try {\n                    ccipArgs = parseOffchainLookup(dataSlice(error.data, 4));\n                }\n                catch (error) {\n                    assert(false, error.message, \"OFFCHAIN_FAULT\", {\n                        reason: \"BAD_DATA\", transaction, info: { data }\n                    });\n                }\n                // Check the sender of the OffchainLookup matches the transaction\n                assert(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), \"CCIP Read sender mismatch\", \"CALL_EXCEPTION\", {\n                    action: \"call\",\n                    data,\n                    reason: \"OffchainLookup\",\n                    transaction: transaction,\n                    invocation: null,\n                    revert: {\n                        signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                        name: \"OffchainLookup\",\n                        args: ccipArgs.errorArgs\n                    }\n                });\n                const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);\n                assert(ccipResult != null, \"CCIP Read failed to fetch data\", \"OFFCHAIN_FAULT\", {\n                    reason: \"FETCH_FAILED\", transaction, info: { data: error.data, errorArgs: ccipArgs.errorArgs }\n                });\n                const tx = {\n                    to: txSender,\n                    data: concat([ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])])\n                };\n                this.emit(\"debug\", { action: \"sendCcipReadCall\", transaction: tx });\n                try {\n                    const result = await this.#call(tx, blockTag, attempt + 1);\n                    this.emit(\"debug\", { action: \"receiveCcipReadCallResult\", transaction: Object.assign({}, tx), result });\n                    return result;\n                }\n                catch (error) {\n                    this.emit(\"debug\", { action: \"receiveCcipReadCallError\", transaction: Object.assign({}, tx), error });\n                    throw error;\n                }\n            }\n            throw error;\n        }\n    }\n    async #checkNetwork(promise) {\n        const { value } = await resolveProperties({\n            network: this.getNetwork(),\n            value: promise\n        });\n        return value;\n    }\n    async call(_tx) {\n        const { tx, blockTag } = await resolveProperties({\n            tx: this._getTransactionRequest(_tx),\n            blockTag: this._getBlockTag(_tx.blockTag)\n        });\n        return await this.#checkNetwork(this.#call(tx, blockTag, _tx.enableCcipRead ? 0 : -1));\n    }\n    // Account\n    async #getAccountValue(request, _address, _blockTag) {\n        let address = this._getAddress(_address);\n        let blockTag = this._getBlockTag(_blockTag);\n        if (typeof (address) !== \"string\" || typeof (blockTag) !== \"string\") {\n            [address, blockTag] = await Promise.all([address, blockTag]);\n        }\n        return await this.#checkNetwork(this.#perform(Object.assign(request, { address, blockTag })));\n    }\n    async getBalance(address, blockTag) {\n        return getBigInt(await this.#getAccountValue({ method: \"getBalance\" }, address, blockTag), \"%response\");\n    }\n    async getTransactionCount(address, blockTag) {\n        return getNumber(await this.#getAccountValue({ method: \"getTransactionCount\" }, address, blockTag), \"%response\");\n    }\n    async getCode(address, blockTag) {\n        return hexlify(await this.#getAccountValue({ method: \"getCode\" }, address, blockTag));\n    }\n    async getStorage(address, _position, blockTag) {\n        const position = getBigInt(_position, \"position\");\n        return hexlify(await this.#getAccountValue({ method: \"getStorage\", position }, address, blockTag));\n    }\n    // Write\n    async broadcastTransaction(signedTx) {\n        const { blockNumber, hash, network } = await resolveProperties({\n            blockNumber: this.getBlockNumber(),\n            hash: this._perform({\n                method: \"broadcastTransaction\",\n                signedTransaction: signedTx\n            }),\n            network: this.getNetwork()\n        });\n        const tx = Transaction.from(signedTx);\n        if (tx.hash !== hash) {\n            throw new Error(\"@TODO: the returned hash did not match\");\n        }\n        return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);\n    }\n    async #getBlock(block, includeTransactions) {\n        // @TODO: Add CustomBlockPlugin check\n        if (isHexString(block, 32)) {\n            return await this.#perform({\n                method: \"getBlock\", blockHash: block, includeTransactions\n            });\n        }\n        let blockTag = this._getBlockTag(block);\n        if (typeof (blockTag) !== \"string\") {\n            blockTag = await blockTag;\n        }\n        return await this.#perform({\n            method: \"getBlock\", blockTag, includeTransactions\n        });\n    }\n    // Queries\n    async getBlock(block, prefetchTxs) {\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#getBlock(block, !!prefetchTxs)\n        });\n        if (params == null) {\n            return null;\n        }\n        return this._wrapBlock(params, network);\n    }\n    async getTransaction(hash) {\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#perform({ method: \"getTransaction\", hash })\n        });\n        if (params == null) {\n            return null;\n        }\n        return this._wrapTransactionResponse(params, network);\n    }\n    async getTransactionReceipt(hash) {\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#perform({ method: \"getTransactionReceipt\", hash })\n        });\n        if (params == null) {\n            return null;\n        }\n        // Some backends did not backfill the effectiveGasPrice into old transactions\n        // in the receipt, so we look it up manually and inject it.\n        if (params.gasPrice == null && params.effectiveGasPrice == null) {\n            const tx = await this.#perform({ method: \"getTransaction\", hash });\n            if (tx == null) {\n                throw new Error(\"report this; could not find tx or effectiveGasPrice\");\n            }\n            params.effectiveGasPrice = tx.gasPrice;\n        }\n        return this._wrapTransactionReceipt(params, network);\n    }\n    async getTransactionResult(hash) {\n        const { result } = await resolveProperties({\n            network: this.getNetwork(),\n            result: this.#perform({ method: \"getTransactionResult\", hash })\n        });\n        if (result == null) {\n            return null;\n        }\n        return hexlify(result);\n    }\n    // Bloom-filter Queries\n    async getLogs(_filter) {\n        let filter = this._getFilter(_filter);\n        if (isPromise(filter)) {\n            filter = await filter;\n        }\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#perform({ method: \"getLogs\", filter })\n        });\n        return params.map((p) => this._wrapLog(p, network));\n    }\n    // ENS\n    _getProvider(chainId) {\n        assert(false, \"provider cannot connect to target network\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_getProvider()\"\n        });\n    }\n    async getResolver(name) {\n        return await EnsResolver.fromName(this, name);\n    }\n    async getAvatar(name) {\n        const resolver = await this.getResolver(name);\n        if (resolver) {\n            return await resolver.getAvatar();\n        }\n        return null;\n    }\n    async resolveName(name) {\n        const resolver = await this.getResolver(name);\n        if (resolver) {\n            return await resolver.getAddress();\n        }\n        return null;\n    }\n    async lookupAddress(address) {\n        address = getAddress(address);\n        const node = namehash(address.substring(2).toLowerCase() + \".addr.reverse\");\n        try {\n            const ensAddr = await EnsResolver.getEnsAddress(this);\n            const ensContract = new Contract(ensAddr, [\n                \"function resolver(bytes32) view returns (address)\"\n            ], this);\n            const resolver = await ensContract.resolver(node);\n            if (resolver == null || resolver === ZeroAddress) {\n                return null;\n            }\n            const resolverContract = new Contract(resolver, [\n                \"function name(bytes32) view returns (string)\"\n            ], this);\n            const name = await resolverContract.name(node);\n            // Failed forward resolution\n            const check = await this.resolveName(name);\n            if (check !== address) {\n                return null;\n            }\n            return name;\n        }\n        catch (error) {\n            // No data was returned from the resolver\n            if (isError(error, \"BAD_DATA\") && error.value === \"0x\") {\n                return null;\n            }\n            // Something reerted\n            if (isError(error, \"CALL_EXCEPTION\")) {\n                return null;\n            }\n            throw error;\n        }\n        return null;\n    }\n    async waitForTransaction(hash, _confirms, timeout) {\n        const confirms = (_confirms != null) ? _confirms : 1;\n        if (confirms === 0) {\n            return this.getTransactionReceipt(hash);\n        }\n        return new Promise(async (resolve, reject) => {\n            let timer = null;\n            const listener = (async (blockNumber) => {\n                try {\n                    const receipt = await this.getTransactionReceipt(hash);\n                    if (receipt != null) {\n                        if (blockNumber - receipt.blockNumber + 1 >= confirms) {\n                            resolve(receipt);\n                            //this.off(\"block\", listener);\n                            if (timer) {\n                                clearTimeout(timer);\n                                timer = null;\n                            }\n                            return;\n                        }\n                    }\n                }\n                catch (error) {\n                    console.log(\"EEE\", error);\n                }\n                this.once(\"block\", listener);\n            });\n            if (timeout != null) {\n                timer = setTimeout(() => {\n                    if (timer == null) {\n                        return;\n                    }\n                    timer = null;\n                    this.off(\"block\", listener);\n                    reject(makeError(\"timeout\", \"TIMEOUT\", { reason: \"timeout\" }));\n                }, timeout);\n            }\n            listener(await this.getBlockNumber());\n        });\n    }\n    async waitForBlock(blockTag) {\n        assert(false, \"not implemented yet\", \"NOT_IMPLEMENTED\", {\n            operation: \"waitForBlock\"\n        });\n    }\n    /**\n     *  Clear a timer created using the [[_setTimeout]] method.\n     */\n    _clearTimeout(timerId) {\n        const timer = this.#timers.get(timerId);\n        if (!timer) {\n            return;\n        }\n        if (timer.timer) {\n            clearTimeout(timer.timer);\n        }\n        this.#timers.delete(timerId);\n    }\n    /**\n     *  Create a timer that will execute %%func%% after at least %%timeout%%\n     *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute\n     *  in the next event loop.\n     *\n     *  [Pausing](AbstractProvider-paused) the provider will pause any\n     *  associated timers.\n     */\n    _setTimeout(_func, timeout) {\n        if (timeout == null) {\n            timeout = 0;\n        }\n        const timerId = this.#nextTimer++;\n        const func = () => {\n            this.#timers.delete(timerId);\n            _func();\n        };\n        if (this.paused) {\n            this.#timers.set(timerId, { timer: null, func, time: timeout });\n        }\n        else {\n            const timer = setTimeout(func, timeout);\n            this.#timers.set(timerId, { timer, func, time: getTime() });\n        }\n        return timerId;\n    }\n    /**\n     *  Perform %%func%% on each subscriber.\n     */\n    _forEachSubscriber(func) {\n        for (const sub of this.#subs.values()) {\n            func(sub.subscriber);\n        }\n    }\n    /**\n     *  Sub-classes may override this to customize subscription\n     *  implementations.\n     */\n    _getSubscriber(sub) {\n        switch (sub.type) {\n            case \"debug\":\n            case \"error\":\n            case \"network\":\n                return new UnmanagedSubscriber(sub.type);\n            case \"block\": {\n                const subscriber = new PollingBlockSubscriber(this);\n                subscriber.pollingInterval = this.pollingInterval;\n                return subscriber;\n            }\n            case \"safe\":\n            case \"finalized\":\n                return new PollingBlockTagSubscriber(this, sub.type);\n            case \"event\":\n                return new PollingEventSubscriber(this, sub.filter);\n            case \"transaction\":\n                return new PollingTransactionSubscriber(this, sub.hash);\n            case \"orphan\":\n                return new PollingOrphanSubscriber(this, sub.filter);\n        }\n        throw new Error(`unsupported event: ${sub.type}`);\n    }\n    /**\n     *  If a [[Subscriber]] fails and needs to replace itself, this\n     *  method may be used.\n     *\n     *  For example, this is used for providers when using the\n     *  ``eth_getFilterChanges`` method, which can return null if state\n     *  filters are not supported by the backend, allowing the Subscriber\n     *  to swap in a [[PollingEventSubscriber]].\n     */\n    _recoverSubscriber(oldSub, newSub) {\n        for (const sub of this.#subs.values()) {\n            if (sub.subscriber === oldSub) {\n                if (sub.started) {\n                    sub.subscriber.stop();\n                }\n                sub.subscriber = newSub;\n                if (sub.started) {\n                    newSub.start();\n                }\n                if (this.#pausedState != null) {\n                    newSub.pause(this.#pausedState);\n                }\n                break;\n            }\n        }\n    }\n    async #hasSub(event, emitArgs) {\n        let sub = await getSubscription(event, this);\n        // This is a log that is removing an existing log; we actually want\n        // to emit an orphan event for the removed log\n        if (sub.type === \"event\" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {\n            sub = await getSubscription({ orphan: \"drop-log\", log: emitArgs[0] }, this);\n        }\n        return this.#subs.get(sub.tag) || null;\n    }\n    async #getSub(event) {\n        const subscription = await getSubscription(event, this);\n        // Prevent tampering with our tag in any subclass' _getSubscriber\n        const tag = subscription.tag;\n        let sub = this.#subs.get(tag);\n        if (!sub) {\n            const subscriber = this._getSubscriber(subscription);\n            const addressableMap = new WeakMap();\n            const nameMap = new Map();\n            sub = { subscriber, tag, addressableMap, nameMap, started: false, listeners: [] };\n            this.#subs.set(tag, sub);\n        }\n        return sub;\n    }\n    async on(event, listener) {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({ listener, once: false });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState != null) {\n                sub.subscriber.pause(this.#pausedState);\n            }\n        }\n        return this;\n    }\n    async once(event, listener) {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({ listener, once: true });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState != null) {\n                sub.subscriber.pause(this.#pausedState);\n            }\n        }\n        return this;\n    }\n    async emit(event, ...args) {\n        const sub = await this.#hasSub(event, args);\n        // If there is not subscription or if a recent emit removed\n        // the last of them (which also deleted the sub) do nothing\n        if (!sub || sub.listeners.length === 0) {\n            return false;\n        }\n        ;\n        const count = sub.listeners.length;\n        sub.listeners = sub.listeners.filter(({ listener, once }) => {\n            const payload = new EventPayload(this, (once ? null : listener), event);\n            try {\n                listener.call(this, ...args, payload);\n            }\n            catch (error) { }\n            return !once;\n        });\n        if (sub.listeners.length === 0) {\n            if (sub.started) {\n                sub.subscriber.stop();\n            }\n            this.#subs.delete(sub.tag);\n        }\n        return (count > 0);\n    }\n    async listenerCount(event) {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) {\n                return 0;\n            }\n            return sub.listeners.length;\n        }\n        let total = 0;\n        for (const { listeners } of this.#subs.values()) {\n            total += listeners.length;\n        }\n        return total;\n    }\n    async listeners(event) {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) {\n                return [];\n            }\n            return sub.listeners.map(({ listener }) => listener);\n        }\n        let result = [];\n        for (const { listeners } of this.#subs.values()) {\n            result = result.concat(listeners.map(({ listener }) => listener));\n        }\n        return result;\n    }\n    async off(event, listener) {\n        const sub = await this.#hasSub(event);\n        if (!sub) {\n            return this;\n        }\n        if (listener) {\n            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);\n            if (index >= 0) {\n                sub.listeners.splice(index, 1);\n            }\n        }\n        if (!listener || sub.listeners.length === 0) {\n            if (sub.started) {\n                sub.subscriber.stop();\n            }\n            this.#subs.delete(sub.tag);\n        }\n        return this;\n    }\n    async removeAllListeners(event) {\n        if (event) {\n            const { tag, started, subscriber } = await this.#getSub(event);\n            if (started) {\n                subscriber.stop();\n            }\n            this.#subs.delete(tag);\n        }\n        else {\n            for (const [tag, { started, subscriber }] of this.#subs) {\n                if (started) {\n                    subscriber.stop();\n                }\n                this.#subs.delete(tag);\n            }\n        }\n        return this;\n    }\n    // Alias for \"on\"\n    async addListener(event, listener) {\n        return await this.on(event, listener);\n    }\n    // Alias for \"off\"\n    async removeListener(event, listener) {\n        return this.off(event, listener);\n    }\n    /**\n     *  If this provider has been destroyed using the [[destroy]] method.\n     *\n     *  Once destroyed, all resources are reclaimed, internal event loops\n     *  and timers are cleaned up and no further requests may be sent to\n     *  the provider.\n     */\n    get destroyed() {\n        return this.#destroyed;\n    }\n    /**\n     *  Sub-classes may use this to shutdown any sockets or release their\n     *  resources and reject any pending requests.\n     *\n     *  Sub-classes **must** call ``super.destroy()``.\n     */\n    destroy() {\n        // Stop all listeners\n        this.removeAllListeners();\n        // Shut down all tiemrs\n        for (const timerId of this.#timers.keys()) {\n            this._clearTimeout(timerId);\n        }\n        this.#destroyed = true;\n    }\n    /**\n     *  Whether the provider is currently paused.\n     *\n     *  A paused provider will not emit any events, and generally should\n     *  not make any requests to the network, but that is up to sub-classes\n     *  to manage.\n     *\n     *  Setting ``paused = true`` is identical to calling ``.pause(false)``,\n     *  which will buffer any events that occur while paused until the\n     *  provider is unpaused.\n     */\n    get paused() { return (this.#pausedState != null); }\n    set paused(pause) {\n        if (!!pause === this.paused) {\n            return;\n        }\n        if (this.paused) {\n            this.resume();\n        }\n        else {\n            this.pause(false);\n        }\n    }\n    /**\n     *  Pause the provider. If %%dropWhilePaused%%, any events that occur\n     *  while paused are dropped, otherwise all events will be emitted once\n     *  the provider is unpaused.\n     */\n    pause(dropWhilePaused) {\n        this.#lastBlockNumber = -1;\n        if (this.#pausedState != null) {\n            if (this.#pausedState == !!dropWhilePaused) {\n                return;\n            }\n            assert(false, \"cannot change pause type; resume first\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"pause\"\n            });\n        }\n        this._forEachSubscriber((s) => s.pause(dropWhilePaused));\n        this.#pausedState = !!dropWhilePaused;\n        for (const timer of this.#timers.values()) {\n            // Clear the timer\n            if (timer.timer) {\n                clearTimeout(timer.timer);\n            }\n            // Remaining time needed for when we become unpaused\n            timer.time = getTime() - timer.time;\n        }\n    }\n    /**\n     *  Resume the provider.\n     */\n    resume() {\n        if (this.#pausedState == null) {\n            return;\n        }\n        this._forEachSubscriber((s) => s.resume());\n        this.#pausedState = null;\n        for (const timer of this.#timers.values()) {\n            // Remaining time when we were paused\n            let timeout = timer.time;\n            if (timeout < 0) {\n                timeout = 0;\n            }\n            // Start time (in cause paused, so we con compute remaininf time)\n            timer.time = getTime();\n            // Start the timer\n            setTimeout(timer.func, timeout);\n        }\n    }\n}\nfunction _parseString(result, start) {\n    try {\n        const bytes = _parseBytes(result, start);\n        if (bytes) {\n            return toUtf8String(bytes);\n        }\n    }\n    catch (error) { }\n    return null;\n}\nfunction _parseBytes(result, start) {\n    if (result === \"0x\") {\n        return null;\n    }\n    try {\n        const offset = getNumber(dataSlice(result, start, start + 32));\n        const length = getNumber(dataSlice(result, offset, offset + 32));\n        return dataSlice(result, offset + 32, offset + 32 + length);\n    }\n    catch (error) { }\n    return null;\n}\nfunction numPad(value) {\n    const result = toBeArray(value);\n    if (result.length > 32) {\n        throw new Error(\"internal; should not happen\");\n    }\n    const padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\nfunction bytesPad(value) {\n    if ((value.length % 32) === 0) {\n        return value;\n    }\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\nconst empty = new Uint8Array([]);\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas) {\n    const result = [];\n    let byteCount = 0;\n    // Add place-holders for pointers as we add items\n    for (let i = 0; i < datas.length; i++) {\n        result.push(empty);\n        byteCount += 32;\n    }\n    for (let i = 0; i < datas.length; i++) {\n        const data = getBytes(datas[i]);\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n    return concat(result);\n}\nconst zeros = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\nfunction parseOffchainLookup(data) {\n    const result = {\n        sender: \"\", urls: [], calldata: \"\", selector: \"\", extraData: \"\", errorArgs: []\n    };\n    assert(dataLength(data) >= 5 * 32, \"insufficient OffchainLookup data\", \"OFFCHAIN_FAULT\", {\n        reason: \"insufficient OffchainLookup data\"\n    });\n    const sender = dataSlice(data, 0, 32);\n    assert(dataSlice(sender, 0, 12) === dataSlice(zeros, 0, 12), \"corrupt OffchainLookup sender\", \"OFFCHAIN_FAULT\", {\n        reason: \"corrupt OffchainLookup sender\"\n    });\n    result.sender = dataSlice(sender, 12);\n    // Read the URLs from the response\n    try {\n        const urls = [];\n        const urlsOffset = getNumber(dataSlice(data, 32, 64));\n        const urlsLength = getNumber(dataSlice(data, urlsOffset, urlsOffset + 32));\n        const urlsData = dataSlice(data, urlsOffset + 32);\n        for (let u = 0; u < urlsLength; u++) {\n            const url = _parseString(urlsData, u * 32);\n            if (url == null) {\n                throw new Error(\"abort\");\n            }\n            urls.push(url);\n        }\n        result.urls = urls;\n    }\n    catch (error) {\n        assert(false, \"corrupt OffchainLookup urls\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup urls\"\n        });\n    }\n    // Get the CCIP calldata to forward\n    try {\n        const calldata = _parseBytes(data, 64);\n        if (calldata == null) {\n            throw new Error(\"abort\");\n        }\n        result.calldata = calldata;\n    }\n    catch (error) {\n        assert(false, \"corrupt OffchainLookup calldata\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup calldata\"\n        });\n    }\n    // Get the callbackSelector (bytes4)\n    assert(dataSlice(data, 100, 128) === dataSlice(zeros, 0, 28), \"corrupt OffchainLookup callbaackSelector\", \"OFFCHAIN_FAULT\", {\n        reason: \"corrupt OffchainLookup callbaackSelector\"\n    });\n    result.selector = dataSlice(data, 96, 100);\n    // Get the extra data to send back to the contract as context\n    try {\n        const extraData = _parseBytes(data, 128);\n        if (extraData == null) {\n            throw new Error(\"abort\");\n        }\n        result.extraData = extraData;\n    }\n    catch (error) {\n        assert(false, \"corrupt OffchainLookup extraData\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup extraData\"\n        });\n    }\n    result.errorArgs = \"sender,urls,calldata,selector,extraData\".split(/,/).map((k) => result[k]);\n    return result;\n}\n//# sourceMappingURL=abstract-provider.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}