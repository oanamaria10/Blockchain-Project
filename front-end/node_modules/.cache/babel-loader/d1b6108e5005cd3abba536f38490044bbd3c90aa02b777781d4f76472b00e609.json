{"ast":null,"code":"const assert = require('assert');\nconst {\n  atob\n} = require('buffer');\nconst {\n  isomorphicDecode\n} = require('./util');\nconst encoder = new TextEncoder();\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-token-code-point\n */\nconst HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;\nconst HTTP_WHITESPACE_REGEX = /(\\u000A|\\u000D|\\u0009|\\u0020)/; // eslint-disable-line\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point\n */\nconst HTTP_QUOTED_STRING_TOKENS = /[\\u0009|\\u0020-\\u007E|\\u0080-\\u00FF]/; // eslint-disable-line\n\n// https://fetch.spec.whatwg.org/#data-url-processor\n/** @param {URL} dataURL */\nfunction dataURLProcessor(dataURL) {\n  // 1. Assert: dataURL’s scheme is \"data\".\n  assert(dataURL.protocol === 'data:');\n\n  // 2. Let input be the result of running the URL\n  // serializer on dataURL with exclude fragment\n  // set to true.\n  let input = URLSerializer(dataURL, true);\n\n  // 3. Remove the leading \"data:\" string from input.\n  input = input.slice(5);\n\n  // 4. Let position point at the start of input.\n  const position = {\n    position: 0\n  };\n\n  // 5. Let mimeType be the result of collecting a\n  // sequence of code points that are not equal\n  // to U+002C (,), given position.\n  let mimeType = collectASequenceOfCodePointsFast(',', input, position);\n\n  // 6. Strip leading and trailing ASCII whitespace\n  // from mimeType.\n  // Undici implementation note: we need to store the\n  // length because if the mimetype has spaces removed,\n  // the wrong amount will be sliced from the input in\n  // step #9\n  const mimeTypeLength = mimeType.length;\n  mimeType = removeASCIIWhitespace(mimeType, true, true);\n\n  // 7. If position is past the end of input, then\n  // return failure\n  if (position.position >= input.length) {\n    return 'failure';\n  }\n\n  // 8. Advance position by 1.\n  position.position++;\n\n  // 9. Let encodedBody be the remainder of input.\n  const encodedBody = input.slice(mimeTypeLength + 1);\n\n  // 10. Let body be the percent-decoding of encodedBody.\n  let body = stringPercentDecode(encodedBody);\n\n  // 11. If mimeType ends with U+003B (;), followed by\n  // zero or more U+0020 SPACE, followed by an ASCII\n  // case-insensitive match for \"base64\", then:\n  if (/;(\\u0020){0,}base64$/i.test(mimeType)) {\n    // 1. Let stringBody be the isomorphic decode of body.\n    const stringBody = isomorphicDecode(body);\n\n    // 2. Set body to the forgiving-base64 decode of\n    // stringBody.\n    body = forgivingBase64(stringBody);\n\n    // 3. If body is failure, then return failure.\n    if (body === 'failure') {\n      return 'failure';\n    }\n\n    // 4. Remove the last 6 code points from mimeType.\n    mimeType = mimeType.slice(0, -6);\n\n    // 5. Remove trailing U+0020 SPACE code points from mimeType,\n    // if any.\n    mimeType = mimeType.replace(/(\\u0020)+$/, '');\n\n    // 6. Remove the last U+003B (;) code point from mimeType.\n    mimeType = mimeType.slice(0, -1);\n  }\n\n  // 12. If mimeType starts with U+003B (;), then prepend\n  // \"text/plain\" to mimeType.\n  if (mimeType.startsWith(';')) {\n    mimeType = 'text/plain' + mimeType;\n  }\n\n  // 13. Let mimeTypeRecord be the result of parsing\n  // mimeType.\n  let mimeTypeRecord = parseMIMEType(mimeType);\n\n  // 14. If mimeTypeRecord is failure, then set\n  // mimeTypeRecord to text/plain;charset=US-ASCII.\n  if (mimeTypeRecord === 'failure') {\n    mimeTypeRecord = parseMIMEType('text/plain;charset=US-ASCII');\n  }\n\n  // 15. Return a new data: URL struct whose MIME\n  // type is mimeTypeRecord and body is body.\n  // https://fetch.spec.whatwg.org/#data-url-struct\n  return {\n    mimeType: mimeTypeRecord,\n    body\n  };\n}\n\n// https://url.spec.whatwg.org/#concept-url-serializer\n/**\n * @param {URL} url\n * @param {boolean} excludeFragment\n */\nfunction URLSerializer(url, excludeFragment = false) {\n  if (!excludeFragment) {\n    return url.href;\n  }\n  const href = url.href;\n  const hashLength = url.hash.length;\n  return hashLength === 0 ? href : href.substring(0, href.length - hashLength);\n}\n\n// https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points\n/**\n * @param {(char: string) => boolean} condition\n * @param {string} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfCodePoints(condition, input, position) {\n  // 1. Let result be the empty string.\n  let result = '';\n\n  // 2. While position doesn’t point past the end of input and the\n  // code point at position within input meets the condition condition:\n  while (position.position < input.length && condition(input[position.position])) {\n    // 1. Append that code point to the end of result.\n    result += input[position.position];\n\n    // 2. Advance position by 1.\n    position.position++;\n  }\n\n  // 3. Return result.\n  return result;\n}\n\n/**\n * A faster collectASequenceOfCodePoints that only works when comparing a single character.\n * @param {string} char\n * @param {string} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfCodePointsFast(char, input, position) {\n  const idx = input.indexOf(char, position.position);\n  const start = position.position;\n  if (idx === -1) {\n    position.position = input.length;\n    return input.slice(start);\n  }\n  position.position = idx;\n  return input.slice(start, position.position);\n}\n\n// https://url.spec.whatwg.org/#string-percent-decode\n/** @param {string} input */\nfunction stringPercentDecode(input) {\n  // 1. Let bytes be the UTF-8 encoding of input.\n  const bytes = encoder.encode(input);\n\n  // 2. Return the percent-decoding of bytes.\n  return percentDecode(bytes);\n}\n\n// https://url.spec.whatwg.org/#percent-decode\n/** @param {Uint8Array} input */\nfunction percentDecode(input) {\n  // 1. Let output be an empty byte sequence.\n  /** @type {number[]} */\n  const output = [];\n\n  // 2. For each byte byte in input:\n  for (let i = 0; i < input.length; i++) {\n    const byte = input[i];\n\n    // 1. If byte is not 0x25 (%), then append byte to output.\n    if (byte !== 0x25) {\n      output.push(byte);\n\n      // 2. Otherwise, if byte is 0x25 (%) and the next two bytes\n      // after byte in input are not in the ranges\n      // 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F),\n      // and 0x61 (a) to 0x66 (f), all inclusive, append byte\n      // to output.\n    } else if (byte === 0x25 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))) {\n      output.push(0x25);\n\n      // 3. Otherwise:\n    } else {\n      // 1. Let bytePoint be the two bytes after byte in input,\n      // decoded, and then interpreted as hexadecimal number.\n      const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);\n      const bytePoint = Number.parseInt(nextTwoBytes, 16);\n\n      // 2. Append a byte whose value is bytePoint to output.\n      output.push(bytePoint);\n\n      // 3. Skip the next two bytes in input.\n      i += 2;\n    }\n  }\n\n  // 3. Return output.\n  return Uint8Array.from(output);\n}\n\n// https://mimesniff.spec.whatwg.org/#parse-a-mime-type\n/** @param {string} input */\nfunction parseMIMEType(input) {\n  // 1. Remove any leading and trailing HTTP whitespace\n  // from input.\n  input = removeHTTPWhitespace(input, true, true);\n\n  // 2. Let position be a position variable for input,\n  // initially pointing at the start of input.\n  const position = {\n    position: 0\n  };\n\n  // 3. Let type be the result of collecting a sequence\n  // of code points that are not U+002F (/) from\n  // input, given position.\n  const type = collectASequenceOfCodePointsFast('/', input, position);\n\n  // 4. If type is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  // https://mimesniff.spec.whatwg.org/#http-token-code-point\n  if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {\n    return 'failure';\n  }\n\n  // 5. If position is past the end of input, then return\n  // failure\n  if (position.position > input.length) {\n    return 'failure';\n  }\n\n  // 6. Advance position by 1. (This skips past U+002F (/).)\n  position.position++;\n\n  // 7. Let subtype be the result of collecting a sequence of\n  // code points that are not U+003B (;) from input, given\n  // position.\n  let subtype = collectASequenceOfCodePointsFast(';', input, position);\n\n  // 8. Remove any trailing HTTP whitespace from subtype.\n  subtype = removeHTTPWhitespace(subtype, false, true);\n\n  // 9. If subtype is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {\n    return 'failure';\n  }\n  const typeLowercase = type.toLowerCase();\n  const subtypeLowercase = subtype.toLowerCase();\n\n  // 10. Let mimeType be a new MIME type record whose type\n  // is type, in ASCII lowercase, and subtype is subtype,\n  // in ASCII lowercase.\n  // https://mimesniff.spec.whatwg.org/#mime-type\n  const mimeType = {\n    type: typeLowercase,\n    subtype: subtypeLowercase,\n    /** @type {Map<string, string>} */\n    parameters: new Map(),\n    // https://mimesniff.spec.whatwg.org/#mime-type-essence\n    essence: `${typeLowercase}/${subtypeLowercase}`\n  };\n\n  // 11. While position is not past the end of input:\n  while (position.position < input.length) {\n    // 1. Advance position by 1. (This skips past U+003B (;).)\n    position.position++;\n\n    // 2. Collect a sequence of code points that are HTTP\n    // whitespace from input given position.\n    collectASequenceOfCodePoints(\n    // https://fetch.spec.whatwg.org/#http-whitespace\n    char => HTTP_WHITESPACE_REGEX.test(char), input, position);\n\n    // 3. Let parameterName be the result of collecting a\n    // sequence of code points that are not U+003B (;)\n    // or U+003D (=) from input, given position.\n    let parameterName = collectASequenceOfCodePoints(char => char !== ';' && char !== '=', input, position);\n\n    // 4. Set parameterName to parameterName, in ASCII\n    // lowercase.\n    parameterName = parameterName.toLowerCase();\n\n    // 5. If position is not past the end of input, then:\n    if (position.position < input.length) {\n      // 1. If the code point at position within input is\n      // U+003B (;), then continue.\n      if (input[position.position] === ';') {\n        continue;\n      }\n\n      // 2. Advance position by 1. (This skips past U+003D (=).)\n      position.position++;\n    }\n\n    // 6. If position is past the end of input, then break.\n    if (position.position > input.length) {\n      break;\n    }\n\n    // 7. Let parameterValue be null.\n    let parameterValue = null;\n\n    // 8. If the code point at position within input is\n    // U+0022 (\"), then:\n    if (input[position.position] === '\"') {\n      // 1. Set parameterValue to the result of collecting\n      // an HTTP quoted string from input, given position\n      // and the extract-value flag.\n      parameterValue = collectAnHTTPQuotedString(input, position, true);\n\n      // 2. Collect a sequence of code points that are not\n      // U+003B (;) from input, given position.\n      collectASequenceOfCodePointsFast(';', input, position);\n\n      // 9. Otherwise:\n    } else {\n      // 1. Set parameterValue to the result of collecting\n      // a sequence of code points that are not U+003B (;)\n      // from input, given position.\n      parameterValue = collectASequenceOfCodePointsFast(';', input, position);\n\n      // 2. Remove any trailing HTTP whitespace from parameterValue.\n      parameterValue = removeHTTPWhitespace(parameterValue, false, true);\n\n      // 3. If parameterValue is the empty string, then continue.\n      if (parameterValue.length === 0) {\n        continue;\n      }\n    }\n\n    // 10. If all of the following are true\n    // - parameterName is not the empty string\n    // - parameterName solely contains HTTP token code points\n    // - parameterValue solely contains HTTP quoted-string token code points\n    // - mimeType’s parameters[parameterName] does not exist\n    // then set mimeType’s parameters[parameterName] to parameterValue.\n    if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {\n      mimeType.parameters.set(parameterName, parameterValue);\n    }\n  }\n\n  // 12. Return mimeType.\n  return mimeType;\n}\n\n// https://infra.spec.whatwg.org/#forgiving-base64-decode\n/** @param {string} data */\nfunction forgivingBase64(data) {\n  // 1. Remove all ASCII whitespace from data.\n  data = data.replace(/[\\u0009\\u000A\\u000C\\u000D\\u0020]/g, ''); // eslint-disable-line\n\n  // 2. If data’s code point length divides by 4 leaving\n  // no remainder, then:\n  if (data.length % 4 === 0) {\n    // 1. If data ends with one or two U+003D (=) code points,\n    // then remove them from data.\n    data = data.replace(/=?=$/, '');\n  }\n\n  // 3. If data’s code point length divides by 4 leaving\n  // a remainder of 1, then return failure.\n  if (data.length % 4 === 1) {\n    return 'failure';\n  }\n\n  // 4. If data contains a code point that is not one of\n  //  U+002B (+)\n  //  U+002F (/)\n  //  ASCII alphanumeric\n  // then return failure.\n  if (/[^+/0-9A-Za-z]/.test(data)) {\n    return 'failure';\n  }\n  const binary = atob(data);\n  const bytes = new Uint8Array(binary.length);\n  for (let byte = 0; byte < binary.length; byte++) {\n    bytes[byte] = binary.charCodeAt(byte);\n  }\n  return bytes;\n}\n\n// https://fetch.spec.whatwg.org/#collect-an-http-quoted-string\n// tests: https://fetch.spec.whatwg.org/#example-http-quoted-string\n/**\n * @param {string} input\n * @param {{ position: number }} position\n * @param {boolean?} extractValue\n */\nfunction collectAnHTTPQuotedString(input, position, extractValue) {\n  // 1. Let positionStart be position.\n  const positionStart = position.position;\n\n  // 2. Let value be the empty string.\n  let value = '';\n\n  // 3. Assert: the code point at position within input\n  // is U+0022 (\").\n  assert(input[position.position] === '\"');\n\n  // 4. Advance position by 1.\n  position.position++;\n\n  // 5. While true:\n  while (true) {\n    // 1. Append the result of collecting a sequence of code points\n    // that are not U+0022 (\") or U+005C (\\) from input, given\n    // position, to value.\n    value += collectASequenceOfCodePoints(char => char !== '\"' && char !== '\\\\', input, position);\n\n    // 2. If position is past the end of input, then break.\n    if (position.position >= input.length) {\n      break;\n    }\n\n    // 3. Let quoteOrBackslash be the code point at position within\n    // input.\n    const quoteOrBackslash = input[position.position];\n\n    // 4. Advance position by 1.\n    position.position++;\n\n    // 5. If quoteOrBackslash is U+005C (\\), then:\n    if (quoteOrBackslash === '\\\\') {\n      // 1. If position is past the end of input, then append\n      // U+005C (\\) to value and break.\n      if (position.position >= input.length) {\n        value += '\\\\';\n        break;\n      }\n\n      // 2. Append the code point at position within input to value.\n      value += input[position.position];\n\n      // 3. Advance position by 1.\n      position.position++;\n\n      // 6. Otherwise:\n    } else {\n      // 1. Assert: quoteOrBackslash is U+0022 (\").\n      assert(quoteOrBackslash === '\"');\n\n      // 2. Break.\n      break;\n    }\n  }\n\n  // 6. If the extract-value flag is set, then return value.\n  if (extractValue) {\n    return value;\n  }\n\n  // 7. Return the code points from positionStart to position,\n  // inclusive, within input.\n  return input.slice(positionStart, position.position);\n}\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type\n */\nfunction serializeAMimeType(mimeType) {\n  assert(mimeType !== 'failure');\n  const {\n    parameters,\n    essence\n  } = mimeType;\n\n  // 1. Let serialization be the concatenation of mimeType’s\n  //    type, U+002F (/), and mimeType’s subtype.\n  let serialization = essence;\n\n  // 2. For each name → value of mimeType’s parameters:\n  for (let [name, value] of parameters.entries()) {\n    // 1. Append U+003B (;) to serialization.\n    serialization += ';';\n\n    // 2. Append name to serialization.\n    serialization += name;\n\n    // 3. Append U+003D (=) to serialization.\n    serialization += '=';\n\n    // 4. If value does not solely contain HTTP token code\n    //    points or value is the empty string, then:\n    if (!HTTP_TOKEN_CODEPOINTS.test(value)) {\n      // 1. Precede each occurence of U+0022 (\") or\n      //    U+005C (\\) in value with U+005C (\\).\n      value = value.replace(/(\\\\|\")/g, '\\\\$1');\n\n      // 2. Prepend U+0022 (\") to value.\n      value = '\"' + value;\n\n      // 3. Append U+0022 (\") to value.\n      value += '\"';\n    }\n\n    // 5. Append value to serialization.\n    serialization += value;\n  }\n\n  // 3. Return serialization.\n  return serialization;\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {string} char\n */\nfunction isHTTPWhiteSpace(char) {\n  return char === '\\r' || char === '\\n' || char === '\\t' || char === ' ';\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {string} str\n */\nfunction removeHTTPWhitespace(str, leading = true, trailing = true) {\n  let lead = 0;\n  let trail = str.length - 1;\n  if (leading) {\n    for (; lead < str.length && isHTTPWhiteSpace(str[lead]); lead++);\n  }\n  if (trailing) {\n    for (; trail > 0 && isHTTPWhiteSpace(str[trail]); trail--);\n  }\n  return str.slice(lead, trail + 1);\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#ascii-whitespace\n * @param {string} char\n */\nfunction isASCIIWhitespace(char) {\n  return char === '\\r' || char === '\\n' || char === '\\t' || char === '\\f' || char === ' ';\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace\n */\nfunction removeASCIIWhitespace(str, leading = true, trailing = true) {\n  let lead = 0;\n  let trail = str.length - 1;\n  if (leading) {\n    for (; lead < str.length && isASCIIWhitespace(str[lead]); lead++);\n  }\n  if (trailing) {\n    for (; trail > 0 && isASCIIWhitespace(str[trail]); trail--);\n  }\n  return str.slice(lead, trail + 1);\n}\nmodule.exports = {\n  dataURLProcessor,\n  URLSerializer,\n  collectASequenceOfCodePoints,\n  collectASequenceOfCodePointsFast,\n  stringPercentDecode,\n  parseMIMEType,\n  collectAnHTTPQuotedString,\n  serializeAMimeType\n};","map":{"version":3,"names":["assert","require","atob","isomorphicDecode","encoder","TextEncoder","HTTP_TOKEN_CODEPOINTS","HTTP_WHITESPACE_REGEX","HTTP_QUOTED_STRING_TOKENS","dataURLProcessor","dataURL","protocol","input","URLSerializer","slice","position","mimeType","collectASequenceOfCodePointsFast","mimeTypeLength","length","removeASCIIWhitespace","encodedBody","body","stringPercentDecode","test","stringBody","forgivingBase64","replace","startsWith","mimeTypeRecord","parseMIMEType","url","excludeFragment","href","hashLength","hash","substring","collectASequenceOfCodePoints","condition","result","char","idx","indexOf","start","bytes","encode","percentDecode","output","i","byte","push","String","fromCharCode","nextTwoBytes","bytePoint","Number","parseInt","Uint8Array","from","removeHTTPWhitespace","type","subtype","typeLowercase","toLowerCase","subtypeLowercase","parameters","Map","essence","parameterName","parameterValue","collectAnHTTPQuotedString","has","set","data","binary","charCodeAt","extractValue","positionStart","value","quoteOrBackslash","serializeAMimeType","serialization","name","entries","isHTTPWhiteSpace","str","leading","trailing","lead","trail","isASCIIWhitespace","module","exports"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/undici/lib/fetch/dataURL.js"],"sourcesContent":["const assert = require('assert')\nconst { atob } = require('buffer')\nconst { isomorphicDecode } = require('./util')\n\nconst encoder = new TextEncoder()\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-token-code-point\n */\nconst HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/\nconst HTTP_WHITESPACE_REGEX = /(\\u000A|\\u000D|\\u0009|\\u0020)/ // eslint-disable-line\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point\n */\nconst HTTP_QUOTED_STRING_TOKENS = /[\\u0009|\\u0020-\\u007E|\\u0080-\\u00FF]/ // eslint-disable-line\n\n// https://fetch.spec.whatwg.org/#data-url-processor\n/** @param {URL} dataURL */\nfunction dataURLProcessor (dataURL) {\n  // 1. Assert: dataURL’s scheme is \"data\".\n  assert(dataURL.protocol === 'data:')\n\n  // 2. Let input be the result of running the URL\n  // serializer on dataURL with exclude fragment\n  // set to true.\n  let input = URLSerializer(dataURL, true)\n\n  // 3. Remove the leading \"data:\" string from input.\n  input = input.slice(5)\n\n  // 4. Let position point at the start of input.\n  const position = { position: 0 }\n\n  // 5. Let mimeType be the result of collecting a\n  // sequence of code points that are not equal\n  // to U+002C (,), given position.\n  let mimeType = collectASequenceOfCodePointsFast(\n    ',',\n    input,\n    position\n  )\n\n  // 6. Strip leading and trailing ASCII whitespace\n  // from mimeType.\n  // Undici implementation note: we need to store the\n  // length because if the mimetype has spaces removed,\n  // the wrong amount will be sliced from the input in\n  // step #9\n  const mimeTypeLength = mimeType.length\n  mimeType = removeASCIIWhitespace(mimeType, true, true)\n\n  // 7. If position is past the end of input, then\n  // return failure\n  if (position.position >= input.length) {\n    return 'failure'\n  }\n\n  // 8. Advance position by 1.\n  position.position++\n\n  // 9. Let encodedBody be the remainder of input.\n  const encodedBody = input.slice(mimeTypeLength + 1)\n\n  // 10. Let body be the percent-decoding of encodedBody.\n  let body = stringPercentDecode(encodedBody)\n\n  // 11. If mimeType ends with U+003B (;), followed by\n  // zero or more U+0020 SPACE, followed by an ASCII\n  // case-insensitive match for \"base64\", then:\n  if (/;(\\u0020){0,}base64$/i.test(mimeType)) {\n    // 1. Let stringBody be the isomorphic decode of body.\n    const stringBody = isomorphicDecode(body)\n\n    // 2. Set body to the forgiving-base64 decode of\n    // stringBody.\n    body = forgivingBase64(stringBody)\n\n    // 3. If body is failure, then return failure.\n    if (body === 'failure') {\n      return 'failure'\n    }\n\n    // 4. Remove the last 6 code points from mimeType.\n    mimeType = mimeType.slice(0, -6)\n\n    // 5. Remove trailing U+0020 SPACE code points from mimeType,\n    // if any.\n    mimeType = mimeType.replace(/(\\u0020)+$/, '')\n\n    // 6. Remove the last U+003B (;) code point from mimeType.\n    mimeType = mimeType.slice(0, -1)\n  }\n\n  // 12. If mimeType starts with U+003B (;), then prepend\n  // \"text/plain\" to mimeType.\n  if (mimeType.startsWith(';')) {\n    mimeType = 'text/plain' + mimeType\n  }\n\n  // 13. Let mimeTypeRecord be the result of parsing\n  // mimeType.\n  let mimeTypeRecord = parseMIMEType(mimeType)\n\n  // 14. If mimeTypeRecord is failure, then set\n  // mimeTypeRecord to text/plain;charset=US-ASCII.\n  if (mimeTypeRecord === 'failure') {\n    mimeTypeRecord = parseMIMEType('text/plain;charset=US-ASCII')\n  }\n\n  // 15. Return a new data: URL struct whose MIME\n  // type is mimeTypeRecord and body is body.\n  // https://fetch.spec.whatwg.org/#data-url-struct\n  return { mimeType: mimeTypeRecord, body }\n}\n\n// https://url.spec.whatwg.org/#concept-url-serializer\n/**\n * @param {URL} url\n * @param {boolean} excludeFragment\n */\nfunction URLSerializer (url, excludeFragment = false) {\n  if (!excludeFragment) {\n    return url.href\n  }\n\n  const href = url.href\n  const hashLength = url.hash.length\n\n  return hashLength === 0 ? href : href.substring(0, href.length - hashLength)\n}\n\n// https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points\n/**\n * @param {(char: string) => boolean} condition\n * @param {string} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfCodePoints (condition, input, position) {\n  // 1. Let result be the empty string.\n  let result = ''\n\n  // 2. While position doesn’t point past the end of input and the\n  // code point at position within input meets the condition condition:\n  while (position.position < input.length && condition(input[position.position])) {\n    // 1. Append that code point to the end of result.\n    result += input[position.position]\n\n    // 2. Advance position by 1.\n    position.position++\n  }\n\n  // 3. Return result.\n  return result\n}\n\n/**\n * A faster collectASequenceOfCodePoints that only works when comparing a single character.\n * @param {string} char\n * @param {string} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfCodePointsFast (char, input, position) {\n  const idx = input.indexOf(char, position.position)\n  const start = position.position\n\n  if (idx === -1) {\n    position.position = input.length\n    return input.slice(start)\n  }\n\n  position.position = idx\n  return input.slice(start, position.position)\n}\n\n// https://url.spec.whatwg.org/#string-percent-decode\n/** @param {string} input */\nfunction stringPercentDecode (input) {\n  // 1. Let bytes be the UTF-8 encoding of input.\n  const bytes = encoder.encode(input)\n\n  // 2. Return the percent-decoding of bytes.\n  return percentDecode(bytes)\n}\n\n// https://url.spec.whatwg.org/#percent-decode\n/** @param {Uint8Array} input */\nfunction percentDecode (input) {\n  // 1. Let output be an empty byte sequence.\n  /** @type {number[]} */\n  const output = []\n\n  // 2. For each byte byte in input:\n  for (let i = 0; i < input.length; i++) {\n    const byte = input[i]\n\n    // 1. If byte is not 0x25 (%), then append byte to output.\n    if (byte !== 0x25) {\n      output.push(byte)\n\n    // 2. Otherwise, if byte is 0x25 (%) and the next two bytes\n    // after byte in input are not in the ranges\n    // 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F),\n    // and 0x61 (a) to 0x66 (f), all inclusive, append byte\n    // to output.\n    } else if (\n      byte === 0x25 &&\n      !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))\n    ) {\n      output.push(0x25)\n\n    // 3. Otherwise:\n    } else {\n      // 1. Let bytePoint be the two bytes after byte in input,\n      // decoded, and then interpreted as hexadecimal number.\n      const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2])\n      const bytePoint = Number.parseInt(nextTwoBytes, 16)\n\n      // 2. Append a byte whose value is bytePoint to output.\n      output.push(bytePoint)\n\n      // 3. Skip the next two bytes in input.\n      i += 2\n    }\n  }\n\n  // 3. Return output.\n  return Uint8Array.from(output)\n}\n\n// https://mimesniff.spec.whatwg.org/#parse-a-mime-type\n/** @param {string} input */\nfunction parseMIMEType (input) {\n  // 1. Remove any leading and trailing HTTP whitespace\n  // from input.\n  input = removeHTTPWhitespace(input, true, true)\n\n  // 2. Let position be a position variable for input,\n  // initially pointing at the start of input.\n  const position = { position: 0 }\n\n  // 3. Let type be the result of collecting a sequence\n  // of code points that are not U+002F (/) from\n  // input, given position.\n  const type = collectASequenceOfCodePointsFast(\n    '/',\n    input,\n    position\n  )\n\n  // 4. If type is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  // https://mimesniff.spec.whatwg.org/#http-token-code-point\n  if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {\n    return 'failure'\n  }\n\n  // 5. If position is past the end of input, then return\n  // failure\n  if (position.position > input.length) {\n    return 'failure'\n  }\n\n  // 6. Advance position by 1. (This skips past U+002F (/).)\n  position.position++\n\n  // 7. Let subtype be the result of collecting a sequence of\n  // code points that are not U+003B (;) from input, given\n  // position.\n  let subtype = collectASequenceOfCodePointsFast(\n    ';',\n    input,\n    position\n  )\n\n  // 8. Remove any trailing HTTP whitespace from subtype.\n  subtype = removeHTTPWhitespace(subtype, false, true)\n\n  // 9. If subtype is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {\n    return 'failure'\n  }\n\n  const typeLowercase = type.toLowerCase()\n  const subtypeLowercase = subtype.toLowerCase()\n\n  // 10. Let mimeType be a new MIME type record whose type\n  // is type, in ASCII lowercase, and subtype is subtype,\n  // in ASCII lowercase.\n  // https://mimesniff.spec.whatwg.org/#mime-type\n  const mimeType = {\n    type: typeLowercase,\n    subtype: subtypeLowercase,\n    /** @type {Map<string, string>} */\n    parameters: new Map(),\n    // https://mimesniff.spec.whatwg.org/#mime-type-essence\n    essence: `${typeLowercase}/${subtypeLowercase}`\n  }\n\n  // 11. While position is not past the end of input:\n  while (position.position < input.length) {\n    // 1. Advance position by 1. (This skips past U+003B (;).)\n    position.position++\n\n    // 2. Collect a sequence of code points that are HTTP\n    // whitespace from input given position.\n    collectASequenceOfCodePoints(\n      // https://fetch.spec.whatwg.org/#http-whitespace\n      char => HTTP_WHITESPACE_REGEX.test(char),\n      input,\n      position\n    )\n\n    // 3. Let parameterName be the result of collecting a\n    // sequence of code points that are not U+003B (;)\n    // or U+003D (=) from input, given position.\n    let parameterName = collectASequenceOfCodePoints(\n      (char) => char !== ';' && char !== '=',\n      input,\n      position\n    )\n\n    // 4. Set parameterName to parameterName, in ASCII\n    // lowercase.\n    parameterName = parameterName.toLowerCase()\n\n    // 5. If position is not past the end of input, then:\n    if (position.position < input.length) {\n      // 1. If the code point at position within input is\n      // U+003B (;), then continue.\n      if (input[position.position] === ';') {\n        continue\n      }\n\n      // 2. Advance position by 1. (This skips past U+003D (=).)\n      position.position++\n    }\n\n    // 6. If position is past the end of input, then break.\n    if (position.position > input.length) {\n      break\n    }\n\n    // 7. Let parameterValue be null.\n    let parameterValue = null\n\n    // 8. If the code point at position within input is\n    // U+0022 (\"), then:\n    if (input[position.position] === '\"') {\n      // 1. Set parameterValue to the result of collecting\n      // an HTTP quoted string from input, given position\n      // and the extract-value flag.\n      parameterValue = collectAnHTTPQuotedString(input, position, true)\n\n      // 2. Collect a sequence of code points that are not\n      // U+003B (;) from input, given position.\n      collectASequenceOfCodePointsFast(\n        ';',\n        input,\n        position\n      )\n\n    // 9. Otherwise:\n    } else {\n      // 1. Set parameterValue to the result of collecting\n      // a sequence of code points that are not U+003B (;)\n      // from input, given position.\n      parameterValue = collectASequenceOfCodePointsFast(\n        ';',\n        input,\n        position\n      )\n\n      // 2. Remove any trailing HTTP whitespace from parameterValue.\n      parameterValue = removeHTTPWhitespace(parameterValue, false, true)\n\n      // 3. If parameterValue is the empty string, then continue.\n      if (parameterValue.length === 0) {\n        continue\n      }\n    }\n\n    // 10. If all of the following are true\n    // - parameterName is not the empty string\n    // - parameterName solely contains HTTP token code points\n    // - parameterValue solely contains HTTP quoted-string token code points\n    // - mimeType’s parameters[parameterName] does not exist\n    // then set mimeType’s parameters[parameterName] to parameterValue.\n    if (\n      parameterName.length !== 0 &&\n      HTTP_TOKEN_CODEPOINTS.test(parameterName) &&\n      (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) &&\n      !mimeType.parameters.has(parameterName)\n    ) {\n      mimeType.parameters.set(parameterName, parameterValue)\n    }\n  }\n\n  // 12. Return mimeType.\n  return mimeType\n}\n\n// https://infra.spec.whatwg.org/#forgiving-base64-decode\n/** @param {string} data */\nfunction forgivingBase64 (data) {\n  // 1. Remove all ASCII whitespace from data.\n  data = data.replace(/[\\u0009\\u000A\\u000C\\u000D\\u0020]/g, '')  // eslint-disable-line\n\n  // 2. If data’s code point length divides by 4 leaving\n  // no remainder, then:\n  if (data.length % 4 === 0) {\n    // 1. If data ends with one or two U+003D (=) code points,\n    // then remove them from data.\n    data = data.replace(/=?=$/, '')\n  }\n\n  // 3. If data’s code point length divides by 4 leaving\n  // a remainder of 1, then return failure.\n  if (data.length % 4 === 1) {\n    return 'failure'\n  }\n\n  // 4. If data contains a code point that is not one of\n  //  U+002B (+)\n  //  U+002F (/)\n  //  ASCII alphanumeric\n  // then return failure.\n  if (/[^+/0-9A-Za-z]/.test(data)) {\n    return 'failure'\n  }\n\n  const binary = atob(data)\n  const bytes = new Uint8Array(binary.length)\n\n  for (let byte = 0; byte < binary.length; byte++) {\n    bytes[byte] = binary.charCodeAt(byte)\n  }\n\n  return bytes\n}\n\n// https://fetch.spec.whatwg.org/#collect-an-http-quoted-string\n// tests: https://fetch.spec.whatwg.org/#example-http-quoted-string\n/**\n * @param {string} input\n * @param {{ position: number }} position\n * @param {boolean?} extractValue\n */\nfunction collectAnHTTPQuotedString (input, position, extractValue) {\n  // 1. Let positionStart be position.\n  const positionStart = position.position\n\n  // 2. Let value be the empty string.\n  let value = ''\n\n  // 3. Assert: the code point at position within input\n  // is U+0022 (\").\n  assert(input[position.position] === '\"')\n\n  // 4. Advance position by 1.\n  position.position++\n\n  // 5. While true:\n  while (true) {\n    // 1. Append the result of collecting a sequence of code points\n    // that are not U+0022 (\") or U+005C (\\) from input, given\n    // position, to value.\n    value += collectASequenceOfCodePoints(\n      (char) => char !== '\"' && char !== '\\\\',\n      input,\n      position\n    )\n\n    // 2. If position is past the end of input, then break.\n    if (position.position >= input.length) {\n      break\n    }\n\n    // 3. Let quoteOrBackslash be the code point at position within\n    // input.\n    const quoteOrBackslash = input[position.position]\n\n    // 4. Advance position by 1.\n    position.position++\n\n    // 5. If quoteOrBackslash is U+005C (\\), then:\n    if (quoteOrBackslash === '\\\\') {\n      // 1. If position is past the end of input, then append\n      // U+005C (\\) to value and break.\n      if (position.position >= input.length) {\n        value += '\\\\'\n        break\n      }\n\n      // 2. Append the code point at position within input to value.\n      value += input[position.position]\n\n      // 3. Advance position by 1.\n      position.position++\n\n    // 6. Otherwise:\n    } else {\n      // 1. Assert: quoteOrBackslash is U+0022 (\").\n      assert(quoteOrBackslash === '\"')\n\n      // 2. Break.\n      break\n    }\n  }\n\n  // 6. If the extract-value flag is set, then return value.\n  if (extractValue) {\n    return value\n  }\n\n  // 7. Return the code points from positionStart to position,\n  // inclusive, within input.\n  return input.slice(positionStart, position.position)\n}\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type\n */\nfunction serializeAMimeType (mimeType) {\n  assert(mimeType !== 'failure')\n  const { parameters, essence } = mimeType\n\n  // 1. Let serialization be the concatenation of mimeType’s\n  //    type, U+002F (/), and mimeType’s subtype.\n  let serialization = essence\n\n  // 2. For each name → value of mimeType’s parameters:\n  for (let [name, value] of parameters.entries()) {\n    // 1. Append U+003B (;) to serialization.\n    serialization += ';'\n\n    // 2. Append name to serialization.\n    serialization += name\n\n    // 3. Append U+003D (=) to serialization.\n    serialization += '='\n\n    // 4. If value does not solely contain HTTP token code\n    //    points or value is the empty string, then:\n    if (!HTTP_TOKEN_CODEPOINTS.test(value)) {\n      // 1. Precede each occurence of U+0022 (\") or\n      //    U+005C (\\) in value with U+005C (\\).\n      value = value.replace(/(\\\\|\")/g, '\\\\$1')\n\n      // 2. Prepend U+0022 (\") to value.\n      value = '\"' + value\n\n      // 3. Append U+0022 (\") to value.\n      value += '\"'\n    }\n\n    // 5. Append value to serialization.\n    serialization += value\n  }\n\n  // 3. Return serialization.\n  return serialization\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {string} char\n */\nfunction isHTTPWhiteSpace (char) {\n  return char === '\\r' || char === '\\n' || char === '\\t' || char === ' '\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {string} str\n */\nfunction removeHTTPWhitespace (str, leading = true, trailing = true) {\n  let lead = 0\n  let trail = str.length - 1\n\n  if (leading) {\n    for (; lead < str.length && isHTTPWhiteSpace(str[lead]); lead++);\n  }\n\n  if (trailing) {\n    for (; trail > 0 && isHTTPWhiteSpace(str[trail]); trail--);\n  }\n\n  return str.slice(lead, trail + 1)\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#ascii-whitespace\n * @param {string} char\n */\nfunction isASCIIWhitespace (char) {\n  return char === '\\r' || char === '\\n' || char === '\\t' || char === '\\f' || char === ' '\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace\n */\nfunction removeASCIIWhitespace (str, leading = true, trailing = true) {\n  let lead = 0\n  let trail = str.length - 1\n\n  if (leading) {\n    for (; lead < str.length && isASCIIWhitespace(str[lead]); lead++);\n  }\n\n  if (trailing) {\n    for (; trail > 0 && isASCIIWhitespace(str[trail]); trail--);\n  }\n\n  return str.slice(lead, trail + 1)\n}\n\nmodule.exports = {\n  dataURLProcessor,\n  URLSerializer,\n  collectASequenceOfCodePoints,\n  collectASequenceOfCodePointsFast,\n  stringPercentDecode,\n  parseMIMEType,\n  collectAnHTTPQuotedString,\n  serializeAMimeType\n}\n"],"mappings":"AAAA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAM;EAAEC;AAAK,CAAC,GAAGD,OAAO,CAAC,QAAQ,CAAC;AAClC,MAAM;EAAEE;AAAiB,CAAC,GAAGF,OAAO,CAAC,QAAQ,CAAC;AAE9C,MAAMG,OAAO,GAAG,IAAIC,WAAW,CAAC,CAAC;;AAEjC;AACA;AACA;AACA,MAAMC,qBAAqB,GAAG,8BAA8B;AAC5D,MAAMC,qBAAqB,GAAG,+BAA+B,EAAC;AAC9D;AACA;AACA;AACA,MAAMC,yBAAyB,GAAG,sCAAsC,EAAC;;AAEzE;AACA;AACA,SAASC,gBAAgBA,CAAEC,OAAO,EAAE;EAClC;EACAV,MAAM,CAACU,OAAO,CAACC,QAAQ,KAAK,OAAO,CAAC;;EAEpC;EACA;EACA;EACA,IAAIC,KAAK,GAAGC,aAAa,CAACH,OAAO,EAAE,IAAI,CAAC;;EAExC;EACAE,KAAK,GAAGA,KAAK,CAACE,KAAK,CAAC,CAAC,CAAC;;EAEtB;EACA,MAAMC,QAAQ,GAAG;IAAEA,QAAQ,EAAE;EAAE,CAAC;;EAEhC;EACA;EACA;EACA,IAAIC,QAAQ,GAAGC,gCAAgC,CAC7C,GAAG,EACHL,KAAK,EACLG,QACF,CAAC;;EAED;EACA;EACA;EACA;EACA;EACA;EACA,MAAMG,cAAc,GAAGF,QAAQ,CAACG,MAAM;EACtCH,QAAQ,GAAGI,qBAAqB,CAACJ,QAAQ,EAAE,IAAI,EAAE,IAAI,CAAC;;EAEtD;EACA;EACA,IAAID,QAAQ,CAACA,QAAQ,IAAIH,KAAK,CAACO,MAAM,EAAE;IACrC,OAAO,SAAS;EAClB;;EAEA;EACAJ,QAAQ,CAACA,QAAQ,EAAE;;EAEnB;EACA,MAAMM,WAAW,GAAGT,KAAK,CAACE,KAAK,CAACI,cAAc,GAAG,CAAC,CAAC;;EAEnD;EACA,IAAII,IAAI,GAAGC,mBAAmB,CAACF,WAAW,CAAC;;EAE3C;EACA;EACA;EACA,IAAI,uBAAuB,CAACG,IAAI,CAACR,QAAQ,CAAC,EAAE;IAC1C;IACA,MAAMS,UAAU,GAAGtB,gBAAgB,CAACmB,IAAI,CAAC;;IAEzC;IACA;IACAA,IAAI,GAAGI,eAAe,CAACD,UAAU,CAAC;;IAElC;IACA,IAAIH,IAAI,KAAK,SAAS,EAAE;MACtB,OAAO,SAAS;IAClB;;IAEA;IACAN,QAAQ,GAAGA,QAAQ,CAACF,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;;IAEhC;IACA;IACAE,QAAQ,GAAGA,QAAQ,CAACW,OAAO,CAAC,YAAY,EAAE,EAAE,CAAC;;IAE7C;IACAX,QAAQ,GAAGA,QAAQ,CAACF,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EAClC;;EAEA;EACA;EACA,IAAIE,QAAQ,CAACY,UAAU,CAAC,GAAG,CAAC,EAAE;IAC5BZ,QAAQ,GAAG,YAAY,GAAGA,QAAQ;EACpC;;EAEA;EACA;EACA,IAAIa,cAAc,GAAGC,aAAa,CAACd,QAAQ,CAAC;;EAE5C;EACA;EACA,IAAIa,cAAc,KAAK,SAAS,EAAE;IAChCA,cAAc,GAAGC,aAAa,CAAC,6BAA6B,CAAC;EAC/D;;EAEA;EACA;EACA;EACA,OAAO;IAAEd,QAAQ,EAAEa,cAAc;IAAEP;EAAK,CAAC;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAST,aAAaA,CAAEkB,GAAG,EAAEC,eAAe,GAAG,KAAK,EAAE;EACpD,IAAI,CAACA,eAAe,EAAE;IACpB,OAAOD,GAAG,CAACE,IAAI;EACjB;EAEA,MAAMA,IAAI,GAAGF,GAAG,CAACE,IAAI;EACrB,MAAMC,UAAU,GAAGH,GAAG,CAACI,IAAI,CAAChB,MAAM;EAElC,OAAOe,UAAU,KAAK,CAAC,GAAGD,IAAI,GAAGA,IAAI,CAACG,SAAS,CAAC,CAAC,EAAEH,IAAI,CAACd,MAAM,GAAGe,UAAU,CAAC;AAC9E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASG,4BAA4BA,CAAEC,SAAS,EAAE1B,KAAK,EAAEG,QAAQ,EAAE;EACjE;EACA,IAAIwB,MAAM,GAAG,EAAE;;EAEf;EACA;EACA,OAAOxB,QAAQ,CAACA,QAAQ,GAAGH,KAAK,CAACO,MAAM,IAAImB,SAAS,CAAC1B,KAAK,CAACG,QAAQ,CAACA,QAAQ,CAAC,CAAC,EAAE;IAC9E;IACAwB,MAAM,IAAI3B,KAAK,CAACG,QAAQ,CAACA,QAAQ,CAAC;;IAElC;IACAA,QAAQ,CAACA,QAAQ,EAAE;EACrB;;EAEA;EACA,OAAOwB,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAStB,gCAAgCA,CAAEuB,IAAI,EAAE5B,KAAK,EAAEG,QAAQ,EAAE;EAChE,MAAM0B,GAAG,GAAG7B,KAAK,CAAC8B,OAAO,CAACF,IAAI,EAAEzB,QAAQ,CAACA,QAAQ,CAAC;EAClD,MAAM4B,KAAK,GAAG5B,QAAQ,CAACA,QAAQ;EAE/B,IAAI0B,GAAG,KAAK,CAAC,CAAC,EAAE;IACd1B,QAAQ,CAACA,QAAQ,GAAGH,KAAK,CAACO,MAAM;IAChC,OAAOP,KAAK,CAACE,KAAK,CAAC6B,KAAK,CAAC;EAC3B;EAEA5B,QAAQ,CAACA,QAAQ,GAAG0B,GAAG;EACvB,OAAO7B,KAAK,CAACE,KAAK,CAAC6B,KAAK,EAAE5B,QAAQ,CAACA,QAAQ,CAAC;AAC9C;;AAEA;AACA;AACA,SAASQ,mBAAmBA,CAAEX,KAAK,EAAE;EACnC;EACA,MAAMgC,KAAK,GAAGxC,OAAO,CAACyC,MAAM,CAACjC,KAAK,CAAC;;EAEnC;EACA,OAAOkC,aAAa,CAACF,KAAK,CAAC;AAC7B;;AAEA;AACA;AACA,SAASE,aAAaA,CAAElC,KAAK,EAAE;EAC7B;EACA;EACA,MAAMmC,MAAM,GAAG,EAAE;;EAEjB;EACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpC,KAAK,CAACO,MAAM,EAAE6B,CAAC,EAAE,EAAE;IACrC,MAAMC,IAAI,GAAGrC,KAAK,CAACoC,CAAC,CAAC;;IAErB;IACA,IAAIC,IAAI,KAAK,IAAI,EAAE;MACjBF,MAAM,CAACG,IAAI,CAACD,IAAI,CAAC;;MAEnB;MACA;MACA;MACA;MACA;IACA,CAAC,MAAM,IACLA,IAAI,KAAK,IAAI,IACb,CAAC,mBAAmB,CAACzB,IAAI,CAAC2B,MAAM,CAACC,YAAY,CAACxC,KAAK,CAACoC,CAAC,GAAG,CAAC,CAAC,EAAEpC,KAAK,CAACoC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAC1E;MACAD,MAAM,CAACG,IAAI,CAAC,IAAI,CAAC;;MAEnB;IACA,CAAC,MAAM;MACL;MACA;MACA,MAAMG,YAAY,GAAGF,MAAM,CAACC,YAAY,CAACxC,KAAK,CAACoC,CAAC,GAAG,CAAC,CAAC,EAAEpC,KAAK,CAACoC,CAAC,GAAG,CAAC,CAAC,CAAC;MACpE,MAAMM,SAAS,GAAGC,MAAM,CAACC,QAAQ,CAACH,YAAY,EAAE,EAAE,CAAC;;MAEnD;MACAN,MAAM,CAACG,IAAI,CAACI,SAAS,CAAC;;MAEtB;MACAN,CAAC,IAAI,CAAC;IACR;EACF;;EAEA;EACA,OAAOS,UAAU,CAACC,IAAI,CAACX,MAAM,CAAC;AAChC;;AAEA;AACA;AACA,SAASjB,aAAaA,CAAElB,KAAK,EAAE;EAC7B;EACA;EACAA,KAAK,GAAG+C,oBAAoB,CAAC/C,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC;;EAE/C;EACA;EACA,MAAMG,QAAQ,GAAG;IAAEA,QAAQ,EAAE;EAAE,CAAC;;EAEhC;EACA;EACA;EACA,MAAM6C,IAAI,GAAG3C,gCAAgC,CAC3C,GAAG,EACHL,KAAK,EACLG,QACF,CAAC;;EAED;EACA;EACA;EACA,IAAI6C,IAAI,CAACzC,MAAM,KAAK,CAAC,IAAI,CAACb,qBAAqB,CAACkB,IAAI,CAACoC,IAAI,CAAC,EAAE;IAC1D,OAAO,SAAS;EAClB;;EAEA;EACA;EACA,IAAI7C,QAAQ,CAACA,QAAQ,GAAGH,KAAK,CAACO,MAAM,EAAE;IACpC,OAAO,SAAS;EAClB;;EAEA;EACAJ,QAAQ,CAACA,QAAQ,EAAE;;EAEnB;EACA;EACA;EACA,IAAI8C,OAAO,GAAG5C,gCAAgC,CAC5C,GAAG,EACHL,KAAK,EACLG,QACF,CAAC;;EAED;EACA8C,OAAO,GAAGF,oBAAoB,CAACE,OAAO,EAAE,KAAK,EAAE,IAAI,CAAC;;EAEpD;EACA;EACA,IAAIA,OAAO,CAAC1C,MAAM,KAAK,CAAC,IAAI,CAACb,qBAAqB,CAACkB,IAAI,CAACqC,OAAO,CAAC,EAAE;IAChE,OAAO,SAAS;EAClB;EAEA,MAAMC,aAAa,GAAGF,IAAI,CAACG,WAAW,CAAC,CAAC;EACxC,MAAMC,gBAAgB,GAAGH,OAAO,CAACE,WAAW,CAAC,CAAC;;EAE9C;EACA;EACA;EACA;EACA,MAAM/C,QAAQ,GAAG;IACf4C,IAAI,EAAEE,aAAa;IACnBD,OAAO,EAAEG,gBAAgB;IACzB;IACAC,UAAU,EAAE,IAAIC,GAAG,CAAC,CAAC;IACrB;IACAC,OAAO,EAAG,GAAEL,aAAc,IAAGE,gBAAiB;EAChD,CAAC;;EAED;EACA,OAAOjD,QAAQ,CAACA,QAAQ,GAAGH,KAAK,CAACO,MAAM,EAAE;IACvC;IACAJ,QAAQ,CAACA,QAAQ,EAAE;;IAEnB;IACA;IACAsB,4BAA4B;IAC1B;IACAG,IAAI,IAAIjC,qBAAqB,CAACiB,IAAI,CAACgB,IAAI,CAAC,EACxC5B,KAAK,EACLG,QACF,CAAC;;IAED;IACA;IACA;IACA,IAAIqD,aAAa,GAAG/B,4BAA4B,CAC7CG,IAAI,IAAKA,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,GAAG,EACtC5B,KAAK,EACLG,QACF,CAAC;;IAED;IACA;IACAqD,aAAa,GAAGA,aAAa,CAACL,WAAW,CAAC,CAAC;;IAE3C;IACA,IAAIhD,QAAQ,CAACA,QAAQ,GAAGH,KAAK,CAACO,MAAM,EAAE;MACpC;MACA;MACA,IAAIP,KAAK,CAACG,QAAQ,CAACA,QAAQ,CAAC,KAAK,GAAG,EAAE;QACpC;MACF;;MAEA;MACAA,QAAQ,CAACA,QAAQ,EAAE;IACrB;;IAEA;IACA,IAAIA,QAAQ,CAACA,QAAQ,GAAGH,KAAK,CAACO,MAAM,EAAE;MACpC;IACF;;IAEA;IACA,IAAIkD,cAAc,GAAG,IAAI;;IAEzB;IACA;IACA,IAAIzD,KAAK,CAACG,QAAQ,CAACA,QAAQ,CAAC,KAAK,GAAG,EAAE;MACpC;MACA;MACA;MACAsD,cAAc,GAAGC,yBAAyB,CAAC1D,KAAK,EAAEG,QAAQ,EAAE,IAAI,CAAC;;MAEjE;MACA;MACAE,gCAAgC,CAC9B,GAAG,EACHL,KAAK,EACLG,QACF,CAAC;;MAEH;IACA,CAAC,MAAM;MACL;MACA;MACA;MACAsD,cAAc,GAAGpD,gCAAgC,CAC/C,GAAG,EACHL,KAAK,EACLG,QACF,CAAC;;MAED;MACAsD,cAAc,GAAGV,oBAAoB,CAACU,cAAc,EAAE,KAAK,EAAE,IAAI,CAAC;;MAElE;MACA,IAAIA,cAAc,CAAClD,MAAM,KAAK,CAAC,EAAE;QAC/B;MACF;IACF;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA,IACEiD,aAAa,CAACjD,MAAM,KAAK,CAAC,IAC1Bb,qBAAqB,CAACkB,IAAI,CAAC4C,aAAa,CAAC,KACxCC,cAAc,CAAClD,MAAM,KAAK,CAAC,IAAIX,yBAAyB,CAACgB,IAAI,CAAC6C,cAAc,CAAC,CAAC,IAC/E,CAACrD,QAAQ,CAACiD,UAAU,CAACM,GAAG,CAACH,aAAa,CAAC,EACvC;MACApD,QAAQ,CAACiD,UAAU,CAACO,GAAG,CAACJ,aAAa,EAAEC,cAAc,CAAC;IACxD;EACF;;EAEA;EACA,OAAOrD,QAAQ;AACjB;;AAEA;AACA;AACA,SAASU,eAAeA,CAAE+C,IAAI,EAAE;EAC9B;EACAA,IAAI,GAAGA,IAAI,CAAC9C,OAAO,CAAC,mCAAmC,EAAE,EAAE,CAAC,EAAE;;EAE9D;EACA;EACA,IAAI8C,IAAI,CAACtD,MAAM,GAAG,CAAC,KAAK,CAAC,EAAE;IACzB;IACA;IACAsD,IAAI,GAAGA,IAAI,CAAC9C,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC;EACjC;;EAEA;EACA;EACA,IAAI8C,IAAI,CAACtD,MAAM,GAAG,CAAC,KAAK,CAAC,EAAE;IACzB,OAAO,SAAS;EAClB;;EAEA;EACA;EACA;EACA;EACA;EACA,IAAI,gBAAgB,CAACK,IAAI,CAACiD,IAAI,CAAC,EAAE;IAC/B,OAAO,SAAS;EAClB;EAEA,MAAMC,MAAM,GAAGxE,IAAI,CAACuE,IAAI,CAAC;EACzB,MAAM7B,KAAK,GAAG,IAAIa,UAAU,CAACiB,MAAM,CAACvD,MAAM,CAAC;EAE3C,KAAK,IAAI8B,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGyB,MAAM,CAACvD,MAAM,EAAE8B,IAAI,EAAE,EAAE;IAC/CL,KAAK,CAACK,IAAI,CAAC,GAAGyB,MAAM,CAACC,UAAU,CAAC1B,IAAI,CAAC;EACvC;EAEA,OAAOL,KAAK;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS0B,yBAAyBA,CAAE1D,KAAK,EAAEG,QAAQ,EAAE6D,YAAY,EAAE;EACjE;EACA,MAAMC,aAAa,GAAG9D,QAAQ,CAACA,QAAQ;;EAEvC;EACA,IAAI+D,KAAK,GAAG,EAAE;;EAEd;EACA;EACA9E,MAAM,CAACY,KAAK,CAACG,QAAQ,CAACA,QAAQ,CAAC,KAAK,GAAG,CAAC;;EAExC;EACAA,QAAQ,CAACA,QAAQ,EAAE;;EAEnB;EACA,OAAO,IAAI,EAAE;IACX;IACA;IACA;IACA+D,KAAK,IAAIzC,4BAA4B,CAClCG,IAAI,IAAKA,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,IAAI,EACvC5B,KAAK,EACLG,QACF,CAAC;;IAED;IACA,IAAIA,QAAQ,CAACA,QAAQ,IAAIH,KAAK,CAACO,MAAM,EAAE;MACrC;IACF;;IAEA;IACA;IACA,MAAM4D,gBAAgB,GAAGnE,KAAK,CAACG,QAAQ,CAACA,QAAQ,CAAC;;IAEjD;IACAA,QAAQ,CAACA,QAAQ,EAAE;;IAEnB;IACA,IAAIgE,gBAAgB,KAAK,IAAI,EAAE;MAC7B;MACA;MACA,IAAIhE,QAAQ,CAACA,QAAQ,IAAIH,KAAK,CAACO,MAAM,EAAE;QACrC2D,KAAK,IAAI,IAAI;QACb;MACF;;MAEA;MACAA,KAAK,IAAIlE,KAAK,CAACG,QAAQ,CAACA,QAAQ,CAAC;;MAEjC;MACAA,QAAQ,CAACA,QAAQ,EAAE;;MAErB;IACA,CAAC,MAAM;MACL;MACAf,MAAM,CAAC+E,gBAAgB,KAAK,GAAG,CAAC;;MAEhC;MACA;IACF;EACF;;EAEA;EACA,IAAIH,YAAY,EAAE;IAChB,OAAOE,KAAK;EACd;;EAEA;EACA;EACA,OAAOlE,KAAK,CAACE,KAAK,CAAC+D,aAAa,EAAE9D,QAAQ,CAACA,QAAQ,CAAC;AACtD;;AAEA;AACA;AACA;AACA,SAASiE,kBAAkBA,CAAEhE,QAAQ,EAAE;EACrChB,MAAM,CAACgB,QAAQ,KAAK,SAAS,CAAC;EAC9B,MAAM;IAAEiD,UAAU;IAAEE;EAAQ,CAAC,GAAGnD,QAAQ;;EAExC;EACA;EACA,IAAIiE,aAAa,GAAGd,OAAO;;EAE3B;EACA,KAAK,IAAI,CAACe,IAAI,EAAEJ,KAAK,CAAC,IAAIb,UAAU,CAACkB,OAAO,CAAC,CAAC,EAAE;IAC9C;IACAF,aAAa,IAAI,GAAG;;IAEpB;IACAA,aAAa,IAAIC,IAAI;;IAErB;IACAD,aAAa,IAAI,GAAG;;IAEpB;IACA;IACA,IAAI,CAAC3E,qBAAqB,CAACkB,IAAI,CAACsD,KAAK,CAAC,EAAE;MACtC;MACA;MACAA,KAAK,GAAGA,KAAK,CAACnD,OAAO,CAAC,SAAS,EAAE,MAAM,CAAC;;MAExC;MACAmD,KAAK,GAAG,GAAG,GAAGA,KAAK;;MAEnB;MACAA,KAAK,IAAI,GAAG;IACd;;IAEA;IACAG,aAAa,IAAIH,KAAK;EACxB;;EAEA;EACA,OAAOG,aAAa;AACtB;;AAEA;AACA;AACA;AACA;AACA,SAASG,gBAAgBA,CAAE5C,IAAI,EAAE;EAC/B,OAAOA,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,GAAG;AACxE;;AAEA;AACA;AACA;AACA;AACA,SAASmB,oBAAoBA,CAAE0B,GAAG,EAAEC,OAAO,GAAG,IAAI,EAAEC,QAAQ,GAAG,IAAI,EAAE;EACnE,IAAIC,IAAI,GAAG,CAAC;EACZ,IAAIC,KAAK,GAAGJ,GAAG,CAAClE,MAAM,GAAG,CAAC;EAE1B,IAAImE,OAAO,EAAE;IACX,OAAOE,IAAI,GAAGH,GAAG,CAAClE,MAAM,IAAIiE,gBAAgB,CAACC,GAAG,CAACG,IAAI,CAAC,CAAC,EAAEA,IAAI,EAAE,CAAC;EAClE;EAEA,IAAID,QAAQ,EAAE;IACZ,OAAOE,KAAK,GAAG,CAAC,IAAIL,gBAAgB,CAACC,GAAG,CAACI,KAAK,CAAC,CAAC,EAAEA,KAAK,EAAE,CAAC;EAC5D;EAEA,OAAOJ,GAAG,CAACvE,KAAK,CAAC0E,IAAI,EAAEC,KAAK,GAAG,CAAC,CAAC;AACnC;;AAEA;AACA;AACA;AACA;AACA,SAASC,iBAAiBA,CAAElD,IAAI,EAAE;EAChC,OAAOA,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,GAAG;AACzF;;AAEA;AACA;AACA;AACA,SAASpB,qBAAqBA,CAAEiE,GAAG,EAAEC,OAAO,GAAG,IAAI,EAAEC,QAAQ,GAAG,IAAI,EAAE;EACpE,IAAIC,IAAI,GAAG,CAAC;EACZ,IAAIC,KAAK,GAAGJ,GAAG,CAAClE,MAAM,GAAG,CAAC;EAE1B,IAAImE,OAAO,EAAE;IACX,OAAOE,IAAI,GAAGH,GAAG,CAAClE,MAAM,IAAIuE,iBAAiB,CAACL,GAAG,CAACG,IAAI,CAAC,CAAC,EAAEA,IAAI,EAAE,CAAC;EACnE;EAEA,IAAID,QAAQ,EAAE;IACZ,OAAOE,KAAK,GAAG,CAAC,IAAIC,iBAAiB,CAACL,GAAG,CAACI,KAAK,CAAC,CAAC,EAAEA,KAAK,EAAE,CAAC;EAC7D;EAEA,OAAOJ,GAAG,CAACvE,KAAK,CAAC0E,IAAI,EAAEC,KAAK,GAAG,CAAC,CAAC;AACnC;AAEAE,MAAM,CAACC,OAAO,GAAG;EACfnF,gBAAgB;EAChBI,aAAa;EACbwB,4BAA4B;EAC5BpB,gCAAgC;EAChCM,mBAAmB;EACnBO,aAAa;EACbwC,yBAAyB;EACzBU;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}