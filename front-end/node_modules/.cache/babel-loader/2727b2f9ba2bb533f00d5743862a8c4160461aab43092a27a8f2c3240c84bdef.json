{"ast":null,"code":"import { __assign, __awaiter, __generator } from \"tslib\";\nimport { API, eventToSentryRequest } from '@sentry/core';\nimport { Status } from '@sentry/types';\nimport { logger, parseRetryAfterHeader, PromiseBuffer, SentryError } from '@sentry/utils';\nimport * as fs from 'fs';\nimport * as url from 'url';\nimport { SDK_NAME, SDK_VERSION } from '../version';\n/** Base Transport class implementation */\nvar BaseTransport = /** @class */function () {\n  /** Create instance and set this.dsn */\n  function BaseTransport(options) {\n    this.options = options;\n    /** A simple buffer holding all requests. */\n    this._buffer = new PromiseBuffer(30);\n    /** Locks transport after receiving 429 response */\n    this._disabledUntil = new Date(Date.now());\n    this._api = new API(options.dsn);\n  }\n  /**\n   * @inheritDoc\n   */\n  BaseTransport.prototype.sendEvent = function (_) {\n    throw new SentryError('Transport Class has to implement `sendEvent` method.');\n  };\n  /**\n   * @inheritDoc\n   */\n  BaseTransport.prototype.close = function (timeout) {\n    return this._buffer.drain(timeout);\n  };\n  /** Returns a build request option object used by request */\n  BaseTransport.prototype._getRequestOptions = function (uri) {\n    var headers = __assign(__assign({}, this._api.getRequestHeaders(SDK_NAME, SDK_VERSION)), this.options.headers);\n    var hostname = uri.hostname,\n      pathname = uri.pathname,\n      port = uri.port,\n      protocol = uri.protocol;\n    // See https://github.com/nodejs/node/blob/38146e717fed2fabe3aacb6540d839475e0ce1c6/lib/internal/url.js#L1268-L1290\n    // We ignore the query string on purpose\n    var path = \"\" + pathname;\n    return __assign({\n      agent: this.client,\n      headers: headers,\n      hostname: hostname,\n      method: 'POST',\n      path: path,\n      port: port,\n      protocol: protocol\n    }, this.options.caCerts && {\n      ca: fs.readFileSync(this.options.caCerts)\n    });\n  };\n  /** JSDoc */\n  BaseTransport.prototype._sendWithModule = function (httpModule, event) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n      return __generator(this, function (_a) {\n        if (new Date(Date.now()) < this._disabledUntil) {\n          return [2 /*return*/, Promise.reject(new SentryError(\"Transport locked till \" + this._disabledUntil + \" due to too many requests.\"))];\n        }\n        if (!this._buffer.isReady()) {\n          return [2 /*return*/, Promise.reject(new SentryError('Not adding Promise due to buffer limit reached.'))];\n        }\n        return [2 /*return*/, this._buffer.add(new Promise(function (resolve, reject) {\n          var sentryReq = eventToSentryRequest(event, _this._api);\n          var options = _this._getRequestOptions(new url.URL(sentryReq.url));\n          var req = httpModule.request(options, function (res) {\n            var statusCode = res.statusCode || 500;\n            var status = Status.fromHttpCode(statusCode);\n            res.setEncoding('utf8');\n            if (status === Status.Success) {\n              resolve({\n                status: status\n              });\n            } else {\n              if (status === Status.RateLimit) {\n                var now = Date.now();\n                /**\n                 * \"Key-value pairs of header names and values. Header names are lower-cased.\"\n                 * https://nodejs.org/api/http.html#http_message_headers\n                 */\n                var retryAfterHeader = res.headers ? res.headers['retry-after'] : '';\n                retryAfterHeader = Array.isArray(retryAfterHeader) ? retryAfterHeader[0] : retryAfterHeader;\n                _this._disabledUntil = new Date(now + parseRetryAfterHeader(now, retryAfterHeader));\n                logger.warn(\"Too many requests, backing off till: \" + _this._disabledUntil);\n              }\n              var rejectionMessage = \"HTTP Error (\" + statusCode + \")\";\n              if (res.headers && res.headers['x-sentry-error']) {\n                rejectionMessage += \": \" + res.headers['x-sentry-error'];\n              }\n              reject(new SentryError(rejectionMessage));\n            }\n            // Force the socket to drain\n            res.on('data', function () {\n              // Drain\n            });\n            res.on('end', function () {\n              // Drain\n            });\n          });\n          req.on('error', reject);\n          req.end(sentryReq.body);\n        }))];\n      });\n    });\n  };\n  return BaseTransport;\n}();\nexport { BaseTransport };","map":{"version":3,"names":["API","eventToSentryRequest","Status","logger","parseRetryAfterHeader","PromiseBuffer","SentryError","fs","url","SDK_NAME","SDK_VERSION","BaseTransport","options","_buffer","_disabledUntil","Date","now","_api","dsn","prototype","sendEvent","_","close","timeout","drain","_getRequestOptions","uri","headers","__assign","getRequestHeaders","hostname","pathname","port","protocol","path","agent","client","method","caCerts","ca","readFileSync","_sendWithModule","httpModule","event","Promise","reject","isReady","add","resolve","sentryReq","_this","URL","req","request","res","statusCode","status","fromHttpCode","setEncoding","Success","RateLimit","retryAfterHeader","Array","isArray","warn","rejectionMessage","on","end","body"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\@sentry\\node\\src\\transports\\base.ts"],"sourcesContent":["import { API, eventToSentryRequest } from '@sentry/core';\nimport { Event, Response, Status, Transport, TransportOptions } from '@sentry/types';\nimport { logger, parseRetryAfterHeader, PromiseBuffer, SentryError } from '@sentry/utils';\nimport * as fs from 'fs';\nimport * as http from 'http';\nimport * as https from 'https';\nimport * as url from 'url';\n\nimport { SDK_NAME, SDK_VERSION } from '../version';\n\n/**\n * Internal used interface for typescript.\n * @hidden\n */\nexport interface HTTPModule {\n  /**\n   * Request wrapper\n   * @param options These are {@see TransportOptions}\n   * @param callback Callback when request is finished\n   */\n  request(\n    options: http.RequestOptions | https.RequestOptions | string | url.URL,\n    callback?: (res: http.IncomingMessage) => void,\n  ): http.ClientRequest;\n\n  // This is the type for nodejs versions that handle the URL argument\n  // (v10.9.0+), but we do not use it just yet because we support older node\n  // versions:\n\n  // request(\n  //   url: string | url.URL,\n  //   options: http.RequestOptions | https.RequestOptions,\n  //   callback?: (res: http.IncomingMessage) => void,\n  // ): http.ClientRequest;\n}\n\n/** Base Transport class implementation */\nexport abstract class BaseTransport implements Transport {\n  /** The Agent used for corresponding transport */\n  public module?: HTTPModule;\n\n  /** The Agent used for corresponding transport */\n  public client?: http.Agent | https.Agent;\n\n  /** API object */\n  protected _api: API;\n\n  /** A simple buffer holding all requests. */\n  protected readonly _buffer: PromiseBuffer<Response> = new PromiseBuffer(30);\n\n  /** Locks transport after receiving 429 response */\n  private _disabledUntil: Date = new Date(Date.now());\n\n  /** Create instance and set this.dsn */\n  public constructor(public options: TransportOptions) {\n    this._api = new API(options.dsn);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendEvent(_: Event): PromiseLike<Response> {\n    throw new SentryError('Transport Class has to implement `sendEvent` method.');\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public close(timeout?: number): PromiseLike<boolean> {\n    return this._buffer.drain(timeout);\n  }\n\n  /** Returns a build request option object used by request */\n  protected _getRequestOptions(uri: url.URL): http.RequestOptions | https.RequestOptions {\n    const headers = {\n      ...this._api.getRequestHeaders(SDK_NAME, SDK_VERSION),\n      ...this.options.headers,\n    };\n    const { hostname, pathname, port, protocol } = uri;\n    // See https://github.com/nodejs/node/blob/38146e717fed2fabe3aacb6540d839475e0ce1c6/lib/internal/url.js#L1268-L1290\n    // We ignore the query string on purpose\n    const path = `${pathname}`;\n\n    return {\n      agent: this.client,\n      headers,\n      hostname,\n      method: 'POST',\n      path,\n      port,\n      protocol,\n      ...(this.options.caCerts && {\n        ca: fs.readFileSync(this.options.caCerts),\n      }),\n    };\n  }\n\n  /** JSDoc */\n  protected async _sendWithModule(httpModule: HTTPModule, event: Event): Promise<Response> {\n    if (new Date(Date.now()) < this._disabledUntil) {\n      return Promise.reject(new SentryError(`Transport locked till ${this._disabledUntil} due to too many requests.`));\n    }\n\n    if (!this._buffer.isReady()) {\n      return Promise.reject(new SentryError('Not adding Promise due to buffer limit reached.'));\n    }\n    return this._buffer.add(\n      new Promise<Response>((resolve, reject) => {\n        const sentryReq = eventToSentryRequest(event, this._api);\n        const options = this._getRequestOptions(new url.URL(sentryReq.url));\n\n        const req = httpModule.request(options, (res: http.IncomingMessage) => {\n          const statusCode = res.statusCode || 500;\n          const status = Status.fromHttpCode(statusCode);\n\n          res.setEncoding('utf8');\n\n          if (status === Status.Success) {\n            resolve({ status });\n          } else {\n            if (status === Status.RateLimit) {\n              const now = Date.now();\n              /**\n               * \"Key-value pairs of header names and values. Header names are lower-cased.\"\n               * https://nodejs.org/api/http.html#http_message_headers\n               */\n              let retryAfterHeader = res.headers ? res.headers['retry-after'] : '';\n              retryAfterHeader = (Array.isArray(retryAfterHeader) ? retryAfterHeader[0] : retryAfterHeader) as string;\n              this._disabledUntil = new Date(now + parseRetryAfterHeader(now, retryAfterHeader));\n              logger.warn(`Too many requests, backing off till: ${this._disabledUntil}`);\n            }\n\n            let rejectionMessage = `HTTP Error (${statusCode})`;\n            if (res.headers && res.headers['x-sentry-error']) {\n              rejectionMessage += `: ${res.headers['x-sentry-error']}`;\n            }\n\n            reject(new SentryError(rejectionMessage));\n          }\n\n          // Force the socket to drain\n          res.on('data', () => {\n            // Drain\n          });\n          res.on('end', () => {\n            // Drain\n          });\n        });\n        req.on('error', reject);\n        req.end(sentryReq.body);\n      }),\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}