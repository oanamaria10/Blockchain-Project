{"ast":null,"code":"'use strict';\n\nconst diagnosticsChannel = require('diagnostics_channel');\nconst {\n  uid,\n  states\n} = require('./constants');\nconst {\n  kReadyState,\n  kSentClose,\n  kByteParser,\n  kReceivedClose\n} = require('./symbols');\nconst {\n  fireEvent,\n  failWebsocketConnection\n} = require('./util');\nconst {\n  CloseEvent\n} = require('./events');\nconst {\n  makeRequest\n} = require('../fetch/request');\nconst {\n  fetching\n} = require('../fetch/index');\nconst {\n  Headers\n} = require('../fetch/headers');\nconst {\n  getGlobalDispatcher\n} = require('../global');\nconst {\n  kHeadersList\n} = require('../core/symbols');\nconst channels = {};\nchannels.open = diagnosticsChannel.channel('undici:websocket:open');\nchannels.close = diagnosticsChannel.channel('undici:websocket:close');\nchannels.socketError = diagnosticsChannel.channel('undici:websocket:socket_error');\n\n/** @type {import('crypto')} */\nlet crypto;\ntry {\n  crypto = require('crypto');\n} catch {}\n\n/**\n * @see https://websockets.spec.whatwg.org/#concept-websocket-establish\n * @param {URL} url\n * @param {string|string[]} protocols\n * @param {import('./websocket').WebSocket} ws\n * @param {(response: any) => void} onEstablish\n * @param {Partial<import('../../types/websocket').WebSocketInit>} options\n */\nfunction establishWebSocketConnection(url, protocols, ws, onEstablish, options) {\n  // 1. Let requestURL be a copy of url, with its scheme set to \"http\", if url’s\n  //    scheme is \"ws\", and to \"https\" otherwise.\n  const requestURL = url;\n  requestURL.protocol = url.protocol === 'ws:' ? 'http:' : 'https:';\n\n  // 2. Let request be a new request, whose URL is requestURL, client is client,\n  //    service-workers mode is \"none\", referrer is \"no-referrer\", mode is\n  //    \"websocket\", credentials mode is \"include\", cache mode is \"no-store\" ,\n  //    and redirect mode is \"error\".\n  const request = makeRequest({\n    urlList: [requestURL],\n    serviceWorkers: 'none',\n    referrer: 'no-referrer',\n    mode: 'websocket',\n    credentials: 'include',\n    cache: 'no-store',\n    redirect: 'error'\n  });\n\n  // Note: undici extension, allow setting custom headers.\n  if (options.headers) {\n    const headersList = new Headers(options.headers)[kHeadersList];\n    request.headersList = headersList;\n  }\n\n  // 3. Append (`Upgrade`, `websocket`) to request’s header list.\n  // 4. Append (`Connection`, `Upgrade`) to request’s header list.\n  // Note: both of these are handled by undici currently.\n  // https://github.com/nodejs/undici/blob/68c269c4144c446f3f1220951338daef4a6b5ec4/lib/client.js#L1397\n\n  // 5. Let keyValue be a nonce consisting of a randomly selected\n  //    16-byte value that has been forgiving-base64-encoded and\n  //    isomorphic encoded.\n  const keyValue = crypto.randomBytes(16).toString('base64');\n\n  // 6. Append (`Sec-WebSocket-Key`, keyValue) to request’s\n  //    header list.\n  request.headersList.append('sec-websocket-key', keyValue);\n\n  // 7. Append (`Sec-WebSocket-Version`, `13`) to request’s\n  //    header list.\n  request.headersList.append('sec-websocket-version', '13');\n\n  // 8. For each protocol in protocols, combine\n  //    (`Sec-WebSocket-Protocol`, protocol) in request’s header\n  //    list.\n  for (const protocol of protocols) {\n    request.headersList.append('sec-websocket-protocol', protocol);\n  }\n\n  // 9. Let permessageDeflate be a user-agent defined\n  //    \"permessage-deflate\" extension header value.\n  // https://github.com/mozilla/gecko-dev/blob/ce78234f5e653a5d3916813ff990f053510227bc/netwerk/protocol/websocket/WebSocketChannel.cpp#L2673\n  // TODO: enable once permessage-deflate is supported\n  const permessageDeflate = ''; // 'permessage-deflate; 15'\n\n  // 10. Append (`Sec-WebSocket-Extensions`, permessageDeflate) to\n  //     request’s header list.\n  // request.headersList.append('sec-websocket-extensions', permessageDeflate)\n\n  // 11. Fetch request with useParallelQueue set to true, and\n  //     processResponse given response being these steps:\n  const controller = fetching({\n    request,\n    useParallelQueue: true,\n    dispatcher: options.dispatcher ?? getGlobalDispatcher(),\n    processResponse(response) {\n      // 1. If response is a network error or its status is not 101,\n      //    fail the WebSocket connection.\n      if (response.type === 'error' || response.status !== 101) {\n        failWebsocketConnection(ws, 'Received network error or non-101 status code.');\n        return;\n      }\n\n      // 2. If protocols is not the empty list and extracting header\n      //    list values given `Sec-WebSocket-Protocol` and response’s\n      //    header list results in null, failure, or the empty byte\n      //    sequence, then fail the WebSocket connection.\n      if (protocols.length !== 0 && !response.headersList.get('Sec-WebSocket-Protocol')) {\n        failWebsocketConnection(ws, 'Server did not respond with sent protocols.');\n        return;\n      }\n\n      // 3. Follow the requirements stated step 2 to step 6, inclusive,\n      //    of the last set of steps in section 4.1 of The WebSocket\n      //    Protocol to validate response. This either results in fail\n      //    the WebSocket connection or the WebSocket connection is\n      //    established.\n\n      // 2. If the response lacks an |Upgrade| header field or the |Upgrade|\n      //    header field contains a value that is not an ASCII case-\n      //    insensitive match for the value \"websocket\", the client MUST\n      //    _Fail the WebSocket Connection_.\n      if (response.headersList.get('Upgrade')?.toLowerCase() !== 'websocket') {\n        failWebsocketConnection(ws, 'Server did not set Upgrade header to \"websocket\".');\n        return;\n      }\n\n      // 3. If the response lacks a |Connection| header field or the\n      //    |Connection| header field doesn't contain a token that is an\n      //    ASCII case-insensitive match for the value \"Upgrade\", the client\n      //    MUST _Fail the WebSocket Connection_.\n      if (response.headersList.get('Connection')?.toLowerCase() !== 'upgrade') {\n        failWebsocketConnection(ws, 'Server did not set Connection header to \"upgrade\".');\n        return;\n      }\n\n      // 4. If the response lacks a |Sec-WebSocket-Accept| header field or\n      //    the |Sec-WebSocket-Accept| contains a value other than the\n      //    base64-encoded SHA-1 of the concatenation of the |Sec-WebSocket-\n      //    Key| (as a string, not base64-decoded) with the string \"258EAFA5-\n      //    E914-47DA-95CA-C5AB0DC85B11\" but ignoring any leading and\n      //    trailing whitespace, the client MUST _Fail the WebSocket\n      //    Connection_.\n      const secWSAccept = response.headersList.get('Sec-WebSocket-Accept');\n      const digest = crypto.createHash('sha1').update(keyValue + uid).digest('base64');\n      if (secWSAccept !== digest) {\n        failWebsocketConnection(ws, 'Incorrect hash received in Sec-WebSocket-Accept header.');\n        return;\n      }\n\n      // 5. If the response includes a |Sec-WebSocket-Extensions| header\n      //    field and this header field indicates the use of an extension\n      //    that was not present in the client's handshake (the server has\n      //    indicated an extension not requested by the client), the client\n      //    MUST _Fail the WebSocket Connection_.  (The parsing of this\n      //    header field to determine which extensions are requested is\n      //    discussed in Section 9.1.)\n      const secExtension = response.headersList.get('Sec-WebSocket-Extensions');\n      if (secExtension !== null && secExtension !== permessageDeflate) {\n        failWebsocketConnection(ws, 'Received different permessage-deflate than the one set.');\n        return;\n      }\n\n      // 6. If the response includes a |Sec-WebSocket-Protocol| header field\n      //    and this header field indicates the use of a subprotocol that was\n      //    not present in the client's handshake (the server has indicated a\n      //    subprotocol not requested by the client), the client MUST _Fail\n      //    the WebSocket Connection_.\n      const secProtocol = response.headersList.get('Sec-WebSocket-Protocol');\n      if (secProtocol !== null && secProtocol !== request.headersList.get('Sec-WebSocket-Protocol')) {\n        failWebsocketConnection(ws, 'Protocol was not set in the opening handshake.');\n        return;\n      }\n      response.socket.on('data', onSocketData);\n      response.socket.on('close', onSocketClose);\n      response.socket.on('error', onSocketError);\n      if (channels.open.hasSubscribers) {\n        channels.open.publish({\n          address: response.socket.address(),\n          protocol: secProtocol,\n          extensions: secExtension\n        });\n      }\n      onEstablish(response);\n    }\n  });\n  return controller;\n}\n\n/**\n * @param {Buffer} chunk\n */\nfunction onSocketData(chunk) {\n  if (!this.ws[kByteParser].write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4\n */\nfunction onSocketClose() {\n  const {\n    ws\n  } = this;\n\n  // If the TCP connection was closed after the\n  // WebSocket closing handshake was completed, the WebSocket connection\n  // is said to have been closed _cleanly_.\n  const wasClean = ws[kSentClose] && ws[kReceivedClose];\n  let code = 1005;\n  let reason = '';\n  const result = ws[kByteParser].closingInfo;\n  if (result) {\n    code = result.code ?? 1005;\n    reason = result.reason;\n  } else if (!ws[kSentClose]) {\n    // If _The WebSocket\n    // Connection is Closed_ and no Close control frame was received by the\n    // endpoint (such as could occur if the underlying transport connection\n    // is lost), _The WebSocket Connection Close Code_ is considered to be\n    // 1006.\n    code = 1006;\n  }\n\n  // 1. Change the ready state to CLOSED (3).\n  ws[kReadyState] = states.CLOSED;\n\n  // 2. If the user agent was required to fail the WebSocket\n  //    connection, or if the WebSocket connection was closed\n  //    after being flagged as full, fire an event named error\n  //    at the WebSocket object.\n  // TODO\n\n  // 3. Fire an event named close at the WebSocket object,\n  //    using CloseEvent, with the wasClean attribute\n  //    initialized to true if the connection closed cleanly\n  //    and false otherwise, the code attribute initialized to\n  //    the WebSocket connection close code, and the reason\n  //    attribute initialized to the result of applying UTF-8\n  //    decode without BOM to the WebSocket connection close\n  //    reason.\n  fireEvent('close', ws, CloseEvent, {\n    wasClean,\n    code,\n    reason\n  });\n  if (channels.close.hasSubscribers) {\n    channels.close.publish({\n      websocket: ws,\n      code,\n      reason\n    });\n  }\n}\nfunction onSocketError(error) {\n  const {\n    ws\n  } = this;\n  ws[kReadyState] = states.CLOSING;\n  if (channels.socketError.hasSubscribers) {\n    channels.socketError.publish(error);\n  }\n  this.destroy();\n}\nmodule.exports = {\n  establishWebSocketConnection\n};","map":{"version":3,"names":["diagnosticsChannel","require","uid","states","kReadyState","kSentClose","kByteParser","kReceivedClose","fireEvent","failWebsocketConnection","CloseEvent","makeRequest","fetching","Headers","getGlobalDispatcher","kHeadersList","channels","open","channel","close","socketError","crypto","establishWebSocketConnection","url","protocols","ws","onEstablish","options","requestURL","protocol","request","urlList","serviceWorkers","referrer","mode","credentials","cache","redirect","headers","headersList","keyValue","randomBytes","toString","append","permessageDeflate","controller","useParallelQueue","dispatcher","processResponse","response","type","status","length","get","toLowerCase","secWSAccept","digest","createHash","update","secExtension","secProtocol","socket","on","onSocketData","onSocketClose","onSocketError","hasSubscribers","publish","address","extensions","chunk","write","pause","wasClean","code","reason","result","closingInfo","CLOSED","websocket","error","CLOSING","destroy","module","exports"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/undici/lib/websocket/connection.js"],"sourcesContent":["'use strict'\n\nconst diagnosticsChannel = require('diagnostics_channel')\nconst { uid, states } = require('./constants')\nconst {\n  kReadyState,\n  kSentClose,\n  kByteParser,\n  kReceivedClose\n} = require('./symbols')\nconst { fireEvent, failWebsocketConnection } = require('./util')\nconst { CloseEvent } = require('./events')\nconst { makeRequest } = require('../fetch/request')\nconst { fetching } = require('../fetch/index')\nconst { Headers } = require('../fetch/headers')\nconst { getGlobalDispatcher } = require('../global')\nconst { kHeadersList } = require('../core/symbols')\n\nconst channels = {}\nchannels.open = diagnosticsChannel.channel('undici:websocket:open')\nchannels.close = diagnosticsChannel.channel('undici:websocket:close')\nchannels.socketError = diagnosticsChannel.channel('undici:websocket:socket_error')\n\n/** @type {import('crypto')} */\nlet crypto\ntry {\n  crypto = require('crypto')\n} catch {\n\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#concept-websocket-establish\n * @param {URL} url\n * @param {string|string[]} protocols\n * @param {import('./websocket').WebSocket} ws\n * @param {(response: any) => void} onEstablish\n * @param {Partial<import('../../types/websocket').WebSocketInit>} options\n */\nfunction establishWebSocketConnection (url, protocols, ws, onEstablish, options) {\n  // 1. Let requestURL be a copy of url, with its scheme set to \"http\", if url’s\n  //    scheme is \"ws\", and to \"https\" otherwise.\n  const requestURL = url\n\n  requestURL.protocol = url.protocol === 'ws:' ? 'http:' : 'https:'\n\n  // 2. Let request be a new request, whose URL is requestURL, client is client,\n  //    service-workers mode is \"none\", referrer is \"no-referrer\", mode is\n  //    \"websocket\", credentials mode is \"include\", cache mode is \"no-store\" ,\n  //    and redirect mode is \"error\".\n  const request = makeRequest({\n    urlList: [requestURL],\n    serviceWorkers: 'none',\n    referrer: 'no-referrer',\n    mode: 'websocket',\n    credentials: 'include',\n    cache: 'no-store',\n    redirect: 'error'\n  })\n\n  // Note: undici extension, allow setting custom headers.\n  if (options.headers) {\n    const headersList = new Headers(options.headers)[kHeadersList]\n\n    request.headersList = headersList\n  }\n\n  // 3. Append (`Upgrade`, `websocket`) to request’s header list.\n  // 4. Append (`Connection`, `Upgrade`) to request’s header list.\n  // Note: both of these are handled by undici currently.\n  // https://github.com/nodejs/undici/blob/68c269c4144c446f3f1220951338daef4a6b5ec4/lib/client.js#L1397\n\n  // 5. Let keyValue be a nonce consisting of a randomly selected\n  //    16-byte value that has been forgiving-base64-encoded and\n  //    isomorphic encoded.\n  const keyValue = crypto.randomBytes(16).toString('base64')\n\n  // 6. Append (`Sec-WebSocket-Key`, keyValue) to request’s\n  //    header list.\n  request.headersList.append('sec-websocket-key', keyValue)\n\n  // 7. Append (`Sec-WebSocket-Version`, `13`) to request’s\n  //    header list.\n  request.headersList.append('sec-websocket-version', '13')\n\n  // 8. For each protocol in protocols, combine\n  //    (`Sec-WebSocket-Protocol`, protocol) in request’s header\n  //    list.\n  for (const protocol of protocols) {\n    request.headersList.append('sec-websocket-protocol', protocol)\n  }\n\n  // 9. Let permessageDeflate be a user-agent defined\n  //    \"permessage-deflate\" extension header value.\n  // https://github.com/mozilla/gecko-dev/blob/ce78234f5e653a5d3916813ff990f053510227bc/netwerk/protocol/websocket/WebSocketChannel.cpp#L2673\n  // TODO: enable once permessage-deflate is supported\n  const permessageDeflate = '' // 'permessage-deflate; 15'\n\n  // 10. Append (`Sec-WebSocket-Extensions`, permessageDeflate) to\n  //     request’s header list.\n  // request.headersList.append('sec-websocket-extensions', permessageDeflate)\n\n  // 11. Fetch request with useParallelQueue set to true, and\n  //     processResponse given response being these steps:\n  const controller = fetching({\n    request,\n    useParallelQueue: true,\n    dispatcher: options.dispatcher ?? getGlobalDispatcher(),\n    processResponse (response) {\n      // 1. If response is a network error or its status is not 101,\n      //    fail the WebSocket connection.\n      if (response.type === 'error' || response.status !== 101) {\n        failWebsocketConnection(ws, 'Received network error or non-101 status code.')\n        return\n      }\n\n      // 2. If protocols is not the empty list and extracting header\n      //    list values given `Sec-WebSocket-Protocol` and response’s\n      //    header list results in null, failure, or the empty byte\n      //    sequence, then fail the WebSocket connection.\n      if (protocols.length !== 0 && !response.headersList.get('Sec-WebSocket-Protocol')) {\n        failWebsocketConnection(ws, 'Server did not respond with sent protocols.')\n        return\n      }\n\n      // 3. Follow the requirements stated step 2 to step 6, inclusive,\n      //    of the last set of steps in section 4.1 of The WebSocket\n      //    Protocol to validate response. This either results in fail\n      //    the WebSocket connection or the WebSocket connection is\n      //    established.\n\n      // 2. If the response lacks an |Upgrade| header field or the |Upgrade|\n      //    header field contains a value that is not an ASCII case-\n      //    insensitive match for the value \"websocket\", the client MUST\n      //    _Fail the WebSocket Connection_.\n      if (response.headersList.get('Upgrade')?.toLowerCase() !== 'websocket') {\n        failWebsocketConnection(ws, 'Server did not set Upgrade header to \"websocket\".')\n        return\n      }\n\n      // 3. If the response lacks a |Connection| header field or the\n      //    |Connection| header field doesn't contain a token that is an\n      //    ASCII case-insensitive match for the value \"Upgrade\", the client\n      //    MUST _Fail the WebSocket Connection_.\n      if (response.headersList.get('Connection')?.toLowerCase() !== 'upgrade') {\n        failWebsocketConnection(ws, 'Server did not set Connection header to \"upgrade\".')\n        return\n      }\n\n      // 4. If the response lacks a |Sec-WebSocket-Accept| header field or\n      //    the |Sec-WebSocket-Accept| contains a value other than the\n      //    base64-encoded SHA-1 of the concatenation of the |Sec-WebSocket-\n      //    Key| (as a string, not base64-decoded) with the string \"258EAFA5-\n      //    E914-47DA-95CA-C5AB0DC85B11\" but ignoring any leading and\n      //    trailing whitespace, the client MUST _Fail the WebSocket\n      //    Connection_.\n      const secWSAccept = response.headersList.get('Sec-WebSocket-Accept')\n      const digest = crypto.createHash('sha1').update(keyValue + uid).digest('base64')\n      if (secWSAccept !== digest) {\n        failWebsocketConnection(ws, 'Incorrect hash received in Sec-WebSocket-Accept header.')\n        return\n      }\n\n      // 5. If the response includes a |Sec-WebSocket-Extensions| header\n      //    field and this header field indicates the use of an extension\n      //    that was not present in the client's handshake (the server has\n      //    indicated an extension not requested by the client), the client\n      //    MUST _Fail the WebSocket Connection_.  (The parsing of this\n      //    header field to determine which extensions are requested is\n      //    discussed in Section 9.1.)\n      const secExtension = response.headersList.get('Sec-WebSocket-Extensions')\n\n      if (secExtension !== null && secExtension !== permessageDeflate) {\n        failWebsocketConnection(ws, 'Received different permessage-deflate than the one set.')\n        return\n      }\n\n      // 6. If the response includes a |Sec-WebSocket-Protocol| header field\n      //    and this header field indicates the use of a subprotocol that was\n      //    not present in the client's handshake (the server has indicated a\n      //    subprotocol not requested by the client), the client MUST _Fail\n      //    the WebSocket Connection_.\n      const secProtocol = response.headersList.get('Sec-WebSocket-Protocol')\n\n      if (secProtocol !== null && secProtocol !== request.headersList.get('Sec-WebSocket-Protocol')) {\n        failWebsocketConnection(ws, 'Protocol was not set in the opening handshake.')\n        return\n      }\n\n      response.socket.on('data', onSocketData)\n      response.socket.on('close', onSocketClose)\n      response.socket.on('error', onSocketError)\n\n      if (channels.open.hasSubscribers) {\n        channels.open.publish({\n          address: response.socket.address(),\n          protocol: secProtocol,\n          extensions: secExtension\n        })\n      }\n\n      onEstablish(response)\n    }\n  })\n\n  return controller\n}\n\n/**\n * @param {Buffer} chunk\n */\nfunction onSocketData (chunk) {\n  if (!this.ws[kByteParser].write(chunk)) {\n    this.pause()\n  }\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4\n */\nfunction onSocketClose () {\n  const { ws } = this\n\n  // If the TCP connection was closed after the\n  // WebSocket closing handshake was completed, the WebSocket connection\n  // is said to have been closed _cleanly_.\n  const wasClean = ws[kSentClose] && ws[kReceivedClose]\n\n  let code = 1005\n  let reason = ''\n\n  const result = ws[kByteParser].closingInfo\n\n  if (result) {\n    code = result.code ?? 1005\n    reason = result.reason\n  } else if (!ws[kSentClose]) {\n    // If _The WebSocket\n    // Connection is Closed_ and no Close control frame was received by the\n    // endpoint (such as could occur if the underlying transport connection\n    // is lost), _The WebSocket Connection Close Code_ is considered to be\n    // 1006.\n    code = 1006\n  }\n\n  // 1. Change the ready state to CLOSED (3).\n  ws[kReadyState] = states.CLOSED\n\n  // 2. If the user agent was required to fail the WebSocket\n  //    connection, or if the WebSocket connection was closed\n  //    after being flagged as full, fire an event named error\n  //    at the WebSocket object.\n  // TODO\n\n  // 3. Fire an event named close at the WebSocket object,\n  //    using CloseEvent, with the wasClean attribute\n  //    initialized to true if the connection closed cleanly\n  //    and false otherwise, the code attribute initialized to\n  //    the WebSocket connection close code, and the reason\n  //    attribute initialized to the result of applying UTF-8\n  //    decode without BOM to the WebSocket connection close\n  //    reason.\n  fireEvent('close', ws, CloseEvent, {\n    wasClean, code, reason\n  })\n\n  if (channels.close.hasSubscribers) {\n    channels.close.publish({\n      websocket: ws,\n      code,\n      reason\n    })\n  }\n}\n\nfunction onSocketError (error) {\n  const { ws } = this\n\n  ws[kReadyState] = states.CLOSING\n\n  if (channels.socketError.hasSubscribers) {\n    channels.socketError.publish(error)\n  }\n\n  this.destroy()\n}\n\nmodule.exports = {\n  establishWebSocketConnection\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}