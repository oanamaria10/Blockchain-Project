{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VarsManager = void 0;\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\nconst debug_1 = __importDefault(require(\"debug\"));\nconst errors_1 = require(\"../errors\");\nconst errors_list_1 = require(\"../errors-list\");\nconst log = (0, debug_1.default)(\"hardhat:core:vars:varsManager\");\nclass VarsManager {\n  constructor(_varsFilePath) {\n    this._varsFilePath = _varsFilePath;\n    this._VERSION = \"hh-vars-1\";\n    this._ENV_VAR_PREFIX = \"HARDHAT_VAR_\";\n    log(\"Creating a new instance of VarsManager\");\n    this._initializeVarsFile();\n    this._storageCache = fs_extra_1.default.readJSONSync(this._varsFilePath);\n    this._envCache = {};\n    this._loadVarsFromEnv();\n  }\n  getStoragePath() {\n    return this._varsFilePath;\n  }\n  set(key, value) {\n    this.validateKey(key);\n    if (value === \"\") {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.VARS.INVALID_EMPTY_VALUE);\n    }\n    const vars = this._storageCache.vars;\n    vars[key] = {\n      value\n    };\n    this._writeStoredVars(vars);\n  }\n  has(key, includeEnvs = false) {\n    if (includeEnvs && key in this._envCache) {\n      return true;\n    }\n    return key in this._storageCache.vars;\n  }\n  get(key, defaultValue, includeEnvs = false) {\n    if (includeEnvs && key in this._envCache) {\n      return this._envCache[key];\n    }\n    return this._storageCache.vars[key]?.value ?? defaultValue;\n  }\n  getEnvVars() {\n    return Object.keys(this._envCache).map(k => `${this._ENV_VAR_PREFIX}${k}`);\n  }\n  list() {\n    return Object.keys(this._storageCache.vars);\n  }\n  delete(key) {\n    const vars = this._storageCache.vars;\n    if (vars[key] === undefined) return false;\n    delete vars[key];\n    this._writeStoredVars(vars);\n    return true;\n  }\n  validateKey(key) {\n    const KEY_REGEX = /^[a-zA-Z_]+[a-zA-Z0-9_]*$/;\n    if (!KEY_REGEX.test(key)) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.VARS.INVALID_CONFIG_VAR_NAME, {\n        value: key\n      });\n    }\n  }\n  _initializeVarsFile() {\n    if (!fs_extra_1.default.pathExistsSync(this._varsFilePath)) {\n      // Initialize the vars file if it does not exist\n      log(`Vars file do not exist. Creating a new one at '${this._varsFilePath}' with version '${this._VERSION}'`);\n      fs_extra_1.default.writeJSONSync(this._varsFilePath, this._getVarsFileStructure(), {\n        spaces: 2\n      });\n    }\n  }\n  _getVarsFileStructure() {\n    return {\n      _format: this._VERSION,\n      vars: {}\n    };\n  }\n  _loadVarsFromEnv() {\n    log(\"Loading ENV variables if any\");\n    for (const key in process.env) {\n      if (key.startsWith(this._ENV_VAR_PREFIX)) {\n        const envVar = process.env[key];\n        if (envVar === undefined || envVar.replace(/[\\s\\t]/g, \"\").length === 0) {\n          throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_ENV_VAR_VALUE, {\n            varName: key,\n            value: envVar\n          });\n        }\n        const envKey = key.replace(this._ENV_VAR_PREFIX, \"\");\n        this.validateKey(envKey);\n        // Store only in cache, not in a file, as the vars are sourced from environment variables\n        this._envCache[envKey] = envVar;\n      }\n    }\n  }\n  _writeStoredVars(vars) {\n    // ENV variables are not stored in the file\n    this._storageCache.vars = vars;\n    fs_extra_1.default.writeJSONSync(this._varsFilePath, this._storageCache, {\n      spaces: 2\n    });\n  }\n}\nexports.VarsManager = VarsManager;","map":{"version":3,"names":["fs_extra_1","__importDefault","require","debug_1","errors_1","errors_list_1","log","default","VarsManager","constructor","_varsFilePath","_VERSION","_ENV_VAR_PREFIX","_initializeVarsFile","_storageCache","readJSONSync","_envCache","_loadVarsFromEnv","getStoragePath","set","key","value","validateKey","HardhatError","ERRORS","VARS","INVALID_EMPTY_VALUE","vars","_writeStoredVars","has","includeEnvs","get","defaultValue","getEnvVars","Object","keys","map","k","list","delete","undefined","KEY_REGEX","test","INVALID_CONFIG_VAR_NAME","pathExistsSync","writeJSONSync","_getVarsFileStructure","spaces","_format","process","env","startsWith","envVar","replace","length","ARGUMENTS","INVALID_ENV_VAR_VALUE","varName","envKey","exports"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\internal\\core\\vars\\vars-manager.ts"],"sourcesContent":["import fs from \"fs-extra\";\nimport debug from \"debug\";\nimport { HardhatError } from \"../errors\";\nimport { ERRORS } from \"../errors-list\";\n\ninterface Var {\n  value: string;\n}\n\ninterface VarsFile {\n  _format: string; // Version of the json vars file\n  vars: Record<string, Var>;\n}\n\nconst log = debug(\"hardhat:core:vars:varsManager\");\n\nexport class VarsManager {\n  private readonly _VERSION = \"hh-vars-1\";\n  private readonly _ENV_VAR_PREFIX = \"HARDHAT_VAR_\";\n  private readonly _storageCache: VarsFile;\n  private readonly _envCache: Record<string, string>;\n\n  constructor(private readonly _varsFilePath: string) {\n    log(\"Creating a new instance of VarsManager\");\n\n    this._initializeVarsFile();\n    this._storageCache = fs.readJSONSync(this._varsFilePath);\n\n    this._envCache = {};\n    this._loadVarsFromEnv();\n  }\n\n  public getStoragePath(): string {\n    return this._varsFilePath;\n  }\n\n  public set(key: string, value: string) {\n    this.validateKey(key);\n\n    if (value === \"\") {\n      throw new HardhatError(ERRORS.VARS.INVALID_EMPTY_VALUE);\n    }\n\n    const vars = this._storageCache.vars;\n\n    vars[key] = { value };\n    this._writeStoredVars(vars);\n  }\n\n  public has(key: string, includeEnvs: boolean = false): boolean {\n    if (includeEnvs && key in this._envCache) {\n      return true;\n    }\n\n    return key in this._storageCache.vars;\n  }\n\n  public get(\n    key: string,\n    defaultValue?: string,\n    includeEnvs: boolean = false\n  ): string | undefined {\n    if (includeEnvs && key in this._envCache) {\n      return this._envCache[key];\n    }\n\n    return this._storageCache.vars[key]?.value ?? defaultValue;\n  }\n\n  public getEnvVars(): string[] {\n    return Object.keys(this._envCache).map(\n      (k) => `${this._ENV_VAR_PREFIX}${k}`\n    );\n  }\n\n  public list(): string[] {\n    return Object.keys(this._storageCache.vars);\n  }\n\n  public delete(key: string): boolean {\n    const vars = this._storageCache.vars;\n\n    if (vars[key] === undefined) return false;\n\n    delete vars[key];\n    this._writeStoredVars(vars);\n\n    return true;\n  }\n\n  public validateKey(key: string) {\n    const KEY_REGEX = /^[a-zA-Z_]+[a-zA-Z0-9_]*$/;\n\n    if (!KEY_REGEX.test(key)) {\n      throw new HardhatError(ERRORS.VARS.INVALID_CONFIG_VAR_NAME, {\n        value: key,\n      });\n    }\n  }\n\n  private _initializeVarsFile() {\n    if (!fs.pathExistsSync(this._varsFilePath)) {\n      // Initialize the vars file if it does not exist\n      log(\n        `Vars file do not exist. Creating a new one at '${this._varsFilePath}' with version '${this._VERSION}'`\n      );\n\n      fs.writeJSONSync(this._varsFilePath, this._getVarsFileStructure(), {\n        spaces: 2,\n      });\n    }\n  }\n\n  private _getVarsFileStructure(): VarsFile {\n    return {\n      _format: this._VERSION,\n      vars: {},\n    };\n  }\n\n  private _loadVarsFromEnv() {\n    log(\"Loading ENV variables if any\");\n\n    for (const key in process.env) {\n      if (key.startsWith(this._ENV_VAR_PREFIX)) {\n        const envVar = process.env[key];\n\n        if (\n          envVar === undefined ||\n          envVar.replace(/[\\s\\t]/g, \"\").length === 0\n        ) {\n          throw new HardhatError(ERRORS.ARGUMENTS.INVALID_ENV_VAR_VALUE, {\n            varName: key,\n            value: envVar!,\n          });\n        }\n\n        const envKey = key.replace(this._ENV_VAR_PREFIX, \"\");\n        this.validateKey(envKey);\n\n        // Store only in cache, not in a file, as the vars are sourced from environment variables\n        this._envCache[envKey] = envVar;\n      }\n    }\n  }\n\n  private _writeStoredVars(vars: Record<string, Var>) {\n    // ENV variables are not stored in the file\n    this._storageCache.vars = vars;\n    fs.writeJSONSync(this._varsFilePath, this._storageCache, { spaces: 2 });\n  }\n}\n"],"mappings":";;;;;;;;;;;AAAA,MAAAA,UAAA,GAAAC,eAAA,CAAAC,OAAA;AACA,MAAAC,OAAA,GAAAF,eAAA,CAAAC,OAAA;AACA,MAAAE,QAAA,GAAAF,OAAA;AACA,MAAAG,aAAA,GAAAH,OAAA;AAWA,MAAMI,GAAG,GAAG,IAAAH,OAAA,CAAAI,OAAK,EAAC,+BAA+B,CAAC;AAElD,MAAaC,WAAW;EAMtBC,YAA6BC,aAAqB;IAArB,KAAAA,aAAa,GAAbA,aAAa;IALzB,KAAAC,QAAQ,GAAG,WAAW;IACtB,KAAAC,eAAe,GAAG,cAAc;IAK/CN,GAAG,CAAC,wCAAwC,CAAC;IAE7C,IAAI,CAACO,mBAAmB,EAAE;IAC1B,IAAI,CAACC,aAAa,GAAGd,UAAA,CAAAO,OAAE,CAACQ,YAAY,CAAC,IAAI,CAACL,aAAa,CAAC;IAExD,IAAI,CAACM,SAAS,GAAG,EAAE;IACnB,IAAI,CAACC,gBAAgB,EAAE;EACzB;EAEOC,cAAcA,CAAA;IACnB,OAAO,IAAI,CAACR,aAAa;EAC3B;EAEOS,GAAGA,CAACC,GAAW,EAAEC,KAAa;IACnC,IAAI,CAACC,WAAW,CAACF,GAAG,CAAC;IAErB,IAAIC,KAAK,KAAK,EAAE,EAAE;MAChB,MAAM,IAAIjB,QAAA,CAAAmB,YAAY,CAAClB,aAAA,CAAAmB,MAAM,CAACC,IAAI,CAACC,mBAAmB,CAAC;;IAGzD,MAAMC,IAAI,GAAG,IAAI,CAACb,aAAa,CAACa,IAAI;IAEpCA,IAAI,CAACP,GAAG,CAAC,GAAG;MAAEC;IAAK,CAAE;IACrB,IAAI,CAACO,gBAAgB,CAACD,IAAI,CAAC;EAC7B;EAEOE,GAAGA,CAACT,GAAW,EAAEU,WAAA,GAAuB,KAAK;IAClD,IAAIA,WAAW,IAAIV,GAAG,IAAI,IAAI,CAACJ,SAAS,EAAE;MACxC,OAAO,IAAI;;IAGb,OAAOI,GAAG,IAAI,IAAI,CAACN,aAAa,CAACa,IAAI;EACvC;EAEOI,GAAGA,CACRX,GAAW,EACXY,YAAqB,EACrBF,WAAA,GAAuB,KAAK;IAE5B,IAAIA,WAAW,IAAIV,GAAG,IAAI,IAAI,CAACJ,SAAS,EAAE;MACxC,OAAO,IAAI,CAACA,SAAS,CAACI,GAAG,CAAC;;IAG5B,OAAO,IAAI,CAACN,aAAa,CAACa,IAAI,CAACP,GAAG,CAAC,EAAEC,KAAK,IAAIW,YAAY;EAC5D;EAEOC,UAAUA,CAAA;IACf,OAAOC,MAAM,CAACC,IAAI,CAAC,IAAI,CAACnB,SAAS,CAAC,CAACoB,GAAG,CACnCC,CAAC,IAAK,GAAG,IAAI,CAACzB,eAAe,GAAGyB,CAAC,EAAE,CACrC;EACH;EAEOC,IAAIA,CAAA;IACT,OAAOJ,MAAM,CAACC,IAAI,CAAC,IAAI,CAACrB,aAAa,CAACa,IAAI,CAAC;EAC7C;EAEOY,MAAMA,CAACnB,GAAW;IACvB,MAAMO,IAAI,GAAG,IAAI,CAACb,aAAa,CAACa,IAAI;IAEpC,IAAIA,IAAI,CAACP,GAAG,CAAC,KAAKoB,SAAS,EAAE,OAAO,KAAK;IAEzC,OAAOb,IAAI,CAACP,GAAG,CAAC;IAChB,IAAI,CAACQ,gBAAgB,CAACD,IAAI,CAAC;IAE3B,OAAO,IAAI;EACb;EAEOL,WAAWA,CAACF,GAAW;IAC5B,MAAMqB,SAAS,GAAG,2BAA2B;IAE7C,IAAI,CAACA,SAAS,CAACC,IAAI,CAACtB,GAAG,CAAC,EAAE;MACxB,MAAM,IAAIhB,QAAA,CAAAmB,YAAY,CAAClB,aAAA,CAAAmB,MAAM,CAACC,IAAI,CAACkB,uBAAuB,EAAE;QAC1DtB,KAAK,EAAED;OACR,CAAC;;EAEN;EAEQP,mBAAmBA,CAAA;IACzB,IAAI,CAACb,UAAA,CAAAO,OAAE,CAACqC,cAAc,CAAC,IAAI,CAAClC,aAAa,CAAC,EAAE;MAC1C;MACAJ,GAAG,CACD,kDAAkD,IAAI,CAACI,aAAa,mBAAmB,IAAI,CAACC,QAAQ,GAAG,CACxG;MAEDX,UAAA,CAAAO,OAAE,CAACsC,aAAa,CAAC,IAAI,CAACnC,aAAa,EAAE,IAAI,CAACoC,qBAAqB,EAAE,EAAE;QACjEC,MAAM,EAAE;OACT,CAAC;;EAEN;EAEQD,qBAAqBA,CAAA;IAC3B,OAAO;MACLE,OAAO,EAAE,IAAI,CAACrC,QAAQ;MACtBgB,IAAI,EAAE;KACP;EACH;EAEQV,gBAAgBA,CAAA;IACtBX,GAAG,CAAC,8BAA8B,CAAC;IAEnC,KAAK,MAAMc,GAAG,IAAI6B,OAAO,CAACC,GAAG,EAAE;MAC7B,IAAI9B,GAAG,CAAC+B,UAAU,CAAC,IAAI,CAACvC,eAAe,CAAC,EAAE;QACxC,MAAMwC,MAAM,GAAGH,OAAO,CAACC,GAAG,CAAC9B,GAAG,CAAC;QAE/B,IACEgC,MAAM,KAAKZ,SAAS,IACpBY,MAAM,CAACC,OAAO,CAAC,SAAS,EAAE,EAAE,CAAC,CAACC,MAAM,KAAK,CAAC,EAC1C;UACA,MAAM,IAAIlD,QAAA,CAAAmB,YAAY,CAAClB,aAAA,CAAAmB,MAAM,CAAC+B,SAAS,CAACC,qBAAqB,EAAE;YAC7DC,OAAO,EAAErC,GAAG;YACZC,KAAK,EAAE+B;WACR,CAAC;;QAGJ,MAAMM,MAAM,GAAGtC,GAAG,CAACiC,OAAO,CAAC,IAAI,CAACzC,eAAe,EAAE,EAAE,CAAC;QACpD,IAAI,CAACU,WAAW,CAACoC,MAAM,CAAC;QAExB;QACA,IAAI,CAAC1C,SAAS,CAAC0C,MAAM,CAAC,GAAGN,MAAM;;;EAGrC;EAEQxB,gBAAgBA,CAACD,IAAyB;IAChD;IACA,IAAI,CAACb,aAAa,CAACa,IAAI,GAAGA,IAAI;IAC9B3B,UAAA,CAAAO,OAAE,CAACsC,aAAa,CAAC,IAAI,CAACnC,aAAa,EAAE,IAAI,CAACI,aAAa,EAAE;MAAEiC,MAAM,EAAE;IAAC,CAAE,CAAC;EACzE;;AAtIFY,OAAA,CAAAnD,WAAA,GAAAA,WAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}