{"ast":null,"code":"import * as API from \"./api.js\";\nexport * from \"./api.js\";\nimport * as BitField from \"./bitfield/Uint32.js\";\nimport * as Path from \"./path/Uint32.js\";\nexport { API };\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @implements {API.BitmapIndexedNode<T, K, C>}\n */\nclass BitmapIndexedNode {\n  /**\n   * @param {API.Edit|null} edit\n   * @param {ReturnType<C['BitField']['empty']>} datamap\n   * @param {ReturnType<C['BitField']['empty']>} nodemap\n   * @param {API.Children<T, K, C>} children\n   * @param {C} config\n   */\n  constructor(edit, datamap, nodemap, children, config) {\n    this.edit = edit;\n    this.config = config;\n    this.datamap = datamap;\n    this.nodemap = nodemap;\n    this.children = children;\n  }\n  get nodeArity() {\n    return this.config.BitField.popcount(this.nodemap);\n  }\n  get dataArity() {\n    return this.config.BitField.popcount(this.datamap);\n  }\n\n  /**\n   * @returns {API.BitmapIndexedNode<T, K, C>}\n   */\n  /* c8 ignore next 3 */\n  empty() {\n    return create(this.config);\n  }\n\n  /**\n   * @template X\n   * @param {API.Uint32} depth\n   * @param {ReturnType<C['Path']['from']>} path\n   * @param {K} key\n   * @param {X} notFound\n   * @returns {T|X}\n   */\n\n  lookup(depth, path, key, notFound) {\n    return lookup(this, depth, path, key, notFound);\n  }\n\n  /**\n   * @template {string} R\n   * @param {API.Edit|null} edit\n   * @param {API.Uint32} depth\n   * @param {ReturnType<C['Path']['from']>} path\n   * @param {K|R} key\n   * @param {T} value\n   * @param {{value:boolean}} addedLeaf\n   * @returns {API.BitmapIndexedNode<T, K | R, C>}\n   */\n  associate(edit, depth, path, key, value, addedLeaf) {\n    return associate(this, edit, depth, path, key, value, addedLeaf);\n  }\n\n  /**\n   * @param {API.Edit|null} edit\n   * @param {API.Uint32} depth\n   * @param {ReturnType<C['Path']['from']>} path\n   * @param {K} key\n   * @param {{value:boolean}} removedLeaf\n   * @returns {API.BitmapIndexedNode<T, K, C>}\n   */\n  dissociate(edit, depth, path, key, removedLeaf) {\n    return dissociate(this, edit, depth, path, key, removedLeaf);\n  }\n\n  /**\n   * @param {API.Edit|null} edit\n   * @returns {API.BitmapIndexedNode<T, K, C>}\n   */\n  fork(edit = null) {\n    return fork(this, edit);\n  }\n\n  /**\n   * @returns {IterableIterator<[K, T]>}\n   */\n  entries() {\n    return entries(this);\n  }\n\n  /**\n   * @returns {IterableIterator<K>}\n   */\n  keys() {\n    return keys(this);\n  }\n\n  /**\n   * @returns {IterableIterator<T>}\n   */\n  values() {\n    return values(this);\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @implements {API.HashCollisionNode<T, K, C>}\n */\nclass HashCollisionNode {\n  /**\n   * @param {API.Edit|null} edit\n   * @param {number} count\n   * @param {API.CollisionEntries<T, K>} children\n   * @param {C} config\n   */\n  /* c8 ignore next 12 */\n  constructor(edit, count, children, config) {\n    this.edit = edit;\n    this.count = count;\n    this.children = children;\n    this.config = config;\n  }\n  get nodeArity() {\n    return /** @type {0} */0;\n  }\n  get dataArity() {\n    return this.count;\n  }\n\n  /**\n   * @template X\n   * @param {API.Uint32} _shift\n   * @param {unknown} _path\n   * @param {K} key\n   * @param {X} notFound\n   * @returns {T|X}\n   */\n  /* c8 ignore next 3 */\n  lookup(_shift, _path, key, notFound) {\n    return lookupCollision(this, key, notFound);\n  }\n\n  /**\n   * @template {string} R\n   * @param {API.Edit|null} edit\n   * @param {API.Uint32} _shift\n   * @param {ReturnType<C['Path']['from']>} path\n   * @param {K|R} key\n   * @param {T} value\n   * @param {{value:boolean}} addedLeaf\n   * @returns {API.HashCollisionNode<T, K | R, C>}\n   */\n  /* c8 ignore next 3 */\n  associate(edit, _shift, path, key, value, addedLeaf) {\n    return associateCollision(this, edit, path, key, value, addedLeaf);\n  }\n\n  /**\n   * @param {API.Edit|null} edit\n   * @param {API.Uint32} _shift\n   * @param {ReturnType<C['Path']['from']>} path\n   * @param {K} key\n   * @param {{value:boolean}} removedLeaf\n   * @returns {API.Node<T, K, C>}\n   */\n  /* c8 ignore next 3 */\n  dissociate(edit, _shift, path, key, removedLeaf) {\n    return dissociateCollision(this, edit, path, key, removedLeaf);\n  }\n\n  /**\n   * @param {API.Edit|null} edit\n   * @returns {this}\n   */\n  /* c8 ignore next 3 */\n  fork(edit = null) {\n    return /** @type {this} */forkCollision(this, edit);\n  }\n\n  /**\n   * @returns {IterableIterator<[K, T]>}\n   */\n  /* c8 ignore next 3 */\n  entries() {\n    return entries(this);\n  }\n\n  /**\n   * @returns {IterableIterator<K>}\n   */\n  /* c8 ignore next 3 */\n  keys() {\n    return keys(this);\n  }\n\n  /**\n   * @returns {IterableIterator<T>}\n   */\n  /* c8 ignore next 3 */\n  values() {\n    return values(this);\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @template X\n * @param {API.HashCollisionNode<T, K, C>} node\n * @param {K} name\n * @param {X} notFound\n * @returns {T|X}\n */\n/* c8 ignore next 8 */\nexport const lookupCollision = (node, name, notFound) => {\n  const {\n    children: entries,\n    count\n  } = node;\n  // find where entry with this name belongs\n  const n = findHashCollisionNodeIndex(entries, count, name);\n  // if entry name at this index matches given name return the value otherwise\n  // return `notFound` as we have no such entry.\n  return entries[n] === name ? ( /** @type {T} */entries[n + 1]) : notFound;\n};\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @template {string} R\n * @param {API.HashCollisionNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {ReturnType<C['Path']['from']>} key\n * @param {K|R} name\n * @param {T} value\n * @param {{value:boolean}} addedLeaf\n * @returns {API.HashCollisionNode<T, K | R, C>}\n */\n/* c8 ignore next 26 */\nexport const associateCollision = (node, edit, key, name, value, addedLeaf) => {\n  const {\n    children,\n    count\n  } = node;\n  const index = findHashCollisionNodeIndex(children, count, name);\n  // If entry at this index has a different name we fork the node and\n  // add a new entry.\n  if (children[index] !== name) {\n    const newNode = node.fork(edit);\n    addedLeaf.value = true;\n    newNode.count += 1;\n    newNode.children.splice(index, key, value);\n    return newNode;\n  }\n  // If name is the same but value is not we fork the node and update\n  // the value\n  else if (children[index + 1] !== value) {\n    const newNode = node.fork(edit);\n    newNode.children[index + 1] = value;\n    return newNode;\n  }\n  // If we got this far entry with this exact name and value is already\n  // present making this a noop, so we return this node back.\n  else {\n    return node;\n  }\n};\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.HashCollisionNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {ReturnType<C['Path']['from']>} hash\n * @param {K} name\n * @param {{value:boolean}} removedLeaf\n * @returns {API.Node<T, K, C>}\n */\n/* c8 ignore next 37 */\nexport const dissociateCollision = (node, edit, hash, name, removedLeaf) => {\n  const {\n    children: entries,\n    count,\n    config\n  } = node;\n  const index = findHashCollisionNodeIndex(entries, count, name);\n  // If there is no entry with a the given name this is noop so we just\n  // return back this node.\n  if (entries[index] !== name) {\n    return node;\n  } else {\n    removedLeaf.value = true;\n    // If conflict contained only two entries removing one of them would\n    // leave us with no conflict which is why we create a new node with a\n    // an entry other than one that would correspond provided name\n    if (count === 2) {\n      const offset = index === 0 ? 2 : 0;\n      return /** @type {API.BitmapIndexedNode<T, K, C>} */(\n        associate(create(config), edit, 0, hash, /** @type {K} */entries[offset], /** @type {T} */entries[offset + 1], removedLeaf)\n      );\n    }\n    // otherwise we got this far we have more than two colliding entries in\n    // which case we simply remove one corresponding to given `name`.\n    //\n    else {\n      const newNode = node.fork(edit);\n      newNode.children.splice(index, 2);\n      newNode.count -= 1;\n      return newNode;\n    }\n  }\n};\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.HashCollisionNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @returns {API.HashCollisionNode<T, K, C>}\n */\n/* c8 ignore next 12 */\nexport const forkCollision = (node, edit = null) => {\n  if (canEdit(node.edit, edit)) {\n    return node;\n  } else {\n    return new HashCollisionNode(edit, node.count, /** @type {API.CollisionEntries<T, K>} */node.children.slice(), node.config);\n  }\n};\n\n/**\n * Finds the index inside collision entries where given `key` belongs, which is\n * index where `key <= entries[index]` is `true`. If no index satisfies this\n * constraint index will be `entries.length` indicating that key belongs in the\n * last position.\n *\n * @template T\n * @template {string} K\n * @param {API.CollisionEntries<T, K>} entries\n * @param {number} count\n * @param {K} key\n */\n/* c8 ignore next 8 */\nconst findHashCollisionNodeIndex = (entries, count, key) => {\n  let index = 0;\n  // increase index until we find a index where key <= entries[index]\n  while (index < count && entries[index] > key) {\n    index += 2;\n  }\n  return index;\n};\nconst defaultConfig = {\n  bitWidth: 32,\n  BitField,\n  Path\n};\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.Edit|null} [edit]\n * @param {C} config\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nexport const create = (config, edit = null) => new BitmapIndexedNode(edit, config.BitField.empty(Math.pow(2, config.bitWidth)), config.BitField.empty(Math.pow(2, config.bitWidth)), /** @type {API.Children<T, K, C>} */[], config);\n\n/**\n * @template T, U\n * @template {string} K\n * @param {API.BitmapIndexedNode<T, K>} node\n * @param {K} key\n * @param {U} notFound\n */\nexport const get = (node, key, notFound) => lookup(node, 0, node.config.Path.from(key), key, notFound);\n\n/**\n * @template T, U\n * @template {string} K\n * @template Bits, BitMap\n * @param {API.BitmapIndexedNode<T, K, API.Config<Bits, BitMap>>} node\n * @param {API.Uint32} depth\n * @param {Bits} path\n * @param {K} key\n * @param {U} notFound\n * @returns {T|U}\n */\nexport const lookup = (node, depth, path, key, notFound) => {\n  const {\n    datamap,\n    nodemap,\n    config\n  } = node;\n  const {\n    Path,\n    BitField\n  } = config;\n  const offset = Path.at(path, depth);\n\n  // If bit is set in the data bitmap we have some key, value under the\n  // matching hash segment.\n  if (BitField.get(datamap, offset)) {\n    const index = BitField.popcount(datamap, offset);\n    // If key matches actual key in the map we found the the value\n    // otherwise we did not.\n    if (keyAt(node, index) === key) {\n      return valueAt(node, index);\n    } else {\n      return notFound;\n    }\n  }\n  // If bit is set in the node bitmapt we have a node under the\n  // matching hash segment.\n  else if (BitField.get(nodemap, offset)) {\n    // Resolve node and continue lookup within it.\n    const child = resolveNode(node, offset);\n    return child.lookup(depth + 1, path, key, notFound);\n  }\n  // If we have neither node nor key-pair for this hash segment\n  // we return notFound.\n  else {\n    return notFound;\n  }\n};\n\n/**\n * @template T, U\n * @template {string} K\n * @template {string} R\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {R} key\n * @param {T} value\n * @param {{ value: boolean }} addedLeaf\n * @returns {API.BitmapIndexedNode<T, K|R, C>}\n */\nexport const set = (node, edit, key, value, addedLeaf) => associate(node, edit, 0, node.config.Path.from(key), key, value, addedLeaf);\n\n/**\n * @template T\n * @template {string} K\n * @template {string} R\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {API.Uint32} depth\n * @param {ReturnType<C['Path']['from']>} path\n * @param {K|R} key\n * @param {T} value\n * @param {{value:boolean}} addedLeaf\n * @returns {API.BitmapIndexedNode<T, K | R, C>}\n */\nexport const associate = (node, edit, depth, path, key, value, addedLeaf) => {\n  const {\n    datamap,\n    nodemap,\n    config\n  } = node;\n  const {\n    Path,\n    BitField\n  } = config;\n  const offset = Path.at(path, depth);\n  // If bit is set in the data bitmap we have some key, value under the\n  // matching hash segment.\n  if (BitField.get(datamap, offset)) {\n    const index = BitField.popcount(datamap, offset);\n    const found = keyAt(node, index);\n    // If we have entry with given name and value is the same return node\n    // as is, otherwise fork node and set the value.\n    if (key === found) {\n      return valueAt(node, index) === value ? node : forkAndSet(node, edit, index, value);\n    }\n    // Otherwise we need to create a branch to contain current key, value and\n    // one been passed.\n    else {\n      const branch = mergeTwoLeaves(config, edit, depth + 1, Path.from(found), found, valueAt(node, index), path, key, value);\n      addedLeaf.value = true;\n      return migrateLeafToBranch(node, edit, offset, branch);\n    }\n  }\n  // If bit is set in the node bitmap we have a branch under the current\n  // hash slice.\n  else if (BitField.get(nodemap, offset)) {\n    const child = resolveNode(node, offset);\n    const newChild = child.associate(edit, depth + 1, path, key, value, addedLeaf);\n    if (child === newChild) {\n      return node;\n    } else {\n      return copyAndSetChild(node, edit, offset, newChild);\n    }\n  }\n  // If we have neither node nor a key-value for this hash segment. We copy\n  // current children and add new key-value pair\n  else {\n    const index = BitField.popcount(datamap, offset);\n    addedLeaf.value = true;\n\n    /** @type {API.BitmapIndexedNode<T, K|R, C>} */\n    const newNode = node.fork(edit);\n\n    // Capture new entry in the data bitmap\n    newNode.datamap = BitField.set(datamap, offset);\n    newNode.children.splice(keyPosition(index), 0, key, value);\n    return newNode;\n  }\n};\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {K} key\n * @param {{ value: boolean }} removedLeaf\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nconst remove = (node, edit, key, removedLeaf) => dissociate(node, edit, 0, node.config.Path.from(key), key, removedLeaf);\nexport { remove as delete };\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} source\n * @param {API.Edit|null} edit\n * @param {API.Uint32} depth\n * @param {ReturnType<C['Path']['from']>} path\n * @param {K} key\n * @param {{value:boolean}} removedLeaf\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nexport const dissociate = (source, edit, depth, path, key, removedLeaf) => {\n  const {\n    datamap,\n    nodemap,\n    config\n  } = source;\n  const {\n    BitField,\n    Path\n  } = config;\n  const offset = Path.at(path, depth);\n  // If bit is set in the data bitmap we have an entry under the\n  // matching hash segment.\n  if (BitField.get(datamap, offset)) {\n    const index = BitField.popcount(datamap, offset);\n    // If key at a given index matches given `name` we fork a node and remove\n    // the entry\n    if (key === keyAt(source, index)) {\n      removedLeaf.value = true;\n      const node = fork(source, edit);\n      // Update the bitmap\n      node.datamap = BitField.unset(source.datamap, offset);\n      // remove the child\n      node.children.splice(keyPosition(index), 2);\n      return node;\n    }\n    // otherwise we don't have such entry so we return node back as is.\n    else {\n      return source;\n    }\n  }\n  // If bit is set in the node bitmapt we have a node under the\n  // matching hash segment.\n  else if (BitField.get(nodemap, offset)) {\n    const node = resolveNode(source, offset);\n    const child = node.dissociate(edit, depth + 1, path, key, removedLeaf);\n    // if child has a single element we need to canonicalize\n    if (hasSingleLeaf(child)) {\n      // if source has a single child, we collapse and return the child\n      // otherwise we inline the child.\n      return hasSingleNode(source) ? child : inlineChild(source, edit, offset, child);\n    } else if (node === child) {\n      return source;\n    } else {\n      return copyAndSetChild(source, edit, offset, child);\n    }\n  }\n  // If we have neither node nor a key-value for this hash segment this is a\n  // noop.\n  else {\n    return source;\n  }\n};\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.Node<T, K, C>} node\n * @returns {IterableIterator<[K, T]>}\n */\nexport const entries = function* ({\n  children\n}) {\n  let offset = 0;\n  const count = children.length;\n  while (offset < count) {\n    const key = children[offset];\n    if (typeof key === \"string\") {\n      offset += 1;\n      const value = children[offset];\n      yield ( /** @type {[K, T]} */[key, value]);\n      offset += 1;\n    } else {\n      break;\n    }\n  }\n  while (offset < count) {\n    const node = /** @type {API.BitmapIndexedNode<T, K, C>} */\n    children[offset];\n    yield* node.entries();\n    offset += 1;\n  }\n};\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nexport const fork = (node, edit) => {\n  if (canEdit(node.edit, edit)) {\n    return node;\n  } else {\n    const newNode = new BitmapIndexedNode(edit, node.datamap, node.nodemap, node.children.slice(), node.config);\n    return newNode;\n  }\n};\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.Node<T, K, C>} node\n * @returns {IterableIterator<K>}\n */\nexport const keys = function* ({\n  children\n}) {\n  let offset = 0;\n  const count = children.length;\n  while (offset < count) {\n    const key = children[offset];\n    if (typeof key === \"string\") {\n      yield ( /** @type {K} */key);\n      offset += 2;\n    } else {\n      break;\n    }\n  }\n  while (offset < count) {\n    const node = /** @type {API.BitmapIndexedNode<T, K>} */children[offset];\n    yield* node.keys();\n    offset += 1;\n  }\n};\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.Node<T, K, C>} node\n * @returns {IterableIterator<T>}\n */\nexport const values = function* ({\n  children\n}) {\n  let offset = 0;\n  const count = children.length;\n  while (offset < count) {\n    const key = children[offset];\n    if (typeof key === \"string\") {\n      offset += 1;\n      yield ( /** @type {T} */children[offset]);\n      offset += 1;\n    } else {\n      break;\n    }\n  }\n  while (offset < count) {\n    const node = /** @type {API.BitmapIndexedNode<T, K>} */children[offset];\n    yield* node.values();\n    offset += 1;\n  }\n};\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {number} offset\n * @param {T} value\n */\nexport const forkAndSet = (node, edit, offset, value) => {\n  const newNode = node.fork(edit);\n  newNode.children[valuePosition(offset)] = value;\n  return newNode;\n};\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} source\n * @param {API.Edit|null} edit\n * @param {number} offset\n * @param {API.Node<T, K, C>} child\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nexport const inlineChild = (source, edit, offset, child) => {\n  const {\n    datamap,\n    nodemap,\n    config\n  } = source;\n  const {\n    BitField\n  } = config;\n  const node = fork(source, edit);\n\n  // remove the node that we are inlining\n  node.children.splice(nodePosition(source, offset), 1);\n  // add key-value pair where it wolud fall\n  node.children.splice(keyPosition(BitField.popcount(datamap, offset)), 0, child.children[0], child.children[1]);\n  node.datamap = BitField.set(datamap, offset);\n  node.nodemap = BitField.unset(nodemap, offset);\n  return node;\n};\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {number} offset\n * @param {API.Node<T, K, C>} child\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nexport const copyAndSetChild = (node, edit, offset, child) => {\n  const newNode = fork(node, edit);\n  newNode.children[nodePosition(node, offset)] = child;\n  return newNode;\n};\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} source\n * @param {API.Edit|null} edit\n * @param {number} offset\n * @param {API.Node<T, K, C>} branch\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nexport const migrateLeafToBranch = (source, edit, offset, branch) => {\n  const {\n    nodemap,\n    datamap,\n    config\n  } = source;\n  const {\n    BitField\n  } = config;\n  const index = BitField.popcount(datamap, offset);\n  // Previous id corresponds to the key position\n  const oldId = keyPosition(index);\n  const newId = nodePosition(source, offset);\n  const node = fork(source, edit);\n\n  // remove an old leaf\n  node.datamap = BitField.unset(datamap, offset);\n  node.children.splice(oldId, 2);\n\n  // add a new branch\n  node.nodemap = BitField.set(nodemap, offset);\n  node.children.splice(newId - 1, 0, branch);\n  return node;\n};\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {C} config\n * @param {API.Edit|null} edit\n * @param {number} depth\n * @param {ReturnType<C['Path']['from']>} oldPath\n * @param {K} oldKey\n * @param {T} oldValue\n * @param {ReturnType<C['Path']['from']>} newPath\n * @param {K} newKey\n * @param {T} newValue\n * @returns {API.Node<T, K, C>}\n */\nexport const mergeTwoLeaves = (config, edit, depth, oldPath, oldKey, oldValue, newPath, newKey, newValue) => {\n  const {\n    BitField,\n    Path\n  } = config;\n  // If we have reached end of the path we can no longer create another\n  // `BitmapIndexedNode`, instead we create a node containing (hash) colliding\n  // entries\n  /* c8 ignore next 7 */\n  if (Path.size < depth) {\n    return new HashCollisionNode(edit, 2, [oldKey, oldValue, newKey, newValue], config);\n  } else {\n    const oldOffset = Path.at(oldPath, depth);\n    const newOffset = Path.at(newPath, depth);\n    // If offsets still match create another intermediery node and merge these\n    // two nodes at next depth level.\n    if (oldOffset === newOffset) {\n      return new BitmapIndexedNode(edit, BitField.empty(Math.pow(2, config.bitWidth)), BitField.from([oldOffset], Math.pow(2, config.bitWidth)), [mergeTwoLeaves(config, edit, depth + 1, oldPath, oldKey, oldValue, newPath, newKey, newValue)], config);\n    }\n    // otherwise create new node with both key-value pairs as it's children\n    else {\n      return new BitmapIndexedNode(edit, BitField.from([oldOffset, newOffset], Math.pow(2, config.bitWidth)), BitField.empty(Math.pow(2, config.bitWidth)), /** @type {API.Children<T, K, C>} */\n\n      // We insert child with a lower index first so that we can derive it's\n      // index on access via popcount\n      oldOffset < newOffset ? [oldKey, oldValue, newKey, newValue] : [newKey, newValue, oldKey, oldValue], config);\n    }\n  }\n};\n\n/**\n * @template {string} K\n * @param {API.BitmapIndexedNode<unknown, K>} node\n * @param {number} index\n */\nexport const keyAt = ({\n  children\n}, index) => ( /** @type {K} */children[keyPosition(index)]);\n\n/**\n * @param {number} index\n */\nexport const keyPosition = index => index * 2;\n\n/**\n * @template T\n * @param {API.BitmapIndexedNode<T>} node\n * @param {number} index\n */\nexport const valueAt = ({\n  children\n}, index) => ( /** @type {T} */children[valuePosition(index)]);\n\n/**\n * @param {number} index\n */\nexport const valuePosition = index => index * 2 + 1;\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {number} offset\n * @returns {API.BitmapIndexedNode<T, K, C>|API.HashCollisionNode<T, K, C>}\n */\nexport const resolveNode = (node, offset) => ( /** @type {API.BitmapIndexedNode<T, K, C>|API.HashCollisionNode<T, K, C>} */\nnode.children[nodePosition(node, offset)]);\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {number} offset\n */\nconst nodePosition = ({\n  children,\n  nodemap,\n  config\n}, offset) => children.length - 1 - config.BitField.popcount(nodemap, offset);\n\n/**\n * @param {API.Edit|null} owner\n * @param {API.Edit|null} editor\n */\nconst canEdit = (owner, editor) => owner != null && owner === editor;\n\n/**\n * Returns `true` if node has a single entry. It also refines type to\n * `BitmapIndexedNode` because `HashCollisionNode` is normalized to\n * `BitmapIndexedNode` when it contains only a single entry.\n *\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.Node<T, K, C>} node\n * @returns {node is API.BitmapIndexedNode<T, K, C>}\n */\nconst hasSingleLeaf = node => node.nodeArity === 0 && node.dataArity === 1;\n\n/**\n * Returns `true` if node has a single childe node and 0 child leaves.\n *\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @returns {node is API.BitmapIndexedNode<T, K, C>}\n */\nconst hasSingleNode = ({\n  config: {\n    BitField\n  },\n  datamap,\n  nodemap\n}) => BitField.popcount(datamap) === 0 && BitField.popcount(nodemap) === 1;","map":{"version":3,"names":["API","BitField","Path","BitmapIndexedNode","constructor","edit","datamap","nodemap","children","config","nodeArity","popcount","dataArity","empty","create","lookup","depth","path","key","notFound","associate","value","addedLeaf","dissociate","removedLeaf","fork","entries","keys","values","HashCollisionNode","count","_shift","_path","lookupCollision","associateCollision","dissociateCollision","forkCollision","node","name","n","findHashCollisionNodeIndex","index","newNode","splice","hash","offset","canEdit","slice","defaultConfig","bitWidth","Math","pow","get","from","at","keyAt","valueAt","child","resolveNode","set","found","forkAndSet","branch","mergeTwoLeaves","migrateLeafToBranch","newChild","copyAndSetChild","keyPosition","remove","delete","source","unset","hasSingleLeaf","hasSingleNode","inlineChild","length","valuePosition","nodePosition","oldId","newId","oldPath","oldKey","oldValue","newPath","newKey","newValue","size","oldOffset","newOffset","owner","editor"],"sources":["C:/FACULTATE/Proiect/node_modules/@perma/map/src/node.js"],"sourcesContent":["import * as API from \"./api.js\"\nexport * from \"./api.js\"\nimport * as BitField from \"./bitfield/Uint32.js\"\nimport * as Path from \"./path/Uint32.js\"\nexport { API }\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @implements {API.BitmapIndexedNode<T, K, C>}\n */\nclass BitmapIndexedNode {\n  /**\n   * @param {API.Edit|null} edit\n   * @param {ReturnType<C['BitField']['empty']>} datamap\n   * @param {ReturnType<C['BitField']['empty']>} nodemap\n   * @param {API.Children<T, K, C>} children\n   * @param {C} config\n   */\n  constructor(edit, datamap, nodemap, children, config) {\n    this.edit = edit\n    this.config = config\n    this.datamap = datamap\n    this.nodemap = nodemap\n    this.children = children\n  }\n\n  get nodeArity() {\n    return this.config.BitField.popcount(this.nodemap)\n  }\n  get dataArity() {\n    return this.config.BitField.popcount(this.datamap)\n  }\n\n  /**\n   * @returns {API.BitmapIndexedNode<T, K, C>}\n   */\n  /* c8 ignore next 3 */\n  empty() {\n    return create(this.config)\n  }\n\n  /**\n   * @template X\n   * @param {API.Uint32} depth\n   * @param {ReturnType<C['Path']['from']>} path\n   * @param {K} key\n   * @param {X} notFound\n   * @returns {T|X}\n   */\n\n  lookup(depth, path, key, notFound) {\n    return lookup(this, depth, path, key, notFound)\n  }\n\n  /**\n   * @template {string} R\n   * @param {API.Edit|null} edit\n   * @param {API.Uint32} depth\n   * @param {ReturnType<C['Path']['from']>} path\n   * @param {K|R} key\n   * @param {T} value\n   * @param {{value:boolean}} addedLeaf\n   * @returns {API.BitmapIndexedNode<T, K | R, C>}\n   */\n  associate(edit, depth, path, key, value, addedLeaf) {\n    return associate(this, edit, depth, path, key, value, addedLeaf)\n  }\n\n  /**\n   * @param {API.Edit|null} edit\n   * @param {API.Uint32} depth\n   * @param {ReturnType<C['Path']['from']>} path\n   * @param {K} key\n   * @param {{value:boolean}} removedLeaf\n   * @returns {API.BitmapIndexedNode<T, K, C>}\n   */\n  dissociate(edit, depth, path, key, removedLeaf) {\n    return dissociate(this, edit, depth, path, key, removedLeaf)\n  }\n\n  /**\n   * @param {API.Edit|null} edit\n   * @returns {API.BitmapIndexedNode<T, K, C>}\n   */\n  fork(edit = null) {\n    return fork(this, edit)\n  }\n\n  /**\n   * @returns {IterableIterator<[K, T]>}\n   */\n  entries() {\n    return entries(this)\n  }\n\n  /**\n   * @returns {IterableIterator<K>}\n   */\n  keys() {\n    return keys(this)\n  }\n\n  /**\n   * @returns {IterableIterator<T>}\n   */\n  values() {\n    return values(this)\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @implements {API.HashCollisionNode<T, K, C>}\n */\nclass HashCollisionNode {\n  /**\n   * @param {API.Edit|null} edit\n   * @param {number} count\n   * @param {API.CollisionEntries<T, K>} children\n   * @param {C} config\n   */\n  /* c8 ignore next 12 */\n  constructor(edit, count, children, config) {\n    this.edit = edit\n    this.count = count\n    this.children = children\n    this.config = config\n  }\n  get nodeArity() {\n    return /** @type {0} */ (0)\n  }\n  get dataArity() {\n    return this.count\n  }\n\n  /**\n   * @template X\n   * @param {API.Uint32} _shift\n   * @param {unknown} _path\n   * @param {K} key\n   * @param {X} notFound\n   * @returns {T|X}\n   */\n  /* c8 ignore next 3 */\n  lookup(_shift, _path, key, notFound) {\n    return lookupCollision(this, key, notFound)\n  }\n\n  /**\n   * @template {string} R\n   * @param {API.Edit|null} edit\n   * @param {API.Uint32} _shift\n   * @param {ReturnType<C['Path']['from']>} path\n   * @param {K|R} key\n   * @param {T} value\n   * @param {{value:boolean}} addedLeaf\n   * @returns {API.HashCollisionNode<T, K | R, C>}\n   */\n  /* c8 ignore next 3 */\n  associate(edit, _shift, path, key, value, addedLeaf) {\n    return associateCollision(this, edit, path, key, value, addedLeaf)\n  }\n\n  /**\n   * @param {API.Edit|null} edit\n   * @param {API.Uint32} _shift\n   * @param {ReturnType<C['Path']['from']>} path\n   * @param {K} key\n   * @param {{value:boolean}} removedLeaf\n   * @returns {API.Node<T, K, C>}\n   */\n  /* c8 ignore next 3 */\n  dissociate(edit, _shift, path, key, removedLeaf) {\n    return dissociateCollision(this, edit, path, key, removedLeaf)\n  }\n\n  /**\n   * @param {API.Edit|null} edit\n   * @returns {this}\n   */\n  /* c8 ignore next 3 */\n  fork(edit = null) {\n    return /** @type {this} */ (forkCollision(this, edit))\n  }\n\n  /**\n   * @returns {IterableIterator<[K, T]>}\n   */\n  /* c8 ignore next 3 */\n  entries() {\n    return entries(this)\n  }\n\n  /**\n   * @returns {IterableIterator<K>}\n   */\n  /* c8 ignore next 3 */\n  keys() {\n    return keys(this)\n  }\n\n  /**\n   * @returns {IterableIterator<T>}\n   */\n  /* c8 ignore next 3 */\n  values() {\n    return values(this)\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @template X\n * @param {API.HashCollisionNode<T, K, C>} node\n * @param {K} name\n * @param {X} notFound\n * @returns {T|X}\n */\n/* c8 ignore next 8 */\nexport const lookupCollision = (node, name, notFound) => {\n  const { children: entries, count } = node\n  // find where entry with this name belongs\n  const n = findHashCollisionNodeIndex(entries, count, name)\n  // if entry name at this index matches given name return the value otherwise\n  // return `notFound` as we have no such entry.\n  return entries[n] === name ? /** @type {T} */ (entries[n + 1]) : notFound\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @template {string} R\n * @param {API.HashCollisionNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {ReturnType<C['Path']['from']>} key\n * @param {K|R} name\n * @param {T} value\n * @param {{value:boolean}} addedLeaf\n * @returns {API.HashCollisionNode<T, K | R, C>}\n */\n/* c8 ignore next 26 */\nexport const associateCollision = (node, edit, key, name, value, addedLeaf) => {\n  const { children, count } = node\n\n  const index = findHashCollisionNodeIndex(children, count, name)\n  // If entry at this index has a different name we fork the node and\n  // add a new entry.\n  if (children[index] !== name) {\n    const newNode = node.fork(edit)\n    addedLeaf.value = true\n    newNode.count += 1\n    newNode.children.splice(index, key, value)\n    return newNode\n  }\n  // If name is the same but value is not we fork the node and update\n  // the value\n  else if (children[index + 1] !== value) {\n    const newNode = node.fork(edit)\n    newNode.children[index + 1] = value\n    return newNode\n  }\n  // If we got this far entry with this exact name and value is already\n  // present making this a noop, so we return this node back.\n  else {\n    return node\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.HashCollisionNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {ReturnType<C['Path']['from']>} hash\n * @param {K} name\n * @param {{value:boolean}} removedLeaf\n * @returns {API.Node<T, K, C>}\n */\n/* c8 ignore next 37 */\nexport const dissociateCollision = (node, edit, hash, name, removedLeaf) => {\n  const { children: entries, count, config } = node\n  const index = findHashCollisionNodeIndex(entries, count, name)\n  // If there is no entry with a the given name this is noop so we just\n  // return back this node.\n  if (entries[index] !== name) {\n    return node\n  } else {\n    removedLeaf.value = true\n    // If conflict contained only two entries removing one of them would\n    // leave us with no conflict which is why we create a new node with a\n    // an entry other than one that would correspond provided name\n    if (count === 2) {\n      const offset = index === 0 ? 2 : 0\n      return /** @type {API.BitmapIndexedNode<T, K, C>} */ (\n        associate(\n          create(config),\n          edit,\n          0,\n          hash,\n          /** @type {K} */ (entries[offset]),\n          /** @type {T} */ (entries[offset + 1]),\n          removedLeaf\n        )\n      )\n    }\n    // otherwise we got this far we have more than two colliding entries in\n    // which case we simply remove one corresponding to given `name`.\n    //\n    else {\n      const newNode = node.fork(edit)\n      newNode.children.splice(index, 2)\n      newNode.count -= 1\n      return newNode\n    }\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.HashCollisionNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @returns {API.HashCollisionNode<T, K, C>}\n */\n/* c8 ignore next 12 */\nexport const forkCollision = (node, edit = null) => {\n  if (canEdit(node.edit, edit)) {\n    return node\n  } else {\n    return new HashCollisionNode(\n      edit,\n      node.count,\n      /** @type {API.CollisionEntries<T, K>} */ (node.children.slice()),\n      node.config\n    )\n  }\n}\n\n/**\n * Finds the index inside collision entries where given `key` belongs, which is\n * index where `key <= entries[index]` is `true`. If no index satisfies this\n * constraint index will be `entries.length` indicating that key belongs in the\n * last position.\n *\n * @template T\n * @template {string} K\n * @param {API.CollisionEntries<T, K>} entries\n * @param {number} count\n * @param {K} key\n */\n/* c8 ignore next 8 */\nconst findHashCollisionNodeIndex = (entries, count, key) => {\n  let index = 0\n  // increase index until we find a index where key <= entries[index]\n  while (index < count && entries[index] > key) {\n    index += 2\n  }\n  return index\n}\n\nconst defaultConfig = { bitWidth: 32, BitField, Path }\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.Edit|null} [edit]\n * @param {C} config\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nexport const create = (config, edit = null) =>\n  new BitmapIndexedNode(\n    edit,\n    config.BitField.empty(Math.pow(2, config.bitWidth)),\n    config.BitField.empty(Math.pow(2, config.bitWidth)),\n    /** @type {API.Children<T, K, C>} */ ([]),\n    config\n  )\n\n/**\n * @template T, U\n * @template {string} K\n * @param {API.BitmapIndexedNode<T, K>} node\n * @param {K} key\n * @param {U} notFound\n */\nexport const get = (node, key, notFound) =>\n  lookup(node, 0, node.config.Path.from(key), key, notFound)\n\n/**\n * @template T, U\n * @template {string} K\n * @template Bits, BitMap\n * @param {API.BitmapIndexedNode<T, K, API.Config<Bits, BitMap>>} node\n * @param {API.Uint32} depth\n * @param {Bits} path\n * @param {K} key\n * @param {U} notFound\n * @returns {T|U}\n */\nexport const lookup = (node, depth, path, key, notFound) => {\n  const { datamap, nodemap, config } = node\n  const { Path, BitField } = config\n  const offset = Path.at(path, depth)\n\n  // If bit is set in the data bitmap we have some key, value under the\n  // matching hash segment.\n  if (BitField.get(datamap, offset)) {\n    const index = BitField.popcount(datamap, offset)\n    // If key matches actual key in the map we found the the value\n    // otherwise we did not.\n    if (keyAt(node, index) === key) {\n      return valueAt(node, index)\n    } else {\n      return notFound\n    }\n  }\n  // If bit is set in the node bitmapt we have a node under the\n  // matching hash segment.\n  else if (BitField.get(nodemap, offset)) {\n    // Resolve node and continue lookup within it.\n    const child = resolveNode(node, offset)\n    return child.lookup(depth + 1, path, key, notFound)\n  }\n  // If we have neither node nor key-pair for this hash segment\n  // we return notFound.\n  else {\n    return notFound\n  }\n}\n\n/**\n * @template T, U\n * @template {string} K\n * @template {string} R\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {R} key\n * @param {T} value\n * @param {{ value: boolean }} addedLeaf\n * @returns {API.BitmapIndexedNode<T, K|R, C>}\n */\nexport const set = (node, edit, key, value, addedLeaf) =>\n  associate(node, edit, 0, node.config.Path.from(key), key, value, addedLeaf)\n\n/**\n * @template T\n * @template {string} K\n * @template {string} R\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {API.Uint32} depth\n * @param {ReturnType<C['Path']['from']>} path\n * @param {K|R} key\n * @param {T} value\n * @param {{value:boolean}} addedLeaf\n * @returns {API.BitmapIndexedNode<T, K | R, C>}\n */\nexport const associate = (node, edit, depth, path, key, value, addedLeaf) => {\n  const { datamap, nodemap, config } = node\n  const { Path, BitField } = config\n  const offset = Path.at(path, depth)\n  // If bit is set in the data bitmap we have some key, value under the\n  // matching hash segment.\n  if (BitField.get(datamap, offset)) {\n    const index = BitField.popcount(datamap, offset)\n    const found = keyAt(node, index)\n    // If we have entry with given name and value is the same return node\n    // as is, otherwise fork node and set the value.\n    if (key === found) {\n      return valueAt(node, index) === value\n        ? node\n        : forkAndSet(node, edit, index, value)\n    }\n    // Otherwise we need to create a branch to contain current key, value and\n    // one been passed.\n    else {\n      const branch = mergeTwoLeaves(\n        config,\n        edit,\n        depth + 1,\n        Path.from(found),\n        found,\n        valueAt(node, index),\n        path,\n        key,\n        value\n      )\n      addedLeaf.value = true\n\n      return migrateLeafToBranch(node, edit, offset, branch)\n    }\n  }\n  // If bit is set in the node bitmap we have a branch under the current\n  // hash slice.\n  else if (BitField.get(nodemap, offset)) {\n    const child = resolveNode(node, offset)\n    const newChild = child.associate(\n      edit,\n      depth + 1,\n      path,\n      key,\n      value,\n      addedLeaf\n    )\n\n    if (child === newChild) {\n      return node\n    } else {\n      return copyAndSetChild(node, edit, offset, newChild)\n    }\n  }\n  // If we have neither node nor a key-value for this hash segment. We copy\n  // current children and add new key-value pair\n  else {\n    const index = BitField.popcount(datamap, offset)\n    addedLeaf.value = true\n\n    /** @type {API.BitmapIndexedNode<T, K|R, C>} */\n    const newNode = node.fork(edit)\n\n    // Capture new entry in the data bitmap\n    newNode.datamap = BitField.set(datamap, offset)\n    newNode.children.splice(keyPosition(index), 0, key, value)\n    return newNode\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {K} key\n * @param {{ value: boolean }} removedLeaf\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nconst remove = (node, edit, key, removedLeaf) =>\n  dissociate(node, edit, 0, node.config.Path.from(key), key, removedLeaf)\n\nexport { remove as delete }\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} source\n * @param {API.Edit|null} edit\n * @param {API.Uint32} depth\n * @param {ReturnType<C['Path']['from']>} path\n * @param {K} key\n * @param {{value:boolean}} removedLeaf\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nexport const dissociate = (source, edit, depth, path, key, removedLeaf) => {\n  const { datamap, nodemap, config } = source\n  const { BitField, Path } = config\n  const offset = Path.at(path, depth)\n  // If bit is set in the data bitmap we have an entry under the\n  // matching hash segment.\n  if (BitField.get(datamap, offset)) {\n    const index = BitField.popcount(datamap, offset)\n    // If key at a given index matches given `name` we fork a node and remove\n    // the entry\n    if (key === keyAt(source, index)) {\n      removedLeaf.value = true\n      const node = fork(source, edit)\n      // Update the bitmap\n      node.datamap = BitField.unset(source.datamap, offset)\n      // remove the child\n      node.children.splice(keyPosition(index), 2)\n      return node\n    }\n    // otherwise we don't have such entry so we return node back as is.\n    else {\n      return source\n    }\n  }\n  // If bit is set in the node bitmapt we have a node under the\n  // matching hash segment.\n  else if (BitField.get(nodemap, offset)) {\n    const node = resolveNode(source, offset)\n    const child = node.dissociate(edit, depth + 1, path, key, removedLeaf)\n    // if child has a single element we need to canonicalize\n    if (hasSingleLeaf(child)) {\n      // if source has a single child, we collapse and return the child\n      // otherwise we inline the child.\n      return hasSingleNode(source)\n        ? child\n        : inlineChild(source, edit, offset, child)\n    } else if (node === child) {\n      return source\n    } else {\n      return copyAndSetChild(source, edit, offset, child)\n    }\n  }\n  // If we have neither node nor a key-value for this hash segment this is a\n  // noop.\n  else {\n    return source\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.Node<T, K, C>} node\n * @returns {IterableIterator<[K, T]>}\n */\nexport const entries = function* ({ children }) {\n  let offset = 0\n  const count = children.length\n  while (offset < count) {\n    const key = children[offset]\n    if (typeof key === \"string\") {\n      offset += 1\n      const value = children[offset]\n      yield /** @type {[K, T]} */ ([key, value])\n      offset += 1\n    } else {\n      break\n    }\n  }\n\n  while (offset < count) {\n    const node = /** @type {API.BitmapIndexedNode<T, K, C>} */ (\n      children[offset]\n    )\n    yield* node.entries()\n    offset += 1\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nexport const fork = (node, edit) => {\n  if (canEdit(node.edit, edit)) {\n    return node\n  } else {\n    const newNode = new BitmapIndexedNode(\n      edit,\n      node.datamap,\n      node.nodemap,\n      node.children.slice(),\n      node.config\n    )\n    return newNode\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.Node<T, K, C>} node\n * @returns {IterableIterator<K>}\n */\nexport const keys = function* ({ children }) {\n  let offset = 0\n  const count = children.length\n  while (offset < count) {\n    const key = children[offset]\n    if (typeof key === \"string\") {\n      yield /** @type {K} */ (key)\n      offset += 2\n    } else {\n      break\n    }\n  }\n\n  while (offset < count) {\n    const node = /** @type {API.BitmapIndexedNode<T, K>} */ (children[offset])\n    yield* node.keys()\n    offset += 1\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.Node<T, K, C>} node\n * @returns {IterableIterator<T>}\n */\nexport const values = function* ({ children }) {\n  let offset = 0\n  const count = children.length\n  while (offset < count) {\n    const key = children[offset]\n    if (typeof key === \"string\") {\n      offset += 1\n      yield /** @type {T} */ (children[offset])\n      offset += 1\n    } else {\n      break\n    }\n  }\n\n  while (offset < count) {\n    const node = /** @type {API.BitmapIndexedNode<T, K>} */ (children[offset])\n    yield* node.values()\n    offset += 1\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {number} offset\n * @param {T} value\n */\nexport const forkAndSet = (node, edit, offset, value) => {\n  const newNode = node.fork(edit)\n  newNode.children[valuePosition(offset)] = value\n  return newNode\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} source\n * @param {API.Edit|null} edit\n * @param {number} offset\n * @param {API.Node<T, K, C>} child\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nexport const inlineChild = (source, edit, offset, child) => {\n  const { datamap, nodemap, config } = source\n  const { BitField } = config\n  const node = fork(source, edit)\n\n  // remove the node that we are inlining\n  node.children.splice(nodePosition(source, offset), 1)\n  // add key-value pair where it wolud fall\n  node.children.splice(\n    keyPosition(BitField.popcount(datamap, offset)),\n    0,\n    child.children[0],\n    child.children[1]\n  )\n\n  node.datamap = BitField.set(datamap, offset)\n  node.nodemap = BitField.unset(nodemap, offset)\n\n  return node\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {number} offset\n * @param {API.Node<T, K, C>} child\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nexport const copyAndSetChild = (node, edit, offset, child) => {\n  const newNode = fork(node, edit)\n  newNode.children[nodePosition(node, offset)] = child\n  return newNode\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} source\n * @param {API.Edit|null} edit\n * @param {number} offset\n * @param {API.Node<T, K, C>} branch\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nexport const migrateLeafToBranch = (source, edit, offset, branch) => {\n  const { nodemap, datamap, config } = source\n  const { BitField } = config\n  const index = BitField.popcount(datamap, offset)\n  // Previous id corresponds to the key position\n  const oldId = keyPosition(index)\n  const newId = nodePosition(source, offset)\n\n  const node = fork(source, edit)\n\n  // remove an old leaf\n  node.datamap = BitField.unset(datamap, offset)\n  node.children.splice(oldId, 2)\n\n  // add a new branch\n  node.nodemap = BitField.set(nodemap, offset)\n  node.children.splice(newId - 1, 0, branch)\n\n  return node\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {C} config\n * @param {API.Edit|null} edit\n * @param {number} depth\n * @param {ReturnType<C['Path']['from']>} oldPath\n * @param {K} oldKey\n * @param {T} oldValue\n * @param {ReturnType<C['Path']['from']>} newPath\n * @param {K} newKey\n * @param {T} newValue\n * @returns {API.Node<T, K, C>}\n */\nexport const mergeTwoLeaves = (\n  config,\n  edit,\n  depth,\n  oldPath,\n  oldKey,\n  oldValue,\n  newPath,\n  newKey,\n  newValue\n) => {\n  const { BitField, Path } = config\n  // If we have reached end of the path we can no longer create another\n  // `BitmapIndexedNode`, instead we create a node containing (hash) colliding\n  // entries\n  /* c8 ignore next 7 */\n  if (Path.size < depth) {\n    return new HashCollisionNode(\n      edit,\n      2,\n      [oldKey, oldValue, newKey, newValue],\n      config\n    )\n  } else {\n    const oldOffset = Path.at(oldPath, depth)\n    const newOffset = Path.at(newPath, depth)\n    // If offsets still match create another intermediery node and merge these\n    // two nodes at next depth level.\n    if (oldOffset === newOffset) {\n      return new BitmapIndexedNode(\n        edit,\n        BitField.empty(Math.pow(2, config.bitWidth)),\n        BitField.from([oldOffset], Math.pow(2, config.bitWidth)),\n        [\n          mergeTwoLeaves(\n            config,\n            edit,\n            depth + 1,\n            oldPath,\n            oldKey,\n            oldValue,\n            newPath,\n            newKey,\n            newValue\n          ),\n        ],\n        config\n      )\n    }\n    // otherwise create new node with both key-value pairs as it's children\n    else {\n      return new BitmapIndexedNode(\n        edit,\n        BitField.from([oldOffset, newOffset], Math.pow(2, config.bitWidth)),\n        BitField.empty(Math.pow(2, config.bitWidth)),\n        /** @type {API.Children<T, K, C>} */\n        (\n          // We insert child with a lower index first so that we can derive it's\n          // index on access via popcount\n          oldOffset < newOffset\n            ? [oldKey, oldValue, newKey, newValue]\n            : [newKey, newValue, oldKey, oldValue]\n        ),\n        config\n      )\n    }\n  }\n}\n\n/**\n * @template {string} K\n * @param {API.BitmapIndexedNode<unknown, K>} node\n * @param {number} index\n */\nexport const keyAt = ({ children }, index) =>\n  /** @type {K} */ (children[keyPosition(index)])\n\n/**\n * @param {number} index\n */\nexport const keyPosition = index => index * 2\n\n/**\n * @template T\n * @param {API.BitmapIndexedNode<T>} node\n * @param {number} index\n */\nexport const valueAt = ({ children }, index) =>\n  /** @type {T} */ (children[valuePosition(index)])\n\n/**\n * @param {number} index\n */\nexport const valuePosition = index => index * 2 + 1\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {number} offset\n * @returns {API.BitmapIndexedNode<T, K, C>|API.HashCollisionNode<T, K, C>}\n */\nexport const resolveNode = (node, offset) =>\n  /** @type {API.BitmapIndexedNode<T, K, C>|API.HashCollisionNode<T, K, C>} */ (\n    node.children[nodePosition(node, offset)]\n  )\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {number} offset\n */\nconst nodePosition = ({ children, nodemap, config }, offset) =>\n  children.length - 1 - config.BitField.popcount(nodemap, offset)\n\n/**\n * @param {API.Edit|null} owner\n * @param {API.Edit|null} editor\n */\nconst canEdit = (owner, editor) => owner != null && owner === editor\n\n/**\n * Returns `true` if node has a single entry. It also refines type to\n * `BitmapIndexedNode` because `HashCollisionNode` is normalized to\n * `BitmapIndexedNode` when it contains only a single entry.\n *\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.Node<T, K, C>} node\n * @returns {node is API.BitmapIndexedNode<T, K, C>}\n */\nconst hasSingleLeaf = node => node.nodeArity === 0 && node.dataArity === 1\n\n/**\n * Returns `true` if node has a single childe node and 0 child leaves.\n *\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @returns {node is API.BitmapIndexedNode<T, K, C>}\n */\nconst hasSingleNode = ({ config: { BitField }, datamap, nodemap }) =>\n  BitField.popcount(datamap) === 0 && BitField.popcount(nodemap) === 1\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}