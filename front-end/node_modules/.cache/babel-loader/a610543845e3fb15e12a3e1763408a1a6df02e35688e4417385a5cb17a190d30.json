{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar varint = require('varint');\nvar cid = require('multiformats/cid');\nvar Digest = require('multiformats/hashes/digest');\nvar dagCbor = require('@ipld/dag-cbor');\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\nvar varint__default = /*#__PURE__*/_interopDefaultLegacy(varint);\nvar Digest__namespace = /*#__PURE__*/_interopNamespace(Digest);\nconst CIDV0_BYTES = {\n  SHA2_256: 18,\n  LENGTH: 32,\n  DAG_PB: 112\n};\nasync function readVarint(reader) {\n  const bytes = await reader.upTo(8);\n  const i = varint__default[\"default\"].decode(bytes);\n  reader.seek(varint__default[\"default\"].decode.bytes);\n  return i;\n}\nasync function readHeader(reader) {\n  const length = await readVarint(reader);\n  if (length === 0) {\n    throw new Error('Invalid CAR header (zero length)');\n  }\n  const header = await reader.exactly(length);\n  reader.seek(length);\n  const block = dagCbor.decode(header);\n  if (block == null || Array.isArray(block) || typeof block !== 'object') {\n    throw new Error('Invalid CAR header format');\n  }\n  if (block.version !== 1) {\n    if (typeof block.version === 'string') {\n      throw new Error(`Invalid CAR version: \"${block.version}\"`);\n    }\n    throw new Error(`Invalid CAR version: ${block.version}`);\n  }\n  if (!Array.isArray(block.roots)) {\n    throw new Error('Invalid CAR header format');\n  }\n  if (Object.keys(block).filter(p => p !== 'roots' && p !== 'version').length) {\n    throw new Error('Invalid CAR header format');\n  }\n  return block;\n}\nasync function readMultihash(reader) {\n  const bytes = await reader.upTo(8);\n  varint__default[\"default\"].decode(bytes);\n  const codeLength = varint__default[\"default\"].decode.bytes;\n  const length = varint__default[\"default\"].decode(bytes.subarray(varint__default[\"default\"].decode.bytes));\n  const lengthLength = varint__default[\"default\"].decode.bytes;\n  const mhLength = codeLength + lengthLength + length;\n  const multihash = await reader.exactly(mhLength);\n  reader.seek(mhLength);\n  return multihash;\n}\nasync function readCid(reader) {\n  const first = await reader.exactly(2);\n  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n    const bytes = await reader.exactly(34);\n    reader.seek(34);\n    const multihash = Digest__namespace.decode(bytes);\n    return cid.CID.create(0, CIDV0_BYTES.DAG_PB, multihash);\n  }\n  const version = await readVarint(reader);\n  if (version !== 1) {\n    throw new Error(`Unexpected CID version (${version})`);\n  }\n  const codec = await readVarint(reader);\n  const bytes = await readMultihash(reader);\n  const multihash = Digest__namespace.decode(bytes);\n  return cid.CID.create(version, codec, multihash);\n}\nasync function readBlockHead(reader) {\n  const start = reader.pos;\n  let length = await readVarint(reader);\n  if (length === 0) {\n    throw new Error('Invalid CAR section (zero length)');\n  }\n  length += reader.pos - start;\n  const cid = await readCid(reader);\n  const blockLength = length - (reader.pos - start);\n  return {\n    cid,\n    length,\n    blockLength\n  };\n}\nasync function readBlock(reader) {\n  const {\n    cid,\n    blockLength\n  } = await readBlockHead(reader);\n  const bytes = await reader.exactly(blockLength);\n  reader.seek(blockLength);\n  return {\n    bytes,\n    cid\n  };\n}\nasync function readBlockIndex(reader) {\n  const offset = reader.pos;\n  const {\n    cid,\n    length,\n    blockLength\n  } = await readBlockHead(reader);\n  const index = {\n    cid,\n    length,\n    blockLength,\n    offset,\n    blockOffset: reader.pos\n  };\n  reader.seek(index.blockLength);\n  return index;\n}\nfunction createDecoder(reader) {\n  const headerPromise = readHeader(reader);\n  return {\n    header: () => headerPromise,\n    async *blocks() {\n      await headerPromise;\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlock(reader);\n      }\n    },\n    async *blocksIndex() {\n      await headerPromise;\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlockIndex(reader);\n      }\n    }\n  };\n}\nfunction bytesReader(bytes) {\n  let pos = 0;\n  return {\n    async upTo(length) {\n      return bytes.subarray(pos, pos + Math.min(length, bytes.length - pos));\n    },\n    async exactly(length) {\n      if (length > bytes.length - pos) {\n        throw new Error('Unexpected end of data');\n      }\n      return bytes.subarray(pos, pos + length);\n    },\n    seek(length) {\n      pos += length;\n    },\n    get pos() {\n      return pos;\n    }\n  };\n}\nfunction chunkReader(readChunk) {\n  let pos = 0;\n  let have = 0;\n  let offset = 0;\n  let currentChunk = new Uint8Array(0);\n  const read = async length => {\n    have = currentChunk.length - offset;\n    const bufa = [currentChunk.subarray(offset)];\n    while (have < length) {\n      const chunk = await readChunk();\n      if (chunk == null) {\n        break;\n      }\n      if (have < 0) {\n        if (chunk.length > have) {\n          bufa.push(chunk.subarray(-have));\n        }\n      } else {\n        bufa.push(chunk);\n      }\n      have += chunk.length;\n    }\n    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));\n    let off = 0;\n    for (const b of bufa) {\n      currentChunk.set(b, off);\n      off += b.length;\n    }\n    offset = 0;\n  };\n  return {\n    async upTo(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length));\n    },\n    async exactly(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n      if (currentChunk.length - offset < length) {\n        throw new Error('Unexpected end of data');\n      }\n      return currentChunk.subarray(offset, offset + length);\n    },\n    seek(length) {\n      pos += length;\n      offset += length;\n    },\n    get pos() {\n      return pos;\n    }\n  };\n}\nfunction asyncIterableReader(asyncIterable) {\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n  async function readChunk() {\n    const next = await iterator.next();\n    if (next.done) {\n      return null;\n    }\n    return next.value;\n  }\n  return chunkReader(readChunk);\n}\nexports.asyncIterableReader = asyncIterableReader;\nexports.bytesReader = bytesReader;\nexports.chunkReader = chunkReader;\nexports.createDecoder = createDecoder;\nexports.readBlockHead = readBlockHead;\nexports.readHeader = readHeader;","map":{"version":3,"names":["Object","defineProperty","exports","value","varint","require","cid","Digest","dagCbor","_interopDefaultLegacy","e","_interopNamespace","__esModule","n","create","keys","forEach","k","d","getOwnPropertyDescriptor","get","enumerable","freeze","varint__default","Digest__namespace","CIDV0_BYTES","SHA2_256","LENGTH","DAG_PB","readVarint","reader","bytes","upTo","i","decode","seek","readHeader","length","Error","header","exactly","block","Array","isArray","version","roots","filter","p","readMultihash","codeLength","subarray","lengthLength","mhLength","multihash","readCid","first","CID","codec","readBlockHead","start","pos","blockLength","readBlock","readBlockIndex","offset","index","blockOffset","createDecoder","headerPromise","blocks","blocksIndex","bytesReader","Math","min","chunkReader","readChunk","have","currentChunk","Uint8Array","read","bufa","chunk","push","reduce","c","off","b","set","asyncIterableReader","asyncIterable","iterator","Symbol","asyncIterator","next","done"],"sources":["C:/FACULTATE/Proiect/node_modules/@ipld/car/cjs/lib/decoder.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar varint = require('varint');\nvar cid = require('multiformats/cid');\nvar Digest = require('multiformats/hashes/digest');\nvar dagCbor = require('@ipld/dag-cbor');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar varint__default = /*#__PURE__*/_interopDefaultLegacy(varint);\nvar Digest__namespace = /*#__PURE__*/_interopNamespace(Digest);\n\nconst CIDV0_BYTES = {\n  SHA2_256: 18,\n  LENGTH: 32,\n  DAG_PB: 112\n};\nasync function readVarint(reader) {\n  const bytes = await reader.upTo(8);\n  const i = varint__default[\"default\"].decode(bytes);\n  reader.seek(varint__default[\"default\"].decode.bytes);\n  return i;\n}\nasync function readHeader(reader) {\n  const length = await readVarint(reader);\n  if (length === 0) {\n    throw new Error('Invalid CAR header (zero length)');\n  }\n  const header = await reader.exactly(length);\n  reader.seek(length);\n  const block = dagCbor.decode(header);\n  if (block == null || Array.isArray(block) || typeof block !== 'object') {\n    throw new Error('Invalid CAR header format');\n  }\n  if (block.version !== 1) {\n    if (typeof block.version === 'string') {\n      throw new Error(`Invalid CAR version: \"${ block.version }\"`);\n    }\n    throw new Error(`Invalid CAR version: ${ block.version }`);\n  }\n  if (!Array.isArray(block.roots)) {\n    throw new Error('Invalid CAR header format');\n  }\n  if (Object.keys(block).filter(p => p !== 'roots' && p !== 'version').length) {\n    throw new Error('Invalid CAR header format');\n  }\n  return block;\n}\nasync function readMultihash(reader) {\n  const bytes = await reader.upTo(8);\n  varint__default[\"default\"].decode(bytes);\n  const codeLength = varint__default[\"default\"].decode.bytes;\n  const length = varint__default[\"default\"].decode(bytes.subarray(varint__default[\"default\"].decode.bytes));\n  const lengthLength = varint__default[\"default\"].decode.bytes;\n  const mhLength = codeLength + lengthLength + length;\n  const multihash = await reader.exactly(mhLength);\n  reader.seek(mhLength);\n  return multihash;\n}\nasync function readCid(reader) {\n  const first = await reader.exactly(2);\n  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n    const bytes = await reader.exactly(34);\n    reader.seek(34);\n    const multihash = Digest__namespace.decode(bytes);\n    return cid.CID.create(0, CIDV0_BYTES.DAG_PB, multihash);\n  }\n  const version = await readVarint(reader);\n  if (version !== 1) {\n    throw new Error(`Unexpected CID version (${ version })`);\n  }\n  const codec = await readVarint(reader);\n  const bytes = await readMultihash(reader);\n  const multihash = Digest__namespace.decode(bytes);\n  return cid.CID.create(version, codec, multihash);\n}\nasync function readBlockHead(reader) {\n  const start = reader.pos;\n  let length = await readVarint(reader);\n  if (length === 0) {\n    throw new Error('Invalid CAR section (zero length)');\n  }\n  length += reader.pos - start;\n  const cid = await readCid(reader);\n  const blockLength = length - (reader.pos - start);\n  return {\n    cid,\n    length,\n    blockLength\n  };\n}\nasync function readBlock(reader) {\n  const {cid, blockLength} = await readBlockHead(reader);\n  const bytes = await reader.exactly(blockLength);\n  reader.seek(blockLength);\n  return {\n    bytes,\n    cid\n  };\n}\nasync function readBlockIndex(reader) {\n  const offset = reader.pos;\n  const {cid, length, blockLength} = await readBlockHead(reader);\n  const index = {\n    cid,\n    length,\n    blockLength,\n    offset,\n    blockOffset: reader.pos\n  };\n  reader.seek(index.blockLength);\n  return index;\n}\nfunction createDecoder(reader) {\n  const headerPromise = readHeader(reader);\n  return {\n    header: () => headerPromise,\n    async *blocks() {\n      await headerPromise;\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlock(reader);\n      }\n    },\n    async *blocksIndex() {\n      await headerPromise;\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlockIndex(reader);\n      }\n    }\n  };\n}\nfunction bytesReader(bytes) {\n  let pos = 0;\n  return {\n    async upTo(length) {\n      return bytes.subarray(pos, pos + Math.min(length, bytes.length - pos));\n    },\n    async exactly(length) {\n      if (length > bytes.length - pos) {\n        throw new Error('Unexpected end of data');\n      }\n      return bytes.subarray(pos, pos + length);\n    },\n    seek(length) {\n      pos += length;\n    },\n    get pos() {\n      return pos;\n    }\n  };\n}\nfunction chunkReader(readChunk) {\n  let pos = 0;\n  let have = 0;\n  let offset = 0;\n  let currentChunk = new Uint8Array(0);\n  const read = async length => {\n    have = currentChunk.length - offset;\n    const bufa = [currentChunk.subarray(offset)];\n    while (have < length) {\n      const chunk = await readChunk();\n      if (chunk == null) {\n        break;\n      }\n      if (have < 0) {\n        if (chunk.length > have) {\n          bufa.push(chunk.subarray(-have));\n        }\n      } else {\n        bufa.push(chunk);\n      }\n      have += chunk.length;\n    }\n    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));\n    let off = 0;\n    for (const b of bufa) {\n      currentChunk.set(b, off);\n      off += b.length;\n    }\n    offset = 0;\n  };\n  return {\n    async upTo(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length));\n    },\n    async exactly(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n      if (currentChunk.length - offset < length) {\n        throw new Error('Unexpected end of data');\n      }\n      return currentChunk.subarray(offset, offset + length);\n    },\n    seek(length) {\n      pos += length;\n      offset += length;\n    },\n    get pos() {\n      return pos;\n    }\n  };\n}\nfunction asyncIterableReader(asyncIterable) {\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n  async function readChunk() {\n    const next = await iterator.next();\n    if (next.done) {\n      return null;\n    }\n    return next.value;\n  }\n  return chunkReader(readChunk);\n}\n\nexports.asyncIterableReader = asyncIterableReader;\nexports.bytesReader = bytesReader;\nexports.chunkReader = chunkReader;\nexports.createDecoder = createDecoder;\nexports.readBlockHead = readBlockHead;\nexports.readHeader = readHeader;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}