{"ast":null,"code":"import * as API from '@ucanto/interface';\nimport { CarBufferReader } from '@ipld/car/buffer-reader';\nimport * as CarBufferWriter from '@ipld/car/buffer-writer';\nimport { base32 } from 'multiformats/bases/base32';\nimport { create as createLink } from './link.js';\nimport { sha256 } from 'multiformats/hashes/sha2';\n\n// @see https://www.iana.org/assignments/media-types/application/vnd.ipld.car\nexport const contentType = 'application/vnd.ipld.car';\nexport const name = 'CAR';\n\n/** @type {API.MulticodecCode<0x0202, 'CAR'>} */\nexport const code = 0x0202;\n\n/**\n * @typedef {{\n * roots: API.IPLDBlock[]\n * blocks: Map<string, API.IPLDBlock>\n * }} Model\n */\n\nclass Writer {\n  /**\n   * @param {API.IPLDBlock[]} blocks\n   * @param {number} byteLength\n   */\n  constructor(blocks = [], byteLength = 0) {\n    this.written = new Set();\n    this.blocks = blocks;\n    this.byteLength = byteLength;\n  }\n  /**\n   * @param {API.IPLDBlock[]} blocks\n   */\n  write(...blocks) {\n    for (const block of blocks) {\n      const id = block.cid.toString(base32);\n      if (!this.written.has(id)) {\n        this.blocks.push(block);\n        this.byteLength += CarBufferWriter.blockLength( /** @type {any} */block);\n        this.written.add(id);\n      }\n    }\n    return this;\n  }\n  /**\n   * @param {API.IPLDBlock[]} rootBlocks\n   */\n  flush(...rootBlocks) {\n    const roots = [];\n    // We reverse the roots so that the first root is the last block in the CAR\n    for (const block of rootBlocks.reverse()) {\n      const id = block.cid.toString(base32);\n      if (!this.written.has(id)) {\n        this.blocks.unshift(block);\n        this.byteLength += CarBufferWriter.blockLength({\n          cid: ( /** @type {CarBufferWriter.CID} */block.cid),\n          bytes: block.bytes\n        });\n        this.written.add(id);\n      }\n\n      // We unshift here because we want to preserve the order of the roots\n      roots.unshift( /** @type {CarBufferWriter.CID} */block.cid);\n    }\n    this.byteLength += CarBufferWriter.headerLength({\n      roots\n    });\n    const buffer = new ArrayBuffer(this.byteLength);\n    const writer = CarBufferWriter.createWriter(buffer, {\n      roots\n    });\n    for (const block of ( /** @type {CarBufferWriter.Block[]} */this.blocks)) {\n      writer.write(block);\n    }\n    return writer.close();\n  }\n}\nexport const createWriter = () => new Writer();\n\n/**\n * @template {Partial<Model>} T\n * @param {T} input\n * @returns {API.ByteView<T>}\n */\nexport const encode = ({\n  roots = [],\n  blocks\n}) => {\n  const writer = new Writer();\n  if (blocks) {\n    writer.write(...blocks.values());\n  }\n  return writer.flush(...roots);\n};\n\n/**\n * @param {API.ByteView<Partial<Model>>} bytes\n * @returns {Model}\n */\nexport const decode = bytes => {\n  const reader = CarBufferReader.fromBytes(bytes);\n  /** @type {API.IPLDBlock[]} */\n  const roots = [];\n  const blocks = new Map();\n  for (const root of reader.getRoots()) {\n    const block = /** @type {API.IPLDBlock} */reader.get(root);\n    if (block) {\n      roots.push(block);\n    }\n  }\n  for (const block of reader.blocks()) {\n    blocks.set(block.cid.toString(), block);\n  }\n  return {\n    roots,\n    blocks\n  };\n};\n\n/**\n * @template {Partial<Model>} T\n * @param {API.ByteView<T>} bytes\n * @param {{hasher?: API.MultihashHasher }} options\n */\nexport const link = async (bytes, {\n  hasher = sha256\n} = {}) => {\n  return /** @type {API.Link<T, typeof code, typeof hasher.code>} */(\n    createLink(code, await hasher.digest(bytes))\n  );\n};\n\n/**\n * @template {Partial<Model>} T\n * @param {T} data\n * @param {{hasher?: API.MultihashHasher }} [options]\n * @returns {Promise<API.Block<T, typeof code>>}\n */\nexport const write = async (data, options) => {\n  const bytes = encode(data);\n  const cid = await link(bytes, options);\n  return {\n    bytes,\n    cid\n  };\n};","map":{"version":3,"names":["API","CarBufferReader","CarBufferWriter","base32","create","createLink","sha256","contentType","name","code","Writer","constructor","blocks","byteLength","written","Set","write","block","id","cid","toString","has","push","blockLength","add","flush","rootBlocks","roots","reverse","unshift","bytes","headerLength","buffer","ArrayBuffer","writer","createWriter","close","encode","values","decode","reader","fromBytes","Map","root","getRoots","get","set","link","hasher","digest","data","options"],"sources":["C:/FACULTATE/Proiect/node_modules/@ucanto/core/src/car.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport { CarBufferReader } from '@ipld/car/buffer-reader'\nimport * as CarBufferWriter from '@ipld/car/buffer-writer'\nimport { base32 } from 'multiformats/bases/base32'\nimport { create as createLink } from './link.js'\nimport { sha256 } from 'multiformats/hashes/sha2'\n\n// @see https://www.iana.org/assignments/media-types/application/vnd.ipld.car\nexport const contentType = 'application/vnd.ipld.car'\nexport const name = 'CAR'\n\n/** @type {API.MulticodecCode<0x0202, 'CAR'>} */\nexport const code = 0x0202\n\n/**\n * @typedef {{\n * roots: API.IPLDBlock[]\n * blocks: Map<string, API.IPLDBlock>\n * }} Model\n */\n\nclass Writer {\n  /**\n   * @param {API.IPLDBlock[]} blocks\n   * @param {number} byteLength\n   */\n  constructor(blocks = [], byteLength = 0) {\n    this.written = new Set()\n    this.blocks = blocks\n    this.byteLength = byteLength\n  }\n  /**\n   * @param {API.IPLDBlock[]} blocks\n   */\n  write(...blocks) {\n    for (const block of blocks) {\n      const id = block.cid.toString(base32)\n      if (!this.written.has(id)) {\n        this.blocks.push(block)\n        this.byteLength += CarBufferWriter.blockLength(\n          /** @type {any} */ (block)\n        )\n        this.written.add(id)\n      }\n    }\n    return this\n  }\n  /**\n   * @param {API.IPLDBlock[]} rootBlocks\n   */\n  flush(...rootBlocks) {\n    const roots = []\n    // We reverse the roots so that the first root is the last block in the CAR\n    for (const block of rootBlocks.reverse()) {\n      const id = block.cid.toString(base32)\n      if (!this.written.has(id)) {\n        this.blocks.unshift(block)\n        this.byteLength += CarBufferWriter.blockLength({\n          cid: /** @type {CarBufferWriter.CID} */ (block.cid),\n          bytes: block.bytes,\n        })\n        this.written.add(id)\n      }\n\n      // We unshift here because we want to preserve the order of the roots\n      roots.unshift(/** @type {CarBufferWriter.CID} */ (block.cid))\n    }\n\n    this.byteLength += CarBufferWriter.headerLength({ roots })\n\n    const buffer = new ArrayBuffer(this.byteLength)\n    const writer = CarBufferWriter.createWriter(buffer, { roots })\n\n    for (const block of /** @type {CarBufferWriter.Block[]} */ (this.blocks)) {\n      writer.write(block)\n    }\n\n    return writer.close()\n  }\n}\n\nexport const createWriter = () => new Writer()\n\n/**\n * @template {Partial<Model>} T\n * @param {T} input\n * @returns {API.ByteView<T>}\n */\nexport const encode = ({ roots = [], blocks }) => {\n  const writer = new Writer()\n  if (blocks) {\n    writer.write(...blocks.values())\n  }\n  return writer.flush(...roots)\n}\n\n/**\n * @param {API.ByteView<Partial<Model>>} bytes\n * @returns {Model}\n */\nexport const decode = bytes => {\n  const reader = CarBufferReader.fromBytes(bytes)\n  /** @type {API.IPLDBlock[]} */\n  const roots = []\n  const blocks = new Map()\n\n  for (const root of reader.getRoots()) {\n    const block = /** @type {API.IPLDBlock} */ (reader.get(root))\n    if (block) {\n      roots.push(block)\n    }\n  }\n\n  for (const block of reader.blocks()) {\n    blocks.set(block.cid.toString(), block)\n  }\n\n  return { roots, blocks }\n}\n\n/**\n * @template {Partial<Model>} T\n * @param {API.ByteView<T>} bytes\n * @param {{hasher?: API.MultihashHasher }} options\n */\nexport const link = async (bytes, { hasher = sha256 } = {}) => {\n  return /** @type {API.Link<T, typeof code, typeof hasher.code>} */ (\n    createLink(code, await hasher.digest(bytes))\n  )\n}\n\n/**\n * @template {Partial<Model>} T\n * @param {T} data\n * @param {{hasher?: API.MultihashHasher }} [options]\n * @returns {Promise<API.Block<T, typeof code>>}\n */\nexport const write = async (data, options) => {\n  const bytes = encode(data)\n  const cid = await link(bytes, options)\n\n  return { bytes, cid }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}