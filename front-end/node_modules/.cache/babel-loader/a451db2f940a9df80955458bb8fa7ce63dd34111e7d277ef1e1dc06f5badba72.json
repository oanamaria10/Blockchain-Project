{"ast":null,"code":"var ZipEntry = require(\"./zipEntry\"),\n  Headers = require(\"./headers\"),\n  Utils = require(\"./util\");\nmodule.exports = function ( /*String|Buffer*/input, /*Number*/inputType) {\n  var entryList = [],\n    entryTable = {},\n    _comment = Buffer.alloc(0),\n    filename = \"\",\n    fs = Utils.FileSystem.require(),\n    inBuffer = null,\n    mainHeader = new Headers.MainHeader(),\n    loadedEntries = false;\n  if (inputType === Utils.Constants.FILE) {\n    // is a filename\n    filename = input;\n    inBuffer = fs.readFileSync(filename);\n    readMainHeader();\n  } else if (inputType === Utils.Constants.BUFFER) {\n    // is a memory buffer\n    inBuffer = input;\n    readMainHeader();\n  } else {\n    // none. is a new file\n    loadedEntries = true;\n  }\n  function iterateEntries(callback) {\n    const totalEntries = mainHeader.diskEntries; // total number of entries\n    let index = mainHeader.offset; // offset of first CEN header\n\n    for (let i = 0; i < totalEntries; i++) {\n      let tmp = index;\n      const entry = new ZipEntry(inBuffer);\n      entry.header = inBuffer.slice(tmp, tmp += Utils.Constants.CENHDR);\n      entry.entryName = inBuffer.slice(tmp, tmp += entry.header.fileNameLength);\n      index += entry.header.entryHeaderSize;\n      callback(entry);\n    }\n  }\n  function readEntries() {\n    loadedEntries = true;\n    entryTable = {};\n    entryList = new Array(mainHeader.diskEntries); // total number of entries\n    var index = mainHeader.offset; // offset of first CEN header\n    for (var i = 0; i < entryList.length; i++) {\n      var tmp = index,\n        entry = new ZipEntry(inBuffer);\n      entry.header = inBuffer.slice(tmp, tmp += Utils.Constants.CENHDR);\n      entry.entryName = inBuffer.slice(tmp, tmp += entry.header.fileNameLength);\n      if (entry.header.extraLength) {\n        entry.extra = inBuffer.slice(tmp, tmp += entry.header.extraLength);\n      }\n      if (entry.header.commentLength) entry.comment = inBuffer.slice(tmp, tmp + entry.header.commentLength);\n      index += entry.header.entryHeaderSize;\n      entryList[i] = entry;\n      entryTable[entry.entryName] = entry;\n    }\n  }\n  function readMainHeader() {\n    var i = inBuffer.length - Utils.Constants.ENDHDR,\n      // END header size\n      max = Math.max(0, i - 0xFFFF),\n      // 0xFFFF is the max zip file comment length\n      n = max,\n      endStart = inBuffer.length,\n      endOffset = -1,\n      // Start offset of the END header\n      commentEnd = 0;\n    for (i; i >= n; i--) {\n      if (inBuffer[i] !== 0x50) continue; // quick check that the byte is 'P'\n      if (inBuffer.readUInt32LE(i) === Utils.Constants.ENDSIG) {\n        // \"PK\\005\\006\"\n        endOffset = i;\n        commentEnd = i;\n        endStart = i + Utils.Constants.ENDHDR;\n        // We already found a regular signature, let's look just a bit further to check if there's any zip64 signature\n        n = i - Utils.Constants.END64HDR;\n        continue;\n      }\n      if (inBuffer.readUInt32LE(i) === Utils.Constants.END64SIG) {\n        // Found a zip64 signature, let's continue reading the whole zip64 record\n        n = max;\n        continue;\n      }\n      if (inBuffer.readUInt32LE(i) == Utils.Constants.ZIP64SIG) {\n        // Found the zip64 record, let's determine it's size\n        endOffset = i;\n        endStart = i + Utils.readBigUInt64LE(inBuffer, i + Utils.Constants.ZIP64SIZE) + Utils.Constants.ZIP64LEAD;\n        break;\n      }\n    }\n    if (!~endOffset) throw new Error(Utils.Errors.INVALID_FORMAT);\n    mainHeader.loadFromBinary(inBuffer.slice(endOffset, endStart));\n    if (mainHeader.commentLength) {\n      _comment = inBuffer.slice(commentEnd + Utils.Constants.ENDHDR);\n    }\n    // readEntries();\n  }\n  return {\n    /**\r\n     * Returns an array of ZipEntry objects existent in the current opened archive\r\n     * @return Array\r\n     */\n    get entries() {\n      if (!loadedEntries) {\n        readEntries();\n      }\n      return entryList;\n    },\n    /**\r\n     * Archive comment\r\n     * @return {String}\r\n     */\n    get comment() {\n      return _comment.toString();\n    },\n    set comment(val) {\n      mainHeader.commentLength = val.length;\n      _comment = val;\n    },\n    getEntryCount: function () {\n      if (!loadedEntries) {\n        return mainHeader.diskEntries;\n      }\n      return entryList.length;\n    },\n    forEach: function (callback) {\n      if (!loadedEntries) {\n        iterateEntries(callback);\n        return;\n      }\n      entryList.forEach(callback);\n    },\n    /**\r\n     * Returns a reference to the entry with the given name or null if entry is inexistent\r\n     *\r\n     * @param entryName\r\n     * @return ZipEntry\r\n     */\n    getEntry: function ( /*String*/entryName) {\n      if (!loadedEntries) {\n        readEntries();\n      }\n      return entryTable[entryName] || null;\n    },\n    /**\r\n     * Adds the given entry to the entry list\r\n     *\r\n     * @param entry\r\n     */\n    setEntry: function ( /*ZipEntry*/entry) {\n      if (!loadedEntries) {\n        readEntries();\n      }\n      entryList.push(entry);\n      entryTable[entry.entryName] = entry;\n      mainHeader.totalEntries = entryList.length;\n    },\n    /**\r\n     * Removes the entry with the given name from the entry list.\r\n     *\r\n     * If the entry is a directory, then all nested files and directories will be removed\r\n     * @param entryName\r\n     */\n    deleteEntry: function ( /*String*/entryName) {\n      if (!loadedEntries) {\n        readEntries();\n      }\n      var entry = entryTable[entryName];\n      if (entry && entry.isDirectory) {\n        var _self = this;\n        this.getEntryChildren(entry).forEach(function (child) {\n          if (child.entryName !== entryName) {\n            _self.deleteEntry(child.entryName);\n          }\n        });\n      }\n      entryList.splice(entryList.indexOf(entry), 1);\n      delete entryTable[entryName];\n      mainHeader.totalEntries = entryList.length;\n    },\n    /**\r\n     *  Iterates and returns all nested files and directories of the given entry\r\n     *\r\n     * @param entry\r\n     * @return Array\r\n     */\n    getEntryChildren: function ( /*ZipEntry*/entry) {\n      if (!loadedEntries) {\n        readEntries();\n      }\n      if (entry.isDirectory) {\n        var list = [],\n          name = entry.entryName,\n          len = name.length;\n        entryList.forEach(function (zipEntry) {\n          if (zipEntry.entryName.substr(0, len) === name) {\n            list.push(zipEntry);\n          }\n        });\n        return list;\n      }\n      return [];\n    },\n    /**\r\n     * Returns the zip file\r\n     *\r\n     * @return Buffer\r\n     */\n    compressToBuffer: function () {\n      if (!loadedEntries) {\n        readEntries();\n      }\n      if (entryList.length > 1) {\n        entryList.sort(function (a, b) {\n          var nameA = a.entryName.toLowerCase();\n          var nameB = b.entryName.toLowerCase();\n          if (nameA < nameB) {\n            return -1;\n          }\n          if (nameA > nameB) {\n            return 1;\n          }\n          return 0;\n        });\n      }\n      var totalSize = 0,\n        dataBlock = [],\n        entryHeaders = [],\n        dindex = 0;\n      mainHeader.size = 0;\n      mainHeader.offset = 0;\n      entryList.forEach(function (entry) {\n        // compress data and set local and entry header accordingly. Reason why is called first\n        var compressedData = entry.getCompressedData();\n        // data header\n        entry.header.offset = dindex;\n        var dataHeader = entry.header.dataHeaderToBinary();\n        var entryNameLen = entry.rawEntryName.length;\n        var extra = entry.extra.toString();\n        var postHeader = Buffer.alloc(entryNameLen + extra.length);\n        entry.rawEntryName.copy(postHeader, 0);\n        postHeader.fill(extra, entryNameLen);\n        var dataLength = dataHeader.length + postHeader.length + compressedData.length;\n        dindex += dataLength;\n        dataBlock.push(dataHeader);\n        dataBlock.push(postHeader);\n        dataBlock.push(compressedData);\n        var entryHeader = entry.packHeader();\n        entryHeaders.push(entryHeader);\n        mainHeader.size += entryHeader.length;\n        totalSize += dataLength + entryHeader.length;\n      });\n      totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length\n      // point to end of data and beginning of central directory first record\n      mainHeader.offset = dindex;\n      dindex = 0;\n      var outBuffer = Buffer.alloc(totalSize);\n      dataBlock.forEach(function (content) {\n        content.copy(outBuffer, dindex); // write data blocks\n        dindex += content.length;\n      });\n      entryHeaders.forEach(function (content) {\n        content.copy(outBuffer, dindex); // write central directory entries\n        dindex += content.length;\n      });\n      var mh = mainHeader.toBinary();\n      if (_comment) {\n        Buffer.from(_comment).copy(mh, Utils.Constants.ENDHDR); // add zip file comment\n      }\n      mh.copy(outBuffer, dindex); // write main header\n\n      return outBuffer;\n    },\n    toAsyncBuffer: function ( /*Function*/onSuccess, /*Function*/onFail, /*Function*/onItemStart, /*Function*/onItemEnd) {\n      if (!loadedEntries) {\n        readEntries();\n      }\n      if (entryList.length > 1) {\n        entryList.sort(function (a, b) {\n          var nameA = a.entryName.toLowerCase();\n          var nameB = b.entryName.toLowerCase();\n          if (nameA > nameB) {\n            return -1;\n          }\n          if (nameA < nameB) {\n            return 1;\n          }\n          return 0;\n        });\n      }\n      var totalSize = 0,\n        dataBlock = [],\n        entryHeaders = [],\n        dindex = 0;\n      mainHeader.size = 0;\n      mainHeader.offset = 0;\n      var compress = function (entryList) {\n        var self = arguments.callee;\n        if (entryList.length) {\n          var entry = entryList.pop();\n          var name = entry.entryName + entry.extra.toString();\n          if (onItemStart) onItemStart(name);\n          entry.getCompressedDataAsync(function (compressedData) {\n            if (onItemEnd) onItemEnd(name);\n            entry.header.offset = dindex;\n            // data header\n            var dataHeader = entry.header.dataHeaderToBinary();\n            var postHeader;\n            try {\n              postHeader = Buffer.alloc(name.length, name); // using alloc will work on node  5.x+\n            } catch (e) {\n              postHeader = new Buffer(name); // use deprecated method if alloc fails...\n            }\n            var dataLength = dataHeader.length + postHeader.length + compressedData.length;\n            dindex += dataLength;\n            dataBlock.push(dataHeader);\n            dataBlock.push(postHeader);\n            dataBlock.push(compressedData);\n            var entryHeader = entry.packHeader();\n            entryHeaders.push(entryHeader);\n            mainHeader.size += entryHeader.length;\n            totalSize += dataLength + entryHeader.length;\n            if (entryList.length) {\n              self(entryList);\n            } else {\n              totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length\n              // point to end of data and beginning of central directory first record\n              mainHeader.offset = dindex;\n              dindex = 0;\n              var outBuffer = Buffer.alloc(totalSize);\n              dataBlock.forEach(function (content) {\n                content.copy(outBuffer, dindex); // write data blocks\n                dindex += content.length;\n              });\n              entryHeaders.forEach(function (content) {\n                content.copy(outBuffer, dindex); // write central directory entries\n                dindex += content.length;\n              });\n              var mh = mainHeader.toBinary();\n              if (_comment) {\n                _comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment\n              }\n              mh.copy(outBuffer, dindex); // write main header\n\n              onSuccess(outBuffer);\n            }\n          });\n        }\n      };\n      compress(entryList);\n    }\n  };\n};","map":{"version":3,"names":["ZipEntry","require","Headers","Utils","module","exports","input","inputType","entryList","entryTable","_comment","Buffer","alloc","filename","fs","FileSystem","inBuffer","mainHeader","MainHeader","loadedEntries","Constants","FILE","readFileSync","readMainHeader","BUFFER","iterateEntries","callback","totalEntries","diskEntries","index","offset","i","tmp","entry","header","slice","CENHDR","entryName","fileNameLength","entryHeaderSize","readEntries","Array","length","extraLength","extra","commentLength","comment","ENDHDR","max","Math","n","endStart","endOffset","commentEnd","readUInt32LE","ENDSIG","END64HDR","END64SIG","ZIP64SIG","readBigUInt64LE","ZIP64SIZE","ZIP64LEAD","Error","Errors","INVALID_FORMAT","loadFromBinary","entries","toString","val","getEntryCount","forEach","getEntry","setEntry","push","deleteEntry","isDirectory","_self","getEntryChildren","child","splice","indexOf","list","name","len","zipEntry","substr","compressToBuffer","sort","a","b","nameA","toLowerCase","nameB","totalSize","dataBlock","entryHeaders","dindex","size","compressedData","getCompressedData","dataHeader","dataHeaderToBinary","entryNameLen","rawEntryName","postHeader","copy","fill","dataLength","entryHeader","packHeader","mainHeaderSize","outBuffer","content","mh","toBinary","from","toAsyncBuffer","onSuccess","onFail","onItemStart","onItemEnd","compress","self","arguments","callee","pop","getCompressedDataAsync","e"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/adm-zip/zipFile.js"],"sourcesContent":["var ZipEntry = require(\"./zipEntry\"),\r\n\tHeaders = require(\"./headers\"),\r\n\tUtils = require(\"./util\");\r\n\r\nmodule.exports = function (/*String|Buffer*/input, /*Number*/inputType) {\r\n\tvar entryList = [],\r\n\t\tentryTable = {},\r\n\t\t_comment = Buffer.alloc(0),\r\n\t\tfilename = \"\",\r\n\t\tfs = Utils.FileSystem.require(),\r\n\t\tinBuffer = null,\r\n\t\tmainHeader = new Headers.MainHeader(),\r\n\t\tloadedEntries = false;\r\n\r\n\tif (inputType === Utils.Constants.FILE) {\r\n\t\t// is a filename\r\n\t\tfilename = input;\r\n\t\tinBuffer = fs.readFileSync(filename);\r\n\t\treadMainHeader();\r\n\t} else if (inputType === Utils.Constants.BUFFER) {\r\n\t\t// is a memory buffer\r\n\t\tinBuffer = input;\r\n\t\treadMainHeader();\r\n\t} else {\r\n\t\t// none. is a new file\r\n\t\tloadedEntries = true;\r\n\t}\r\n\r\n\tfunction iterateEntries(callback) {\r\n\t\tconst totalEntries = mainHeader.diskEntries; // total number of entries\r\n\t\tlet index = mainHeader.offset; // offset of first CEN header\r\n\r\n\t\tfor (let i = 0; i < totalEntries; i++) {\r\n\t\t\tlet tmp = index;\r\n\t\t\tconst entry = new ZipEntry(inBuffer);\r\n\r\n\t\t\tentry.header = inBuffer.slice(tmp, tmp += Utils.Constants.CENHDR);\r\n\t\t\tentry.entryName = inBuffer.slice(tmp, tmp += entry.header.fileNameLength);\r\n\r\n\t\t\tindex += entry.header.entryHeaderSize;\r\n\r\n\t\t\tcallback(entry);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction readEntries() {\r\n\t\tloadedEntries = true;\r\n\t\tentryTable = {};\r\n\t\tentryList = new Array(mainHeader.diskEntries);  // total number of entries\r\n\t\tvar index = mainHeader.offset;  // offset of first CEN header\r\n\t\tfor (var i = 0; i < entryList.length; i++) {\r\n\r\n\t\t\tvar tmp = index,\r\n\t\t\t\tentry = new ZipEntry(inBuffer);\r\n\t\t\tentry.header = inBuffer.slice(tmp, tmp += Utils.Constants.CENHDR);\r\n\r\n\t\t\tentry.entryName = inBuffer.slice(tmp, tmp += entry.header.fileNameLength);\r\n\r\n\t\t\tif (entry.header.extraLength) {\r\n\t\t\t\tentry.extra = inBuffer.slice(tmp, tmp += entry.header.extraLength);\r\n\t\t\t}\r\n\r\n\t\t\tif (entry.header.commentLength)\r\n\t\t\t\tentry.comment = inBuffer.slice(tmp, tmp + entry.header.commentLength);\r\n\r\n\t\t\tindex += entry.header.entryHeaderSize;\r\n\r\n\t\t\tentryList[i] = entry;\r\n\t\t\tentryTable[entry.entryName] = entry;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction readMainHeader() {\r\n\t\tvar i = inBuffer.length - Utils.Constants.ENDHDR, // END header size\r\n\t\t\tmax = Math.max(0, i - 0xFFFF), // 0xFFFF is the max zip file comment length\r\n\t\t\tn = max,\r\n\t\t\tendStart = inBuffer.length,\r\n\t\t\tendOffset = -1, // Start offset of the END header\r\n\t\t\tcommentEnd = 0;\r\n\r\n\t\tfor (i; i >= n; i--) {\r\n\t\t\tif (inBuffer[i] !== 0x50) continue; // quick check that the byte is 'P'\r\n\t\t\tif (inBuffer.readUInt32LE(i) === Utils.Constants.ENDSIG) { // \"PK\\005\\006\"\r\n\t\t\t\tendOffset = i;\r\n\t\t\t\tcommentEnd = i;\r\n\t\t\t\tendStart = i + Utils.Constants.ENDHDR;\r\n\t\t\t\t// We already found a regular signature, let's look just a bit further to check if there's any zip64 signature\r\n\t\t\t\tn = i - Utils.Constants.END64HDR;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif (inBuffer.readUInt32LE(i) === Utils.Constants.END64SIG) {\r\n\t\t\t\t// Found a zip64 signature, let's continue reading the whole zip64 record\r\n\t\t\t\tn = max;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif (inBuffer.readUInt32LE(i) == Utils.Constants.ZIP64SIG) {\r\n\t\t\t\t// Found the zip64 record, let's determine it's size\r\n\t\t\t\tendOffset = i;\r\n\t\t\t\tendStart = i + Utils.readBigUInt64LE(inBuffer, i + Utils.Constants.ZIP64SIZE) + Utils.Constants.ZIP64LEAD;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!~endOffset)\r\n\t\t\tthrow new Error(Utils.Errors.INVALID_FORMAT);\r\n\r\n\t\tmainHeader.loadFromBinary(inBuffer.slice(endOffset, endStart));\r\n\t\tif (mainHeader.commentLength) {\r\n\t\t\t_comment = inBuffer.slice(commentEnd + Utils.Constants.ENDHDR);\r\n\t\t}\r\n\t\t// readEntries();\r\n\t}\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * Returns an array of ZipEntry objects existent in the current opened archive\r\n\t\t * @return Array\r\n\t\t */\r\n\t\tget entries() {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treadEntries();\r\n\t\t\t}\r\n\t\t\treturn entryList;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Archive comment\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tget comment() {\r\n\t\t\treturn _comment.toString();\r\n\t\t},\r\n\t\tset comment(val) {\r\n\t\t\tmainHeader.commentLength = val.length;\r\n\t\t\t_comment = val;\r\n\t\t},\r\n\r\n\t\tgetEntryCount: function() {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treturn mainHeader.diskEntries;\r\n\t\t\t}\r\n\r\n\t\t\treturn entryList.length;\r\n\t\t},\r\n\r\n\t\tforEach: function(callback) {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\titerateEntries(callback);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tentryList.forEach(callback);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns a reference to the entry with the given name or null if entry is inexistent\r\n\t\t *\r\n\t\t * @param entryName\r\n\t\t * @return ZipEntry\r\n\t\t */\r\n\t\tgetEntry: function (/*String*/entryName) {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treadEntries();\r\n\t\t\t}\r\n\t\t\treturn entryTable[entryName] || null;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds the given entry to the entry list\r\n\t\t *\r\n\t\t * @param entry\r\n\t\t */\r\n\t\tsetEntry: function (/*ZipEntry*/entry) {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treadEntries();\r\n\t\t\t}\r\n\t\t\tentryList.push(entry);\r\n\t\t\tentryTable[entry.entryName] = entry;\r\n\t\t\tmainHeader.totalEntries = entryList.length;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Removes the entry with the given name from the entry list.\r\n\t\t *\r\n\t\t * If the entry is a directory, then all nested files and directories will be removed\r\n\t\t * @param entryName\r\n\t\t */\r\n\t\tdeleteEntry: function (/*String*/entryName) {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treadEntries();\r\n\t\t\t}\r\n\t\t\tvar entry = entryTable[entryName];\r\n\t\t\tif (entry && entry.isDirectory) {\r\n\t\t\t\tvar _self = this;\r\n\t\t\t\tthis.getEntryChildren(entry).forEach(function (child) {\r\n\t\t\t\t\tif (child.entryName !== entryName) {\r\n\t\t\t\t\t\t_self.deleteEntry(child.entryName)\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tentryList.splice(entryList.indexOf(entry), 1);\r\n\t\t\tdelete(entryTable[entryName]);\r\n\t\t\tmainHeader.totalEntries = entryList.length;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t *  Iterates and returns all nested files and directories of the given entry\r\n\t\t *\r\n\t\t * @param entry\r\n\t\t * @return Array\r\n\t\t */\r\n\t\tgetEntryChildren: function (/*ZipEntry*/entry) {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treadEntries();\r\n\t\t\t}\r\n\t\t\tif (entry.isDirectory) {\r\n\t\t\t\tvar list = [],\r\n\t\t\t\t\tname = entry.entryName,\r\n\t\t\t\t\tlen = name.length;\r\n\r\n\t\t\t\tentryList.forEach(function (zipEntry) {\r\n\t\t\t\t\tif (zipEntry.entryName.substr(0, len) === name) {\r\n\t\t\t\t\t\tlist.push(zipEntry);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\treturn list;\r\n\t\t\t}\r\n\t\t\treturn []\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the zip file\r\n\t\t *\r\n\t\t * @return Buffer\r\n\t\t */\r\n\t\tcompressToBuffer: function () {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treadEntries();\r\n\t\t\t}\r\n\t\t\tif (entryList.length > 1) {\r\n\t\t\t\tentryList.sort(function (a, b) {\r\n\t\t\t\t\tvar nameA = a.entryName.toLowerCase();\r\n\t\t\t\t\tvar nameB = b.entryName.toLowerCase();\r\n\t\t\t\t\tif (nameA < nameB) {\r\n\t\t\t\t\t\treturn -1\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (nameA > nameB) {\r\n\t\t\t\t\t\treturn 1\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tvar totalSize = 0,\r\n\t\t\t\tdataBlock = [],\r\n\t\t\t\tentryHeaders = [],\r\n\t\t\t\tdindex = 0;\r\n\r\n\t\t\tmainHeader.size = 0;\r\n\t\t\tmainHeader.offset = 0;\r\n\r\n\t\t\tentryList.forEach(function (entry) {\r\n\t\t\t\t// compress data and set local and entry header accordingly. Reason why is called first\r\n\t\t\t\tvar compressedData = entry.getCompressedData();\r\n\t\t\t\t// data header\r\n\t\t\t\tentry.header.offset = dindex;\r\n\t\t\t\tvar dataHeader = entry.header.dataHeaderToBinary();\r\n\t\t\t\tvar entryNameLen = entry.rawEntryName.length;\r\n\t\t\t\tvar extra = entry.extra.toString();\r\n\t\t\t\tvar postHeader = Buffer.alloc(entryNameLen + extra.length);\r\n\t\t\t\tentry.rawEntryName.copy(postHeader, 0);\r\n\t\t\t\tpostHeader.fill(extra, entryNameLen);\r\n\r\n\t\t\t\tvar dataLength = dataHeader.length + postHeader.length + compressedData.length;\r\n\r\n\t\t\t\tdindex += dataLength;\r\n\r\n\t\t\t\tdataBlock.push(dataHeader);\r\n\t\t\t\tdataBlock.push(postHeader);\r\n\t\t\t\tdataBlock.push(compressedData);\r\n\r\n\t\t\t\tvar entryHeader = entry.packHeader();\r\n\t\t\t\tentryHeaders.push(entryHeader);\r\n\t\t\t\tmainHeader.size += entryHeader.length;\r\n\t\t\t\ttotalSize += (dataLength + entryHeader.length);\r\n\t\t\t});\r\n\r\n\t\t\ttotalSize += mainHeader.mainHeaderSize; // also includes zip file comment length\r\n\t\t\t// point to end of data and beginning of central directory first record\r\n\t\t\tmainHeader.offset = dindex;\r\n\r\n\t\t\tdindex = 0;\r\n\t\t\tvar outBuffer = Buffer.alloc(totalSize);\r\n\t\t\tdataBlock.forEach(function (content) {\r\n\t\t\t\tcontent.copy(outBuffer, dindex); // write data blocks\r\n\t\t\t\tdindex += content.length;\r\n\t\t\t});\r\n\t\t\tentryHeaders.forEach(function (content) {\r\n\t\t\t\tcontent.copy(outBuffer, dindex); // write central directory entries\r\n\t\t\t\tdindex += content.length;\r\n\t\t\t});\r\n\r\n\t\t\tvar mh = mainHeader.toBinary();\r\n\t\t\tif (_comment) {\r\n\t\t\t\tBuffer.from(_comment).copy(mh, Utils.Constants.ENDHDR); // add zip file comment\r\n\t\t\t}\r\n\r\n\t\t\tmh.copy(outBuffer, dindex); // write main header\r\n\r\n\t\t\treturn outBuffer\r\n\t\t},\r\n\r\n\t\ttoAsyncBuffer: function (/*Function*/onSuccess, /*Function*/onFail, /*Function*/onItemStart, /*Function*/onItemEnd) {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treadEntries();\r\n\t\t\t}\r\n\t\t\tif (entryList.length > 1) {\r\n\t\t\t\tentryList.sort(function (a, b) {\r\n\t\t\t\t\tvar nameA = a.entryName.toLowerCase();\r\n\t\t\t\t\tvar nameB = b.entryName.toLowerCase();\r\n\t\t\t\t\tif (nameA > nameB) {\r\n\t\t\t\t\t\treturn -1\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (nameA < nameB) {\r\n\t\t\t\t\t\treturn 1\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tvar totalSize = 0,\r\n\t\t\t\tdataBlock = [],\r\n\t\t\t\tentryHeaders = [],\r\n\t\t\t\tdindex = 0;\r\n\r\n\t\t\tmainHeader.size = 0;\r\n\t\t\tmainHeader.offset = 0;\r\n\r\n\t\t\tvar compress = function (entryList) {\r\n\t\t\t\tvar self = arguments.callee;\r\n\t\t\t\tif (entryList.length) {\r\n\t\t\t\t\tvar entry = entryList.pop();\r\n\t\t\t\t\tvar name = entry.entryName + entry.extra.toString();\r\n\t\t\t\t\tif (onItemStart) onItemStart(name);\r\n\t\t\t\t\tentry.getCompressedDataAsync(function (compressedData) {\r\n\t\t\t\t\t\tif (onItemEnd) onItemEnd(name);\r\n\r\n\t\t\t\t\t\tentry.header.offset = dindex;\r\n\t\t\t\t\t\t// data header\r\n\t\t\t\t\t\tvar dataHeader = entry.header.dataHeaderToBinary();\r\n\t\t\t\t\t\tvar postHeader;\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tpostHeader = Buffer.alloc(name.length, name);  // using alloc will work on node  5.x+\r\n\t\t\t\t\t\t} catch(e){\r\n\t\t\t\t\t\t\tpostHeader = new Buffer(name); // use deprecated method if alloc fails...\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar dataLength = dataHeader.length + postHeader.length + compressedData.length;\r\n\r\n\t\t\t\t\t\tdindex += dataLength;\r\n\r\n\t\t\t\t\t\tdataBlock.push(dataHeader);\r\n\t\t\t\t\t\tdataBlock.push(postHeader);\r\n\t\t\t\t\t\tdataBlock.push(compressedData);\r\n\r\n\t\t\t\t\t\tvar entryHeader = entry.packHeader();\r\n\t\t\t\t\t\tentryHeaders.push(entryHeader);\r\n\t\t\t\t\t\tmainHeader.size += entryHeader.length;\r\n\t\t\t\t\t\ttotalSize += (dataLength + entryHeader.length);\r\n\r\n\t\t\t\t\t\tif (entryList.length) {\r\n\t\t\t\t\t\t\tself(entryList);\r\n\t\t\t\t\t\t} else {\r\n\r\n\r\n\t\t\t\t\t\t\ttotalSize += mainHeader.mainHeaderSize; // also includes zip file comment length\r\n\t\t\t\t\t\t\t// point to end of data and beginning of central directory first record\r\n\t\t\t\t\t\t\tmainHeader.offset = dindex;\r\n\r\n\t\t\t\t\t\t\tdindex = 0;\r\n\t\t\t\t\t\t\tvar outBuffer = Buffer.alloc(totalSize);\r\n\t\t\t\t\t\t\tdataBlock.forEach(function (content) {\r\n\t\t\t\t\t\t\t\tcontent.copy(outBuffer, dindex); // write data blocks\r\n\t\t\t\t\t\t\t\tdindex += content.length;\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\tentryHeaders.forEach(function (content) {\r\n\t\t\t\t\t\t\t\tcontent.copy(outBuffer, dindex); // write central directory entries\r\n\t\t\t\t\t\t\t\tdindex += content.length;\r\n\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\tvar mh = mainHeader.toBinary();\r\n\t\t\t\t\t\t\tif (_comment) {\r\n\t\t\t\t\t\t\t\t_comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tmh.copy(outBuffer, dindex); // write main header\r\n\r\n\t\t\t\t\t\t\tonSuccess(outBuffer);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tcompress(entryList);\r\n\t\t}\r\n\t}\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}