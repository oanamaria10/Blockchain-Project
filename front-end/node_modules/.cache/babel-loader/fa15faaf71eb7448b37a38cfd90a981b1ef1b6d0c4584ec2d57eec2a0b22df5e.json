{"ast":null,"code":"'use strict';\n\nconst {\n  isBlobLike,\n  toUSVString,\n  makeIterator\n} = require('./util');\nconst {\n  kState\n} = require('./symbols');\nconst {\n  File: UndiciFile,\n  FileLike,\n  isFileLike\n} = require('./file');\nconst {\n  webidl\n} = require('./webidl');\nconst {\n  Blob,\n  File: NativeFile\n} = require('buffer');\n\n/** @type {globalThis['File']} */\nconst File = NativeFile ?? UndiciFile;\n\n// https://xhr.spec.whatwg.org/#formdata\nclass FormData {\n  constructor(form) {\n    if (form !== undefined) {\n      throw webidl.errors.conversionFailed({\n        prefix: 'FormData constructor',\n        argument: 'Argument 1',\n        types: ['undefined']\n      });\n    }\n    this[kState] = [];\n  }\n  append(name, value, filename = undefined) {\n    webidl.brandCheck(this, FormData);\n    webidl.argumentLengthCheck(arguments, 2, {\n      header: 'FormData.append'\n    });\n    if (arguments.length === 3 && !isBlobLike(value)) {\n      throw new TypeError(\"Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'\");\n    }\n\n    // 1. Let value be value if given; otherwise blobValue.\n\n    name = webidl.converters.USVString(name);\n    value = isBlobLike(value) ? webidl.converters.Blob(value, {\n      strict: false\n    }) : webidl.converters.USVString(value);\n    filename = arguments.length === 3 ? webidl.converters.USVString(filename) : undefined;\n\n    // 2. Let entry be the result of creating an entry with\n    // name, value, and filename if given.\n    const entry = makeEntry(name, value, filename);\n\n    // 3. Append entry to this’s entry list.\n    this[kState].push(entry);\n  }\n  delete(name) {\n    webidl.brandCheck(this, FormData);\n    webidl.argumentLengthCheck(arguments, 1, {\n      header: 'FormData.delete'\n    });\n    name = webidl.converters.USVString(name);\n\n    // The delete(name) method steps are to remove all entries whose name\n    // is name from this’s entry list.\n    this[kState] = this[kState].filter(entry => entry.name !== name);\n  }\n  get(name) {\n    webidl.brandCheck(this, FormData);\n    webidl.argumentLengthCheck(arguments, 1, {\n      header: 'FormData.get'\n    });\n    name = webidl.converters.USVString(name);\n\n    // 1. If there is no entry whose name is name in this’s entry list,\n    // then return null.\n    const idx = this[kState].findIndex(entry => entry.name === name);\n    if (idx === -1) {\n      return null;\n    }\n\n    // 2. Return the value of the first entry whose name is name from\n    // this’s entry list.\n    return this[kState][idx].value;\n  }\n  getAll(name) {\n    webidl.brandCheck(this, FormData);\n    webidl.argumentLengthCheck(arguments, 1, {\n      header: 'FormData.getAll'\n    });\n    name = webidl.converters.USVString(name);\n\n    // 1. If there is no entry whose name is name in this’s entry list,\n    // then return the empty list.\n    // 2. Return the values of all entries whose name is name, in order,\n    // from this’s entry list.\n    return this[kState].filter(entry => entry.name === name).map(entry => entry.value);\n  }\n  has(name) {\n    webidl.brandCheck(this, FormData);\n    webidl.argumentLengthCheck(arguments, 1, {\n      header: 'FormData.has'\n    });\n    name = webidl.converters.USVString(name);\n\n    // The has(name) method steps are to return true if there is an entry\n    // whose name is name in this’s entry list; otherwise false.\n    return this[kState].findIndex(entry => entry.name === name) !== -1;\n  }\n  set(name, value, filename = undefined) {\n    webidl.brandCheck(this, FormData);\n    webidl.argumentLengthCheck(arguments, 2, {\n      header: 'FormData.set'\n    });\n    if (arguments.length === 3 && !isBlobLike(value)) {\n      throw new TypeError(\"Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'\");\n    }\n\n    // The set(name, value) and set(name, blobValue, filename) method steps\n    // are:\n\n    // 1. Let value be value if given; otherwise blobValue.\n\n    name = webidl.converters.USVString(name);\n    value = isBlobLike(value) ? webidl.converters.Blob(value, {\n      strict: false\n    }) : webidl.converters.USVString(value);\n    filename = arguments.length === 3 ? toUSVString(filename) : undefined;\n\n    // 2. Let entry be the result of creating an entry with name, value, and\n    // filename if given.\n    const entry = makeEntry(name, value, filename);\n\n    // 3. If there are entries in this’s entry list whose name is name, then\n    // replace the first such entry with entry and remove the others.\n    const idx = this[kState].findIndex(entry => entry.name === name);\n    if (idx !== -1) {\n      this[kState] = [...this[kState].slice(0, idx), entry, ...this[kState].slice(idx + 1).filter(entry => entry.name !== name)];\n    } else {\n      // 4. Otherwise, append entry to this’s entry list.\n      this[kState].push(entry);\n    }\n  }\n  entries() {\n    webidl.brandCheck(this, FormData);\n    return makeIterator(() => this[kState].map(pair => [pair.name, pair.value]), 'FormData', 'key+value');\n  }\n  keys() {\n    webidl.brandCheck(this, FormData);\n    return makeIterator(() => this[kState].map(pair => [pair.name, pair.value]), 'FormData', 'key');\n  }\n  values() {\n    webidl.brandCheck(this, FormData);\n    return makeIterator(() => this[kState].map(pair => [pair.name, pair.value]), 'FormData', 'value');\n  }\n\n  /**\n   * @param {(value: string, key: string, self: FormData) => void} callbackFn\n   * @param {unknown} thisArg\n   */\n  forEach(callbackFn, thisArg = globalThis) {\n    webidl.brandCheck(this, FormData);\n    webidl.argumentLengthCheck(arguments, 1, {\n      header: 'FormData.forEach'\n    });\n    if (typeof callbackFn !== 'function') {\n      throw new TypeError(\"Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'.\");\n    }\n    for (const [key, value] of this) {\n      callbackFn.apply(thisArg, [value, key, this]);\n    }\n  }\n}\nFormData.prototype[Symbol.iterator] = FormData.prototype.entries;\nObject.defineProperties(FormData.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'FormData',\n    configurable: true\n  }\n});\n\n/**\n * @see https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#create-an-entry\n * @param {string} name\n * @param {string|Blob} value\n * @param {?string} filename\n * @returns\n */\nfunction makeEntry(name, value, filename) {\n  // 1. Set name to the result of converting name into a scalar value string.\n  // \"To convert a string into a scalar value string, replace any surrogates\n  //  with U+FFFD.\"\n  // see: https://nodejs.org/dist/latest-v18.x/docs/api/buffer.html#buftostringencoding-start-end\n  name = Buffer.from(name).toString('utf8');\n\n  // 2. If value is a string, then set value to the result of converting\n  //    value into a scalar value string.\n  if (typeof value === 'string') {\n    value = Buffer.from(value).toString('utf8');\n  } else {\n    // 3. Otherwise:\n\n    // 1. If value is not a File object, then set value to a new File object,\n    //    representing the same bytes, whose name attribute value is \"blob\"\n    if (!isFileLike(value)) {\n      value = value instanceof Blob ? new File([value], 'blob', {\n        type: value.type\n      }) : new FileLike(value, 'blob', {\n        type: value.type\n      });\n    }\n\n    // 2. If filename is given, then set value to a new File object,\n    //    representing the same bytes, whose name attribute is filename.\n    if (filename !== undefined) {\n      /** @type {FilePropertyBag} */\n      const options = {\n        type: value.type,\n        lastModified: value.lastModified\n      };\n      value = NativeFile && value instanceof NativeFile || value instanceof UndiciFile ? new File([value], filename, options) : new FileLike(value, filename, options);\n    }\n  }\n\n  // 4. Return an entry whose name is name and whose value is value.\n  return {\n    name,\n    value\n  };\n}\nmodule.exports = {\n  FormData\n};","map":{"version":3,"names":["isBlobLike","toUSVString","makeIterator","require","kState","File","UndiciFile","FileLike","isFileLike","webidl","Blob","NativeFile","FormData","constructor","form","undefined","errors","conversionFailed","prefix","argument","types","append","name","value","filename","brandCheck","argumentLengthCheck","arguments","header","length","TypeError","converters","USVString","strict","entry","makeEntry","push","delete","filter","get","idx","findIndex","getAll","map","has","set","slice","entries","pair","keys","values","forEach","callbackFn","thisArg","globalThis","key","apply","prototype","Symbol","iterator","Object","defineProperties","toStringTag","configurable","Buffer","from","toString","type","options","lastModified","module","exports"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/undici/lib/fetch/formdata.js"],"sourcesContent":["'use strict'\n\nconst { isBlobLike, toUSVString, makeIterator } = require('./util')\nconst { kState } = require('./symbols')\nconst { File: UndiciFile, FileLike, isFileLike } = require('./file')\nconst { webidl } = require('./webidl')\nconst { Blob, File: NativeFile } = require('buffer')\n\n/** @type {globalThis['File']} */\nconst File = NativeFile ?? UndiciFile\n\n// https://xhr.spec.whatwg.org/#formdata\nclass FormData {\n  constructor (form) {\n    if (form !== undefined) {\n      throw webidl.errors.conversionFailed({\n        prefix: 'FormData constructor',\n        argument: 'Argument 1',\n        types: ['undefined']\n      })\n    }\n\n    this[kState] = []\n  }\n\n  append (name, value, filename = undefined) {\n    webidl.brandCheck(this, FormData)\n\n    webidl.argumentLengthCheck(arguments, 2, { header: 'FormData.append' })\n\n    if (arguments.length === 3 && !isBlobLike(value)) {\n      throw new TypeError(\n        \"Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'\"\n      )\n    }\n\n    // 1. Let value be value if given; otherwise blobValue.\n\n    name = webidl.converters.USVString(name)\n    value = isBlobLike(value)\n      ? webidl.converters.Blob(value, { strict: false })\n      : webidl.converters.USVString(value)\n    filename = arguments.length === 3\n      ? webidl.converters.USVString(filename)\n      : undefined\n\n    // 2. Let entry be the result of creating an entry with\n    // name, value, and filename if given.\n    const entry = makeEntry(name, value, filename)\n\n    // 3. Append entry to this’s entry list.\n    this[kState].push(entry)\n  }\n\n  delete (name) {\n    webidl.brandCheck(this, FormData)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.delete' })\n\n    name = webidl.converters.USVString(name)\n\n    // The delete(name) method steps are to remove all entries whose name\n    // is name from this’s entry list.\n    this[kState] = this[kState].filter(entry => entry.name !== name)\n  }\n\n  get (name) {\n    webidl.brandCheck(this, FormData)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.get' })\n\n    name = webidl.converters.USVString(name)\n\n    // 1. If there is no entry whose name is name in this’s entry list,\n    // then return null.\n    const idx = this[kState].findIndex((entry) => entry.name === name)\n    if (idx === -1) {\n      return null\n    }\n\n    // 2. Return the value of the first entry whose name is name from\n    // this’s entry list.\n    return this[kState][idx].value\n  }\n\n  getAll (name) {\n    webidl.brandCheck(this, FormData)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.getAll' })\n\n    name = webidl.converters.USVString(name)\n\n    // 1. If there is no entry whose name is name in this’s entry list,\n    // then return the empty list.\n    // 2. Return the values of all entries whose name is name, in order,\n    // from this’s entry list.\n    return this[kState]\n      .filter((entry) => entry.name === name)\n      .map((entry) => entry.value)\n  }\n\n  has (name) {\n    webidl.brandCheck(this, FormData)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.has' })\n\n    name = webidl.converters.USVString(name)\n\n    // The has(name) method steps are to return true if there is an entry\n    // whose name is name in this’s entry list; otherwise false.\n    return this[kState].findIndex((entry) => entry.name === name) !== -1\n  }\n\n  set (name, value, filename = undefined) {\n    webidl.brandCheck(this, FormData)\n\n    webidl.argumentLengthCheck(arguments, 2, { header: 'FormData.set' })\n\n    if (arguments.length === 3 && !isBlobLike(value)) {\n      throw new TypeError(\n        \"Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'\"\n      )\n    }\n\n    // The set(name, value) and set(name, blobValue, filename) method steps\n    // are:\n\n    // 1. Let value be value if given; otherwise blobValue.\n\n    name = webidl.converters.USVString(name)\n    value = isBlobLike(value)\n      ? webidl.converters.Blob(value, { strict: false })\n      : webidl.converters.USVString(value)\n    filename = arguments.length === 3\n      ? toUSVString(filename)\n      : undefined\n\n    // 2. Let entry be the result of creating an entry with name, value, and\n    // filename if given.\n    const entry = makeEntry(name, value, filename)\n\n    // 3. If there are entries in this’s entry list whose name is name, then\n    // replace the first such entry with entry and remove the others.\n    const idx = this[kState].findIndex((entry) => entry.name === name)\n    if (idx !== -1) {\n      this[kState] = [\n        ...this[kState].slice(0, idx),\n        entry,\n        ...this[kState].slice(idx + 1).filter((entry) => entry.name !== name)\n      ]\n    } else {\n      // 4. Otherwise, append entry to this’s entry list.\n      this[kState].push(entry)\n    }\n  }\n\n  entries () {\n    webidl.brandCheck(this, FormData)\n\n    return makeIterator(\n      () => this[kState].map(pair => [pair.name, pair.value]),\n      'FormData',\n      'key+value'\n    )\n  }\n\n  keys () {\n    webidl.brandCheck(this, FormData)\n\n    return makeIterator(\n      () => this[kState].map(pair => [pair.name, pair.value]),\n      'FormData',\n      'key'\n    )\n  }\n\n  values () {\n    webidl.brandCheck(this, FormData)\n\n    return makeIterator(\n      () => this[kState].map(pair => [pair.name, pair.value]),\n      'FormData',\n      'value'\n    )\n  }\n\n  /**\n   * @param {(value: string, key: string, self: FormData) => void} callbackFn\n   * @param {unknown} thisArg\n   */\n  forEach (callbackFn, thisArg = globalThis) {\n    webidl.brandCheck(this, FormData)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.forEach' })\n\n    if (typeof callbackFn !== 'function') {\n      throw new TypeError(\n        \"Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'.\"\n      )\n    }\n\n    for (const [key, value] of this) {\n      callbackFn.apply(thisArg, [value, key, this])\n    }\n  }\n}\n\nFormData.prototype[Symbol.iterator] = FormData.prototype.entries\n\nObject.defineProperties(FormData.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'FormData',\n    configurable: true\n  }\n})\n\n/**\n * @see https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#create-an-entry\n * @param {string} name\n * @param {string|Blob} value\n * @param {?string} filename\n * @returns\n */\nfunction makeEntry (name, value, filename) {\n  // 1. Set name to the result of converting name into a scalar value string.\n  // \"To convert a string into a scalar value string, replace any surrogates\n  //  with U+FFFD.\"\n  // see: https://nodejs.org/dist/latest-v18.x/docs/api/buffer.html#buftostringencoding-start-end\n  name = Buffer.from(name).toString('utf8')\n\n  // 2. If value is a string, then set value to the result of converting\n  //    value into a scalar value string.\n  if (typeof value === 'string') {\n    value = Buffer.from(value).toString('utf8')\n  } else {\n    // 3. Otherwise:\n\n    // 1. If value is not a File object, then set value to a new File object,\n    //    representing the same bytes, whose name attribute value is \"blob\"\n    if (!isFileLike(value)) {\n      value = value instanceof Blob\n        ? new File([value], 'blob', { type: value.type })\n        : new FileLike(value, 'blob', { type: value.type })\n    }\n\n    // 2. If filename is given, then set value to a new File object,\n    //    representing the same bytes, whose name attribute is filename.\n    if (filename !== undefined) {\n      /** @type {FilePropertyBag} */\n      const options = {\n        type: value.type,\n        lastModified: value.lastModified\n      }\n\n      value = (NativeFile && value instanceof NativeFile) || value instanceof UndiciFile\n        ? new File([value], filename, options)\n        : new FileLike(value, filename, options)\n    }\n  }\n\n  // 4. Return an entry whose name is name and whose value is value.\n  return { name, value }\n}\n\nmodule.exports = { FormData }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}