{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSolidityFilesCachePath = exports.SolidityFilesCache = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\nconst t = __importStar(require(\"io-ts\"));\nconst path = __importStar(require(\"path\"));\nconst constants_1 = require(\"../../internal/constants\");\nconst log = (0, debug_1.default)(\"hardhat:core:tasks:compile:cache\");\nconst FORMAT_VERSION = \"hh-sol-cache-2\";\nconst CacheEntryCodec = t.type({\n  lastModificationDate: t.number,\n  contentHash: t.string,\n  sourceName: t.string,\n  solcConfig: t.any,\n  imports: t.array(t.string),\n  versionPragmas: t.array(t.string),\n  artifacts: t.array(t.string)\n});\nconst CacheCodec = t.type({\n  _format: t.string,\n  files: t.record(t.string, CacheEntryCodec)\n});\nclass SolidityFilesCache {\n  static createEmpty() {\n    return new SolidityFilesCache({\n      _format: FORMAT_VERSION,\n      files: {}\n    });\n  }\n  static async readFromFile(solidityFilesCachePath) {\n    let cacheRaw = {\n      _format: FORMAT_VERSION,\n      files: {}\n    };\n    if (await fs_extra_1.default.pathExists(solidityFilesCachePath)) {\n      cacheRaw = await fs_extra_1.default.readJson(solidityFilesCachePath);\n    }\n    const result = CacheCodec.decode(cacheRaw);\n    if (result.isRight()) {\n      const solidityFilesCache = new SolidityFilesCache(result.value);\n      await solidityFilesCache.removeNonExistingFiles();\n      return solidityFilesCache;\n    }\n    log(\"There was a problem reading the cache\");\n    return new SolidityFilesCache({\n      _format: FORMAT_VERSION,\n      files: {}\n    });\n  }\n  constructor(_cache) {\n    this._cache = _cache;\n  }\n  async removeNonExistingFiles() {\n    await Promise.all(Object.keys(this._cache.files).map(async absolutePath => {\n      if (!(await fs_extra_1.default.pathExists(absolutePath))) {\n        this.removeEntry(absolutePath);\n      }\n    }));\n  }\n  async writeToFile(solidityFilesCachePath) {\n    await fs_extra_1.default.outputJson(solidityFilesCachePath, this._cache, {\n      spaces: 2\n    });\n  }\n  addFile(absolutePath, entry) {\n    this._cache.files[absolutePath] = entry;\n  }\n  getEntries() {\n    return Object.values(this._cache.files);\n  }\n  getEntry(file) {\n    return this._cache.files[file];\n  }\n  removeEntry(file) {\n    delete this._cache.files[file];\n  }\n  hasFileChanged(absolutePath, contentHash, solcConfig) {\n    const isEqual = require(\"lodash/isEqual\");\n    const cacheEntry = this.getEntry(absolutePath);\n    if (cacheEntry === undefined) {\n      // new file or no cache available, assume it's new\n      return true;\n    }\n    if (cacheEntry.contentHash !== contentHash) {\n      return true;\n    }\n    if (solcConfig !== undefined && !isEqual(solcConfig, cacheEntry.solcConfig)) {\n      return true;\n    }\n    return false;\n  }\n}\nexports.SolidityFilesCache = SolidityFilesCache;\nfunction getSolidityFilesCachePath(paths) {\n  return path.join(paths.cache, constants_1.SOLIDITY_FILES_CACHE_FILENAME);\n}\nexports.getSolidityFilesCachePath = getSolidityFilesCachePath;","map":{"version":3,"names":["debug_1","__importDefault","require","fs_extra_1","t","__importStar","path","constants_1","log","default","FORMAT_VERSION","CacheEntryCodec","type","lastModificationDate","number","contentHash","string","sourceName","solcConfig","any","imports","array","versionPragmas","artifacts","CacheCodec","_format","files","record","SolidityFilesCache","createEmpty","readFromFile","solidityFilesCachePath","cacheRaw","pathExists","readJson","result","decode","isRight","solidityFilesCache","value","removeNonExistingFiles","constructor","_cache","Promise","all","Object","keys","map","absolutePath","removeEntry","writeToFile","outputJson","spaces","addFile","entry","getEntries","values","getEntry","file","hasFileChanged","isEqual","cacheEntry","undefined","exports","getSolidityFilesCachePath","paths","join","cache","SOLIDITY_FILES_CACHE_FILENAME"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\builtin-tasks\\utils\\solidity-files-cache.ts"],"sourcesContent":["import type { LoDashStatic } from \"lodash\";\nimport type { ProjectPathsConfig, SolcConfig } from \"../../types\";\n\nimport debug from \"debug\";\nimport fsExtra from \"fs-extra\";\nimport * as t from \"io-ts\";\nimport * as path from \"path\";\n\nimport { SOLIDITY_FILES_CACHE_FILENAME } from \"../../internal/constants\";\n\nconst log = debug(\"hardhat:core:tasks:compile:cache\");\n\nconst FORMAT_VERSION = \"hh-sol-cache-2\";\n\nconst CacheEntryCodec = t.type({\n  lastModificationDate: t.number,\n  contentHash: t.string,\n  sourceName: t.string,\n  solcConfig: t.any,\n  imports: t.array(t.string),\n  versionPragmas: t.array(t.string),\n  artifacts: t.array(t.string),\n});\n\nconst CacheCodec = t.type({\n  _format: t.string,\n  files: t.record(t.string, CacheEntryCodec),\n});\n\nexport interface CacheEntry {\n  lastModificationDate: number;\n  contentHash: string;\n  sourceName: string;\n  solcConfig: SolcConfig;\n  imports: string[];\n  versionPragmas: string[];\n  artifacts: string[];\n}\n\nexport interface Cache {\n  _format: string;\n  files: Record<string, CacheEntry>;\n}\n\nexport class SolidityFilesCache {\n  public static createEmpty(): SolidityFilesCache {\n    return new SolidityFilesCache({\n      _format: FORMAT_VERSION,\n      files: {},\n    });\n  }\n\n  public static async readFromFile(\n    solidityFilesCachePath: string\n  ): Promise<SolidityFilesCache> {\n    let cacheRaw: Cache = {\n      _format: FORMAT_VERSION,\n      files: {},\n    };\n    if (await fsExtra.pathExists(solidityFilesCachePath)) {\n      cacheRaw = await fsExtra.readJson(solidityFilesCachePath);\n    }\n\n    const result = CacheCodec.decode(cacheRaw);\n\n    if (result.isRight()) {\n      const solidityFilesCache = new SolidityFilesCache(result.value);\n      await solidityFilesCache.removeNonExistingFiles();\n      return solidityFilesCache;\n    }\n\n    log(\"There was a problem reading the cache\");\n\n    return new SolidityFilesCache({\n      _format: FORMAT_VERSION,\n      files: {},\n    });\n  }\n\n  constructor(private _cache: Cache) {}\n\n  public async removeNonExistingFiles() {\n    await Promise.all(\n      Object.keys(this._cache.files).map(async (absolutePath) => {\n        if (!(await fsExtra.pathExists(absolutePath))) {\n          this.removeEntry(absolutePath);\n        }\n      })\n    );\n  }\n\n  public async writeToFile(solidityFilesCachePath: string) {\n    await fsExtra.outputJson(solidityFilesCachePath, this._cache, {\n      spaces: 2,\n    });\n  }\n\n  public addFile(absolutePath: string, entry: CacheEntry) {\n    this._cache.files[absolutePath] = entry;\n  }\n\n  public getEntries(): CacheEntry[] {\n    return Object.values(this._cache.files);\n  }\n\n  public getEntry(file: string): CacheEntry | undefined {\n    return this._cache.files[file];\n  }\n\n  public removeEntry(file: string) {\n    delete this._cache.files[file];\n  }\n\n  public hasFileChanged(\n    absolutePath: string,\n    contentHash: string,\n    solcConfig?: SolcConfig\n  ): boolean {\n    const isEqual = require(\"lodash/isEqual\") as LoDashStatic[\"isEqual\"];\n\n    const cacheEntry = this.getEntry(absolutePath);\n\n    if (cacheEntry === undefined) {\n      // new file or no cache available, assume it's new\n      return true;\n    }\n\n    if (cacheEntry.contentHash !== contentHash) {\n      return true;\n    }\n\n    if (\n      solcConfig !== undefined &&\n      !isEqual(solcConfig, cacheEntry.solcConfig)\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n}\n\nexport function getSolidityFilesCachePath(paths: ProjectPathsConfig): string {\n  return path.join(paths.cache, SOLIDITY_FILES_CACHE_FILENAME);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}