{"ast":null,"code":"/** Auto-generated with @ipld/schema@v4.2.0 at Thu Sep 14 2023 from IPLD Schema:\n *\n * # CarV1HeaderOrV2Pragma is a more relaxed form, and can parse {version:x} where\n * # roots are optional. This is typically useful for the {verison:2} CARv2\n * # pragma.\n *\n * type CarV1HeaderOrV2Pragma struct {\n * \troots optional [&Any]\n * \t# roots is _not_ optional for CarV1 but we defer that check within code to\n * \t# gracefully handle the V2 case where it's just {version:X}\n * \tversion Int\n * }\n *\n * # CarV1Header is the strict form of the header, and requires roots to be\n * # present. This is compatible with the CARv1 specification.\n *\n * # type CarV1Header struct {\n * # \troots [&Any]\n * # \tversion Int\n * # }\n *\n */\n\nconst Kinds = {\n  Null: /** @returns {undefined|null} */( /** @type {any} */obj) => obj === null ? obj : undefined,\n  Int: /** @returns {undefined|number} */( /** @type {any} */obj) => Number.isInteger(obj) ? obj : undefined,\n  Float: /** @returns {undefined|number} */( /** @type {any} */obj) => typeof obj === 'number' && Number.isFinite(obj) ? obj : undefined,\n  String: /** @returns {undefined|string} */( /** @type {any} */obj) => typeof obj === 'string' ? obj : undefined,\n  Bool: /** @returns {undefined|boolean} */( /** @type {any} */obj) => typeof obj === 'boolean' ? obj : undefined,\n  Bytes: /** @returns {undefined|Uint8Array} */( /** @type {any} */obj) => obj instanceof Uint8Array ? obj : undefined,\n  Link: /** @returns {undefined|object} */( /** @type {any} */obj) => obj !== null && typeof obj === 'object' && obj.asCID === obj ? obj : undefined,\n  List: /** @returns {undefined|Array<any>} */( /** @type {any} */obj) => Array.isArray(obj) ? obj : undefined,\n  Map: /** @returns {undefined|object} */( /** @type {any} */obj) => obj !== null && typeof obj === 'object' && obj.asCID !== obj && !Array.isArray(obj) && !(obj instanceof Uint8Array) ? obj : undefined\n};\n/** @type {{ [k in string]: (obj:any)=>undefined|any}} */\nconst Types = {\n  'CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)': Kinds.Link,\n  'CarV1HeaderOrV2Pragma > roots (anon)': /** @returns {undefined|any} */( /** @type {any} */obj) => {\n    if (Kinds.List(obj) === undefined) {\n      return undefined;\n    }\n    for (let i = 0; i < obj.length; i++) {\n      let v = obj[i];\n      v = Types['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v);\n      if (v === undefined) {\n        return undefined;\n      }\n      if (v !== obj[i]) {\n        const ret = obj.slice(0, i);\n        for (let j = i; j < obj.length; j++) {\n          let v = obj[j];\n          v = Types['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v);\n          if (v === undefined) {\n            return undefined;\n          }\n          ret.push(v);\n        }\n        return ret;\n      }\n    }\n    return obj;\n  },\n  Int: Kinds.Int,\n  CarV1HeaderOrV2Pragma: /** @returns {undefined|any} */( /** @type {any} */obj) => {\n    if (Kinds.Map(obj) === undefined) {\n      return undefined;\n    }\n    const entries = Object.entries(obj);\n    /** @type {{[k in string]: any}} */\n    let ret = obj;\n    let requiredCount = 1;\n    for (let i = 0; i < entries.length; i++) {\n      const [key, value] = entries[i];\n      switch (key) {\n        case 'roots':\n          {\n            const v = Types['CarV1HeaderOrV2Pragma > roots (anon)'](obj[key]);\n            if (v === undefined) {\n              return undefined;\n            }\n            if (v !== value || ret !== obj) {\n              if (ret === obj) {\n                /** @type {{[k in string]: any}} */\n                ret = {};\n                for (let j = 0; j < i; j++) {\n                  ret[entries[j][0]] = entries[j][1];\n                }\n              }\n              ret.roots = v;\n            }\n          }\n          break;\n        case 'version':\n          {\n            requiredCount--;\n            const v = Types.Int(obj[key]);\n            if (v === undefined) {\n              return undefined;\n            }\n            if (v !== value || ret !== obj) {\n              if (ret === obj) {\n                /** @type {{[k in string]: any}} */\n                ret = {};\n                for (let j = 0; j < i; j++) {\n                  ret[entries[j][0]] = entries[j][1];\n                }\n              }\n              ret.version = v;\n            }\n          }\n          break;\n        default:\n          return undefined;\n      }\n    }\n    if (requiredCount > 0) {\n      return undefined;\n    }\n    return ret;\n  }\n};\n/** @type {{ [k in string]: (obj:any)=>undefined|any}} */\nconst Reprs = {\n  'CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)': Kinds.Link,\n  'CarV1HeaderOrV2Pragma > roots (anon)': /** @returns {undefined|any} */( /** @type {any} */obj) => {\n    if (Kinds.List(obj) === undefined) {\n      return undefined;\n    }\n    for (let i = 0; i < obj.length; i++) {\n      let v = obj[i];\n      v = Reprs['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v);\n      if (v === undefined) {\n        return undefined;\n      }\n      if (v !== obj[i]) {\n        const ret = obj.slice(0, i);\n        for (let j = i; j < obj.length; j++) {\n          let v = obj[j];\n          v = Reprs['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v);\n          if (v === undefined) {\n            return undefined;\n          }\n          ret.push(v);\n        }\n        return ret;\n      }\n    }\n    return obj;\n  },\n  Int: Kinds.Int,\n  CarV1HeaderOrV2Pragma: /** @returns {undefined|any} */( /** @type {any} */obj) => {\n    if (Kinds.Map(obj) === undefined) {\n      return undefined;\n    }\n    const entries = Object.entries(obj);\n    /** @type {{[k in string]: any}} */\n    let ret = obj;\n    let requiredCount = 1;\n    for (let i = 0; i < entries.length; i++) {\n      const [key, value] = entries[i];\n      switch (key) {\n        case 'roots':\n          {\n            const v = Reprs['CarV1HeaderOrV2Pragma > roots (anon)'](value);\n            if (v === undefined) {\n              return undefined;\n            }\n            if (v !== value || ret !== obj) {\n              if (ret === obj) {\n                /** @type {{[k in string]: any}} */\n                ret = {};\n                for (let j = 0; j < i; j++) {\n                  ret[entries[j][0]] = entries[j][1];\n                }\n              }\n              ret.roots = v;\n            }\n          }\n          break;\n        case 'version':\n          {\n            requiredCount--;\n            const v = Reprs.Int(value);\n            if (v === undefined) {\n              return undefined;\n            }\n            if (v !== value || ret !== obj) {\n              if (ret === obj) {\n                /** @type {{[k in string]: any}} */\n                ret = {};\n                for (let j = 0; j < i; j++) {\n                  ret[entries[j][0]] = entries[j][1];\n                }\n              }\n              ret.version = v;\n            }\n          }\n          break;\n        default:\n          return undefined;\n      }\n    }\n    if (requiredCount > 0) {\n      return undefined;\n    }\n    return ret;\n  }\n};\nexport const CarV1HeaderOrV2Pragma = {\n  toTyped: Types.CarV1HeaderOrV2Pragma,\n  toRepresentation: Reprs.CarV1HeaderOrV2Pragma\n};","map":{"version":3,"names":["Kinds","Null","obj","undefined","Int","Number","isInteger","Float","isFinite","String","Bool","Bytes","Uint8Array","Link","asCID","List","Array","isArray","Map","Types","CarV1HeaderOrV2Pragma > roots (anon)","i","length","v","ret","slice","j","push","CarV1HeaderOrV2Pragma","entries","Object","requiredCount","key","value","roots","version","Reprs","toTyped","toRepresentation"],"sources":["C:/FACULTATE/Proiect/node_modules/@ucanto/core/node_modules/@ipld/car/src/header-validator.js"],"sourcesContent":["/** Auto-generated with @ipld/schema@v4.2.0 at Thu Sep 14 2023 from IPLD Schema:\n *\n * # CarV1HeaderOrV2Pragma is a more relaxed form, and can parse {version:x} where\n * # roots are optional. This is typically useful for the {verison:2} CARv2\n * # pragma.\n *\n * type CarV1HeaderOrV2Pragma struct {\n * \troots optional [&Any]\n * \t# roots is _not_ optional for CarV1 but we defer that check within code to\n * \t# gracefully handle the V2 case where it's just {version:X}\n * \tversion Int\n * }\n *\n * # CarV1Header is the strict form of the header, and requires roots to be\n * # present. This is compatible with the CARv1 specification.\n *\n * # type CarV1Header struct {\n * # \troots [&Any]\n * # \tversion Int\n * # }\n *\n */\n\nconst Kinds = {\n  Null: /** @returns {undefined|null} */ (/** @type {any} */ obj) => obj === null ? obj : undefined,\n  Int: /** @returns {undefined|number} */ (/** @type {any} */ obj) => Number.isInteger(obj) ? obj : undefined,\n  Float: /** @returns {undefined|number} */ (/** @type {any} */ obj) => typeof obj === 'number' && Number.isFinite(obj) ? obj : undefined,\n  String: /** @returns {undefined|string} */ (/** @type {any} */ obj) => typeof obj === 'string' ? obj : undefined,\n  Bool: /** @returns {undefined|boolean} */ (/** @type {any} */ obj) => typeof obj === 'boolean' ? obj : undefined,\n  Bytes: /** @returns {undefined|Uint8Array} */ (/** @type {any} */ obj) => obj instanceof Uint8Array ? obj : undefined,\n  Link: /** @returns {undefined|object} */ (/** @type {any} */ obj) => obj !== null && typeof obj === 'object' && obj.asCID === obj ? obj : undefined,\n  List: /** @returns {undefined|Array<any>} */ (/** @type {any} */ obj) => Array.isArray(obj) ? obj : undefined,\n  Map: /** @returns {undefined|object} */ (/** @type {any} */ obj) => obj !== null && typeof obj === 'object' && obj.asCID !== obj && !Array.isArray(obj) && !(obj instanceof Uint8Array) ? obj : undefined\n}\n/** @type {{ [k in string]: (obj:any)=>undefined|any}} */\nconst Types = {\n  'CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)': Kinds.Link,\n  'CarV1HeaderOrV2Pragma > roots (anon)': /** @returns {undefined|any} */ (/** @type {any} */ obj) => {\n    if (Kinds.List(obj) === undefined) {\n      return undefined\n    }\n    for (let i = 0; i < obj.length; i++) {\n      let v = obj[i]\n      v = Types['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v)\n      if (v === undefined) {\n        return undefined\n      }\n      if (v !== obj[i]) {\n        const ret = obj.slice(0, i)\n        for (let j = i; j < obj.length; j++) {\n          let v = obj[j]\n          v = Types['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v)\n          if (v === undefined) {\n            return undefined\n          }\n          ret.push(v)\n        }\n        return ret\n      }\n    }\n    return obj\n  },\n  Int: Kinds.Int,\n  CarV1HeaderOrV2Pragma: /** @returns {undefined|any} */ (/** @type {any} */ obj) => {\n    if (Kinds.Map(obj) === undefined) {\n      return undefined\n    }\n    const entries = Object.entries(obj)\n    /** @type {{[k in string]: any}} */\n    let ret = obj\n    let requiredCount = 1\n    for (let i = 0; i < entries.length; i++) {\n      const [key, value] = entries[i]\n      switch (key) {\n        case 'roots':\n          {\n            const v = Types['CarV1HeaderOrV2Pragma > roots (anon)'](obj[key])\n            if (v === undefined) {\n              return undefined\n            }\n            if (v !== value || ret !== obj) {\n              if (ret === obj) {\n                /** @type {{[k in string]: any}} */\n                ret = {}\n                for (let j = 0; j < i; j++) {\n                  ret[entries[j][0]] = entries[j][1]\n                }\n              }\n              ret.roots = v\n            }\n          }\n          break\n        case 'version':\n          {\n            requiredCount--\n            const v = Types.Int(obj[key])\n            if (v === undefined) {\n              return undefined\n            }\n            if (v !== value || ret !== obj) {\n              if (ret === obj) {\n                /** @type {{[k in string]: any}} */\n                ret = {}\n                for (let j = 0; j < i; j++) {\n                  ret[entries[j][0]] = entries[j][1]\n                }\n              }\n              ret.version = v\n            }\n          }\n          break\n        default:\n          return undefined\n      }\n    }\n\n    if (requiredCount > 0) {\n      return undefined\n    }\n    return ret\n  }\n}\n/** @type {{ [k in string]: (obj:any)=>undefined|any}} */\nconst Reprs = {\n  'CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)': Kinds.Link,\n  'CarV1HeaderOrV2Pragma > roots (anon)': /** @returns {undefined|any} */ (/** @type {any} */ obj) => {\n    if (Kinds.List(obj) === undefined) {\n      return undefined\n    }\n    for (let i = 0; i < obj.length; i++) {\n      let v = obj[i]\n      v = Reprs['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v)\n      if (v === undefined) {\n        return undefined\n      }\n      if (v !== obj[i]) {\n        const ret = obj.slice(0, i)\n        for (let j = i; j < obj.length; j++) {\n          let v = obj[j]\n          v = Reprs['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v)\n          if (v === undefined) {\n            return undefined\n          }\n          ret.push(v)\n        }\n        return ret\n      }\n    }\n    return obj\n  },\n  Int: Kinds.Int,\n  CarV1HeaderOrV2Pragma: /** @returns {undefined|any} */ (/** @type {any} */ obj) => {\n    if (Kinds.Map(obj) === undefined) {\n      return undefined\n    }\n    const entries = Object.entries(obj)\n    /** @type {{[k in string]: any}} */\n    let ret = obj\n    let requiredCount = 1\n    for (let i = 0; i < entries.length; i++) {\n      const [key, value] = entries[i]\n      switch (key) {\n        case 'roots':\n          {\n            const v = Reprs['CarV1HeaderOrV2Pragma > roots (anon)'](value)\n            if (v === undefined) {\n              return undefined\n            }\n            if (v !== value || ret !== obj) {\n              if (ret === obj) {\n                /** @type {{[k in string]: any}} */\n                ret = {}\n                for (let j = 0; j < i; j++) {\n                  ret[entries[j][0]] = entries[j][1]\n                }\n              }\n              ret.roots = v\n            }\n          }\n          break\n        case 'version':\n          {\n            requiredCount--\n            const v = Reprs.Int(value)\n            if (v === undefined) {\n              return undefined\n            }\n            if (v !== value || ret !== obj) {\n              if (ret === obj) {\n                /** @type {{[k in string]: any}} */\n                ret = {}\n                for (let j = 0; j < i; j++) {\n                  ret[entries[j][0]] = entries[j][1]\n                }\n              }\n              ret.version = v\n            }\n          }\n          break\n        default:\n          return undefined\n      }\n    }\n    if (requiredCount > 0) {\n      return undefined\n    }\n    return ret\n  }\n}\n\nexport const CarV1HeaderOrV2Pragma = {\n  toTyped: Types.CarV1HeaderOrV2Pragma,\n  toRepresentation: Reprs.CarV1HeaderOrV2Pragma\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,KAAK,GAAG;EACZC,IAAI,EAAE,gCAAiCA,CAAA,CAAC,kBAAmBC,GAAG,KAAKA,GAAG,KAAK,IAAI,GAAGA,GAAG,GAAGC,SAAS;EACjGC,GAAG,EAAE,kCAAmCA,CAAA,CAAC,kBAAmBF,GAAG,KAAKG,MAAM,CAACC,SAAS,CAACJ,GAAG,CAAC,GAAGA,GAAG,GAAGC,SAAS;EAC3GI,KAAK,EAAE,kCAAmCA,CAAA,CAAC,kBAAmBL,GAAG,KAAK,OAAOA,GAAG,KAAK,QAAQ,IAAIG,MAAM,CAACG,QAAQ,CAACN,GAAG,CAAC,GAAGA,GAAG,GAAGC,SAAS;EACvIM,MAAM,EAAE,kCAAmCA,CAAA,CAAC,kBAAmBP,GAAG,KAAK,OAAOA,GAAG,KAAK,QAAQ,GAAGA,GAAG,GAAGC,SAAS;EAChHO,IAAI,EAAE,mCAAoCA,CAAA,CAAC,kBAAmBR,GAAG,KAAK,OAAOA,GAAG,KAAK,SAAS,GAAGA,GAAG,GAAGC,SAAS;EAChHQ,KAAK,EAAE,sCAAuCA,CAAA,CAAC,kBAAmBT,GAAG,KAAKA,GAAG,YAAYU,UAAU,GAAGV,GAAG,GAAGC,SAAS;EACrHU,IAAI,EAAE,kCAAmCA,CAAA,CAAC,kBAAmBX,GAAG,KAAKA,GAAG,KAAK,IAAI,IAAI,OAAOA,GAAG,KAAK,QAAQ,IAAIA,GAAG,CAACY,KAAK,KAAKZ,GAAG,GAAGA,GAAG,GAAGC,SAAS;EACnJY,IAAI,EAAE,sCAAuCA,CAAA,CAAC,kBAAmBb,GAAG,KAAKc,KAAK,CAACC,OAAO,CAACf,GAAG,CAAC,GAAGA,GAAG,GAAGC,SAAS;EAC7Ge,GAAG,EAAE,kCAAmCA,CAAA,CAAC,kBAAmBhB,GAAG,KAAKA,GAAG,KAAK,IAAI,IAAI,OAAOA,GAAG,KAAK,QAAQ,IAAIA,GAAG,CAACY,KAAK,KAAKZ,GAAG,IAAI,CAACc,KAAK,CAACC,OAAO,CAACf,GAAG,CAAC,IAAI,EAAEA,GAAG,YAAYU,UAAU,CAAC,GAAGV,GAAG,GAAGC;AAClM,CAAC;AACD;AACA,MAAMgB,KAAK,GAAG;EACZ,yDAAyD,EAAEnB,KAAK,CAACa,IAAI;EACrE,sCAAsC,EAAE,+BAAgCO,CAAA,CAAC,kBAAmBlB,GAAG,KAAK;IAClG,IAAIF,KAAK,CAACe,IAAI,CAACb,GAAG,CAAC,KAAKC,SAAS,EAAE;MACjC,OAAOA,SAAS;IAClB;IACA,KAAK,IAAIkB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnB,GAAG,CAACoB,MAAM,EAAED,CAAC,EAAE,EAAE;MACnC,IAAIE,CAAC,GAAGrB,GAAG,CAACmB,CAAC,CAAC;MACdE,CAAC,GAAGJ,KAAK,CAAC,yDAAyD,CAAC,CAACI,CAAC,CAAC;MACvE,IAAIA,CAAC,KAAKpB,SAAS,EAAE;QACnB,OAAOA,SAAS;MAClB;MACA,IAAIoB,CAAC,KAAKrB,GAAG,CAACmB,CAAC,CAAC,EAAE;QAChB,MAAMG,GAAG,GAAGtB,GAAG,CAACuB,KAAK,CAAC,CAAC,EAAEJ,CAAC,CAAC;QAC3B,KAAK,IAAIK,CAAC,GAAGL,CAAC,EAAEK,CAAC,GAAGxB,GAAG,CAACoB,MAAM,EAAEI,CAAC,EAAE,EAAE;UACnC,IAAIH,CAAC,GAAGrB,GAAG,CAACwB,CAAC,CAAC;UACdH,CAAC,GAAGJ,KAAK,CAAC,yDAAyD,CAAC,CAACI,CAAC,CAAC;UACvE,IAAIA,CAAC,KAAKpB,SAAS,EAAE;YACnB,OAAOA,SAAS;UAClB;UACAqB,GAAG,CAACG,IAAI,CAACJ,CAAC,CAAC;QACb;QACA,OAAOC,GAAG;MACZ;IACF;IACA,OAAOtB,GAAG;EACZ,CAAC;EACDE,GAAG,EAAEJ,KAAK,CAACI,GAAG;EACdwB,qBAAqB,EAAE,+BAAgCA,CAAA,CAAC,kBAAmB1B,GAAG,KAAK;IACjF,IAAIF,KAAK,CAACkB,GAAG,CAAChB,GAAG,CAAC,KAAKC,SAAS,EAAE;MAChC,OAAOA,SAAS;IAClB;IACA,MAAM0B,OAAO,GAAGC,MAAM,CAACD,OAAO,CAAC3B,GAAG,CAAC;IACnC;IACA,IAAIsB,GAAG,GAAGtB,GAAG;IACb,IAAI6B,aAAa,GAAG,CAAC;IACrB,KAAK,IAAIV,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGQ,OAAO,CAACP,MAAM,EAAED,CAAC,EAAE,EAAE;MACvC,MAAM,CAACW,GAAG,EAAEC,KAAK,CAAC,GAAGJ,OAAO,CAACR,CAAC,CAAC;MAC/B,QAAQW,GAAG;QACT,KAAK,OAAO;UACV;YACE,MAAMT,CAAC,GAAGJ,KAAK,CAAC,sCAAsC,CAAC,CAACjB,GAAG,CAAC8B,GAAG,CAAC,CAAC;YACjE,IAAIT,CAAC,KAAKpB,SAAS,EAAE;cACnB,OAAOA,SAAS;YAClB;YACA,IAAIoB,CAAC,KAAKU,KAAK,IAAIT,GAAG,KAAKtB,GAAG,EAAE;cAC9B,IAAIsB,GAAG,KAAKtB,GAAG,EAAE;gBACf;gBACAsB,GAAG,GAAG,CAAC,CAAC;gBACR,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,CAAC,EAAEK,CAAC,EAAE,EAAE;kBAC1BF,GAAG,CAACK,OAAO,CAACH,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGG,OAAO,CAACH,CAAC,CAAC,CAAC,CAAC,CAAC;gBACpC;cACF;cACAF,GAAG,CAACU,KAAK,GAAGX,CAAC;YACf;UACF;UACA;QACF,KAAK,SAAS;UACZ;YACEQ,aAAa,EAAE;YACf,MAAMR,CAAC,GAAGJ,KAAK,CAACf,GAAG,CAACF,GAAG,CAAC8B,GAAG,CAAC,CAAC;YAC7B,IAAIT,CAAC,KAAKpB,SAAS,EAAE;cACnB,OAAOA,SAAS;YAClB;YACA,IAAIoB,CAAC,KAAKU,KAAK,IAAIT,GAAG,KAAKtB,GAAG,EAAE;cAC9B,IAAIsB,GAAG,KAAKtB,GAAG,EAAE;gBACf;gBACAsB,GAAG,GAAG,CAAC,CAAC;gBACR,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,CAAC,EAAEK,CAAC,EAAE,EAAE;kBAC1BF,GAAG,CAACK,OAAO,CAACH,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGG,OAAO,CAACH,CAAC,CAAC,CAAC,CAAC,CAAC;gBACpC;cACF;cACAF,GAAG,CAACW,OAAO,GAAGZ,CAAC;YACjB;UACF;UACA;QACF;UACE,OAAOpB,SAAS;MACpB;IACF;IAEA,IAAI4B,aAAa,GAAG,CAAC,EAAE;MACrB,OAAO5B,SAAS;IAClB;IACA,OAAOqB,GAAG;EACZ;AACF,CAAC;AACD;AACA,MAAMY,KAAK,GAAG;EACZ,yDAAyD,EAAEpC,KAAK,CAACa,IAAI;EACrE,sCAAsC,EAAE,+BAAgCO,CAAA,CAAC,kBAAmBlB,GAAG,KAAK;IAClG,IAAIF,KAAK,CAACe,IAAI,CAACb,GAAG,CAAC,KAAKC,SAAS,EAAE;MACjC,OAAOA,SAAS;IAClB;IACA,KAAK,IAAIkB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnB,GAAG,CAACoB,MAAM,EAAED,CAAC,EAAE,EAAE;MACnC,IAAIE,CAAC,GAAGrB,GAAG,CAACmB,CAAC,CAAC;MACdE,CAAC,GAAGa,KAAK,CAAC,yDAAyD,CAAC,CAACb,CAAC,CAAC;MACvE,IAAIA,CAAC,KAAKpB,SAAS,EAAE;QACnB,OAAOA,SAAS;MAClB;MACA,IAAIoB,CAAC,KAAKrB,GAAG,CAACmB,CAAC,CAAC,EAAE;QAChB,MAAMG,GAAG,GAAGtB,GAAG,CAACuB,KAAK,CAAC,CAAC,EAAEJ,CAAC,CAAC;QAC3B,KAAK,IAAIK,CAAC,GAAGL,CAAC,EAAEK,CAAC,GAAGxB,GAAG,CAACoB,MAAM,EAAEI,CAAC,EAAE,EAAE;UACnC,IAAIH,CAAC,GAAGrB,GAAG,CAACwB,CAAC,CAAC;UACdH,CAAC,GAAGa,KAAK,CAAC,yDAAyD,CAAC,CAACb,CAAC,CAAC;UACvE,IAAIA,CAAC,KAAKpB,SAAS,EAAE;YACnB,OAAOA,SAAS;UAClB;UACAqB,GAAG,CAACG,IAAI,CAACJ,CAAC,CAAC;QACb;QACA,OAAOC,GAAG;MACZ;IACF;IACA,OAAOtB,GAAG;EACZ,CAAC;EACDE,GAAG,EAAEJ,KAAK,CAACI,GAAG;EACdwB,qBAAqB,EAAE,+BAAgCA,CAAA,CAAC,kBAAmB1B,GAAG,KAAK;IACjF,IAAIF,KAAK,CAACkB,GAAG,CAAChB,GAAG,CAAC,KAAKC,SAAS,EAAE;MAChC,OAAOA,SAAS;IAClB;IACA,MAAM0B,OAAO,GAAGC,MAAM,CAACD,OAAO,CAAC3B,GAAG,CAAC;IACnC;IACA,IAAIsB,GAAG,GAAGtB,GAAG;IACb,IAAI6B,aAAa,GAAG,CAAC;IACrB,KAAK,IAAIV,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGQ,OAAO,CAACP,MAAM,EAAED,CAAC,EAAE,EAAE;MACvC,MAAM,CAACW,GAAG,EAAEC,KAAK,CAAC,GAAGJ,OAAO,CAACR,CAAC,CAAC;MAC/B,QAAQW,GAAG;QACT,KAAK,OAAO;UACV;YACE,MAAMT,CAAC,GAAGa,KAAK,CAAC,sCAAsC,CAAC,CAACH,KAAK,CAAC;YAC9D,IAAIV,CAAC,KAAKpB,SAAS,EAAE;cACnB,OAAOA,SAAS;YAClB;YACA,IAAIoB,CAAC,KAAKU,KAAK,IAAIT,GAAG,KAAKtB,GAAG,EAAE;cAC9B,IAAIsB,GAAG,KAAKtB,GAAG,EAAE;gBACf;gBACAsB,GAAG,GAAG,CAAC,CAAC;gBACR,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,CAAC,EAAEK,CAAC,EAAE,EAAE;kBAC1BF,GAAG,CAACK,OAAO,CAACH,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGG,OAAO,CAACH,CAAC,CAAC,CAAC,CAAC,CAAC;gBACpC;cACF;cACAF,GAAG,CAACU,KAAK,GAAGX,CAAC;YACf;UACF;UACA;QACF,KAAK,SAAS;UACZ;YACEQ,aAAa,EAAE;YACf,MAAMR,CAAC,GAAGa,KAAK,CAAChC,GAAG,CAAC6B,KAAK,CAAC;YAC1B,IAAIV,CAAC,KAAKpB,SAAS,EAAE;cACnB,OAAOA,SAAS;YAClB;YACA,IAAIoB,CAAC,KAAKU,KAAK,IAAIT,GAAG,KAAKtB,GAAG,EAAE;cAC9B,IAAIsB,GAAG,KAAKtB,GAAG,EAAE;gBACf;gBACAsB,GAAG,GAAG,CAAC,CAAC;gBACR,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,CAAC,EAAEK,CAAC,EAAE,EAAE;kBAC1BF,GAAG,CAACK,OAAO,CAACH,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGG,OAAO,CAACH,CAAC,CAAC,CAAC,CAAC,CAAC;gBACpC;cACF;cACAF,GAAG,CAACW,OAAO,GAAGZ,CAAC;YACjB;UACF;UACA;QACF;UACE,OAAOpB,SAAS;MACpB;IACF;IACA,IAAI4B,aAAa,GAAG,CAAC,EAAE;MACrB,OAAO5B,SAAS;IAClB;IACA,OAAOqB,GAAG;EACZ;AACF,CAAC;AAED,OAAO,MAAMI,qBAAqB,GAAG;EACnCS,OAAO,EAAElB,KAAK,CAACS,qBAAqB;EACpCU,gBAAgB,EAAEF,KAAK,CAACR;AAC1B,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}