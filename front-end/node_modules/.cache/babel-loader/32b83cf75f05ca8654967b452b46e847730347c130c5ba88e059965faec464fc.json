{"ast":null,"code":"import * as API from './api.js';\nimport { OUT_BYTES_PER_QUAD, FR_RATIO, IN_BYTES_PER_QUAD, MIN_PAYLOAD_SIZE } from './constant.js';\n\n/**\n * Determine the additional bytes of zeroed padding to append to the\n * end of a resource of `size` length in order to fit within a pow2 piece while\n * leaving enough room for Fr32 padding (2 bits per 254).\n *\n * @param {number} payloadSize - The size of the payload.\n * @returns {number}\n */\nexport function toZeroPaddedSize(payloadSize) {\n  const size = Math.max(payloadSize, MIN_PAYLOAD_SIZE);\n  const highestBit = Math.floor(Math.log2(size));\n  const bound = Math.ceil(FR_RATIO * 2 ** (highestBit + 1));\n  // the size is either the closest pow2 number, or the next pow2 number if we\n  // don't have space for padding\n  return size <= bound ? bound : Math.ceil(FR_RATIO * 2 ** (highestBit + 2));\n}\n\n/**\n * Derives fr32 padded size from the source content size (that MUST be\n * multiples of {@link IN_BYTES_PER_QUAD}) in bytes.\n *\n * @param {number} size\n */\nexport const toPieceSize = size => toZeroPaddedSize(size) / FR_RATIO;\n\n/**\n * Derives fr32 unpadded size from the Fr32 padded size in bytes.\n *\n * @param {number} size\n */\nexport const fromPieceSize = size => size * FR_RATIO;\n\n/**\n * Takes source bytes that returns fr32 padded bytes.\n *\n * @param {Uint8Array} source\n * @param {Uint8Array} output\n * @returns {API.Fr23Padded}\n */\nexport const pad = (source, output = new Uint8Array(toPieceSize(source.length))) => {\n  const size = toZeroPaddedSize(source.byteLength);\n  // Calculate number of quads in the given source\n  const quadCount = size / IN_BYTES_PER_QUAD;\n\n  // Cycle over four(4) 31-byte groups, leaving 1 byte in between:\n  // 31 + 1 + 31 + 1 + 31 + 1 + 31 = 127\n  for (let n = 0; n < quadCount; n++) {\n    const readOffset = n * IN_BYTES_PER_QUAD;\n    const writeOffset = n * OUT_BYTES_PER_QUAD;\n\n    // First 31 bytes + 6 bits are taken as-is (trimmed later)\n    output.set(source.subarray(readOffset, readOffset + 32), writeOffset);\n\n    // first 2-bit \"shim\" forced into the otherwise identical output\n    output[writeOffset + 31] &= 0b00111111;\n\n    // copy next Fr32 preceded with the last two bits of the previous Fr32\n    for (let i = 32; i < 64; i++) {\n      output[writeOffset + i] = source[readOffset + i] << 2 | source[readOffset + i - 1] >> 6;\n    }\n\n    // next 2-bit shim\n    output[writeOffset + 63] &= 0b00111111;\n    for (let i = 64; i < 96; i++) {\n      output[writeOffset + i] = source[readOffset + i] << 4 | source[readOffset + i - 1] >> 4;\n    }\n\n    // next 2-bit shim\n    output[writeOffset + 95] &= 0b00111111;\n    for (let i = 96; i < 127; i++) {\n      output[writeOffset + i] = source[readOffset + i] << 6 | source[readOffset + i - 1] >> 2;\n    }\n\n    // we shim last 2-bits by shifting the last byte by two bits\n    output[writeOffset + 127] = source[readOffset + 126] >> 2;\n  }\n  return output;\n};\n\n/**\n * @param {API.Fr23Padded} source\n * @param {Uint8Array} [out]\n */\nexport const unpad = (source, out = new Uint8Array(fromPieceSize(source.length))) => {\n  const chunks = source.length / 128;\n  for (let chunk = 0; chunk < chunks; chunk++) {\n    const inOffNext = chunk * 128 + 1;\n    const outOff = chunk * 127;\n    let at = source[chunk * 128];\n    for (let i = 0; i < 32; i++) {\n      const next = source[i + inOffNext];\n      out[outOff + i] = at;\n      at = next;\n    }\n    out[outOff + 31] |= at << 6;\n    for (let i = 32; i < 64; i++) {\n      const next = source[i + inOffNext];\n      out[outOff + i] = at >> 2;\n      out[outOff + i] |= next << 6;\n      at = next;\n    }\n    out[outOff + 63] ^= at << 6 ^ at << 4;\n    for (let i = 64; i < 96; i++) {\n      const next = source[i + inOffNext];\n      out[outOff + i] = at >> 4;\n      out[outOff + i] |= next << 4;\n      at = next;\n    }\n    out[outOff + 95] ^= at << 4 ^ at << 2;\n    for (let i = 96; i < 127; i++) {\n      const next = source[i + inOffNext];\n      out[outOff + i];\n      out[outOff + i] = at >> 6;\n      out[outOff + i] |= next << 2;\n      at = next;\n    }\n  }\n  return out;\n};","map":{"version":3,"names":["API","OUT_BYTES_PER_QUAD","FR_RATIO","IN_BYTES_PER_QUAD","MIN_PAYLOAD_SIZE","toZeroPaddedSize","payloadSize","size","Math","max","highestBit","floor","log2","bound","ceil","toPieceSize","fromPieceSize","pad","source","output","Uint8Array","length","byteLength","quadCount","n","readOffset","writeOffset","set","subarray","i","unpad","out","chunks","chunk","inOffNext","outOff","at","next"],"sources":["C:/FACULTATE/Proiect/node_modules/@web3-storage/data-segment/src/fr32.js"],"sourcesContent":["import * as API from './api.js'\nimport {\n  OUT_BYTES_PER_QUAD,\n  FR_RATIO,\n  IN_BYTES_PER_QUAD,\n  MIN_PAYLOAD_SIZE,\n} from './constant.js'\n\n/**\n * Determine the additional bytes of zeroed padding to append to the\n * end of a resource of `size` length in order to fit within a pow2 piece while\n * leaving enough room for Fr32 padding (2 bits per 254).\n *\n * @param {number} payloadSize - The size of the payload.\n * @returns {number}\n */\nexport function toZeroPaddedSize(payloadSize) {\n  const size = Math.max(payloadSize, MIN_PAYLOAD_SIZE)\n  const highestBit = Math.floor(Math.log2(size))\n\n  const bound = Math.ceil(FR_RATIO * 2 ** (highestBit + 1))\n  // the size is either the closest pow2 number, or the next pow2 number if we\n  // don't have space for padding\n  return size <= bound ? bound : Math.ceil(FR_RATIO * 2 ** (highestBit + 2))\n}\n\n/**\n * Derives fr32 padded size from the source content size (that MUST be\n * multiples of {@link IN_BYTES_PER_QUAD}) in bytes.\n *\n * @param {number} size\n */\nexport const toPieceSize = (size) => toZeroPaddedSize(size) / FR_RATIO\n\n/**\n * Derives fr32 unpadded size from the Fr32 padded size in bytes.\n *\n * @param {number} size\n */\nexport const fromPieceSize = (size) => size * FR_RATIO\n\n/**\n * Takes source bytes that returns fr32 padded bytes.\n *\n * @param {Uint8Array} source\n * @param {Uint8Array} output\n * @returns {API.Fr23Padded}\n */\nexport const pad = (\n  source,\n  output = new Uint8Array(toPieceSize(source.length))\n) => {\n  const size = toZeroPaddedSize(source.byteLength)\n  // Calculate number of quads in the given source\n  const quadCount = size / IN_BYTES_PER_QUAD\n\n  // Cycle over four(4) 31-byte groups, leaving 1 byte in between:\n  // 31 + 1 + 31 + 1 + 31 + 1 + 31 = 127\n  for (let n = 0; n < quadCount; n++) {\n    const readOffset = n * IN_BYTES_PER_QUAD\n    const writeOffset = n * OUT_BYTES_PER_QUAD\n\n    // First 31 bytes + 6 bits are taken as-is (trimmed later)\n    output.set(source.subarray(readOffset, readOffset + 32), writeOffset)\n\n    // first 2-bit \"shim\" forced into the otherwise identical output\n    output[writeOffset + 31] &= 0b00111111\n\n    // copy next Fr32 preceded with the last two bits of the previous Fr32\n    for (let i = 32; i < 64; i++) {\n      output[writeOffset + i] =\n        (source[readOffset + i] << 2) | (source[readOffset + i - 1] >> 6)\n    }\n\n    // next 2-bit shim\n    output[writeOffset + 63] &= 0b00111111\n\n    for (let i = 64; i < 96; i++) {\n      output[writeOffset + i] =\n        (source[readOffset + i] << 4) | (source[readOffset + i - 1] >> 4)\n    }\n\n    // next 2-bit shim\n    output[writeOffset + 95] &= 0b00111111\n\n    for (let i = 96; i < 127; i++) {\n      output[writeOffset + i] =\n        (source[readOffset + i] << 6) | (source[readOffset + i - 1] >> 2)\n    }\n\n    // we shim last 2-bits by shifting the last byte by two bits\n    output[writeOffset + 127] = source[readOffset + 126] >> 2\n  }\n\n  return output\n}\n\n/**\n * @param {API.Fr23Padded} source\n * @param {Uint8Array} [out]\n */\nexport const unpad = (\n  source,\n  out = new Uint8Array(fromPieceSize(source.length))\n) => {\n  const chunks = source.length / 128\n  for (let chunk = 0; chunk < chunks; chunk++) {\n    const inOffNext = chunk * 128 + 1\n    const outOff = chunk * 127\n\n    let at = source[chunk * 128]\n\n    for (let i = 0; i < 32; i++) {\n      const next = source[i + inOffNext]\n\n      out[outOff + i] = at\n\n      at = next\n    }\n\n    out[outOff + 31] |= at << 6\n\n    for (let i = 32; i < 64; i++) {\n      const next = source[i + inOffNext]\n\n      out[outOff + i] = at >> 2\n      out[outOff + i] |= next << 6\n\n      at = next\n    }\n\n    out[outOff + 63] ^= (at << 6) ^ (at << 4)\n\n    for (let i = 64; i < 96; i++) {\n      const next = source[i + inOffNext]\n\n      out[outOff + i] = at >> 4\n      out[outOff + i] |= next << 4\n\n      at = next\n    }\n\n    out[outOff + 95] ^= (at << 4) ^ (at << 2)\n\n    for (let i = 96; i < 127; i++) {\n      const next = source[i + inOffNext]\n\n      out[outOff + i]\n      out[outOff + i] = at >> 6\n      out[outOff + i] |= next << 2\n\n      at = next\n    }\n  }\n\n  return out\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}