{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.download = void 0;\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\nconst path_1 = __importDefault(require(\"path\"));\nconst packageInfo_1 = require(\"./packageInfo\");\nconst proxy_1 = require(\"./proxy\");\nconst TEMP_FILE_PREFIX = \"tmp-\";\nfunction resolveTempFileName(filePath) {\n  const {\n    dir,\n    ext,\n    name\n  } = path_1.default.parse(filePath);\n  return path_1.default.format({\n    dir,\n    ext,\n    name: `${TEMP_FILE_PREFIX}${name}`\n  });\n}\nasync function download(url, filePath, timeoutMillis = 10000, extraHeaders = {}) {\n  const {\n    getGlobalDispatcher,\n    ProxyAgent,\n    request\n  } = await Promise.resolve().then(() => __importStar(require(\"undici\")));\n  let dispatcher;\n  if (process.env.http_proxy !== undefined && (0, proxy_1.shouldUseProxy)(url)) {\n    dispatcher = new ProxyAgent(process.env.http_proxy);\n  } else {\n    dispatcher = getGlobalDispatcher();\n  }\n  const hardhatVersion = (0, packageInfo_1.getHardhatVersion)();\n  // Fetch the url\n  const response = await request(url, {\n    dispatcher,\n    headersTimeout: timeoutMillis,\n    maxRedirections: 10,\n    method: \"GET\",\n    headers: {\n      ...extraHeaders,\n      \"User-Agent\": `hardhat ${hardhatVersion}`\n    }\n  });\n  if (response.statusCode >= 200 && response.statusCode <= 299) {\n    const responseBody = Buffer.from(await response.body.arrayBuffer());\n    const tmpFilePath = resolveTempFileName(filePath);\n    await fs_extra_1.default.ensureDir(path_1.default.dirname(filePath));\n    await fs_extra_1.default.writeFile(tmpFilePath, responseBody);\n    return fs_extra_1.default.move(tmpFilePath, filePath, {\n      overwrite: true\n    });\n  }\n  // undici's response bodies must always be consumed to prevent leaks\n  const text = await response.body.text();\n  // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n  throw new Error(`Failed to download ${url} - ${response.statusCode} received. ${text}`);\n}\nexports.download = download;","map":{"version":3,"names":["fs_extra_1","__importDefault","require","path_1","packageInfo_1","proxy_1","TEMP_FILE_PREFIX","resolveTempFileName","filePath","dir","ext","name","default","parse","format","download","url","timeoutMillis","extraHeaders","getGlobalDispatcher","ProxyAgent","request","Promise","resolve","then","__importStar","dispatcher","process","env","http_proxy","undefined","shouldUseProxy","hardhatVersion","getHardhatVersion","response","headersTimeout","maxRedirections","method","headers","statusCode","responseBody","Buffer","from","body","arrayBuffer","tmpFilePath","ensureDir","dirname","writeFile","move","overwrite","text","Error","exports"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\internal\\util\\download.ts"],"sourcesContent":["import type { Dispatcher } from \"undici\";\n\nimport fsExtra from \"fs-extra\";\nimport path from \"path\";\n\nimport { getHardhatVersion } from \"./packageInfo\";\nimport { shouldUseProxy } from \"./proxy\";\n\nconst TEMP_FILE_PREFIX = \"tmp-\";\n\nfunction resolveTempFileName(filePath: string): string {\n  const { dir, ext, name } = path.parse(filePath);\n\n  return path.format({\n    dir,\n    ext,\n    name: `${TEMP_FILE_PREFIX}${name}`,\n  });\n}\n\nexport async function download(\n  url: string,\n  filePath: string,\n  timeoutMillis = 10000,\n  extraHeaders: { [name: string]: string } = {}\n) {\n  const { getGlobalDispatcher, ProxyAgent, request } = await import(\"undici\");\n\n  let dispatcher: Dispatcher;\n  if (process.env.http_proxy !== undefined && shouldUseProxy(url)) {\n    dispatcher = new ProxyAgent(process.env.http_proxy);\n  } else {\n    dispatcher = getGlobalDispatcher();\n  }\n\n  const hardhatVersion = getHardhatVersion();\n\n  // Fetch the url\n  const response = await request(url, {\n    dispatcher,\n    headersTimeout: timeoutMillis,\n    maxRedirections: 10,\n    method: \"GET\",\n    headers: {\n      ...extraHeaders,\n      \"User-Agent\": `hardhat ${hardhatVersion}`,\n    },\n  });\n\n  if (response.statusCode >= 200 && response.statusCode <= 299) {\n    const responseBody = Buffer.from(await response.body.arrayBuffer());\n    const tmpFilePath = resolveTempFileName(filePath);\n    await fsExtra.ensureDir(path.dirname(filePath));\n\n    await fsExtra.writeFile(tmpFilePath, responseBody);\n    return fsExtra.move(tmpFilePath, filePath, { overwrite: true });\n  }\n  // undici's response bodies must always be consumed to prevent leaks\n  const text = await response.body.text();\n\n  // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n  throw new Error(\n    `Failed to download ${url} - ${response.statusCode} received. ${text}`\n  );\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,MAAAA,UAAA,GAAAC,eAAA,CAAAC,OAAA;AACA,MAAAC,MAAA,GAAAF,eAAA,CAAAC,OAAA;AAEA,MAAAE,aAAA,GAAAF,OAAA;AACA,MAAAG,OAAA,GAAAH,OAAA;AAEA,MAAMI,gBAAgB,GAAG,MAAM;AAE/B,SAASC,mBAAmBA,CAACC,QAAgB;EAC3C,MAAM;IAAEC,GAAG;IAAEC,GAAG;IAAEC;EAAI,CAAE,GAAGR,MAAA,CAAAS,OAAI,CAACC,KAAK,CAACL,QAAQ,CAAC;EAE/C,OAAOL,MAAA,CAAAS,OAAI,CAACE,MAAM,CAAC;IACjBL,GAAG;IACHC,GAAG;IACHC,IAAI,EAAE,GAAGL,gBAAgB,GAAGK,IAAI;GACjC,CAAC;AACJ;AAEO,eAAeI,QAAQA,CAC5BC,GAAW,EACXR,QAAgB,EAChBS,aAAa,GAAG,KAAK,EACrBC,YAAA,GAA2C,EAAE;EAE7C,MAAM;IAAEC,mBAAmB;IAAEC,UAAU;IAAEC;EAAO,CAAE,GAAG,MAAAC,OAAA,CAAAC,OAAA,GAAAC,IAAA,OAAAC,YAAA,CAAAvB,OAAA,CAAa,QAAQ,GAAC;EAE3E,IAAIwB,UAAsB;EAC1B,IAAIC,OAAO,CAACC,GAAG,CAACC,UAAU,KAAKC,SAAS,IAAI,IAAAzB,OAAA,CAAA0B,cAAc,EAACf,GAAG,CAAC,EAAE;IAC/DU,UAAU,GAAG,IAAIN,UAAU,CAACO,OAAO,CAACC,GAAG,CAACC,UAAU,CAAC;GACpD,MAAM;IACLH,UAAU,GAAGP,mBAAmB,EAAE;;EAGpC,MAAMa,cAAc,GAAG,IAAA5B,aAAA,CAAA6B,iBAAiB,GAAE;EAE1C;EACA,MAAMC,QAAQ,GAAG,MAAMb,OAAO,CAACL,GAAG,EAAE;IAClCU,UAAU;IACVS,cAAc,EAAElB,aAAa;IAC7BmB,eAAe,EAAE,EAAE;IACnBC,MAAM,EAAE,KAAK;IACbC,OAAO,EAAE;MACP,GAAGpB,YAAY;MACf,YAAY,EAAE,WAAWc,cAAc;;GAE1C,CAAC;EAEF,IAAIE,QAAQ,CAACK,UAAU,IAAI,GAAG,IAAIL,QAAQ,CAACK,UAAU,IAAI,GAAG,EAAE;IAC5D,MAAMC,YAAY,GAAGC,MAAM,CAACC,IAAI,CAAC,MAAMR,QAAQ,CAACS,IAAI,CAACC,WAAW,EAAE,CAAC;IACnE,MAAMC,WAAW,GAAGtC,mBAAmB,CAACC,QAAQ,CAAC;IACjD,MAAMR,UAAA,CAAAY,OAAO,CAACkC,SAAS,CAAC3C,MAAA,CAAAS,OAAI,CAACmC,OAAO,CAACvC,QAAQ,CAAC,CAAC;IAE/C,MAAMR,UAAA,CAAAY,OAAO,CAACoC,SAAS,CAACH,WAAW,EAAEL,YAAY,CAAC;IAClD,OAAOxC,UAAA,CAAAY,OAAO,CAACqC,IAAI,CAACJ,WAAW,EAAErC,QAAQ,EAAE;MAAE0C,SAAS,EAAE;IAAI,CAAE,CAAC;;EAEjE;EACA,MAAMC,IAAI,GAAG,MAAMjB,QAAQ,CAACS,IAAI,CAACQ,IAAI,EAAE;EAEvC;EACA,MAAM,IAAIC,KAAK,CACb,sBAAsBpC,GAAG,MAAMkB,QAAQ,CAACK,UAAU,cAAcY,IAAI,EAAE,CACvE;AACH;AA5CAE,OAAA,CAAAtC,QAAA,GAAAA,QAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}