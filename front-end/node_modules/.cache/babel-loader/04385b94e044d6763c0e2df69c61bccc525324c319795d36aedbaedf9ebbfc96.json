{"ast":null,"code":"'use strict';\n\nvar ipfsUnixfs = require('ipfs-unixfs');\nvar persist = require('../../utils/persist.js');\nvar dagPb = require('@ipld/dag-pb');\nvar rawCodec = require('multiformats/codecs/raw');\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\nvar dagPb__namespace = /*#__PURE__*/_interopNamespace(dagPb);\nvar rawCodec__namespace = /*#__PURE__*/_interopNamespace(rawCodec);\nasync function* bufferImporter(file, block, options) {\n  for await (let buffer of file.content) {\n    yield async () => {\n      options.progress(buffer.length, file.path);\n      let unixfs;\n      const opts = {\n        codec: dagPb__namespace,\n        cidVersion: options.cidVersion,\n        hasher: options.hasher,\n        onlyHash: options.onlyHash\n      };\n      if (options.rawLeaves) {\n        opts.codec = rawCodec__namespace;\n        opts.cidVersion = 1;\n      } else {\n        unixfs = new ipfsUnixfs.UnixFS({\n          type: options.leafType,\n          data: buffer\n        });\n        buffer = dagPb__namespace.encode({\n          Data: unixfs.marshal(),\n          Links: []\n        });\n      }\n      return {\n        cid: await persist(buffer, block, opts),\n        unixfs,\n        size: buffer.length\n      };\n    };\n  }\n}\nmodule.exports = bufferImporter;","map":{"version":3,"names":["ipfsUnixfs","require","persist","dagPb","rawCodec","_interopNamespace","e","__esModule","n","Object","create","keys","forEach","k","d","getOwnPropertyDescriptor","defineProperty","get","enumerable","freeze","dagPb__namespace","rawCodec__namespace","bufferImporter","file","block","options","buffer","content","progress","length","path","unixfs","opts","codec","cidVersion","hasher","onlyHash","rawLeaves","UnixFS","type","leafType","data","encode","Data","marshal","Links","cid","size","module","exports"],"sources":["C:/FACULTATE/Proiect/node_modules/ipfs-unixfs-importer/cjs/src/dag-builder/file/buffer-importer.js"],"sourcesContent":["'use strict';\n\nvar ipfsUnixfs = require('ipfs-unixfs');\nvar persist = require('../../utils/persist.js');\nvar dagPb = require('@ipld/dag-pb');\nvar rawCodec = require('multiformats/codecs/raw');\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar dagPb__namespace = /*#__PURE__*/_interopNamespace(dagPb);\nvar rawCodec__namespace = /*#__PURE__*/_interopNamespace(rawCodec);\n\nasync function* bufferImporter(file, block, options) {\n  for await (let buffer of file.content) {\n    yield async () => {\n      options.progress(buffer.length, file.path);\n      let unixfs;\n      const opts = {\n        codec: dagPb__namespace,\n        cidVersion: options.cidVersion,\n        hasher: options.hasher,\n        onlyHash: options.onlyHash\n      };\n      if (options.rawLeaves) {\n        opts.codec = rawCodec__namespace;\n        opts.cidVersion = 1;\n      } else {\n        unixfs = new ipfsUnixfs.UnixFS({\n          type: options.leafType,\n          data: buffer\n        });\n        buffer = dagPb__namespace.encode({\n          Data: unixfs.marshal(),\n          Links: []\n        });\n      }\n      return {\n        cid: await persist(buffer, block, opts),\n        unixfs,\n        size: buffer.length\n      };\n    };\n  }\n}\n\nmodule.exports = bufferImporter;\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,UAAU,GAAGC,OAAO,CAAC,aAAa,CAAC;AACvC,IAAIC,OAAO,GAAGD,OAAO,CAAC,wBAAwB,CAAC;AAC/C,IAAIE,KAAK,GAAGF,OAAO,CAAC,cAAc,CAAC;AACnC,IAAIG,QAAQ,GAAGH,OAAO,CAAC,yBAAyB,CAAC;AAEjD,SAASI,iBAAiBA,CAACC,CAAC,EAAE;EAC5B,IAAIA,CAAC,IAAIA,CAAC,CAACC,UAAU,EAAE,OAAOD,CAAC;EAC/B,IAAIE,CAAC,GAAGC,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;EAC3B,IAAIJ,CAAC,EAAE;IACLG,MAAM,CAACE,IAAI,CAACL,CAAC,CAAC,CAACM,OAAO,CAAC,UAAUC,CAAC,EAAE;MAClC,IAAIA,CAAC,KAAK,SAAS,EAAE;QACnB,IAAIC,CAAC,GAAGL,MAAM,CAACM,wBAAwB,CAACT,CAAC,EAAEO,CAAC,CAAC;QAC7CJ,MAAM,CAACO,cAAc,CAACR,CAAC,EAAEK,CAAC,EAAEC,CAAC,CAACG,GAAG,GAAGH,CAAC,GAAG;UACtCI,UAAU,EAAE,IAAI;UAChBD,GAAG,EAAE,SAAAA,CAAA,EAAY;YAAE,OAAOX,CAAC,CAACO,CAAC,CAAC;UAAE;QAClC,CAAC,CAAC;MACJ;IACF,CAAC,CAAC;EACJ;EACAL,CAAC,CAAC,SAAS,CAAC,GAAGF,CAAC;EAChB,OAAOG,MAAM,CAACU,MAAM,CAACX,CAAC,CAAC;AACzB;AAEA,IAAIY,gBAAgB,GAAG,aAAaf,iBAAiB,CAACF,KAAK,CAAC;AAC5D,IAAIkB,mBAAmB,GAAG,aAAahB,iBAAiB,CAACD,QAAQ,CAAC;AAElE,gBAAgBkB,cAAcA,CAACC,IAAI,EAAEC,KAAK,EAAEC,OAAO,EAAE;EACnD,WAAW,IAAIC,MAAM,IAAIH,IAAI,CAACI,OAAO,EAAE;IACrC,MAAM,YAAY;MAChBF,OAAO,CAACG,QAAQ,CAACF,MAAM,CAACG,MAAM,EAAEN,IAAI,CAACO,IAAI,CAAC;MAC1C,IAAIC,MAAM;MACV,MAAMC,IAAI,GAAG;QACXC,KAAK,EAAEb,gBAAgB;QACvBc,UAAU,EAAET,OAAO,CAACS,UAAU;QAC9BC,MAAM,EAAEV,OAAO,CAACU,MAAM;QACtBC,QAAQ,EAAEX,OAAO,CAACW;MACpB,CAAC;MACD,IAAIX,OAAO,CAACY,SAAS,EAAE;QACrBL,IAAI,CAACC,KAAK,GAAGZ,mBAAmB;QAChCW,IAAI,CAACE,UAAU,GAAG,CAAC;MACrB,CAAC,MAAM;QACLH,MAAM,GAAG,IAAI/B,UAAU,CAACsC,MAAM,CAAC;UAC7BC,IAAI,EAAEd,OAAO,CAACe,QAAQ;UACtBC,IAAI,EAAEf;QACR,CAAC,CAAC;QACFA,MAAM,GAAGN,gBAAgB,CAACsB,MAAM,CAAC;UAC/BC,IAAI,EAAEZ,MAAM,CAACa,OAAO,CAAC,CAAC;UACtBC,KAAK,EAAE;QACT,CAAC,CAAC;MACJ;MACA,OAAO;QACLC,GAAG,EAAE,MAAM5C,OAAO,CAACwB,MAAM,EAAEF,KAAK,EAAEQ,IAAI,CAAC;QACvCD,MAAM;QACNgB,IAAI,EAAErB,MAAM,CAACG;MACf,CAAC;IACH,CAAC;EACH;AACF;AAEAmB,MAAM,CAACC,OAAO,GAAG3B,cAAc","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}