{"ast":null,"code":"/**\n * A doubly linked list-based Least Recently Used (LRU) cache. Will keep most\n * recently used items while discarding least recently used items when its limit\n * is reached.\n *\n * Licensed under MIT. Copyright (c) 2010 Rasmus Andersson <http://hunch.se/>\n * See README.md for details.\n *\n * Illustration of the design:\n *\n *       entry             entry             entry             entry\n *       ______            ______            ______            ______\n *      | head |.newer => |      |.newer => |      |.newer => | tail |\n *      |  A   |          |  B   |          |  C   |          |  D   |\n *      |______| <= older.|______| <= older.|______| <= older.|______|\n *\n *  removed  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  added\n */\n(function (g, f) {\n  const e = typeof exports == 'object' ? exports : typeof g == 'object' ? g : {};\n  f(e);\n  if (typeof define == 'function' && define.amd) {\n    define('lru', e);\n  }\n})(this, function (exports) {\n  const NEWER = Symbol('newer');\n  const OLDER = Symbol('older');\n  function LRUMap(limit, entries) {\n    if (typeof limit !== 'number') {\n      // called as (entries)\n      entries = limit;\n      limit = 0;\n    }\n    this.size = 0;\n    this.limit = limit;\n    this.oldest = this.newest = undefined;\n    this._keymap = new Map();\n    if (entries) {\n      this.assign(entries);\n      if (limit < 1) {\n        this.limit = this.size;\n      }\n    }\n  }\n  exports.LRUMap = LRUMap;\n  function Entry(key, value) {\n    this.key = key;\n    this.value = value;\n    this[NEWER] = undefined;\n    this[OLDER] = undefined;\n  }\n  LRUMap.prototype._markEntryAsUsed = function (entry) {\n    if (entry === this.newest) {\n      // Already the most recenlty used entry, so no need to update the list\n      return;\n    }\n    // HEAD--------------TAIL\n    //   <.older   .newer>\n    //  <--- add direction --\n    //   A  B  C  <D>  E\n    if (entry[NEWER]) {\n      if (entry === this.oldest) {\n        this.oldest = entry[NEWER];\n      }\n      entry[NEWER][OLDER] = entry[OLDER]; // C <-- E.\n    }\n    if (entry[OLDER]) {\n      entry[OLDER][NEWER] = entry[NEWER]; // C. --> E\n    }\n    entry[NEWER] = undefined; // D --x\n    entry[OLDER] = this.newest; // D. --> E\n    if (this.newest) {\n      this.newest[NEWER] = entry; // E. <-- D\n    }\n    this.newest = entry;\n  };\n  LRUMap.prototype.assign = function (entries) {\n    let entry,\n      limit = this.limit || Number.MAX_VALUE;\n    this._keymap.clear();\n    let it = entries[Symbol.iterator]();\n    for (let itv = it.next(); !itv.done; itv = it.next()) {\n      let e = new Entry(itv.value[0], itv.value[1]);\n      this._keymap.set(e.key, e);\n      if (!entry) {\n        this.oldest = e;\n      } else {\n        entry[NEWER] = e;\n        e[OLDER] = entry;\n      }\n      entry = e;\n      if (limit-- == 0) {\n        throw new Error('overflow');\n      }\n    }\n    this.newest = entry;\n    this.size = this._keymap.size;\n  };\n  LRUMap.prototype.get = function (key) {\n    // First, find our cache entry\n    var entry = this._keymap.get(key);\n    if (!entry) return; // Not cached. Sorry.\n    // As <key> was found in the cache, register it as being requested recently\n    this._markEntryAsUsed(entry);\n    return entry.value;\n  };\n  LRUMap.prototype.set = function (key, value) {\n    var entry = this._keymap.get(key);\n    if (entry) {\n      // update existing\n      entry.value = value;\n      this._markEntryAsUsed(entry);\n      return this;\n    }\n\n    // new entry\n    this._keymap.set(key, entry = new Entry(key, value));\n    if (this.newest) {\n      // link previous tail to the new tail (entry)\n      this.newest[NEWER] = entry;\n      entry[OLDER] = this.newest;\n    } else {\n      // we're first in -- yay\n      this.oldest = entry;\n    }\n\n    // add new entry to the end of the linked list -- it's now the freshest entry.\n    this.newest = entry;\n    ++this.size;\n    if (this.size > this.limit) {\n      // we hit the limit -- remove the head\n      this.shift();\n    }\n    return this;\n  };\n  LRUMap.prototype.shift = function () {\n    // todo: handle special case when limit == 1\n    var entry = this.oldest;\n    if (entry) {\n      if (this.oldest[NEWER]) {\n        // advance the list\n        this.oldest = this.oldest[NEWER];\n        this.oldest[OLDER] = undefined;\n      } else {\n        // the cache is exhausted\n        this.oldest = undefined;\n        this.newest = undefined;\n      }\n      // Remove last strong reference to <entry> and remove links from the purged\n      // entry being returned:\n      entry[NEWER] = entry[OLDER] = undefined;\n      this._keymap.delete(entry.key);\n      --this.size;\n      return [entry.key, entry.value];\n    }\n  };\n\n  // ----------------------------------------------------------------------------\n  // Following code is optional and can be removed without breaking the core\n  // functionality.\n\n  LRUMap.prototype.find = function (key) {\n    let e = this._keymap.get(key);\n    return e ? e.value : undefined;\n  };\n  LRUMap.prototype.has = function (key) {\n    return this._keymap.has(key);\n  };\n  LRUMap.prototype['delete'] = function (key) {\n    var entry = this._keymap.get(key);\n    if (!entry) return;\n    this._keymap.delete(entry.key);\n    if (entry[NEWER] && entry[OLDER]) {\n      // relink the older entry with the newer entry\n      entry[OLDER][NEWER] = entry[NEWER];\n      entry[NEWER][OLDER] = entry[OLDER];\n    } else if (entry[NEWER]) {\n      // remove the link to us\n      entry[NEWER][OLDER] = undefined;\n      // link the newer entry to head\n      this.oldest = entry[NEWER];\n    } else if (entry[OLDER]) {\n      // remove the link to us\n      entry[OLDER][NEWER] = undefined;\n      // link the newer entry to head\n      this.newest = entry[OLDER];\n    } else {\n      // if(entry[OLDER] === undefined && entry.newer === undefined) {\n      this.oldest = this.newest = undefined;\n    }\n    this.size--;\n    return entry.value;\n  };\n  LRUMap.prototype.clear = function () {\n    // Not clearing links should be safe, as we don't expose live links to user\n    this.oldest = this.newest = undefined;\n    this.size = 0;\n    this._keymap.clear();\n  };\n  function EntryIterator(oldestEntry) {\n    this.entry = oldestEntry;\n  }\n  EntryIterator.prototype[Symbol.iterator] = function () {\n    return this;\n  };\n  EntryIterator.prototype.next = function () {\n    let ent = this.entry;\n    if (ent) {\n      this.entry = ent[NEWER];\n      return {\n        done: false,\n        value: [ent.key, ent.value]\n      };\n    } else {\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n  };\n  function KeyIterator(oldestEntry) {\n    this.entry = oldestEntry;\n  }\n  KeyIterator.prototype[Symbol.iterator] = function () {\n    return this;\n  };\n  KeyIterator.prototype.next = function () {\n    let ent = this.entry;\n    if (ent) {\n      this.entry = ent[NEWER];\n      return {\n        done: false,\n        value: ent.key\n      };\n    } else {\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n  };\n  function ValueIterator(oldestEntry) {\n    this.entry = oldestEntry;\n  }\n  ValueIterator.prototype[Symbol.iterator] = function () {\n    return this;\n  };\n  ValueIterator.prototype.next = function () {\n    let ent = this.entry;\n    if (ent) {\n      this.entry = ent[NEWER];\n      return {\n        done: false,\n        value: ent.value\n      };\n    } else {\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n  };\n  LRUMap.prototype.keys = function () {\n    return new KeyIterator(this.oldest);\n  };\n  LRUMap.prototype.values = function () {\n    return new ValueIterator(this.oldest);\n  };\n  LRUMap.prototype.entries = function () {\n    return this;\n  };\n  LRUMap.prototype[Symbol.iterator] = function () {\n    return new EntryIterator(this.oldest);\n  };\n  LRUMap.prototype.forEach = function (fun, thisObj) {\n    if (typeof thisObj !== 'object') {\n      thisObj = this;\n    }\n    let entry = this.oldest;\n    while (entry) {\n      fun.call(thisObj, entry.value, entry.key, this);\n      entry = entry[NEWER];\n    }\n  };\n\n  /** Returns a JSON (array) representation */\n  LRUMap.prototype.toJSON = function () {\n    var s = new Array(this.size),\n      i = 0,\n      entry = this.oldest;\n    while (entry) {\n      s[i++] = {\n        key: entry.key,\n        value: entry.value\n      };\n      entry = entry[NEWER];\n    }\n    return s;\n  };\n\n  /** Returns a String representation */\n  LRUMap.prototype.toString = function () {\n    var s = '',\n      entry = this.oldest;\n    while (entry) {\n      s += String(entry.key) + ':' + entry.value;\n      entry = entry[NEWER];\n      if (entry) {\n        s += ' < ';\n      }\n    }\n    return s;\n  };\n});","map":{"version":3,"names":["g","f","e","exports","define","amd","NEWER","Symbol","OLDER","LRUMap","limit","entries","size","oldest","newest","undefined","_keymap","Map","assign","Entry","key","value","prototype","_markEntryAsUsed","entry","Number","MAX_VALUE","clear","it","iterator","itv","next","done","set","Error","get","shift","delete","find","has","EntryIterator","oldestEntry","ent","KeyIterator","ValueIterator","keys","values","forEach","fun","thisObj","call","toJSON","s","Array","i","toString","String"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/lru_map/lru.js"],"sourcesContent":["/**\n * A doubly linked list-based Least Recently Used (LRU) cache. Will keep most\n * recently used items while discarding least recently used items when its limit\n * is reached.\n *\n * Licensed under MIT. Copyright (c) 2010 Rasmus Andersson <http://hunch.se/>\n * See README.md for details.\n *\n * Illustration of the design:\n *\n *       entry             entry             entry             entry\n *       ______            ______            ______            ______\n *      | head |.newer => |      |.newer => |      |.newer => | tail |\n *      |  A   |          |  B   |          |  C   |          |  D   |\n *      |______| <= older.|______| <= older.|______| <= older.|______|\n *\n *  removed  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  added\n */\n(function(g,f){\n  const e = typeof exports == 'object' ? exports : typeof g == 'object' ? g : {};\n  f(e);\n  if (typeof define == 'function' && define.amd) { define('lru', e); }\n})(this, function(exports) {\n\nconst NEWER = Symbol('newer');\nconst OLDER = Symbol('older');\n\nfunction LRUMap(limit, entries) {\n  if (typeof limit !== 'number') {\n    // called as (entries)\n    entries = limit;\n    limit = 0;\n  }\n\n  this.size = 0;\n  this.limit = limit;\n  this.oldest = this.newest = undefined;\n  this._keymap = new Map();\n\n  if (entries) {\n    this.assign(entries);\n    if (limit < 1) {\n      this.limit = this.size;\n    }\n  }\n}\n\nexports.LRUMap = LRUMap;\n\nfunction Entry(key, value) {\n  this.key = key;\n  this.value = value;\n  this[NEWER] = undefined;\n  this[OLDER] = undefined;\n}\n\n\nLRUMap.prototype._markEntryAsUsed = function(entry) {\n  if (entry === this.newest) {\n    // Already the most recenlty used entry, so no need to update the list\n    return;\n  }\n  // HEAD--------------TAIL\n  //   <.older   .newer>\n  //  <--- add direction --\n  //   A  B  C  <D>  E\n  if (entry[NEWER]) {\n    if (entry === this.oldest) {\n      this.oldest = entry[NEWER];\n    }\n    entry[NEWER][OLDER] = entry[OLDER]; // C <-- E.\n  }\n  if (entry[OLDER]) {\n    entry[OLDER][NEWER] = entry[NEWER]; // C. --> E\n  }\n  entry[NEWER] = undefined; // D --x\n  entry[OLDER] = this.newest; // D. --> E\n  if (this.newest) {\n    this.newest[NEWER] = entry; // E. <-- D\n  }\n  this.newest = entry;\n};\n\nLRUMap.prototype.assign = function(entries) {\n  let entry, limit = this.limit || Number.MAX_VALUE;\n  this._keymap.clear();\n  let it = entries[Symbol.iterator]();\n  for (let itv = it.next(); !itv.done; itv = it.next()) {\n    let e = new Entry(itv.value[0], itv.value[1]);\n    this._keymap.set(e.key, e);\n    if (!entry) {\n      this.oldest = e;\n    } else {\n      entry[NEWER] = e;\n      e[OLDER] = entry;\n    }\n    entry = e;\n    if (limit-- == 0) {\n      throw new Error('overflow');\n    }\n  }\n  this.newest = entry;\n  this.size = this._keymap.size;\n};\n\nLRUMap.prototype.get = function(key) {\n  // First, find our cache entry\n  var entry = this._keymap.get(key);\n  if (!entry) return; // Not cached. Sorry.\n  // As <key> was found in the cache, register it as being requested recently\n  this._markEntryAsUsed(entry);\n  return entry.value;\n};\n\nLRUMap.prototype.set = function(key, value) {\n  var entry = this._keymap.get(key);\n\n  if (entry) {\n    // update existing\n    entry.value = value;\n    this._markEntryAsUsed(entry);\n    return this;\n  }\n\n  // new entry\n  this._keymap.set(key, (entry = new Entry(key, value)));\n\n  if (this.newest) {\n    // link previous tail to the new tail (entry)\n    this.newest[NEWER] = entry;\n    entry[OLDER] = this.newest;\n  } else {\n    // we're first in -- yay\n    this.oldest = entry;\n  }\n\n  // add new entry to the end of the linked list -- it's now the freshest entry.\n  this.newest = entry;\n  ++this.size;\n  if (this.size > this.limit) {\n    // we hit the limit -- remove the head\n    this.shift();\n  }\n\n  return this;\n};\n\nLRUMap.prototype.shift = function() {\n  // todo: handle special case when limit == 1\n  var entry = this.oldest;\n  if (entry) {\n    if (this.oldest[NEWER]) {\n      // advance the list\n      this.oldest = this.oldest[NEWER];\n      this.oldest[OLDER] = undefined;\n    } else {\n      // the cache is exhausted\n      this.oldest = undefined;\n      this.newest = undefined;\n    }\n    // Remove last strong reference to <entry> and remove links from the purged\n    // entry being returned:\n    entry[NEWER] = entry[OLDER] = undefined;\n    this._keymap.delete(entry.key);\n    --this.size;\n    return [entry.key, entry.value];\n  }\n};\n\n// ----------------------------------------------------------------------------\n// Following code is optional and can be removed without breaking the core\n// functionality.\n\nLRUMap.prototype.find = function(key) {\n  let e = this._keymap.get(key);\n  return e ? e.value : undefined;\n};\n\nLRUMap.prototype.has = function(key) {\n  return this._keymap.has(key);\n};\n\nLRUMap.prototype['delete'] = function(key) {\n  var entry = this._keymap.get(key);\n  if (!entry) return;\n  this._keymap.delete(entry.key);\n  if (entry[NEWER] && entry[OLDER]) {\n    // relink the older entry with the newer entry\n    entry[OLDER][NEWER] = entry[NEWER];\n    entry[NEWER][OLDER] = entry[OLDER];\n  } else if (entry[NEWER]) {\n    // remove the link to us\n    entry[NEWER][OLDER] = undefined;\n    // link the newer entry to head\n    this.oldest = entry[NEWER];\n  } else if (entry[OLDER]) {\n    // remove the link to us\n    entry[OLDER][NEWER] = undefined;\n    // link the newer entry to head\n    this.newest = entry[OLDER];\n  } else {// if(entry[OLDER] === undefined && entry.newer === undefined) {\n    this.oldest = this.newest = undefined;\n  }\n\n  this.size--;\n  return entry.value;\n};\n\nLRUMap.prototype.clear = function() {\n  // Not clearing links should be safe, as we don't expose live links to user\n  this.oldest = this.newest = undefined;\n  this.size = 0;\n  this._keymap.clear();\n};\n\n\nfunction EntryIterator(oldestEntry) { this.entry = oldestEntry; }\nEntryIterator.prototype[Symbol.iterator] = function() { return this; }\nEntryIterator.prototype.next = function() {\n  let ent = this.entry;\n  if (ent) {\n    this.entry = ent[NEWER];\n    return { done: false, value: [ent.key, ent.value] };\n  } else {\n    return { done: true, value: undefined };\n  }\n};\n\n\nfunction KeyIterator(oldestEntry) { this.entry = oldestEntry; }\nKeyIterator.prototype[Symbol.iterator] = function() { return this; }\nKeyIterator.prototype.next = function() {\n  let ent = this.entry;\n  if (ent) {\n    this.entry = ent[NEWER];\n    return { done: false, value: ent.key };\n  } else {\n    return { done: true, value: undefined };\n  }\n};\n\nfunction ValueIterator(oldestEntry) { this.entry = oldestEntry; }\nValueIterator.prototype[Symbol.iterator] = function() { return this; }\nValueIterator.prototype.next = function() {\n  let ent = this.entry;\n  if (ent) {\n    this.entry = ent[NEWER];\n    return { done: false, value: ent.value };\n  } else {\n    return { done: true, value: undefined };\n  }\n};\n\n\nLRUMap.prototype.keys = function() {\n  return new KeyIterator(this.oldest);\n};\n\nLRUMap.prototype.values = function() {\n  return new ValueIterator(this.oldest);\n};\n\nLRUMap.prototype.entries = function() {\n  return this;\n};\n\nLRUMap.prototype[Symbol.iterator] = function() {\n  return new EntryIterator(this.oldest);\n};\n\nLRUMap.prototype.forEach = function(fun, thisObj) {\n  if (typeof thisObj !== 'object') {\n    thisObj = this;\n  }\n  let entry = this.oldest;\n  while (entry) {\n    fun.call(thisObj, entry.value, entry.key, this);\n    entry = entry[NEWER];\n  }\n};\n\n/** Returns a JSON (array) representation */\nLRUMap.prototype.toJSON = function() {\n  var s = new Array(this.size), i = 0, entry = this.oldest;\n  while (entry) {\n    s[i++] = { key: entry.key, value: entry.value };\n    entry = entry[NEWER];\n  }\n  return s;\n};\n\n/** Returns a String representation */\nLRUMap.prototype.toString = function() {\n  var s = '', entry = this.oldest;\n  while (entry) {\n    s += String(entry.key)+':'+entry.value;\n    entry = entry[NEWER];\n    if (entry) {\n      s += ' < ';\n    }\n  }\n  return s;\n};\n\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}