{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.includesOwnPackageName = exports.replaceBackslashes = exports.isAbsolutePathSourceName = exports.normalizeSourceName = exports.localSourceNameToPath = exports.localPathToSourceName = exports.validateSourceNameExistenceAndCasing = exports.isLocalSourceName = exports.validateSourceNameFormat = void 0;\nconst path_1 = __importDefault(require(\"path\"));\nconst errors_1 = require(\"../internal/core/errors\");\nconst errors_list_1 = require(\"../internal/core/errors-list\");\nconst fs_utils_1 = require(\"../internal/util/fs-utils\");\nconst packageInfo_1 = require(\"../internal/util/packageInfo\");\nconst NODE_MODULES = \"node_modules\";\n/**\n * This function validates the source name's format.\n *\n * It throws if the format is invalid.\n * If it doesn't throw all you know is that the format is valid.\n */\nfunction validateSourceNameFormat(sourceName) {\n  if (isAbsolutePathSourceName(sourceName)) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_ABSOLUTE_PATH, {\n      name: sourceName\n    });\n  }\n  if (isExplicitRelativePath(sourceName)) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_RELATIVE_PATH, {\n      name: sourceName\n    });\n  }\n  // We check this before normalizing so we are sure that the difference\n  // comes from slash vs backslash\n  if (replaceBackslashes(sourceName) !== sourceName) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_BACKSLASHES, {\n      name: sourceName\n    });\n  }\n  if (normalizeSourceName(sourceName) !== sourceName) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.INVALID_SOURCE_NOT_NORMALIZED, {\n      name: sourceName\n    });\n  }\n}\nexports.validateSourceNameFormat = validateSourceNameFormat;\n/**\n * This function returns true if the sourceName is, potentially, from a local\n * file. It doesn't validate that the file actually exists.\n *\n * The source name must be in a valid format.\n */\nasync function isLocalSourceName(projectRoot, sourceName) {\n  // Note that we consider \"hardhat/console.sol\" as a special case here.\n  // This lets someone have a \"hardhat\" directory within their project without\n  // it impacting their use of `console.log`.\n  // See issue https://github.com/nomiclabs/hardhat/issues/998\n  if (sourceName.includes(NODE_MODULES) || sourceName === \"hardhat/console.sol\") {\n    return false;\n  }\n  const slashIndex = sourceName.indexOf(\"/\");\n  const firstDirOrFileName = slashIndex !== -1 ? sourceName.substring(0, slashIndex) : sourceName;\n  try {\n    await (0, fs_utils_1.getFileTrueCase)(projectRoot, firstDirOrFileName);\n  } catch (error) {\n    if (error instanceof fs_utils_1.FileNotFoundError) {\n      return false;\n    }\n    // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n  return true;\n}\nexports.isLocalSourceName = isLocalSourceName;\n/**\n * Validates that a source name exists, starting from `fromDir`, and has the\n * right casing.\n *\n * The source name must be in a valid format.\n */\nasync function validateSourceNameExistenceAndCasing(fromDir, sourceName) {\n  const trueCaseSourceName = await getSourceNameTrueCase(fromDir, sourceName);\n  if (trueCaseSourceName !== sourceName) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.WRONG_CASING, {\n      incorrect: sourceName,\n      correct: trueCaseSourceName\n    });\n  }\n}\nexports.validateSourceNameExistenceAndCasing = validateSourceNameExistenceAndCasing;\n/**\n * Returns the source name of an existing local file's absolute path.\n *\n * Throws is the file doesn't exist, it's not inside the project, or belongs\n * to a library.\n */\nasync function localPathToSourceName(projectRoot, localFileAbsolutePath) {\n  const relativePath = path_1.default.relative(projectRoot, localFileAbsolutePath);\n  const normalized = normalizeSourceName(relativePath);\n  if (normalized.startsWith(\"..\")) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.EXTERNAL_AS_LOCAL, {\n      path: localFileAbsolutePath\n    });\n  }\n  if (normalized.includes(NODE_MODULES)) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.NODE_MODULES_AS_LOCAL, {\n      path: localFileAbsolutePath\n    });\n  }\n  return getSourceNameTrueCase(projectRoot, relativePath);\n}\nexports.localPathToSourceName = localPathToSourceName;\n/**\n * This function takes a valid local source name and returns its path. The\n * source name doesn't need to point to an existing file.\n */\nfunction localSourceNameToPath(projectRoot, sourceName) {\n  return path_1.default.join(projectRoot, sourceName);\n}\nexports.localSourceNameToPath = localSourceNameToPath;\n/**\n * Normalizes the source name, for example, by replacing `a/./b` with `a/b`.\n *\n * The sourceName param doesn't have to be a valid source name. It can,\n * for example, be denormalized.\n */\nfunction normalizeSourceName(sourceName) {\n  return replaceBackslashes(path_1.default.normalize(sourceName));\n}\nexports.normalizeSourceName = normalizeSourceName;\n/**\n * This function returns true if the sourceName is a unix absolute path or a\n * platform-dependent one.\n *\n * This function is used instead of just `path.isAbsolute` to ensure that\n * source names never start with `/`, even on Windows.\n */\nfunction isAbsolutePathSourceName(sourceName) {\n  return path_1.default.isAbsolute(sourceName) || sourceName.startsWith(\"/\");\n}\nexports.isAbsolutePathSourceName = isAbsolutePathSourceName;\n/**\n * This function returns true if the sourceName is a unix path that is based on\n * the current directory `./`.\n */\nfunction isExplicitRelativePath(sourceName) {\n  const [base] = sourceName.split(\"/\", 1);\n  return base === \".\" || base === \"..\";\n}\n/**\n * This function replaces backslashes (\\\\) with slashes (/).\n *\n * Note that a source name must not contain backslashes.\n */\nfunction replaceBackslashes(str) {\n  // Based in the npm module slash\n  const isExtendedLengthPath = /^\\\\\\\\\\?\\\\/.test(str);\n  const hasNonAscii = /[^\\u0000-\\u0080]+/.test(str);\n  if (isExtendedLengthPath || hasNonAscii) {\n    return str;\n  }\n  return str.replace(/\\\\/g, \"/\");\n}\nexports.replaceBackslashes = replaceBackslashes;\nfunction slashesToPathSeparator(str) {\n  if (path_1.default.sep === \"/\") {\n    return str;\n  }\n  return str.replace(/\\//g, path_1.default.sep);\n}\n/**\n * Returns the true casing of `p` as a relative path from `fromDir`. Throws if\n * `p` doesn't exist. `p` MUST be in source name format.\n */\nasync function getSourceNameTrueCase(fromDir, p) {\n  try {\n    const realCase = await (0, fs_utils_1.getFileTrueCase)(fromDir, slashesToPathSeparator(p));\n    return normalizeSourceName(realCase);\n  } catch (error) {\n    if (error instanceof fs_utils_1.FileNotFoundError) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.FILE_NOT_FOUND, {\n        name: p\n      }, error);\n    }\n    // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n}\n/**\n * This function returns true if the sourceName contains the current package's name\n * as a substring\n */\nasync function includesOwnPackageName(sourceName) {\n  const packageName = await (0, packageInfo_1.getPackageName)(sourceName);\n  if (packageName !== \"\") {\n    return sourceName.startsWith(`${packageName}/`);\n  }\n  return false;\n}\nexports.includesOwnPackageName = includesOwnPackageName;","map":{"version":3,"names":["path_1","__importDefault","require","errors_1","errors_list_1","fs_utils_1","packageInfo_1","NODE_MODULES","validateSourceNameFormat","sourceName","isAbsolutePathSourceName","HardhatError","ERRORS","SOURCE_NAMES","INVALID_SOURCE_NAME_ABSOLUTE_PATH","name","isExplicitRelativePath","INVALID_SOURCE_NAME_RELATIVE_PATH","replaceBackslashes","INVALID_SOURCE_NAME_BACKSLASHES","normalizeSourceName","INVALID_SOURCE_NOT_NORMALIZED","exports","isLocalSourceName","projectRoot","includes","slashIndex","indexOf","firstDirOrFileName","substring","getFileTrueCase","error","FileNotFoundError","validateSourceNameExistenceAndCasing","fromDir","trueCaseSourceName","getSourceNameTrueCase","WRONG_CASING","incorrect","correct","localPathToSourceName","localFileAbsolutePath","relativePath","default","relative","normalized","startsWith","EXTERNAL_AS_LOCAL","path","NODE_MODULES_AS_LOCAL","localSourceNameToPath","join","normalize","isAbsolute","base","split","str","isExtendedLengthPath","test","hasNonAscii","replace","slashesToPathSeparator","sep","p","realCase","FILE_NOT_FOUND","includesOwnPackageName","packageName","getPackageName"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\utils\\source-names.ts"],"sourcesContent":["import path from \"path\";\n\nimport { HardhatError } from \"../internal/core/errors\";\nimport { ERRORS } from \"../internal/core/errors-list\";\nimport { FileNotFoundError, getFileTrueCase } from \"../internal/util/fs-utils\";\nimport { getPackageName } from \"../internal/util/packageInfo\";\n\nconst NODE_MODULES = \"node_modules\";\n\n/**\n * This function validates the source name's format.\n *\n * It throws if the format is invalid.\n * If it doesn't throw all you know is that the format is valid.\n */\nexport function validateSourceNameFormat(sourceName: string) {\n  if (isAbsolutePathSourceName(sourceName)) {\n    throw new HardhatError(\n      ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_ABSOLUTE_PATH,\n      {\n        name: sourceName,\n      }\n    );\n  }\n\n  if (isExplicitRelativePath(sourceName)) {\n    throw new HardhatError(\n      ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_RELATIVE_PATH,\n      {\n        name: sourceName,\n      }\n    );\n  }\n\n  // We check this before normalizing so we are sure that the difference\n  // comes from slash vs backslash\n  if (replaceBackslashes(sourceName) !== sourceName) {\n    throw new HardhatError(\n      ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_BACKSLASHES,\n      {\n        name: sourceName,\n      }\n    );\n  }\n\n  if (normalizeSourceName(sourceName) !== sourceName) {\n    throw new HardhatError(ERRORS.SOURCE_NAMES.INVALID_SOURCE_NOT_NORMALIZED, {\n      name: sourceName,\n    });\n  }\n}\n\n/**\n * This function returns true if the sourceName is, potentially, from a local\n * file. It doesn't validate that the file actually exists.\n *\n * The source name must be in a valid format.\n */\nexport async function isLocalSourceName(\n  projectRoot: string,\n  sourceName: string\n): Promise<boolean> {\n  // Note that we consider \"hardhat/console.sol\" as a special case here.\n  // This lets someone have a \"hardhat\" directory within their project without\n  // it impacting their use of `console.log`.\n  // See issue https://github.com/nomiclabs/hardhat/issues/998\n  if (\n    sourceName.includes(NODE_MODULES) ||\n    sourceName === \"hardhat/console.sol\"\n  ) {\n    return false;\n  }\n\n  const slashIndex = sourceName.indexOf(\"/\");\n  const firstDirOrFileName =\n    slashIndex !== -1 ? sourceName.substring(0, slashIndex) : sourceName;\n\n  try {\n    await getFileTrueCase(projectRoot, firstDirOrFileName);\n  } catch (error) {\n    if (error instanceof FileNotFoundError) {\n      return false;\n    }\n\n    // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n\n  return true;\n}\n\n/**\n * Validates that a source name exists, starting from `fromDir`, and has the\n * right casing.\n *\n * The source name must be in a valid format.\n */\nexport async function validateSourceNameExistenceAndCasing(\n  fromDir: string,\n  sourceName: string\n) {\n  const trueCaseSourceName = await getSourceNameTrueCase(fromDir, sourceName);\n\n  if (trueCaseSourceName !== sourceName) {\n    throw new HardhatError(ERRORS.SOURCE_NAMES.WRONG_CASING, {\n      incorrect: sourceName,\n      correct: trueCaseSourceName,\n    });\n  }\n}\n\n/**\n * Returns the source name of an existing local file's absolute path.\n *\n * Throws is the file doesn't exist, it's not inside the project, or belongs\n * to a library.\n */\nexport async function localPathToSourceName(\n  projectRoot: string,\n  localFileAbsolutePath: string\n): Promise<string> {\n  const relativePath = path.relative(projectRoot, localFileAbsolutePath);\n  const normalized = normalizeSourceName(relativePath);\n\n  if (normalized.startsWith(\"..\")) {\n    throw new HardhatError(ERRORS.SOURCE_NAMES.EXTERNAL_AS_LOCAL, {\n      path: localFileAbsolutePath,\n    });\n  }\n\n  if (normalized.includes(NODE_MODULES)) {\n    throw new HardhatError(ERRORS.SOURCE_NAMES.NODE_MODULES_AS_LOCAL, {\n      path: localFileAbsolutePath,\n    });\n  }\n\n  return getSourceNameTrueCase(projectRoot, relativePath);\n}\n\n/**\n * This function takes a valid local source name and returns its path. The\n * source name doesn't need to point to an existing file.\n */\nexport function localSourceNameToPath(\n  projectRoot: string,\n  sourceName: string\n): string {\n  return path.join(projectRoot, sourceName);\n}\n\n/**\n * Normalizes the source name, for example, by replacing `a/./b` with `a/b`.\n *\n * The sourceName param doesn't have to be a valid source name. It can,\n * for example, be denormalized.\n */\nexport function normalizeSourceName(sourceName: string): string {\n  return replaceBackslashes(path.normalize(sourceName));\n}\n\n/**\n * This function returns true if the sourceName is a unix absolute path or a\n * platform-dependent one.\n *\n * This function is used instead of just `path.isAbsolute` to ensure that\n * source names never start with `/`, even on Windows.\n */\nexport function isAbsolutePathSourceName(sourceName: string): boolean {\n  return path.isAbsolute(sourceName) || sourceName.startsWith(\"/\");\n}\n\n/**\n * This function returns true if the sourceName is a unix path that is based on\n * the current directory `./`.\n */\nfunction isExplicitRelativePath(sourceName: string): boolean {\n  const [base] = sourceName.split(\"/\", 1);\n  return base === \".\" || base === \"..\";\n}\n\n/**\n * This function replaces backslashes (\\\\) with slashes (/).\n *\n * Note that a source name must not contain backslashes.\n */\nexport function replaceBackslashes(str: string): string {\n  // Based in the npm module slash\n  const isExtendedLengthPath = /^\\\\\\\\\\?\\\\/.test(str);\n  const hasNonAscii = /[^\\u0000-\\u0080]+/.test(str);\n\n  if (isExtendedLengthPath || hasNonAscii) {\n    return str;\n  }\n\n  return str.replace(/\\\\/g, \"/\");\n}\n\nfunction slashesToPathSeparator(str: string): string {\n  if (path.sep === \"/\") {\n    return str;\n  }\n\n  return str.replace(/\\//g, path.sep);\n}\n\n/**\n * Returns the true casing of `p` as a relative path from `fromDir`. Throws if\n * `p` doesn't exist. `p` MUST be in source name format.\n */\nasync function getSourceNameTrueCase(\n  fromDir: string,\n  p: string\n): Promise<string> {\n  try {\n    const realCase = await getFileTrueCase(fromDir, slashesToPathSeparator(p));\n    return normalizeSourceName(realCase);\n  } catch (error) {\n    if (error instanceof FileNotFoundError) {\n      throw new HardhatError(\n        ERRORS.SOURCE_NAMES.FILE_NOT_FOUND,\n        {\n          name: p,\n        },\n        error\n      );\n    }\n\n    // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n}\n\n/**\n * This function returns true if the sourceName contains the current package's name\n * as a substring\n */\nexport async function includesOwnPackageName(\n  sourceName: string\n): Promise<boolean> {\n  const packageName = await getPackageName(sourceName);\n  if (packageName !== \"\") {\n    return sourceName.startsWith(`${packageName}/`);\n  }\n  return false;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}