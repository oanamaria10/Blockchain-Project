{"ast":null,"code":"import { __assign, __values } from \"tslib\";\nimport { isInstanceOf, isString } from './is';\nimport { logger } from './logger';\nimport { getGlobalObject } from './misc';\nimport { fill } from './object';\nimport { getFunctionName } from './stacktrace';\nimport { supportsHistory, supportsNativeFetch } from './supports';\nvar global = getGlobalObject();\n/**\n * Instrument native APIs to call handlers that can be used to create breadcrumbs, APM spans etc.\n *  - Console API\n *  - Fetch API\n *  - XHR API\n *  - History API\n *  - DOM API (click/typing)\n *  - Error API\n *  - UnhandledRejection API\n */\nvar handlers = {};\nvar instrumented = {};\n/** Instruments given API */\nfunction instrument(type) {\n  if (instrumented[type]) {\n    return;\n  }\n  instrumented[type] = true;\n  switch (type) {\n    case 'console':\n      instrumentConsole();\n      break;\n    case 'dom':\n      instrumentDOM();\n      break;\n    case 'xhr':\n      instrumentXHR();\n      break;\n    case 'fetch':\n      instrumentFetch();\n      break;\n    case 'history':\n      instrumentHistory();\n      break;\n    case 'error':\n      instrumentError();\n      break;\n    case 'unhandledrejection':\n      instrumentUnhandledRejection();\n      break;\n    default:\n      logger.warn('unknown instrumentation type:', type);\n  }\n}\n/**\n * Add handler that will be called when given type of instrumentation triggers.\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nexport function addInstrumentationHandler(handler) {\n  if (!handler || typeof handler.type !== 'string' || typeof handler.callback !== 'function') {\n    return;\n  }\n  handlers[handler.type] = handlers[handler.type] || [];\n  handlers[handler.type].push(handler.callback);\n  instrument(handler.type);\n}\n/** JSDoc */\nfunction triggerHandlers(type, data) {\n  var e_1, _a;\n  if (!type || !handlers[type]) {\n    return;\n  }\n  try {\n    for (var _b = __values(handlers[type] || []), _c = _b.next(); !_c.done; _c = _b.next()) {\n      var handler = _c.value;\n      try {\n        handler(data);\n      } catch (e) {\n        logger.error(\"Error while triggering instrumentation handler.\\nType: \" + type + \"\\nName: \" + getFunctionName(handler) + \"\\nError: \" + e);\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n}\n/** JSDoc */\nfunction instrumentConsole() {\n  if (!('console' in global)) {\n    return;\n  }\n  ['debug', 'info', 'warn', 'error', 'log', 'assert'].forEach(function (level) {\n    if (!(level in global.console)) {\n      return;\n    }\n    fill(global.console, level, function (originalConsoleLevel) {\n      return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        triggerHandlers('console', {\n          args: args,\n          level: level\n        });\n        // this fails for some browsers. :(\n        if (originalConsoleLevel) {\n          Function.prototype.apply.call(originalConsoleLevel, global.console, args);\n        }\n      };\n    });\n  });\n}\n/** JSDoc */\nfunction instrumentFetch() {\n  if (!supportsNativeFetch()) {\n    return;\n  }\n  fill(global, 'fetch', function (originalFetch) {\n    return function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      var handlerData = {\n        args: args,\n        fetchData: {\n          method: getFetchMethod(args),\n          url: getFetchUrl(args)\n        },\n        startTimestamp: Date.now()\n      };\n      triggerHandlers('fetch', __assign({}, handlerData));\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      return originalFetch.apply(global, args).then(function (response) {\n        triggerHandlers('fetch', __assign(__assign({}, handlerData), {\n          endTimestamp: Date.now(),\n          response: response\n        }));\n        return response;\n      }, function (error) {\n        triggerHandlers('fetch', __assign(__assign({}, handlerData), {\n          endTimestamp: Date.now(),\n          error: error\n        }));\n        // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n        //       it means the sentry.javascript SDK caught an error invoking your application code.\n        //       This is expected behavior and NOT indicative of a bug with sentry.javascript.\n        throw error;\n      });\n    };\n  });\n}\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/** Extract `method` from fetch call arguments */\nfunction getFetchMethod(fetchArgs) {\n  if (fetchArgs === void 0) {\n    fetchArgs = [];\n  }\n  if ('Request' in global && isInstanceOf(fetchArgs[0], Request) && fetchArgs[0].method) {\n    return String(fetchArgs[0].method).toUpperCase();\n  }\n  if (fetchArgs[1] && fetchArgs[1].method) {\n    return String(fetchArgs[1].method).toUpperCase();\n  }\n  return 'GET';\n}\n/** Extract `url` from fetch call arguments */\nfunction getFetchUrl(fetchArgs) {\n  if (fetchArgs === void 0) {\n    fetchArgs = [];\n  }\n  if (typeof fetchArgs[0] === 'string') {\n    return fetchArgs[0];\n  }\n  if ('Request' in global && isInstanceOf(fetchArgs[0], Request)) {\n    return fetchArgs[0].url;\n  }\n  return String(fetchArgs[0]);\n}\n/* eslint-enable @typescript-eslint/no-unsafe-member-access */\n/** JSDoc */\nfunction instrumentXHR() {\n  if (!('XMLHttpRequest' in global)) {\n    return;\n  }\n  // Poor man's implementation of ES6 `Map`, tracking and keeping in sync key and value separately.\n  var requestKeys = [];\n  var requestValues = [];\n  var xhrproto = XMLHttpRequest.prototype;\n  fill(xhrproto, 'open', function (originalOpen) {\n    return function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      var xhr = this;\n      var url = args[1];\n      xhr.__sentry_xhr__ = {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        method: isString(args[0]) ? args[0].toUpperCase() : args[0],\n        url: args[1]\n      };\n      // if Sentry key appears in URL, don't capture it as a request\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      if (isString(url) && xhr.__sentry_xhr__.method === 'POST' && url.match(/sentry_key/)) {\n        xhr.__sentry_own_request__ = true;\n      }\n      var onreadystatechangeHandler = function () {\n        if (xhr.readyState === 4) {\n          try {\n            // touching statusCode in some platforms throws\n            // an exception\n            if (xhr.__sentry_xhr__) {\n              xhr.__sentry_xhr__.status_code = xhr.status;\n            }\n          } catch (e) {\n            /* do nothing */\n          }\n          try {\n            var requestPos = requestKeys.indexOf(xhr);\n            if (requestPos !== -1) {\n              // Make sure to pop both key and value to keep it in sync.\n              requestKeys.splice(requestPos);\n              var args_1 = requestValues.splice(requestPos)[0];\n              if (xhr.__sentry_xhr__ && args_1[0] !== undefined) {\n                xhr.__sentry_xhr__.body = args_1[0];\n              }\n            }\n          } catch (e) {\n            /* do nothing */\n          }\n          triggerHandlers('xhr', {\n            args: args,\n            endTimestamp: Date.now(),\n            startTimestamp: Date.now(),\n            xhr: xhr\n          });\n        }\n      };\n      if ('onreadystatechange' in xhr && typeof xhr.onreadystatechange === 'function') {\n        fill(xhr, 'onreadystatechange', function (original) {\n          return function () {\n            var readyStateArgs = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n              readyStateArgs[_i] = arguments[_i];\n            }\n            onreadystatechangeHandler();\n            return original.apply(xhr, readyStateArgs);\n          };\n        });\n      } else {\n        xhr.addEventListener('readystatechange', onreadystatechangeHandler);\n      }\n      return originalOpen.apply(xhr, args);\n    };\n  });\n  fill(xhrproto, 'send', function (originalSend) {\n    return function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      requestKeys.push(this);\n      requestValues.push(args);\n      triggerHandlers('xhr', {\n        args: args,\n        startTimestamp: Date.now(),\n        xhr: this\n      });\n      return originalSend.apply(this, args);\n    };\n  });\n}\nvar lastHref;\n/** JSDoc */\nfunction instrumentHistory() {\n  if (!supportsHistory()) {\n    return;\n  }\n  var oldOnPopState = global.onpopstate;\n  global.onpopstate = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var to = global.location.href;\n    // keep track of the current URL state, as we always receive only the updated state\n    var from = lastHref;\n    lastHref = to;\n    triggerHandlers('history', {\n      from: from,\n      to: to\n    });\n    if (oldOnPopState) {\n      return oldOnPopState.apply(this, args);\n    }\n  };\n  /** @hidden */\n  function historyReplacementFunction(originalHistoryFunction) {\n    return function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      var url = args.length > 2 ? args[2] : undefined;\n      if (url) {\n        // coerce to string (this is what pushState does)\n        var from = lastHref;\n        var to = String(url);\n        // keep track of the current URL state, as we always receive only the updated state\n        lastHref = to;\n        triggerHandlers('history', {\n          from: from,\n          to: to\n        });\n      }\n      return originalHistoryFunction.apply(this, args);\n    };\n  }\n  fill(global.history, 'pushState', historyReplacementFunction);\n  fill(global.history, 'replaceState', historyReplacementFunction);\n}\n/** JSDoc */\nfunction instrumentDOM() {\n  if (!('document' in global)) {\n    return;\n  }\n  // Capture breadcrumbs from any click that is unhandled / bubbled up all the way\n  // to the document. Do this before we instrument addEventListener.\n  global.document.addEventListener('click', domEventHandler('click', triggerHandlers.bind(null, 'dom')), false);\n  global.document.addEventListener('keypress', keypressEventHandler(triggerHandlers.bind(null, 'dom')), false);\n  // After hooking into document bubbled up click and keypresses events, we also hook into user handled click & keypresses.\n  ['EventTarget', 'Node'].forEach(function (target) {\n    /* eslint-disable @typescript-eslint/no-unsafe-member-access */\n    var proto = global[target] && global[target].prototype;\n    // eslint-disable-next-line no-prototype-builtins\n    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n      return;\n    }\n    /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n    fill(proto, 'addEventListener', function (original) {\n      return function (eventName, fn, options) {\n        if (fn && fn.handleEvent) {\n          if (eventName === 'click') {\n            fill(fn, 'handleEvent', function (innerOriginal) {\n              return function (event) {\n                domEventHandler('click', triggerHandlers.bind(null, 'dom'))(event);\n                return innerOriginal.call(this, event);\n              };\n            });\n          }\n          if (eventName === 'keypress') {\n            fill(fn, 'handleEvent', function (innerOriginal) {\n              return function (event) {\n                keypressEventHandler(triggerHandlers.bind(null, 'dom'))(event);\n                return innerOriginal.call(this, event);\n              };\n            });\n          }\n        } else {\n          if (eventName === 'click') {\n            domEventHandler('click', triggerHandlers.bind(null, 'dom'), true)(this);\n          }\n          if (eventName === 'keypress') {\n            keypressEventHandler(triggerHandlers.bind(null, 'dom'))(this);\n          }\n        }\n        return original.call(this, eventName, fn, options);\n      };\n    });\n    fill(proto, 'removeEventListener', function (original) {\n      return function (eventName, fn, options) {\n        try {\n          original.call(this, eventName, fn.__sentry_wrapped__, options);\n        } catch (e) {\n          // ignore, accessing __sentry_wrapped__ will throw in some Selenium environments\n        }\n        return original.call(this, eventName, fn, options);\n      };\n    });\n  });\n}\nvar debounceDuration = 1000;\nvar debounceTimer = 0;\nvar keypressTimeout;\nvar lastCapturedEvent;\n/**\n * Wraps addEventListener to capture UI breadcrumbs\n * @param name the event name (e.g. \"click\")\n * @param handler function that will be triggered\n * @param debounce decides whether it should wait till another event loop\n * @returns wrapped breadcrumb events handler\n * @hidden\n */\nfunction domEventHandler(name, handler, debounce) {\n  if (debounce === void 0) {\n    debounce = false;\n  }\n  return function (event) {\n    // reset keypress timeout; e.g. triggering a 'click' after\n    // a 'keypress' will reset the keypress debounce so that a new\n    // set of keypresses can be recorded\n    keypressTimeout = undefined;\n    // It's possible this handler might trigger multiple times for the same\n    // event (e.g. event propagation through node ancestors). Ignore if we've\n    // already captured the event.\n    if (!event || lastCapturedEvent === event) {\n      return;\n    }\n    lastCapturedEvent = event;\n    if (debounceTimer) {\n      clearTimeout(debounceTimer);\n    }\n    if (debounce) {\n      debounceTimer = setTimeout(function () {\n        handler({\n          event: event,\n          name: name\n        });\n      });\n    } else {\n      handler({\n        event: event,\n        name: name\n      });\n    }\n  };\n}\n/**\n * Wraps addEventListener to capture keypress UI events\n * @param handler function that will be triggered\n * @returns wrapped keypress events handler\n * @hidden\n */\nfunction keypressEventHandler(handler) {\n  // TODO: if somehow user switches keypress target before\n  //       debounce timeout is triggered, we will only capture\n  //       a single breadcrumb from the FIRST target (acceptable?)\n  return function (event) {\n    var target;\n    try {\n      target = event.target;\n    } catch (e) {\n      // just accessing event properties can throw an exception in some rare circumstances\n      // see: https://github.com/getsentry/raven-js/issues/838\n      return;\n    }\n    var tagName = target && target.tagName;\n    // only consider keypress events on actual input elements\n    // this will disregard keypresses targeting body (e.g. tabbing\n    // through elements, hotkeys, etc)\n    if (!tagName || tagName !== 'INPUT' && tagName !== 'TEXTAREA' && !target.isContentEditable) {\n      return;\n    }\n    // record first keypress in a series, but ignore subsequent\n    // keypresses until debounce clears\n    if (!keypressTimeout) {\n      domEventHandler('input', handler)(event);\n    }\n    clearTimeout(keypressTimeout);\n    keypressTimeout = setTimeout(function () {\n      keypressTimeout = undefined;\n    }, debounceDuration);\n  };\n}\nvar _oldOnErrorHandler = null;\n/** JSDoc */\nfunction instrumentError() {\n  _oldOnErrorHandler = global.onerror;\n  global.onerror = function (msg, url, line, column, error) {\n    triggerHandlers('error', {\n      column: column,\n      error: error,\n      line: line,\n      msg: msg,\n      url: url\n    });\n    if (_oldOnErrorHandler) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnErrorHandler.apply(this, arguments);\n    }\n    return false;\n  };\n}\nvar _oldOnUnhandledRejectionHandler = null;\n/** JSDoc */\nfunction instrumentUnhandledRejection() {\n  _oldOnUnhandledRejectionHandler = global.onunhandledrejection;\n  global.onunhandledrejection = function (e) {\n    triggerHandlers('unhandledrejection', e);\n    if (_oldOnUnhandledRejectionHandler) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnUnhandledRejectionHandler.apply(this, arguments);\n    }\n    return true;\n  };\n}","map":{"version":3,"names":["isInstanceOf","isString","logger","getGlobalObject","fill","getFunctionName","supportsHistory","supportsNativeFetch","global","handlers","instrumented","instrument","type","instrumentConsole","instrumentDOM","instrumentXHR","instrumentFetch","instrumentHistory","instrumentError","instrumentUnhandledRejection","warn","addInstrumentationHandler","handler","callback","push","triggerHandlers","data","_b","__values","_c","next","done","value","e","error","forEach","level","console","originalConsoleLevel","args","_i","arguments","length","Function","prototype","apply","call","originalFetch","handlerData","fetchData","method","getFetchMethod","url","getFetchUrl","startTimestamp","Date","now","__assign","then","response","endTimestamp","fetchArgs","Request","String","toUpperCase","requestKeys","requestValues","xhrproto","XMLHttpRequest","originalOpen","xhr","__sentry_xhr__","match","__sentry_own_request__","onreadystatechangeHandler","readyState","status_code","status","requestPos","indexOf","splice","args_1","undefined","body","onreadystatechange","original","readyStateArgs","addEventListener","originalSend","lastHref","oldOnPopState","onpopstate","to","location","href","from","historyReplacementFunction","originalHistoryFunction","history","document","domEventHandler","bind","keypressEventHandler","target","proto","hasOwnProperty","eventName","fn","options","handleEvent","innerOriginal","event","__sentry_wrapped__","debounceDuration","debounceTimer","keypressTimeout","lastCapturedEvent","name","debounce","clearTimeout","setTimeout","tagName","isContentEditable","_oldOnErrorHandler","onerror","msg","line","column","_oldOnUnhandledRejectionHandler","onunhandledrejection"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\@sentry\\utils\\src\\instrument.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/ban-types */\nimport { WrappedFunction } from '@sentry/types';\n\nimport { isInstanceOf, isString } from './is';\nimport { logger } from './logger';\nimport { getGlobalObject } from './misc';\nimport { fill } from './object';\nimport { getFunctionName } from './stacktrace';\nimport { supportsHistory, supportsNativeFetch } from './supports';\n\nconst global = getGlobalObject<Window>();\n\n/** Object describing handler that will be triggered for a given `type` of instrumentation */\ninterface InstrumentHandler {\n  type: InstrumentHandlerType;\n  callback: InstrumentHandlerCallback;\n}\ntype InstrumentHandlerType =\n  | 'console'\n  | 'dom'\n  | 'fetch'\n  | 'history'\n  | 'sentry'\n  | 'xhr'\n  | 'error'\n  | 'unhandledrejection';\ntype InstrumentHandlerCallback = (data: any) => void;\n\n/**\n * Instrument native APIs to call handlers that can be used to create breadcrumbs, APM spans etc.\n *  - Console API\n *  - Fetch API\n *  - XHR API\n *  - History API\n *  - DOM API (click/typing)\n *  - Error API\n *  - UnhandledRejection API\n */\n\nconst handlers: { [key in InstrumentHandlerType]?: InstrumentHandlerCallback[] } = {};\nconst instrumented: { [key in InstrumentHandlerType]?: boolean } = {};\n\n/** Instruments given API */\nfunction instrument(type: InstrumentHandlerType): void {\n  if (instrumented[type]) {\n    return;\n  }\n\n  instrumented[type] = true;\n\n  switch (type) {\n    case 'console':\n      instrumentConsole();\n      break;\n    case 'dom':\n      instrumentDOM();\n      break;\n    case 'xhr':\n      instrumentXHR();\n      break;\n    case 'fetch':\n      instrumentFetch();\n      break;\n    case 'history':\n      instrumentHistory();\n      break;\n    case 'error':\n      instrumentError();\n      break;\n    case 'unhandledrejection':\n      instrumentUnhandledRejection();\n      break;\n    default:\n      logger.warn('unknown instrumentation type:', type);\n  }\n}\n\n/**\n * Add handler that will be called when given type of instrumentation triggers.\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nexport function addInstrumentationHandler(handler: InstrumentHandler): void {\n  if (!handler || typeof handler.type !== 'string' || typeof handler.callback !== 'function') {\n    return;\n  }\n  handlers[handler.type] = handlers[handler.type] || [];\n  (handlers[handler.type] as InstrumentHandlerCallback[]).push(handler.callback);\n  instrument(handler.type);\n}\n\n/** JSDoc */\nfunction triggerHandlers(type: InstrumentHandlerType, data: any): void {\n  if (!type || !handlers[type]) {\n    return;\n  }\n\n  for (const handler of handlers[type] || []) {\n    try {\n      handler(data);\n    } catch (e) {\n      logger.error(\n        `Error while triggering instrumentation handler.\\nType: ${type}\\nName: ${getFunctionName(\n          handler,\n        )}\\nError: ${e}`,\n      );\n    }\n  }\n}\n\n/** JSDoc */\nfunction instrumentConsole(): void {\n  if (!('console' in global)) {\n    return;\n  }\n\n  ['debug', 'info', 'warn', 'error', 'log', 'assert'].forEach(function(level: string): void {\n    if (!(level in global.console)) {\n      return;\n    }\n\n    fill(global.console, level, function(originalConsoleLevel: () => any): Function {\n      return function(...args: any[]): void {\n        triggerHandlers('console', { args, level });\n\n        // this fails for some browsers. :(\n        if (originalConsoleLevel) {\n          Function.prototype.apply.call(originalConsoleLevel, global.console, args);\n        }\n      };\n    });\n  });\n}\n\n/** JSDoc */\nfunction instrumentFetch(): void {\n  if (!supportsNativeFetch()) {\n    return;\n  }\n\n  fill(global, 'fetch', function(originalFetch: () => void): () => void {\n    return function(...args: any[]): void {\n      const handlerData = {\n        args,\n        fetchData: {\n          method: getFetchMethod(args),\n          url: getFetchUrl(args),\n        },\n        startTimestamp: Date.now(),\n      };\n\n      triggerHandlers('fetch', {\n        ...handlerData,\n      });\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      return originalFetch.apply(global, args).then(\n        (response: Response) => {\n          triggerHandlers('fetch', {\n            ...handlerData,\n            endTimestamp: Date.now(),\n            response,\n          });\n          return response;\n        },\n        (error: Error) => {\n          triggerHandlers('fetch', {\n            ...handlerData,\n            endTimestamp: Date.now(),\n            error,\n          });\n          // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n          //       it means the sentry.javascript SDK caught an error invoking your application code.\n          //       This is expected behavior and NOT indicative of a bug with sentry.javascript.\n          throw error;\n        },\n      );\n    };\n  });\n}\n\ntype XHRSendInput = null | Blob | BufferSource | FormData | URLSearchParams | string;\n\n/** JSDoc */\ninterface SentryWrappedXMLHttpRequest extends XMLHttpRequest {\n  [key: string]: any;\n  __sentry_xhr__?: {\n    method?: string;\n    url?: string;\n    status_code?: number;\n    body?: XHRSendInput;\n  };\n}\n\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/** Extract `method` from fetch call arguments */\nfunction getFetchMethod(fetchArgs: any[] = []): string {\n  if ('Request' in global && isInstanceOf(fetchArgs[0], Request) && fetchArgs[0].method) {\n    return String(fetchArgs[0].method).toUpperCase();\n  }\n  if (fetchArgs[1] && fetchArgs[1].method) {\n    return String(fetchArgs[1].method).toUpperCase();\n  }\n  return 'GET';\n}\n\n/** Extract `url` from fetch call arguments */\nfunction getFetchUrl(fetchArgs: any[] = []): string {\n  if (typeof fetchArgs[0] === 'string') {\n    return fetchArgs[0];\n  }\n  if ('Request' in global && isInstanceOf(fetchArgs[0], Request)) {\n    return fetchArgs[0].url;\n  }\n  return String(fetchArgs[0]);\n}\n/* eslint-enable @typescript-eslint/no-unsafe-member-access */\n\n/** JSDoc */\nfunction instrumentXHR(): void {\n  if (!('XMLHttpRequest' in global)) {\n    return;\n  }\n\n  // Poor man's implementation of ES6 `Map`, tracking and keeping in sync key and value separately.\n  const requestKeys: XMLHttpRequest[] = [];\n  const requestValues: Array<any>[] = [];\n  const xhrproto = XMLHttpRequest.prototype;\n\n  fill(xhrproto, 'open', function(originalOpen: () => void): () => void {\n    return function(this: SentryWrappedXMLHttpRequest, ...args: any[]): void {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const xhr = this;\n      const url = args[1];\n      xhr.__sentry_xhr__ = {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        method: isString(args[0]) ? args[0].toUpperCase() : args[0],\n        url: args[1],\n      };\n\n      // if Sentry key appears in URL, don't capture it as a request\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      if (isString(url) && xhr.__sentry_xhr__.method === 'POST' && url.match(/sentry_key/)) {\n        xhr.__sentry_own_request__ = true;\n      }\n\n      const onreadystatechangeHandler = function(): void {\n        if (xhr.readyState === 4) {\n          try {\n            // touching statusCode in some platforms throws\n            // an exception\n            if (xhr.__sentry_xhr__) {\n              xhr.__sentry_xhr__.status_code = xhr.status;\n            }\n          } catch (e) {\n            /* do nothing */\n          }\n\n          try {\n            const requestPos = requestKeys.indexOf(xhr);\n            if (requestPos !== -1) {\n              // Make sure to pop both key and value to keep it in sync.\n              requestKeys.splice(requestPos);\n              const args = requestValues.splice(requestPos)[0];\n              if (xhr.__sentry_xhr__ && args[0] !== undefined) {\n                xhr.__sentry_xhr__.body = args[0] as XHRSendInput;\n              }\n            }\n          } catch (e) {\n            /* do nothing */\n          }\n\n          triggerHandlers('xhr', {\n            args,\n            endTimestamp: Date.now(),\n            startTimestamp: Date.now(),\n            xhr,\n          });\n        }\n      };\n\n      if ('onreadystatechange' in xhr && typeof xhr.onreadystatechange === 'function') {\n        fill(xhr, 'onreadystatechange', function(original: WrappedFunction): Function {\n          return function(...readyStateArgs: any[]): void {\n            onreadystatechangeHandler();\n            return original.apply(xhr, readyStateArgs);\n          };\n        });\n      } else {\n        xhr.addEventListener('readystatechange', onreadystatechangeHandler);\n      }\n\n      return originalOpen.apply(xhr, args);\n    };\n  });\n\n  fill(xhrproto, 'send', function(originalSend: () => void): () => void {\n    return function(this: SentryWrappedXMLHttpRequest, ...args: any[]): void {\n      requestKeys.push(this);\n      requestValues.push(args);\n\n      triggerHandlers('xhr', {\n        args,\n        startTimestamp: Date.now(),\n        xhr: this,\n      });\n\n      return originalSend.apply(this, args);\n    };\n  });\n}\n\nlet lastHref: string;\n\n/** JSDoc */\nfunction instrumentHistory(): void {\n  if (!supportsHistory()) {\n    return;\n  }\n\n  const oldOnPopState = global.onpopstate;\n  global.onpopstate = function(this: WindowEventHandlers, ...args: any[]): any {\n    const to = global.location.href;\n    // keep track of the current URL state, as we always receive only the updated state\n    const from = lastHref;\n    lastHref = to;\n    triggerHandlers('history', {\n      from,\n      to,\n    });\n    if (oldOnPopState) {\n      return oldOnPopState.apply(this, args);\n    }\n  };\n\n  /** @hidden */\n  function historyReplacementFunction(originalHistoryFunction: () => void): () => void {\n    return function(this: History, ...args: any[]): void {\n      const url = args.length > 2 ? args[2] : undefined;\n      if (url) {\n        // coerce to string (this is what pushState does)\n        const from = lastHref;\n        const to = String(url);\n        // keep track of the current URL state, as we always receive only the updated state\n        lastHref = to;\n        triggerHandlers('history', {\n          from,\n          to,\n        });\n      }\n      return originalHistoryFunction.apply(this, args);\n    };\n  }\n\n  fill(global.history, 'pushState', historyReplacementFunction);\n  fill(global.history, 'replaceState', historyReplacementFunction);\n}\n\n/** JSDoc */\nfunction instrumentDOM(): void {\n  if (!('document' in global)) {\n    return;\n  }\n\n  // Capture breadcrumbs from any click that is unhandled / bubbled up all the way\n  // to the document. Do this before we instrument addEventListener.\n  global.document.addEventListener('click', domEventHandler('click', triggerHandlers.bind(null, 'dom')), false);\n  global.document.addEventListener('keypress', keypressEventHandler(triggerHandlers.bind(null, 'dom')), false);\n\n  // After hooking into document bubbled up click and keypresses events, we also hook into user handled click & keypresses.\n  ['EventTarget', 'Node'].forEach((target: string) => {\n    /* eslint-disable @typescript-eslint/no-unsafe-member-access */\n    const proto = (global as any)[target] && (global as any)[target].prototype;\n\n    // eslint-disable-next-line no-prototype-builtins\n    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n      return;\n    }\n    /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n\n    fill(proto, 'addEventListener', function(\n      original: () => void,\n    ): (\n      eventName: string,\n      fn: EventListenerOrEventListenerObject,\n      options?: boolean | AddEventListenerOptions,\n    ) => void {\n      return function(\n        this: any,\n        eventName: string,\n        fn: EventListenerOrEventListenerObject,\n        options?: boolean | AddEventListenerOptions,\n      ): (eventName: string, fn: EventListenerOrEventListenerObject, capture?: boolean, secure?: boolean) => void {\n        if (fn && (fn as EventListenerObject).handleEvent) {\n          if (eventName === 'click') {\n            fill(fn, 'handleEvent', function(innerOriginal: () => void): (caughtEvent: Event) => void {\n              return function(this: any, event: Event): (event: Event) => void {\n                domEventHandler('click', triggerHandlers.bind(null, 'dom'))(event);\n                return innerOriginal.call(this, event);\n              };\n            });\n          }\n          if (eventName === 'keypress') {\n            fill(fn, 'handleEvent', function(innerOriginal: () => void): (caughtEvent: Event) => void {\n              return function(this: any, event: Event): (event: Event) => void {\n                keypressEventHandler(triggerHandlers.bind(null, 'dom'))(event);\n                return innerOriginal.call(this, event);\n              };\n            });\n          }\n        } else {\n          if (eventName === 'click') {\n            domEventHandler('click', triggerHandlers.bind(null, 'dom'), true)(this);\n          }\n          if (eventName === 'keypress') {\n            keypressEventHandler(triggerHandlers.bind(null, 'dom'))(this);\n          }\n        }\n\n        return original.call(this, eventName, fn, options);\n      };\n    });\n\n    fill(proto, 'removeEventListener', function(\n      original: () => void,\n    ): (\n      this: any,\n      eventName: string,\n      fn: EventListenerOrEventListenerObject,\n      options?: boolean | EventListenerOptions,\n    ) => () => void {\n      return function(\n        this: any,\n        eventName: string,\n        fn: EventListenerOrEventListenerObject,\n        options?: boolean | EventListenerOptions,\n      ): () => void {\n        try {\n          original.call(this, eventName, ((fn as unknown) as WrappedFunction).__sentry_wrapped__, options);\n        } catch (e) {\n          // ignore, accessing __sentry_wrapped__ will throw in some Selenium environments\n        }\n        return original.call(this, eventName, fn, options);\n      };\n    });\n  });\n}\n\nconst debounceDuration: number = 1000;\nlet debounceTimer: number = 0;\nlet keypressTimeout: number | undefined;\nlet lastCapturedEvent: Event | undefined;\n\n/**\n * Wraps addEventListener to capture UI breadcrumbs\n * @param name the event name (e.g. \"click\")\n * @param handler function that will be triggered\n * @param debounce decides whether it should wait till another event loop\n * @returns wrapped breadcrumb events handler\n * @hidden\n */\nfunction domEventHandler(name: string, handler: Function, debounce: boolean = false): (event: Event) => void {\n  return (event: Event): void => {\n    // reset keypress timeout; e.g. triggering a 'click' after\n    // a 'keypress' will reset the keypress debounce so that a new\n    // set of keypresses can be recorded\n    keypressTimeout = undefined;\n    // It's possible this handler might trigger multiple times for the same\n    // event (e.g. event propagation through node ancestors). Ignore if we've\n    // already captured the event.\n    if (!event || lastCapturedEvent === event) {\n      return;\n    }\n\n    lastCapturedEvent = event;\n\n    if (debounceTimer) {\n      clearTimeout(debounceTimer);\n    }\n\n    if (debounce) {\n      debounceTimer = setTimeout(() => {\n        handler({ event, name });\n      });\n    } else {\n      handler({ event, name });\n    }\n  };\n}\n\n/**\n * Wraps addEventListener to capture keypress UI events\n * @param handler function that will be triggered\n * @returns wrapped keypress events handler\n * @hidden\n */\nfunction keypressEventHandler(handler: Function): (event: Event) => void {\n  // TODO: if somehow user switches keypress target before\n  //       debounce timeout is triggered, we will only capture\n  //       a single breadcrumb from the FIRST target (acceptable?)\n  return (event: Event): void => {\n    let target;\n\n    try {\n      target = event.target;\n    } catch (e) {\n      // just accessing event properties can throw an exception in some rare circumstances\n      // see: https://github.com/getsentry/raven-js/issues/838\n      return;\n    }\n\n    const tagName = target && (target as HTMLElement).tagName;\n\n    // only consider keypress events on actual input elements\n    // this will disregard keypresses targeting body (e.g. tabbing\n    // through elements, hotkeys, etc)\n    if (!tagName || (tagName !== 'INPUT' && tagName !== 'TEXTAREA' && !(target as HTMLElement).isContentEditable)) {\n      return;\n    }\n\n    // record first keypress in a series, but ignore subsequent\n    // keypresses until debounce clears\n    if (!keypressTimeout) {\n      domEventHandler('input', handler)(event);\n    }\n    clearTimeout(keypressTimeout);\n\n    keypressTimeout = (setTimeout(() => {\n      keypressTimeout = undefined;\n    }, debounceDuration) as any) as number;\n  };\n}\n\nlet _oldOnErrorHandler: OnErrorEventHandler = null;\n/** JSDoc */\nfunction instrumentError(): void {\n  _oldOnErrorHandler = global.onerror;\n\n  global.onerror = function(msg: any, url: any, line: any, column: any, error: any): boolean {\n    triggerHandlers('error', {\n      column,\n      error,\n      line,\n      msg,\n      url,\n    });\n\n    if (_oldOnErrorHandler) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnErrorHandler.apply(this, arguments);\n    }\n\n    return false;\n  };\n}\n\nlet _oldOnUnhandledRejectionHandler: ((e: any) => void) | null = null;\n/** JSDoc */\nfunction instrumentUnhandledRejection(): void {\n  _oldOnUnhandledRejectionHandler = global.onunhandledrejection;\n\n  global.onunhandledrejection = function(e: any): boolean {\n    triggerHandlers('unhandledrejection', e);\n\n    if (_oldOnUnhandledRejectionHandler) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnUnhandledRejectionHandler.apply(this, arguments);\n    }\n\n    return true;\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}