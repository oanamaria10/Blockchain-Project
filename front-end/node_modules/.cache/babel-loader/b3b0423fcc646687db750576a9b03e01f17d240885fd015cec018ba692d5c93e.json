{"ast":null,"code":"export * from \"./api.js\";\nimport * as Node from \"./node.js\";\nimport { create as createBitmapIndexedNode } from \"./node.js\";\nimport * as API from \"./api.js\";\nimport * as Uint32Path from \"./path/Uint32.js\";\nimport * as Uint8ArrayPath from \"./path/Uint8Array.js\";\nimport * as Uint32BitField from \"./bitfield/Uint32.js\";\nimport * as Uint8ArrayBitField from \"./bitfield/Uint8Array.js\";\nconst NOT_FOUND = new RangeError(\"Not Found\");\n\n/**\n * A `bitWidth` determines the number of bits of the hash to use for index\n * calculation at each level of the tree. In first layer will distribute\n * children by the first `bitWidth` bits of the key hash. In the next layer\n * next `bitWidth` number of bits of the key hash are used to determine\n * placement of it's children and so on. Each node in the tree will hold\n * `2 ** bitWidth` number of elements.\n *\n * For example when we insert an entry named `result` it will generate a\n * folowing hash (with murmur3 32) `442064690` which in binary would be\n *\n * ```\n * 11010010110010101111100110010\n * ```\n *\n * Which will correspond to a following key path\n *\n * ```\n * 11010/01011/00101/01111/10011/0010\n * ```\n *\n * Whis in decimals would be\n *\n * ```ts\n * 26/11/5/15/19/2'\n * ```\n *\n * If we then insert `fish` it would produce following path\n *\n * ```ts\n * 26/3/4/18/28/19/1\n * ```\n * @template [V=unknown]\n * @template {string} [K=string]\n * @template {API.Config} [C=API.Config<API.Uint32>]\n * @param {Partial<C>} [options]\n * @returns {API.PersistentHashMap<V, K, C>}\n */\nexport const empty = options => {\n  const config = configure(options);\n  return new PersistentHashMap(0, createBitmapIndexedNode(config, null), config);\n};\n\n/**\n * @template {API.Config} [C=API.Config<API.Uint32>]\n * @param {Partial<C>} config\n * @returns {C}\n */\nconst configure = ({\n  bitWidth = 5,\n  /* c8 ignore next 4 */\n  BitField = bitWidth === 5 ? Uint32BitField : Uint8ArrayBitField,\n  Path = bitWidth === 5 ? Uint32Path.configure({\n    bitWidth\n  }) : Uint8ArrayPath.configure({\n    bitWidth\n  })\n} = {}) => ( /** @type {C} */{\n  bitWidth,\n  BitField,\n  Path\n});\n\n/**\n * Creates HashMap from the provided entries.\n *\n * @template [V=unknown]\n * @template {string} [K=string]\n * @template {API.Config} [C=API.Config<API.Uint32>]\n * @param {Iterable<[K, V]>} entries\n * @param {Partial<C>} [options]\n * @returns {API.PersistentHashMap<V, K, C>}\n */\nexport const from = (entries, options) => {\n  const node = /** @type {API.HashMapBuilder<V, K, C>} */builder(options);\n  for (const [key, value] of entries) {\n    node.set(key, value);\n  }\n  return node.build();\n};\n\n/**\n * @template T\n * @template {string} K\n * @param {API.HAMT<T, K>} hamt\n * @param {K} key\n */\nexport const has = (hamt, key) => Node.get(hamt.root, key, NOT_FOUND) !== NOT_FOUND;\n\n/**\n * @template T\n * @template {string} K\n * @template [U=undefined]\n * @param {API.HAMT<T, K>} hamt\n * @param {K} key\n * @param {U} notFound\n * @returns {T|U}\n */\nexport const get = (hamt, key, notFound = ( /** @type {U} */undefined)) => Node.get(hamt.root, key, notFound);\n\n/**\n * @template {string} K\n * @template T\n * @template {API.Config} C\n * @param {Partial<C>} [options]\n * @returns {API.HashMapBuilder<T, K, C>}\n */\nexport const builder = options => {\n  const edit = {};\n  const config = configure(options);\n  return new HashMapBuilder(edit, 0, createBitmapIndexedNode(config, edit), config);\n};\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @implements {API.PersistentHashMap<T, K, C>}\n */\nclass PersistentHashMap {\n  /**\n   *\n   * @param {number} count\n   * @param {API.BitmapIndexedNode<T, K, C>} root\n   * @param {C} config\n   */\n  constructor(count = 0, root, config) {\n    this.count = count;\n    this.root = root;\n    this.config = config;\n  }\n  get size() {\n    return this.count;\n  }\n  clone() {\n    return new PersistentHashMap(this.count, this.root, this.config);\n  }\n\n  /**\n   * @returns {API.PersistentHashMap<T, K, C>}\n   */\n  empty() {\n    return new PersistentHashMap(0, createBitmapIndexedNode(this.config, null), this.config);\n  }\n  /**\n   * @param {K} key\n   * @returns {boolean}\n   */\n  has(key) {\n    return has(this, key);\n  }\n  /**\n   * @param {K} key\n   * @returns {T|undefined}\n   */\n  get(key) {\n    return Node.get(this.root, key, undefined);\n  }\n  /**\n   * @template {string} R\n   * @param {R} key\n   * @param {T} value\n   * @returns {PersistentHashMap<T, K|R, C>}\n   */\n  set(key, value) {\n    const addedLeaf = {\n      value: false\n    };\n    const root = Node.set(this.root, null, key, value, addedLeaf);\n    if (root === this.root) {\n      return this;\n    } else {\n      return new PersistentHashMap(addedLeaf.value ? this.count + 1 : this.count, root, this.config);\n    }\n  }\n  /**\n   * @param {K} key\n   */\n  delete(key) {\n    const root = Node.delete(this.root, null, key, {\n      value: false\n    });\n    if (root === this.root) {\n      return this;\n    } else {\n      return new PersistentHashMap(this.count - 1, root, this.config);\n    }\n  }\n\n  /* c8 ignore next 3 */\n  get bitField() {\n    return this.config.BitField.or(this.root.datamap, this.root.nodemap);\n  }\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  entries() {\n    return this.root.entries();\n  }\n  keys() {\n    return this.root.keys();\n  }\n  values() {\n    return this.root.values();\n  }\n\n  /**\n   * @returns {API.HashMapBuilder<T, K, C>}\n   */\n\n  createBuilder() {\n    return new HashMapBuilder({}, this.count, this.root, this.config);\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n */\nclass HashMapBuilder {\n  /**\n   * @param {API.Edit} edit\n   * @param {number} count\n   * @param {API.BitmapIndexedNode<T, K, C>} root\n   * @param {C} config\n   */\n  constructor(edit, count, root, config) {\n    /**\n     * @type {API.Edit|null}\n     * @private\n     */\n    this.edit = edit;\n    /**\n     * @private\n     */\n    this.count = count;\n    this.root = root;\n    this.config = config;\n  }\n  get size() {\n    if (this.edit) {\n      return this.count;\n    } else {\n      throw new Error(`.size was accessed on the finalized builder`);\n    }\n  }\n  /**\n   * @template {string} R\n   * @param {R} key\n   * @param {T} value\n   * @returns {HashMapBuilder<T, K|R, C>}\n   */\n  set(key, value) {\n    if (this.edit) {\n      const addedLeaf = {\n        value: false\n      };\n      const root = Node.set(this.root, this.edit, key, value, addedLeaf);\n      if (this.root !== root) {\n        this.root = /** @type {API.BitmapIndexedNode<T, K, C>} */root;\n      }\n      if (addedLeaf.value) {\n        this.count += 1;\n      }\n      return this;\n    } else {\n      throw new Error(`.set was called on the finalized builder`);\n    }\n  }\n  /**\n   * @param {K} key\n   */\n  delete(key) {\n    if (this.edit) {\n      if (this.count === 0) {\n        return this;\n      }\n      const removedLeaf = {\n        value: false\n      };\n      const root = Node.delete(this.root, this.edit, key, removedLeaf);\n      if (root !== this.root) {\n        this.root = root;\n      }\n      if (removedLeaf.value) {\n        this.count -= 1;\n      }\n      return this;\n    } else {\n      throw new Error(`.delete was called on the finalized builder`);\n    }\n  }\n  build() {\n    if (this.edit) {\n      this.edit = null;\n      return new PersistentHashMap(this.count, this.root, this.config);\n    } else {\n      throw new Error(`.build was called on the finalized builder`);\n    }\n  }\n}","map":{"version":3,"names":["Node","create","createBitmapIndexedNode","API","Uint32Path","Uint8ArrayPath","Uint32BitField","Uint8ArrayBitField","NOT_FOUND","RangeError","empty","options","config","configure","PersistentHashMap","bitWidth","BitField","Path","from","entries","node","builder","key","value","set","build","has","hamt","get","root","notFound","undefined","edit","HashMapBuilder","constructor","count","size","clone","addedLeaf","delete","bitField","or","datamap","nodemap","Symbol","iterator","keys","values","createBuilder","Error","removedLeaf"],"sources":["C:/FACULTATE/Proiect/node_modules/@perma/map/src/lib.js"],"sourcesContent":["export * from \"./api.js\"\nimport * as Node from \"./node.js\"\nimport { create as createBitmapIndexedNode } from \"./node.js\"\nimport * as API from \"./api.js\"\nimport * as Uint32Path from \"./path/Uint32.js\"\nimport * as Uint8ArrayPath from \"./path/Uint8Array.js\"\nimport * as Uint32BitField from \"./bitfield/Uint32.js\"\nimport * as Uint8ArrayBitField from \"./bitfield/Uint8Array.js\"\n\nconst NOT_FOUND = new RangeError(\"Not Found\")\n\n/**\n * A `bitWidth` determines the number of bits of the hash to use for index\n * calculation at each level of the tree. In first layer will distribute\n * children by the first `bitWidth` bits of the key hash. In the next layer\n * next `bitWidth` number of bits of the key hash are used to determine\n * placement of it's children and so on. Each node in the tree will hold\n * `2 ** bitWidth` number of elements.\n *\n * For example when we insert an entry named `result` it will generate a\n * folowing hash (with murmur3 32) `442064690` which in binary would be\n *\n * ```\n * 11010010110010101111100110010\n * ```\n *\n * Which will correspond to a following key path\n *\n * ```\n * 11010/01011/00101/01111/10011/0010\n * ```\n *\n * Whis in decimals would be\n *\n * ```ts\n * 26/11/5/15/19/2'\n * ```\n *\n * If we then insert `fish` it would produce following path\n *\n * ```ts\n * 26/3/4/18/28/19/1\n * ```\n * @template [V=unknown]\n * @template {string} [K=string]\n * @template {API.Config} [C=API.Config<API.Uint32>]\n * @param {Partial<C>} [options]\n * @returns {API.PersistentHashMap<V, K, C>}\n */\nexport const empty = options => {\n  const config = configure(options)\n  return new PersistentHashMap(0, createBitmapIndexedNode(config, null), config)\n}\n\n/**\n * @template {API.Config} [C=API.Config<API.Uint32>]\n * @param {Partial<C>} config\n * @returns {C}\n */\nconst configure = ({\n  bitWidth = 5,\n  /* c8 ignore next 4 */\n  BitField = bitWidth === 5 ? Uint32BitField : Uint8ArrayBitField,\n  Path = bitWidth === 5\n    ? Uint32Path.configure({ bitWidth })\n    : Uint8ArrayPath.configure({ bitWidth }),\n} = {}) => /** @type {C} */ ({ bitWidth, BitField, Path })\n\n/**\n * Creates HashMap from the provided entries.\n *\n * @template [V=unknown]\n * @template {string} [K=string]\n * @template {API.Config} [C=API.Config<API.Uint32>]\n * @param {Iterable<[K, V]>} entries\n * @param {Partial<C>} [options]\n * @returns {API.PersistentHashMap<V, K, C>}\n */\nexport const from = (entries, options) => {\n  const node = /** @type {API.HashMapBuilder<V, K, C>} */ (builder(options))\n  for (const [key, value] of entries) {\n    node.set(key, value)\n  }\n\n  return node.build()\n}\n\n/**\n * @template T\n * @template {string} K\n * @param {API.HAMT<T, K>} hamt\n * @param {K} key\n */\nexport const has = (hamt, key) =>\n  Node.get(hamt.root, key, NOT_FOUND) !== NOT_FOUND\n\n/**\n * @template T\n * @template {string} K\n * @template [U=undefined]\n * @param {API.HAMT<T, K>} hamt\n * @param {K} key\n * @param {U} notFound\n * @returns {T|U}\n */\nexport const get = (hamt, key, notFound = /** @type {U} */ (undefined)) =>\n  Node.get(hamt.root, key, notFound)\n\n/**\n * @template {string} K\n * @template T\n * @template {API.Config} C\n * @param {Partial<C>} [options]\n * @returns {API.HashMapBuilder<T, K, C>}\n */\nexport const builder = options => {\n  const edit = {}\n  const config = configure(options)\n  return new HashMapBuilder(\n    edit,\n    0,\n    createBitmapIndexedNode(config, edit),\n    config\n  )\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @implements {API.PersistentHashMap<T, K, C>}\n */\nclass PersistentHashMap {\n  /**\n   *\n   * @param {number} count\n   * @param {API.BitmapIndexedNode<T, K, C>} root\n   * @param {C} config\n   */\n  constructor(count = 0, root, config) {\n    this.count = count\n    this.root = root\n    this.config = config\n  }\n\n  get size() {\n    return this.count\n  }\n\n  clone() {\n    return new PersistentHashMap(this.count, this.root, this.config)\n  }\n\n  /**\n   * @returns {API.PersistentHashMap<T, K, C>}\n   */\n  empty() {\n    return new PersistentHashMap(\n      0,\n      createBitmapIndexedNode(this.config, null),\n      this.config\n    )\n  }\n  /**\n   * @param {K} key\n   * @returns {boolean}\n   */\n  has(key) {\n    return has(this, key)\n  }\n  /**\n   * @param {K} key\n   * @returns {T|undefined}\n   */\n  get(key) {\n    return Node.get(this.root, key, undefined)\n  }\n  /**\n   * @template {string} R\n   * @param {R} key\n   * @param {T} value\n   * @returns {PersistentHashMap<T, K|R, C>}\n   */\n  set(key, value) {\n    const addedLeaf = { value: false }\n    const root = Node.set(this.root, null, key, value, addedLeaf)\n    if (root === this.root) {\n      return this\n    } else {\n      return new PersistentHashMap(\n        addedLeaf.value ? this.count + 1 : this.count,\n        root,\n        this.config\n      )\n    }\n  }\n  /**\n   * @param {K} key\n   */\n  delete(key) {\n    const root = Node.delete(this.root, null, key, { value: false })\n\n    if (root === this.root) {\n      return this\n    } else {\n      return new PersistentHashMap(this.count - 1, root, this.config)\n    }\n  }\n\n  /* c8 ignore next 3 */\n  get bitField() {\n    return this.config.BitField.or(this.root.datamap, this.root.nodemap)\n  }\n\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  entries() {\n    return this.root.entries()\n  }\n  keys() {\n    return this.root.keys()\n  }\n  values() {\n    return this.root.values()\n  }\n\n  /**\n   * @returns {API.HashMapBuilder<T, K, C>}\n   */\n\n  createBuilder() {\n    return new HashMapBuilder({}, this.count, this.root, this.config)\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n */\nclass HashMapBuilder {\n  /**\n   * @param {API.Edit} edit\n   * @param {number} count\n   * @param {API.BitmapIndexedNode<T, K, C>} root\n   * @param {C} config\n   */\n  constructor(edit, count, root, config) {\n    /**\n     * @type {API.Edit|null}\n     * @private\n     */\n    this.edit = edit\n    /**\n     * @private\n     */\n    this.count = count\n    this.root = root\n    this.config = config\n  }\n\n  get size() {\n    if (this.edit) {\n      return this.count\n    } else {\n      throw new Error(`.size was accessed on the finalized builder`)\n    }\n  }\n  /**\n   * @template {string} R\n   * @param {R} key\n   * @param {T} value\n   * @returns {HashMapBuilder<T, K|R, C>}\n   */\n  set(key, value) {\n    if (this.edit) {\n      const addedLeaf = { value: false }\n      const root = Node.set(this.root, this.edit, key, value, addedLeaf)\n\n      if (this.root !== root) {\n        this.root = /** @type {API.BitmapIndexedNode<T, K, C>} */ (root)\n      }\n\n      if (addedLeaf.value) {\n        this.count += 1\n      }\n\n      return this\n    } else {\n      throw new Error(`.set was called on the finalized builder`)\n    }\n  }\n  /**\n   * @param {K} key\n   */\n  delete(key) {\n    if (this.edit) {\n      if (this.count === 0) {\n        return this\n      }\n      const removedLeaf = { value: false }\n      const root = Node.delete(this.root, this.edit, key, removedLeaf)\n\n      if (root !== this.root) {\n        this.root = root\n      }\n      if (removedLeaf.value) {\n        this.count -= 1\n      }\n      return this\n    } else {\n      throw new Error(`.delete was called on the finalized builder`)\n    }\n  }\n\n  build() {\n    if (this.edit) {\n      this.edit = null\n      return new PersistentHashMap(this.count, this.root, this.config)\n    } else {\n      throw new Error(`.build was called on the finalized builder`)\n    }\n  }\n}\n"],"mappings":"AAAA,cAAc,UAAU;AACxB,OAAO,KAAKA,IAAI,MAAM,WAAW;AACjC,SAASC,MAAM,IAAIC,uBAAuB,QAAQ,WAAW;AAC7D,OAAO,KAAKC,GAAG,MAAM,UAAU;AAC/B,OAAO,KAAKC,UAAU,MAAM,kBAAkB;AAC9C,OAAO,KAAKC,cAAc,MAAM,sBAAsB;AACtD,OAAO,KAAKC,cAAc,MAAM,sBAAsB;AACtD,OAAO,KAAKC,kBAAkB,MAAM,0BAA0B;AAE9D,MAAMC,SAAS,GAAG,IAAIC,UAAU,CAAC,WAAW,CAAC;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,KAAK,GAAGC,OAAO,IAAI;EAC9B,MAAMC,MAAM,GAAGC,SAAS,CAACF,OAAO,CAAC;EACjC,OAAO,IAAIG,iBAAiB,CAAC,CAAC,EAAEZ,uBAAuB,CAACU,MAAM,EAAE,IAAI,CAAC,EAAEA,MAAM,CAAC;AAChF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAMC,SAAS,GAAGA,CAAC;EACjBE,QAAQ,GAAG,CAAC;EACZ;EACAC,QAAQ,GAAGD,QAAQ,KAAK,CAAC,GAAGT,cAAc,GAAGC,kBAAkB;EAC/DU,IAAI,GAAGF,QAAQ,KAAK,CAAC,GACjBX,UAAU,CAACS,SAAS,CAAC;IAAEE;EAAS,CAAC,CAAC,GAClCV,cAAc,CAACQ,SAAS,CAAC;IAAEE;EAAS,CAAC;AAC3C,CAAC,GAAG,CAAC,CAAC,OAAK,gBAAkB;EAAEA,QAAQ;EAAEC,QAAQ;EAAEC;AAAK,CAAC,CAAC;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,IAAI,GAAGA,CAACC,OAAO,EAAER,OAAO,KAAK;EACxC,MAAMS,IAAI,GAAG,0CAA4CC,OAAO,CAACV,OAAO,CAAE;EAC1E,KAAK,MAAM,CAACW,GAAG,EAAEC,KAAK,CAAC,IAAIJ,OAAO,EAAE;IAClCC,IAAI,CAACI,GAAG,CAACF,GAAG,EAAEC,KAAK,CAAC;EACtB;EAEA,OAAOH,IAAI,CAACK,KAAK,CAAC,CAAC;AACrB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,GAAG,GAAGA,CAACC,IAAI,EAAEL,GAAG,KAC3BtB,IAAI,CAAC4B,GAAG,CAACD,IAAI,CAACE,IAAI,EAAEP,GAAG,EAAEd,SAAS,CAAC,KAAKA,SAAS;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMoB,GAAG,GAAGA,CAACD,IAAI,EAAEL,GAAG,EAAEQ,QAAQ,KAAG,gBAAkBC,SAAS,CAAC,KACpE/B,IAAI,CAAC4B,GAAG,CAACD,IAAI,CAACE,IAAI,EAAEP,GAAG,EAAEQ,QAAQ,CAAC;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMT,OAAO,GAAGV,OAAO,IAAI;EAChC,MAAMqB,IAAI,GAAG,CAAC,CAAC;EACf,MAAMpB,MAAM,GAAGC,SAAS,CAACF,OAAO,CAAC;EACjC,OAAO,IAAIsB,cAAc,CACvBD,IAAI,EACJ,CAAC,EACD9B,uBAAuB,CAACU,MAAM,EAAEoB,IAAI,CAAC,EACrCpB,MACF,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,iBAAiB,CAAC;EACtB;AACF;AACA;AACA;AACA;AACA;EACEoB,WAAWA,CAACC,KAAK,GAAG,CAAC,EAAEN,IAAI,EAAEjB,MAAM,EAAE;IACnC,IAAI,CAACuB,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACN,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACjB,MAAM,GAAGA,MAAM;EACtB;EAEA,IAAIwB,IAAIA,CAAA,EAAG;IACT,OAAO,IAAI,CAACD,KAAK;EACnB;EAEAE,KAAKA,CAAA,EAAG;IACN,OAAO,IAAIvB,iBAAiB,CAAC,IAAI,CAACqB,KAAK,EAAE,IAAI,CAACN,IAAI,EAAE,IAAI,CAACjB,MAAM,CAAC;EAClE;;EAEA;AACF;AACA;EACEF,KAAKA,CAAA,EAAG;IACN,OAAO,IAAII,iBAAiB,CAC1B,CAAC,EACDZ,uBAAuB,CAAC,IAAI,CAACU,MAAM,EAAE,IAAI,CAAC,EAC1C,IAAI,CAACA,MACP,CAAC;EACH;EACA;AACF;AACA;AACA;EACEc,GAAGA,CAACJ,GAAG,EAAE;IACP,OAAOI,GAAG,CAAC,IAAI,EAAEJ,GAAG,CAAC;EACvB;EACA;AACF;AACA;AACA;EACEM,GAAGA,CAACN,GAAG,EAAE;IACP,OAAOtB,IAAI,CAAC4B,GAAG,CAAC,IAAI,CAACC,IAAI,EAAEP,GAAG,EAAES,SAAS,CAAC;EAC5C;EACA;AACF;AACA;AACA;AACA;AACA;EACEP,GAAGA,CAACF,GAAG,EAAEC,KAAK,EAAE;IACd,MAAMe,SAAS,GAAG;MAAEf,KAAK,EAAE;IAAM,CAAC;IAClC,MAAMM,IAAI,GAAG7B,IAAI,CAACwB,GAAG,CAAC,IAAI,CAACK,IAAI,EAAE,IAAI,EAAEP,GAAG,EAAEC,KAAK,EAAEe,SAAS,CAAC;IAC7D,IAAIT,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;MACtB,OAAO,IAAI;IACb,CAAC,MAAM;MACL,OAAO,IAAIf,iBAAiB,CAC1BwB,SAAS,CAACf,KAAK,GAAG,IAAI,CAACY,KAAK,GAAG,CAAC,GAAG,IAAI,CAACA,KAAK,EAC7CN,IAAI,EACJ,IAAI,CAACjB,MACP,CAAC;IACH;EACF;EACA;AACF;AACA;EACE2B,MAAMA,CAACjB,GAAG,EAAE;IACV,MAAMO,IAAI,GAAG7B,IAAI,CAACuC,MAAM,CAAC,IAAI,CAACV,IAAI,EAAE,IAAI,EAAEP,GAAG,EAAE;MAAEC,KAAK,EAAE;IAAM,CAAC,CAAC;IAEhE,IAAIM,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;MACtB,OAAO,IAAI;IACb,CAAC,MAAM;MACL,OAAO,IAAIf,iBAAiB,CAAC,IAAI,CAACqB,KAAK,GAAG,CAAC,EAAEN,IAAI,EAAE,IAAI,CAACjB,MAAM,CAAC;IACjE;EACF;;EAEA;EACA,IAAI4B,QAAQA,CAAA,EAAG;IACb,OAAO,IAAI,CAAC5B,MAAM,CAACI,QAAQ,CAACyB,EAAE,CAAC,IAAI,CAACZ,IAAI,CAACa,OAAO,EAAE,IAAI,CAACb,IAAI,CAACc,OAAO,CAAC;EACtE;EAEA,CAACC,MAAM,CAACC,QAAQ,IAAI;IAClB,OAAO,IAAI,CAAC1B,OAAO,CAAC,CAAC;EACvB;EAEAA,OAAOA,CAAA,EAAG;IACR,OAAO,IAAI,CAACU,IAAI,CAACV,OAAO,CAAC,CAAC;EAC5B;EACA2B,IAAIA,CAAA,EAAG;IACL,OAAO,IAAI,CAACjB,IAAI,CAACiB,IAAI,CAAC,CAAC;EACzB;EACAC,MAAMA,CAAA,EAAG;IACP,OAAO,IAAI,CAAClB,IAAI,CAACkB,MAAM,CAAC,CAAC;EAC3B;;EAEA;AACF;AACA;;EAEEC,aAAaA,CAAA,EAAG;IACd,OAAO,IAAIf,cAAc,CAAC,CAAC,CAAC,EAAE,IAAI,CAACE,KAAK,EAAE,IAAI,CAACN,IAAI,EAAE,IAAI,CAACjB,MAAM,CAAC;EACnE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAMqB,cAAc,CAAC;EACnB;AACF;AACA;AACA;AACA;AACA;EACEC,WAAWA,CAACF,IAAI,EAAEG,KAAK,EAAEN,IAAI,EAAEjB,MAAM,EAAE;IACrC;AACJ;AACA;AACA;IACI,IAAI,CAACoB,IAAI,GAAGA,IAAI;IAChB;AACJ;AACA;IACI,IAAI,CAACG,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACN,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACjB,MAAM,GAAGA,MAAM;EACtB;EAEA,IAAIwB,IAAIA,CAAA,EAAG;IACT,IAAI,IAAI,CAACJ,IAAI,EAAE;MACb,OAAO,IAAI,CAACG,KAAK;IACnB,CAAC,MAAM;MACL,MAAM,IAAIc,KAAK,CAAE,6CAA4C,CAAC;IAChE;EACF;EACA;AACF;AACA;AACA;AACA;AACA;EACEzB,GAAGA,CAACF,GAAG,EAAEC,KAAK,EAAE;IACd,IAAI,IAAI,CAACS,IAAI,EAAE;MACb,MAAMM,SAAS,GAAG;QAAEf,KAAK,EAAE;MAAM,CAAC;MAClC,MAAMM,IAAI,GAAG7B,IAAI,CAACwB,GAAG,CAAC,IAAI,CAACK,IAAI,EAAE,IAAI,CAACG,IAAI,EAAEV,GAAG,EAAEC,KAAK,EAAEe,SAAS,CAAC;MAElE,IAAI,IAAI,CAACT,IAAI,KAAKA,IAAI,EAAE;QACtB,IAAI,CAACA,IAAI,GAAG,6CAA+CA,IAAK;MAClE;MAEA,IAAIS,SAAS,CAACf,KAAK,EAAE;QACnB,IAAI,CAACY,KAAK,IAAI,CAAC;MACjB;MAEA,OAAO,IAAI;IACb,CAAC,MAAM;MACL,MAAM,IAAIc,KAAK,CAAE,0CAAyC,CAAC;IAC7D;EACF;EACA;AACF;AACA;EACEV,MAAMA,CAACjB,GAAG,EAAE;IACV,IAAI,IAAI,CAACU,IAAI,EAAE;MACb,IAAI,IAAI,CAACG,KAAK,KAAK,CAAC,EAAE;QACpB,OAAO,IAAI;MACb;MACA,MAAMe,WAAW,GAAG;QAAE3B,KAAK,EAAE;MAAM,CAAC;MACpC,MAAMM,IAAI,GAAG7B,IAAI,CAACuC,MAAM,CAAC,IAAI,CAACV,IAAI,EAAE,IAAI,CAACG,IAAI,EAAEV,GAAG,EAAE4B,WAAW,CAAC;MAEhE,IAAIrB,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;QACtB,IAAI,CAACA,IAAI,GAAGA,IAAI;MAClB;MACA,IAAIqB,WAAW,CAAC3B,KAAK,EAAE;QACrB,IAAI,CAACY,KAAK,IAAI,CAAC;MACjB;MACA,OAAO,IAAI;IACb,CAAC,MAAM;MACL,MAAM,IAAIc,KAAK,CAAE,6CAA4C,CAAC;IAChE;EACF;EAEAxB,KAAKA,CAAA,EAAG;IACN,IAAI,IAAI,CAACO,IAAI,EAAE;MACb,IAAI,CAACA,IAAI,GAAG,IAAI;MAChB,OAAO,IAAIlB,iBAAiB,CAAC,IAAI,CAACqB,KAAK,EAAE,IAAI,CAACN,IAAI,EAAE,IAAI,CAACjB,MAAM,CAAC;IAClE,CAAC,MAAM;MACL,MAAM,IAAIqC,KAAK,CAAE,4CAA2C,CAAC;IAC/D;EACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}