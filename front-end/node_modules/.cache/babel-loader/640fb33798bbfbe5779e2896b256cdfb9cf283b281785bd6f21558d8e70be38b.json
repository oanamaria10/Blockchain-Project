{"ast":null,"code":"/**\n * External Interfaces for other EthereumJS libraries\n */\nexport {};","map":{"version":3,"names":[],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\@nomicfoundation\\ethereumjs-common\\src\\interfaces.ts"],"sourcesContent":["/**\n * External Interfaces for other EthereumJS libraries\n */\n\nimport type { Account, Address, PrefixedHexString } from '@nomicfoundation/ethereumjs-util'\n\nexport interface StorageDump {\n  [key: string]: string\n}\n\n/**\n * Object that can contain a set of storage keys associated with an account.\n */\nexport interface StorageRange {\n  /**\n   * A dictionary where the keys are hashed storage keys, and the values are\n   * objects containing the preimage of the hashed key (in `key`) and the\n   * storage key (in `value`). Currently, there is no way to retrieve preimages,\n   * so they are always `null`.\n   */\n  storage: {\n    [key: string]: {\n      key: string | null\n      value: string\n    }\n  }\n  /**\n   * The next (hashed) storage key after the greatest storage key\n   * contained in `storage`.\n   */\n  nextKey: string | null\n}\n\nexport type AccountFields = Partial<Pick<Account, 'nonce' | 'balance' | 'storageRoot' | 'codeHash'>>\n\nexport type StorageProof = {\n  key: PrefixedHexString\n  proof: PrefixedHexString[]\n  value: PrefixedHexString\n}\n\nexport type Proof = {\n  address: PrefixedHexString\n  balance: PrefixedHexString\n  codeHash: PrefixedHexString\n  nonce: PrefixedHexString\n  storageHash: PrefixedHexString\n  accountProof: PrefixedHexString[]\n  storageProof: StorageProof[]\n}\n\n/*\n * Access List types\n */\n\nexport type AccessListItem = {\n  address: PrefixedHexString\n  storageKeys: PrefixedHexString[]\n}\n\n/*\n * An Access List as a tuple of [address: Uint8Array, storageKeys: Uint8Array[]]\n */\nexport type AccessListBytesItem = [Uint8Array, Uint8Array[]]\nexport type AccessListBytes = AccessListBytesItem[]\nexport type AccessList = AccessListItem[]\n\nexport interface StateManagerInterface {\n  getAccount(address: Address): Promise<Account | undefined>\n  putAccount(address: Address, account?: Account): Promise<void>\n  deleteAccount(address: Address): Promise<void>\n  modifyAccountFields(address: Address, accountFields: AccountFields): Promise<void>\n  putContractCode(address: Address, value: Uint8Array): Promise<void>\n  getContractCode(address: Address): Promise<Uint8Array>\n  getContractStorage(address: Address, key: Uint8Array): Promise<Uint8Array>\n  putContractStorage(address: Address, key: Uint8Array, value: Uint8Array): Promise<void>\n  clearContractStorage(address: Address): Promise<void>\n  checkpoint(): Promise<void>\n  commit(): Promise<void>\n  revert(): Promise<void>\n  getStateRoot(): Promise<Uint8Array>\n  setStateRoot(stateRoot: Uint8Array, clearCache?: boolean): Promise<void>\n  getProof?(address: Address, storageSlots: Uint8Array[]): Promise<Proof>\n  hasStateRoot(root: Uint8Array): Promise<boolean> // only used in client\n  shallowCopy(downlevelCaches?: boolean): StateManagerInterface\n}\n\nexport interface EVMStateManagerInterface extends StateManagerInterface {\n  originalStorageCache: {\n    get(address: Address, key: Uint8Array): Promise<Uint8Array>\n    clear(): void\n  }\n\n  dumpStorage(address: Address): Promise<StorageDump> // only used in client\n  dumpStorageRange(address: Address, startKey: bigint, limit: number): Promise<StorageRange> // only used in client\n  generateCanonicalGenesis(initState: any): Promise<void> // TODO make input more typesafe\n  getProof(address: Address, storageSlots?: Uint8Array[]): Promise<Proof>\n\n  shallowCopy(downlevelCaches?: boolean): EVMStateManagerInterface\n}\n"],"mappings":"AAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}