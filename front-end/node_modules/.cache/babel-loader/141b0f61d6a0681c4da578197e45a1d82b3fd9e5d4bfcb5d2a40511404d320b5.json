{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.normalizeLibraryRuntimeBytecodeIfNecessary = exports.zeroOutSlices = exports.zeroOutAddresses = exports.linkHexStringBytecode = exports.normalizeCompilerOutputBytecode = exports.getLibraryAddressPositions = void 0;\nconst opcodes_1 = require(\"./opcodes\");\nfunction getLibraryAddressPositions(bytecodeOutput) {\n  const positions = [];\n  for (const libs of Object.values(bytecodeOutput.linkReferences)) {\n    for (const references of Object.values(libs)) {\n      for (const ref of references) {\n        positions.push(ref.start);\n      }\n    }\n  }\n  return positions;\n}\nexports.getLibraryAddressPositions = getLibraryAddressPositions;\nfunction normalizeCompilerOutputBytecode(compilerOutputBytecodeObject, addressesPositions) {\n  const ZERO_ADDRESS = \"0000000000000000000000000000000000000000\";\n  for (const position of addressesPositions) {\n    compilerOutputBytecodeObject = linkHexStringBytecode(compilerOutputBytecodeObject, ZERO_ADDRESS, position);\n  }\n  return Buffer.from(compilerOutputBytecodeObject, \"hex\");\n}\nexports.normalizeCompilerOutputBytecode = normalizeCompilerOutputBytecode;\nfunction linkHexStringBytecode(code, address, position) {\n  if (address.startsWith(\"0x\")) {\n    address = address.substring(2);\n  }\n  return code.substring(0, position * 2) + address + code.slice(position * 2 + address.length);\n}\nexports.linkHexStringBytecode = linkHexStringBytecode;\nfunction zeroOutAddresses(code, addressesPositions) {\n  const addressesSlices = addressesPositions.map(start => ({\n    start,\n    length: 20\n  }));\n  return zeroOutSlices(code, addressesSlices);\n}\nexports.zeroOutAddresses = zeroOutAddresses;\nfunction zeroOutSlices(code, slices) {\n  for (const {\n    start,\n    length\n  } of slices) {\n    code = Buffer.concat([code.slice(0, start), Buffer.alloc(length, 0), code.slice(start + length)]);\n  }\n  return code;\n}\nexports.zeroOutSlices = zeroOutSlices;\nfunction normalizeLibraryRuntimeBytecodeIfNecessary(code) {\n  // Libraries' protection normalization:\n  // Solidity 0.4.20 introduced a protection to prevent libraries from being called directly.\n  // This is done by modifying the code on deployment, and hard-coding the contract address.\n  // The first instruction is a PUSH20 of the address, which we zero-out as a way of normalizing\n  // it. Note that it's also zeroed-out in the compiler output.\n  if (code[0] === opcodes_1.Opcode.PUSH20) {\n    return zeroOutAddresses(code, [1]);\n  }\n  return code;\n}\nexports.normalizeLibraryRuntimeBytecodeIfNecessary = normalizeLibraryRuntimeBytecodeIfNecessary;","map":{"version":3,"names":["opcodes_1","require","getLibraryAddressPositions","bytecodeOutput","positions","libs","Object","values","linkReferences","references","ref","push","start","exports","normalizeCompilerOutputBytecode","compilerOutputBytecodeObject","addressesPositions","ZERO_ADDRESS","position","linkHexStringBytecode","Buffer","from","code","address","startsWith","substring","slice","length","zeroOutAddresses","addressesSlices","map","zeroOutSlices","slices","concat","alloc","normalizeLibraryRuntimeBytecodeIfNecessary","Opcode","PUSH20"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\internal\\hardhat-network\\stack-traces\\library-utils.ts"],"sourcesContent":["import { CompilerOutputBytecode } from \"../../../types\";\n\nimport { Opcode } from \"./opcodes\";\n\nexport function getLibraryAddressPositions(\n  bytecodeOutput: CompilerOutputBytecode\n): number[] {\n  const positions = [];\n  for (const libs of Object.values(bytecodeOutput.linkReferences)) {\n    for (const references of Object.values(libs)) {\n      for (const ref of references) {\n        positions.push(ref.start);\n      }\n    }\n  }\n\n  return positions;\n}\n\nexport function normalizeCompilerOutputBytecode(\n  compilerOutputBytecodeObject: string,\n  addressesPositions: number[]\n): Buffer {\n  const ZERO_ADDRESS = \"0000000000000000000000000000000000000000\";\n  for (const position of addressesPositions) {\n    compilerOutputBytecodeObject = linkHexStringBytecode(\n      compilerOutputBytecodeObject,\n      ZERO_ADDRESS,\n      position\n    );\n  }\n\n  return Buffer.from(compilerOutputBytecodeObject, \"hex\");\n}\n\nexport function linkHexStringBytecode(\n  code: string,\n  address: string,\n  position: number\n) {\n  if (address.startsWith(\"0x\")) {\n    address = address.substring(2);\n  }\n\n  return (\n    code.substring(0, position * 2) +\n    address +\n    code.slice(position * 2 + address.length)\n  );\n}\n\nexport function zeroOutAddresses(\n  code: Uint8Array,\n  addressesPositions: number[]\n): Uint8Array {\n  const addressesSlices = addressesPositions.map((start) => ({\n    start,\n    length: 20,\n  }));\n\n  return zeroOutSlices(code, addressesSlices);\n}\n\nexport function zeroOutSlices(\n  code: Uint8Array,\n  slices: Array<{ start: number; length: number }>\n): Uint8Array {\n  for (const { start, length } of slices) {\n    code = Buffer.concat([\n      code.slice(0, start),\n      Buffer.alloc(length, 0),\n      code.slice(start + length),\n    ]);\n  }\n\n  return code;\n}\n\nexport function normalizeLibraryRuntimeBytecodeIfNecessary(\n  code: Uint8Array\n): Uint8Array {\n  // Libraries' protection normalization:\n  // Solidity 0.4.20 introduced a protection to prevent libraries from being called directly.\n  // This is done by modifying the code on deployment, and hard-coding the contract address.\n  // The first instruction is a PUSH20 of the address, which we zero-out as a way of normalizing\n  // it. Note that it's also zeroed-out in the compiler output.\n  if (code[0] === Opcode.PUSH20) {\n    return zeroOutAddresses(code, [1]);\n  }\n\n  return code;\n}\n"],"mappings":";;;;;;AAEA,MAAAA,SAAA,GAAAC,OAAA;AAEA,SAAgBC,0BAA0BA,CACxCC,cAAsC;EAEtC,MAAMC,SAAS,GAAG,EAAE;EACpB,KAAK,MAAMC,IAAI,IAAIC,MAAM,CAACC,MAAM,CAACJ,cAAc,CAACK,cAAc,CAAC,EAAE;IAC/D,KAAK,MAAMC,UAAU,IAAIH,MAAM,CAACC,MAAM,CAACF,IAAI,CAAC,EAAE;MAC5C,KAAK,MAAMK,GAAG,IAAID,UAAU,EAAE;QAC5BL,SAAS,CAACO,IAAI,CAACD,GAAG,CAACE,KAAK,CAAC;;;;EAK/B,OAAOR,SAAS;AAClB;AAbAS,OAAA,CAAAX,0BAAA,GAAAA,0BAAA;AAeA,SAAgBY,+BAA+BA,CAC7CC,4BAAoC,EACpCC,kBAA4B;EAE5B,MAAMC,YAAY,GAAG,0CAA0C;EAC/D,KAAK,MAAMC,QAAQ,IAAIF,kBAAkB,EAAE;IACzCD,4BAA4B,GAAGI,qBAAqB,CAClDJ,4BAA4B,EAC5BE,YAAY,EACZC,QAAQ,CACT;;EAGH,OAAOE,MAAM,CAACC,IAAI,CAACN,4BAA4B,EAAE,KAAK,CAAC;AACzD;AAdAF,OAAA,CAAAC,+BAAA,GAAAA,+BAAA;AAgBA,SAAgBK,qBAAqBA,CACnCG,IAAY,EACZC,OAAe,EACfL,QAAgB;EAEhB,IAAIK,OAAO,CAACC,UAAU,CAAC,IAAI,CAAC,EAAE;IAC5BD,OAAO,GAAGA,OAAO,CAACE,SAAS,CAAC,CAAC,CAAC;;EAGhC,OACEH,IAAI,CAACG,SAAS,CAAC,CAAC,EAAEP,QAAQ,GAAG,CAAC,CAAC,GAC/BK,OAAO,GACPD,IAAI,CAACI,KAAK,CAACR,QAAQ,GAAG,CAAC,GAAGK,OAAO,CAACI,MAAM,CAAC;AAE7C;AAdAd,OAAA,CAAAM,qBAAA,GAAAA,qBAAA;AAgBA,SAAgBS,gBAAgBA,CAC9BN,IAAgB,EAChBN,kBAA4B;EAE5B,MAAMa,eAAe,GAAGb,kBAAkB,CAACc,GAAG,CAAElB,KAAK,KAAM;IACzDA,KAAK;IACLe,MAAM,EAAE;GACT,CAAC,CAAC;EAEH,OAAOI,aAAa,CAACT,IAAI,EAAEO,eAAe,CAAC;AAC7C;AAVAhB,OAAA,CAAAe,gBAAA,GAAAA,gBAAA;AAYA,SAAgBG,aAAaA,CAC3BT,IAAgB,EAChBU,MAAgD;EAEhD,KAAK,MAAM;IAAEpB,KAAK;IAAEe;EAAM,CAAE,IAAIK,MAAM,EAAE;IACtCV,IAAI,GAAGF,MAAM,CAACa,MAAM,CAAC,CACnBX,IAAI,CAACI,KAAK,CAAC,CAAC,EAAEd,KAAK,CAAC,EACpBQ,MAAM,CAACc,KAAK,CAACP,MAAM,EAAE,CAAC,CAAC,EACvBL,IAAI,CAACI,KAAK,CAACd,KAAK,GAAGe,MAAM,CAAC,CAC3B,CAAC;;EAGJ,OAAOL,IAAI;AACb;AAbAT,OAAA,CAAAkB,aAAA,GAAAA,aAAA;AAeA,SAAgBI,0CAA0CA,CACxDb,IAAgB;EAEhB;EACA;EACA;EACA;EACA;EACA,IAAIA,IAAI,CAAC,CAAC,CAAC,KAAKtB,SAAA,CAAAoC,MAAM,CAACC,MAAM,EAAE;IAC7B,OAAOT,gBAAgB,CAACN,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC;;EAGpC,OAAOA,IAAI;AACb;AAbAT,OAAA,CAAAsB,0CAAA,GAAAA,0CAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}