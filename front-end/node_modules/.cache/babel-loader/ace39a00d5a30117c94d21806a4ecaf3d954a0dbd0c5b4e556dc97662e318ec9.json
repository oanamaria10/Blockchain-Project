{"ast":null,"code":"// @ts-check\n\n'use strict';\n\n/* global WebAssembly */\nconst assert = require('assert');\nconst net = require('net');\nconst http = require('http');\nconst {\n  pipeline\n} = require('stream');\nconst util = require('./core/util');\nconst timers = require('./timers');\nconst Request = require('./core/request');\nconst DispatcherBase = require('./dispatcher-base');\nconst {\n  RequestContentLengthMismatchError,\n  ResponseContentLengthMismatchError,\n  InvalidArgumentError,\n  RequestAbortedError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  SocketError,\n  InformationalError,\n  BodyTimeoutError,\n  HTTPParserError,\n  ResponseExceededMaxSizeError,\n  ClientDestroyedError\n} = require('./core/errors');\nconst buildConnector = require('./core/connect');\nconst {\n  kUrl,\n  kReset,\n  kServerName,\n  kClient,\n  kBusy,\n  kParser,\n  kConnect,\n  kBlocking,\n  kResuming,\n  kRunning,\n  kPending,\n  kSize,\n  kWriting,\n  kQueue,\n  kConnected,\n  kConnecting,\n  kNeedDrain,\n  kNoRef,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kPipelining,\n  kSocket,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kConnector,\n  kMaxRedirections,\n  kMaxRequests,\n  kCounter,\n  kClose,\n  kDestroy,\n  kDispatch,\n  kInterceptors,\n  kLocalAddress,\n  kMaxResponseSize,\n  kHTTPConnVersion,\n  // HTTP2\n  kHost,\n  kHTTP2Session,\n  kHTTP2SessionState,\n  kHTTP2BuildRequest,\n  kHTTP2CopyHeaders,\n  kHTTP1BuildRequest\n} = require('./core/symbols');\n\n/** @type {import('http2')} */\nlet http2;\ntry {\n  http2 = require('http2');\n} catch {\n  // @ts-ignore\n  http2 = {\n    constants: {}\n  };\n}\nconst {\n  constants: {\n    HTTP2_HEADER_AUTHORITY,\n    HTTP2_HEADER_METHOD,\n    HTTP2_HEADER_PATH,\n    HTTP2_HEADER_SCHEME,\n    HTTP2_HEADER_CONTENT_LENGTH,\n    HTTP2_HEADER_EXPECT,\n    HTTP2_HEADER_STATUS\n  }\n} = http2;\n\n// Experimental\nlet h2ExperimentalWarned = false;\nconst FastBuffer = Buffer[Symbol.species];\nconst kClosedResolve = Symbol('kClosedResolve');\nconst channels = {};\ntry {\n  const diagnosticsChannel = require('diagnostics_channel');\n  channels.sendHeaders = diagnosticsChannel.channel('undici:client:sendHeaders');\n  channels.beforeConnect = diagnosticsChannel.channel('undici:client:beforeConnect');\n  channels.connectError = diagnosticsChannel.channel('undici:client:connectError');\n  channels.connected = diagnosticsChannel.channel('undici:client:connected');\n} catch {\n  channels.sendHeaders = {\n    hasSubscribers: false\n  };\n  channels.beforeConnect = {\n    hasSubscribers: false\n  };\n  channels.connectError = {\n    hasSubscribers: false\n  };\n  channels.connected = {\n    hasSubscribers: false\n  };\n}\n\n/**\n * @type {import('../types/client').default}\n */\nclass Client extends DispatcherBase {\n  /**\n   *\n   * @param {string|URL} url\n   * @param {import('../types/client').Client.Options} options\n   */\n  constructor(url, {\n    interceptors,\n    maxHeaderSize,\n    headersTimeout,\n    socketTimeout,\n    requestTimeout,\n    connectTimeout,\n    bodyTimeout,\n    idleTimeout,\n    keepAlive,\n    keepAliveTimeout,\n    maxKeepAliveTimeout,\n    keepAliveMaxTimeout,\n    keepAliveTimeoutThreshold,\n    socketPath,\n    pipelining,\n    tls,\n    strictContentLength,\n    maxCachedSessions,\n    maxRedirections,\n    connect,\n    maxRequestsPerClient,\n    localAddress,\n    maxResponseSize,\n    autoSelectFamily,\n    autoSelectFamilyAttemptTimeout,\n    // h2\n    allowH2,\n    maxConcurrentStreams\n  } = {}) {\n    super();\n    if (keepAlive !== undefined) {\n      throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead');\n    }\n    if (socketTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead');\n    }\n    if (requestTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead');\n    }\n    if (idleTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead');\n    }\n    if (maxKeepAliveTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead');\n    }\n    if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {\n      throw new InvalidArgumentError('invalid maxHeaderSize');\n    }\n    if (socketPath != null && typeof socketPath !== 'string') {\n      throw new InvalidArgumentError('invalid socketPath');\n    }\n    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n      throw new InvalidArgumentError('invalid connectTimeout');\n    }\n    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeout');\n    }\n    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveMaxTimeout');\n    }\n    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold');\n    }\n    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('headersTimeout must be a positive integer or zero');\n    }\n    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero');\n    }\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object');\n    }\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number');\n    }\n    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n      throw new InvalidArgumentError('maxRequestsPerClient must be a positive number');\n    }\n    if (localAddress != null && (typeof localAddress !== 'string' || net.isIP(localAddress) === 0)) {\n      throw new InvalidArgumentError('localAddress must be valid string IP address');\n    }\n    if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {\n      throw new InvalidArgumentError('maxResponseSize must be a positive number');\n    }\n    if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {\n      throw new InvalidArgumentError('autoSelectFamilyAttemptTimeout must be a positive number');\n    }\n\n    // h2\n    if (allowH2 != null && typeof allowH2 !== 'boolean') {\n      throw new InvalidArgumentError('allowH2 must be a valid boolean value');\n    }\n    if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== 'number' || maxConcurrentStreams < 1)) {\n      throw new InvalidArgumentError('maxConcurrentStreams must be a possitive integer, greater than 0');\n    }\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        allowH2,\n        socketPath,\n        timeout: connectTimeout,\n        ...(util.nodeHasAutoSelectFamily && autoSelectFamily ? {\n          autoSelectFamily,\n          autoSelectFamilyAttemptTimeout\n        } : undefined),\n        ...connect\n      });\n    }\n    this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor({\n      maxRedirections\n    })];\n    this[kUrl] = util.parseOrigin(url);\n    this[kConnector] = connect;\n    this[kSocket] = null;\n    this[kPipelining] = pipelining != null ? pipelining : 1;\n    this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;\n    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;\n    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout;\n    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;\n    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];\n    this[kServerName] = null;\n    this[kLocalAddress] = localAddress != null ? localAddress : null;\n    this[kResuming] = 0; // 0, idle, 1, scheduled, 2 resuming\n    this[kNeedDrain] = 0; // 0, idle, 1, scheduled, 2 resuming\n    this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\\r\\n`;\n    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300e3;\n    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300e3;\n    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;\n    this[kMaxRedirections] = maxRedirections;\n    this[kMaxRequests] = maxRequestsPerClient;\n    this[kClosedResolve] = null;\n    this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;\n    this[kHTTPConnVersion] = 'h1';\n\n    // HTTP/2\n    this[kHTTP2Session] = null;\n    this[kHTTP2SessionState] = !allowH2 ? null : {\n      // streams: null, // Fixed queue of streams - For future support of `push`\n      openStreams: 0,\n      // Keep track of them to decide wether or not unref the session\n      maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100 // Max peerConcurrentStreams for a Node h2 server\n    };\n    this[kHost] = `${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}`;\n\n    // kQueue is built up of 3 sections separated by\n    // the kRunningIdx and kPendingIdx indices.\n    // |   complete   |   running   |   pending   |\n    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n    // kRunningIdx points to the first running element.\n    // kPendingIdx points to the first pending element.\n    // This implements a fast queue with an amortized\n    // time of O(1).\n\n    this[kQueue] = [];\n    this[kRunningIdx] = 0;\n    this[kPendingIdx] = 0;\n  }\n  get pipelining() {\n    return this[kPipelining];\n  }\n  set pipelining(value) {\n    this[kPipelining] = value;\n    resume(this, true);\n  }\n  get [kPending]() {\n    return this[kQueue].length - this[kPendingIdx];\n  }\n  get [kRunning]() {\n    return this[kPendingIdx] - this[kRunningIdx];\n  }\n  get [kSize]() {\n    return this[kQueue].length - this[kRunningIdx];\n  }\n  get [kConnected]() {\n    return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;\n  }\n  get [kBusy]() {\n    const socket = this[kSocket];\n    return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;\n  }\n\n  /* istanbul ignore: only used for test */\n  [kConnect](cb) {\n    connect(this);\n    this.once('connect', cb);\n  }\n  [kDispatch](opts, handler) {\n    const origin = opts.origin || this[kUrl].origin;\n    const request = this[kHTTPConnVersion] === 'h2' ? Request[kHTTP2BuildRequest](origin, opts, handler) : Request[kHTTP1BuildRequest](origin, opts, handler);\n    this[kQueue].push(request);\n    if (this[kResuming]) {\n      // Do nothing.\n    } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {\n      // Wait a tick in case stream/iterator is ended in the same tick.\n      this[kResuming] = 1;\n      process.nextTick(resume, this);\n    } else {\n      resume(this, true);\n    }\n    if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n      this[kNeedDrain] = 2;\n    }\n    return this[kNeedDrain] < 2;\n  }\n  async [kClose]() {\n    // TODO: for H2 we need to gracefully flush the remaining enqueued\n    // request and close each stream.\n    return new Promise(resolve => {\n      if (!this[kSize]) {\n        resolve(null);\n      } else {\n        this[kClosedResolve] = resolve;\n      }\n    });\n  }\n  async [kDestroy](err) {\n    return new Promise(resolve => {\n      const requests = this[kQueue].splice(this[kPendingIdx]);\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i];\n        errorRequest(this, request, err);\n      }\n      const callback = () => {\n        if (this[kClosedResolve]) {\n          // TODO (fix): Should we error here with ClientDestroyedError?\n          this[kClosedResolve]();\n          this[kClosedResolve] = null;\n        }\n        resolve();\n      };\n      if (this[kHTTP2Session] != null) {\n        util.destroy(this[kHTTP2Session], err);\n        this[kHTTP2Session] = null;\n        this[kHTTP2SessionState] = null;\n      }\n      if (!this[kSocket]) {\n        queueMicrotask(callback);\n      } else {\n        util.destroy(this[kSocket].on('close', callback), err);\n      }\n      resume(this);\n    });\n  }\n}\nfunction onHttp2SessionError(err) {\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID');\n  this[kSocket][kError] = err;\n  onError(this[kClient], err);\n}\nfunction onHttp2FrameError(type, code, id) {\n  const err = new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`);\n  if (id === 0) {\n    this[kSocket][kError] = err;\n    onError(this[kClient], err);\n  }\n}\nfunction onHttp2SessionEnd() {\n  util.destroy(this, new SocketError('other side closed'));\n  util.destroy(this[kSocket], new SocketError('other side closed'));\n}\nfunction onHTTP2GoAway(code) {\n  const client = this[kClient];\n  const err = new InformationalError(`HTTP/2: \"GOAWAY\" frame received with code ${code}`);\n  client[kSocket] = null;\n  client[kHTTP2Session] = null;\n  if (client.destroyed) {\n    assert(this[kPending] === 0);\n\n    // Fail entire queue.\n    const requests = client[kQueue].splice(client[kRunningIdx]);\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i];\n      errorRequest(this, request, err);\n    }\n  } else if (client[kRunning] > 0) {\n    // Fail head of pipeline.\n    const request = client[kQueue][client[kRunningIdx]];\n    client[kQueue][client[kRunningIdx]++] = null;\n    errorRequest(client, request, err);\n  }\n  client[kPendingIdx] = client[kRunningIdx];\n  assert(client[kRunning] === 0);\n  client.emit('disconnect', client[kUrl], [client], err);\n  resume(client);\n}\nconst constants = require('./llhttp/constants');\nconst createRedirectInterceptor = require('./interceptor/redirectInterceptor');\nconst EMPTY_BUF = Buffer.alloc(0);\nasync function lazyllhttp() {\n  const llhttpWasmData = process.env.JEST_WORKER_ID ? require('./llhttp/llhttp-wasm.js') : undefined;\n  let mod;\n  try {\n    mod = await WebAssembly.compile(Buffer.from(require('./llhttp/llhttp_simd-wasm.js'), 'base64'));\n  } catch (e) {\n    /* istanbul ignore next */\n\n    // We could check if the error was caused by the simd option not\n    // being enabled, but the occurring of this other error\n    // * https://github.com/emscripten-core/emscripten/issues/11495\n    // got me to remove that check to avoid breaking Node 12.\n    mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require('./llhttp/llhttp-wasm.js'), 'base64'));\n  }\n  return await WebAssembly.instantiate(mod, {\n    env: {\n      /* eslint-disable camelcase */\n\n      wasm_on_url: (p, at, len) => {\n        /* istanbul ignore next */\n        return 0;\n      },\n      wasm_on_status: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n        return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n      },\n      wasm_on_message_begin: p => {\n        assert.strictEqual(currentParser.ptr, p);\n        return currentParser.onMessageBegin() || 0;\n      },\n      wasm_on_header_field: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n        return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n      },\n      wasm_on_header_value: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n        return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n      },\n      wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {\n        assert.strictEqual(currentParser.ptr, p);\n        return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;\n      },\n      wasm_on_body: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n        return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n      },\n      wasm_on_message_complete: p => {\n        assert.strictEqual(currentParser.ptr, p);\n        return currentParser.onMessageComplete() || 0;\n      }\n\n      /* eslint-enable camelcase */\n    }\n  });\n}\nlet llhttpInstance = null;\nlet llhttpPromise = lazyllhttp();\nllhttpPromise.catch();\nlet currentParser = null;\nlet currentBufferRef = null;\nlet currentBufferSize = 0;\nlet currentBufferPtr = null;\nconst TIMEOUT_HEADERS = 1;\nconst TIMEOUT_BODY = 2;\nconst TIMEOUT_IDLE = 3;\nclass Parser {\n  constructor(client, socket, {\n    exports\n  }) {\n    assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);\n    this.llhttp = exports;\n    this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);\n    this.client = client;\n    this.socket = socket;\n    this.timeout = null;\n    this.timeoutValue = null;\n    this.timeoutType = null;\n    this.statusCode = null;\n    this.statusText = '';\n    this.upgrade = false;\n    this.headers = [];\n    this.headersSize = 0;\n    this.headersMaxSize = client[kMaxHeadersSize];\n    this.shouldKeepAlive = false;\n    this.paused = false;\n    this.resume = this.resume.bind(this);\n    this.bytesRead = 0;\n    this.keepAlive = '';\n    this.contentLength = '';\n    this.connection = '';\n    this.maxResponseSize = client[kMaxResponseSize];\n  }\n  setTimeout(value, type) {\n    this.timeoutType = type;\n    if (value !== this.timeoutValue) {\n      timers.clearTimeout(this.timeout);\n      if (value) {\n        this.timeout = timers.setTimeout(onParserTimeout, value, this);\n        // istanbul ignore else: only for jest\n        if (this.timeout.unref) {\n          this.timeout.unref();\n        }\n      } else {\n        this.timeout = null;\n      }\n      this.timeoutValue = value;\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n  }\n  resume() {\n    if (this.socket.destroyed || !this.paused) {\n      return;\n    }\n    assert(this.ptr != null);\n    assert(currentParser == null);\n    this.llhttp.llhttp_resume(this.ptr);\n    assert(this.timeoutType === TIMEOUT_BODY);\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n    this.paused = false;\n    this.execute(this.socket.read() || EMPTY_BUF); // Flush parser.\n    this.readMore();\n  }\n  readMore() {\n    while (!this.paused && this.ptr) {\n      const chunk = this.socket.read();\n      if (chunk === null) {\n        break;\n      }\n      this.execute(chunk);\n    }\n  }\n  execute(data) {\n    assert(this.ptr != null);\n    assert(currentParser == null);\n    assert(!this.paused);\n    const {\n      socket,\n      llhttp\n    } = this;\n    if (data.length > currentBufferSize) {\n      if (currentBufferPtr) {\n        llhttp.free(currentBufferPtr);\n      }\n      currentBufferSize = Math.ceil(data.length / 4096) * 4096;\n      currentBufferPtr = llhttp.malloc(currentBufferSize);\n    }\n    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);\n\n    // Call `execute` on the wasm parser.\n    // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n    // and finally the length of bytes to parse.\n    // The return value is an error code or `constants.ERROR.OK`.\n    try {\n      let ret;\n      try {\n        currentBufferRef = data;\n        currentParser = this;\n        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);\n        /* eslint-disable-next-line no-useless-catch */\n      } catch (err) {\n        /* istanbul ignore next: difficult to make a test case for */\n        throw err;\n      } finally {\n        currentParser = null;\n        currentBufferRef = null;\n      }\n      const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;\n      if (ret === constants.ERROR.PAUSED_UPGRADE) {\n        this.onUpgrade(data.slice(offset));\n      } else if (ret === constants.ERROR.PAUSED) {\n        this.paused = true;\n        socket.unshift(data.slice(offset));\n      } else if (ret !== constants.ERROR.OK) {\n        const ptr = llhttp.llhttp_get_error_reason(this.ptr);\n        let message = '';\n        /* istanbul ignore else: difficult to make a test case for */\n        if (ptr) {\n          const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);\n          message = 'Response does not match the HTTP/1.1 protocol (' + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ')';\n        }\n        throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));\n      }\n    } catch (err) {\n      util.destroy(socket, err);\n    }\n  }\n  destroy() {\n    assert(this.ptr != null);\n    assert(currentParser == null);\n    this.llhttp.llhttp_free(this.ptr);\n    this.ptr = null;\n    timers.clearTimeout(this.timeout);\n    this.timeout = null;\n    this.timeoutValue = null;\n    this.timeoutType = null;\n    this.paused = false;\n  }\n  onStatus(buf) {\n    this.statusText = buf.toString();\n  }\n  onMessageBegin() {\n    const {\n      socket,\n      client\n    } = this;\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1;\n    }\n    const request = client[kQueue][client[kRunningIdx]];\n    if (!request) {\n      return -1;\n    }\n  }\n  onHeaderField(buf) {\n    const len = this.headers.length;\n    if ((len & 1) === 0) {\n      this.headers.push(buf);\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);\n    }\n    this.trackHeader(buf.length);\n  }\n  onHeaderValue(buf) {\n    let len = this.headers.length;\n    if ((len & 1) === 1) {\n      this.headers.push(buf);\n      len += 1;\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);\n    }\n    const key = this.headers[len - 2];\n    if (key.length === 10 && key.toString().toLowerCase() === 'keep-alive') {\n      this.keepAlive += buf.toString();\n    } else if (key.length === 10 && key.toString().toLowerCase() === 'connection') {\n      this.connection += buf.toString();\n    } else if (key.length === 14 && key.toString().toLowerCase() === 'content-length') {\n      this.contentLength += buf.toString();\n    }\n    this.trackHeader(buf.length);\n  }\n  trackHeader(len) {\n    this.headersSize += len;\n    if (this.headersSize >= this.headersMaxSize) {\n      util.destroy(this.socket, new HeadersOverflowError());\n    }\n  }\n  onUpgrade(head) {\n    const {\n      upgrade,\n      client,\n      socket,\n      headers,\n      statusCode\n    } = this;\n    assert(upgrade);\n    const request = client[kQueue][client[kRunningIdx]];\n    assert(request);\n    assert(!socket.destroyed);\n    assert(socket === client[kSocket]);\n    assert(!this.paused);\n    assert(request.upgrade || request.method === 'CONNECT');\n    this.statusCode = null;\n    this.statusText = '';\n    this.shouldKeepAlive = null;\n    assert(this.headers.length % 2 === 0);\n    this.headers = [];\n    this.headersSize = 0;\n    socket.unshift(head);\n    socket[kParser].destroy();\n    socket[kParser] = null;\n    socket[kClient] = null;\n    socket[kError] = null;\n    socket.removeListener('error', onSocketError).removeListener('readable', onSocketReadable).removeListener('end', onSocketEnd).removeListener('close', onSocketClose);\n    client[kSocket] = null;\n    client[kQueue][client[kRunningIdx]++] = null;\n    client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'));\n    try {\n      request.onUpgrade(statusCode, headers, socket);\n    } catch (err) {\n      util.destroy(socket, err);\n    }\n    resume(client);\n  }\n  onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {\n    const {\n      client,\n      socket,\n      headers,\n      statusText\n    } = this;\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1;\n    }\n    const request = client[kQueue][client[kRunningIdx]];\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (!request) {\n      return -1;\n    }\n    assert(!this.upgrade);\n    assert(this.statusCode < 200);\n    if (statusCode === 100) {\n      util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)));\n      return -1;\n    }\n\n    /* this can only happen if server is misbehaving */\n    if (upgrade && !request.upgrade) {\n      util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)));\n      return -1;\n    }\n    assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);\n    this.statusCode = statusCode;\n    this.shouldKeepAlive = shouldKeepAlive ||\n    // Override llhttp value which does not allow keepAlive for HEAD.\n    request.method === 'HEAD' && !socket[kReset] && this.connection.toLowerCase() === 'keep-alive';\n    if (this.statusCode >= 200) {\n      const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];\n      this.setTimeout(bodyTimeout, TIMEOUT_BODY);\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n    if (request.method === 'CONNECT') {\n      assert(client[kRunning] === 1);\n      this.upgrade = true;\n      return 2;\n    }\n    if (upgrade) {\n      assert(client[kRunning] === 1);\n      this.upgrade = true;\n      return 2;\n    }\n    assert(this.headers.length % 2 === 0);\n    this.headers = [];\n    this.headersSize = 0;\n    if (this.shouldKeepAlive && client[kPipelining]) {\n      const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;\n      if (keepAliveTimeout != null) {\n        const timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);\n        if (timeout <= 0) {\n          socket[kReset] = true;\n        } else {\n          client[kKeepAliveTimeoutValue] = timeout;\n        }\n      } else {\n        client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];\n      }\n    } else {\n      // Stop more requests from being dispatched.\n      socket[kReset] = true;\n    }\n    const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;\n    if (request.aborted) {\n      return -1;\n    }\n    if (request.method === 'HEAD') {\n      return 1;\n    }\n    if (statusCode < 200) {\n      return 1;\n    }\n    if (socket[kBlocking]) {\n      socket[kBlocking] = false;\n      resume(client);\n    }\n    return pause ? constants.ERROR.PAUSED : 0;\n  }\n  onBody(buf) {\n    const {\n      client,\n      socket,\n      statusCode,\n      maxResponseSize\n    } = this;\n    if (socket.destroyed) {\n      return -1;\n    }\n    const request = client[kQueue][client[kRunningIdx]];\n    assert(request);\n    assert.strictEqual(this.timeoutType, TIMEOUT_BODY);\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n    assert(statusCode >= 200);\n    if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {\n      util.destroy(socket, new ResponseExceededMaxSizeError());\n      return -1;\n    }\n    this.bytesRead += buf.length;\n    if (request.onData(buf) === false) {\n      return constants.ERROR.PAUSED;\n    }\n  }\n  onMessageComplete() {\n    const {\n      client,\n      socket,\n      statusCode,\n      upgrade,\n      headers,\n      contentLength,\n      bytesRead,\n      shouldKeepAlive\n    } = this;\n    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n      return -1;\n    }\n    if (upgrade) {\n      return;\n    }\n    const request = client[kQueue][client[kRunningIdx]];\n    assert(request);\n    assert(statusCode >= 100);\n    this.statusCode = null;\n    this.statusText = '';\n    this.bytesRead = 0;\n    this.contentLength = '';\n    this.keepAlive = '';\n    this.connection = '';\n    assert(this.headers.length % 2 === 0);\n    this.headers = [];\n    this.headersSize = 0;\n    if (statusCode < 200) {\n      return;\n    }\n\n    /* istanbul ignore next: should be handled by llhttp? */\n    if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n      util.destroy(socket, new ResponseContentLengthMismatchError());\n      return -1;\n    }\n    request.onComplete(headers);\n    client[kQueue][client[kRunningIdx]++] = null;\n    if (socket[kWriting]) {\n      assert.strictEqual(client[kRunning], 0);\n      // Response completed before request.\n      util.destroy(socket, new InformationalError('reset'));\n      return constants.ERROR.PAUSED;\n    } else if (!shouldKeepAlive) {\n      util.destroy(socket, new InformationalError('reset'));\n      return constants.ERROR.PAUSED;\n    } else if (socket[kReset] && client[kRunning] === 0) {\n      // Destroy socket once all requests have completed.\n      // The request at the tail of the pipeline is the one\n      // that requested reset and no further requests should\n      // have been queued since then.\n      util.destroy(socket, new InformationalError('reset'));\n      return constants.ERROR.PAUSED;\n    } else if (client[kPipelining] === 1) {\n      // We must wait a full event loop cycle to reuse this socket to make sure\n      // that non-spec compliant servers are not closing the connection even if they\n      // said they won't.\n      setImmediate(resume, client);\n    } else {\n      resume(client);\n    }\n  }\n}\nfunction onParserTimeout(parser) {\n  const {\n    socket,\n    timeoutType,\n    client\n  } = parser;\n\n  /* istanbul ignore else */\n  if (timeoutType === TIMEOUT_HEADERS) {\n    if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {\n      assert(!parser.paused, 'cannot be paused while waiting for headers');\n      util.destroy(socket, new HeadersTimeoutError());\n    }\n  } else if (timeoutType === TIMEOUT_BODY) {\n    if (!parser.paused) {\n      util.destroy(socket, new BodyTimeoutError());\n    }\n  } else if (timeoutType === TIMEOUT_IDLE) {\n    assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);\n    util.destroy(socket, new InformationalError('socket idle timeout'));\n  }\n}\nfunction onSocketReadable() {\n  const {\n    [kParser]: parser\n  } = this;\n  if (parser) {\n    parser.readMore();\n  }\n}\nfunction onSocketError(err) {\n  const {\n    [kClient]: client,\n    [kParser]: parser\n  } = this;\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID');\n  if (client[kHTTPConnVersion] !== 'h2') {\n    // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n    // to the user.\n    if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {\n      // We treat all incoming data so for as a valid response.\n      parser.onMessageComplete();\n      return;\n    }\n  }\n  this[kError] = err;\n  onError(this[kClient], err);\n}\nfunction onError(client, err) {\n  if (client[kRunning] === 0 && err.code !== 'UND_ERR_INFO' && err.code !== 'UND_ERR_SOCKET') {\n    // Error is not caused by running request and not a recoverable\n    // socket error.\n\n    assert(client[kPendingIdx] === client[kRunningIdx]);\n    const requests = client[kQueue].splice(client[kRunningIdx]);\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i];\n      errorRequest(client, request, err);\n    }\n    assert(client[kSize] === 0);\n  }\n}\nfunction onSocketEnd() {\n  const {\n    [kParser]: parser,\n    [kClient]: client\n  } = this;\n  if (client[kHTTPConnVersion] !== 'h2') {\n    if (parser.statusCode && !parser.shouldKeepAlive) {\n      // We treat all incoming data so far as a valid response.\n      parser.onMessageComplete();\n      return;\n    }\n  }\n  util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)));\n}\nfunction onSocketClose() {\n  const {\n    [kClient]: client,\n    [kParser]: parser\n  } = this;\n  if (client[kHTTPConnVersion] === 'h1' && parser) {\n    if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {\n      // We treat all incoming data so far as a valid response.\n      parser.onMessageComplete();\n    }\n    this[kParser].destroy();\n    this[kParser] = null;\n  }\n  const err = this[kError] || new SocketError('closed', util.getSocketInfo(this));\n  client[kSocket] = null;\n  if (client.destroyed) {\n    assert(client[kPending] === 0);\n\n    // Fail entire queue.\n    const requests = client[kQueue].splice(client[kRunningIdx]);\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i];\n      errorRequest(client, request, err);\n    }\n  } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {\n    // Fail head of pipeline.\n    const request = client[kQueue][client[kRunningIdx]];\n    client[kQueue][client[kRunningIdx]++] = null;\n    errorRequest(client, request, err);\n  }\n  client[kPendingIdx] = client[kRunningIdx];\n  assert(client[kRunning] === 0);\n  client.emit('disconnect', client[kUrl], [client], err);\n  resume(client);\n}\nasync function connect(client) {\n  assert(!client[kConnecting]);\n  assert(!client[kSocket]);\n  let {\n    host,\n    hostname,\n    protocol,\n    port\n  } = client[kUrl];\n\n  // Resolve ipv6\n  if (hostname[0] === '[') {\n    const idx = hostname.indexOf(']');\n    assert(idx !== -1);\n    const ip = hostname.substring(1, idx);\n    assert(net.isIP(ip));\n    hostname = ip;\n  }\n  client[kConnecting] = true;\n  if (channels.beforeConnect.hasSubscribers) {\n    channels.beforeConnect.publish({\n      connectParams: {\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      },\n      connector: client[kConnector]\n    });\n  }\n  try {\n    const socket = await new Promise((resolve, reject) => {\n      client[kConnector]({\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      }, (err, socket) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(socket);\n        }\n      });\n    });\n    if (client.destroyed) {\n      util.destroy(socket.on('error', () => {}), new ClientDestroyedError());\n      return;\n    }\n    client[kConnecting] = false;\n    assert(socket);\n    const isH2 = socket.alpnProtocol === 'h2';\n    if (isH2) {\n      if (!h2ExperimentalWarned) {\n        h2ExperimentalWarned = true;\n        process.emitWarning('H2 support is experimental, expect them to change at any time.', {\n          code: 'UNDICI-H2'\n        });\n      }\n      const session = http2.connect(client[kUrl], {\n        createConnection: () => socket,\n        peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams\n      });\n      client[kHTTPConnVersion] = 'h2';\n      session[kClient] = client;\n      session[kSocket] = socket;\n      session.on('error', onHttp2SessionError);\n      session.on('frameError', onHttp2FrameError);\n      session.on('end', onHttp2SessionEnd);\n      session.on('goaway', onHTTP2GoAway);\n      session.on('close', onSocketClose);\n      session.unref();\n      client[kHTTP2Session] = session;\n      socket[kHTTP2Session] = session;\n    } else {\n      if (!llhttpInstance) {\n        llhttpInstance = await llhttpPromise;\n        llhttpPromise = null;\n      }\n      socket[kNoRef] = false;\n      socket[kWriting] = false;\n      socket[kReset] = false;\n      socket[kBlocking] = false;\n      socket[kParser] = new Parser(client, socket, llhttpInstance);\n    }\n    socket[kCounter] = 0;\n    socket[kMaxRequests] = client[kMaxRequests];\n    socket[kClient] = client;\n    socket[kError] = null;\n    socket.on('error', onSocketError).on('readable', onSocketReadable).on('end', onSocketEnd).on('close', onSocketClose);\n    client[kSocket] = socket;\n    if (channels.connected.hasSubscribers) {\n      channels.connected.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        socket\n      });\n    }\n    client.emit('connect', client[kUrl], [client]);\n  } catch (err) {\n    if (client.destroyed) {\n      return;\n    }\n    client[kConnecting] = false;\n    if (channels.connectError.hasSubscribers) {\n      channels.connectError.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        error: err\n      });\n    }\n    if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n      assert(client[kRunning] === 0);\n      while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {\n        const request = client[kQueue][client[kPendingIdx]++];\n        errorRequest(client, request, err);\n      }\n    } else {\n      onError(client, err);\n    }\n    client.emit('connectionError', client[kUrl], [client], err);\n  }\n  resume(client);\n}\nfunction emitDrain(client) {\n  client[kNeedDrain] = 0;\n  client.emit('drain', client[kUrl], [client]);\n}\nfunction resume(client, sync) {\n  if (client[kResuming] === 2) {\n    return;\n  }\n  client[kResuming] = 2;\n  _resume(client, sync);\n  client[kResuming] = 0;\n  if (client[kRunningIdx] > 256) {\n    client[kQueue].splice(0, client[kRunningIdx]);\n    client[kPendingIdx] -= client[kRunningIdx];\n    client[kRunningIdx] = 0;\n  }\n}\nfunction _resume(client, sync) {\n  while (true) {\n    if (client.destroyed) {\n      assert(client[kPending] === 0);\n      return;\n    }\n    if (client[kClosedResolve] && !client[kSize]) {\n      client[kClosedResolve]();\n      client[kClosedResolve] = null;\n      return;\n    }\n    const socket = client[kSocket];\n    if (socket && !socket.destroyed && socket.alpnProtocol !== 'h2') {\n      if (client[kSize] === 0) {\n        if (!socket[kNoRef] && socket.unref) {\n          socket.unref();\n          socket[kNoRef] = true;\n        }\n      } else if (socket[kNoRef] && socket.ref) {\n        socket.ref();\n        socket[kNoRef] = false;\n      }\n      if (client[kSize] === 0) {\n        if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {\n          socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);\n        }\n      } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n        if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n          const request = client[kQueue][client[kRunningIdx]];\n          const headersTimeout = request.headersTimeout != null ? request.headersTimeout : client[kHeadersTimeout];\n          socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);\n        }\n      }\n    }\n    if (client[kBusy]) {\n      client[kNeedDrain] = 2;\n    } else if (client[kNeedDrain] === 2) {\n      if (sync) {\n        client[kNeedDrain] = 1;\n        process.nextTick(emitDrain, client);\n      } else {\n        emitDrain(client);\n      }\n      continue;\n    }\n    if (client[kPending] === 0) {\n      return;\n    }\n    if (client[kRunning] >= (client[kPipelining] || 1)) {\n      return;\n    }\n    const request = client[kQueue][client[kPendingIdx]];\n    if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {\n      if (client[kRunning] > 0) {\n        return;\n      }\n      client[kServerName] = request.servername;\n      if (socket && socket.servername !== request.servername) {\n        util.destroy(socket, new InformationalError('servername changed'));\n        return;\n      }\n    }\n    if (client[kConnecting]) {\n      return;\n    }\n    if (!socket && !client[kHTTP2Session]) {\n      connect(client);\n      return;\n    }\n    if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n      return;\n    }\n    if (client[kRunning] > 0 && !request.idempotent) {\n      // Non-idempotent request cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return;\n    }\n    if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {\n      // Don't dispatch an upgrade until all preceding requests have completed.\n      // A misbehaving server might upgrade the connection before all pipelined\n      // request has completed.\n      return;\n    }\n    if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body))) {\n      // Request with stream or iterator body can error while other requests\n      // are inflight and indirectly error those as well.\n      // Ensure this doesn't happen by waiting for inflight\n      // to complete before dispatching.\n\n      // Request with stream or iterator body cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return;\n    }\n    if (!request.aborted && write(client, request)) {\n      client[kPendingIdx]++;\n    } else {\n      client[kQueue].splice(client[kPendingIdx], 1);\n    }\n  }\n}\n\n// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2\nfunction shouldSendContentLength(method) {\n  return method !== 'GET' && method !== 'HEAD' && method !== 'OPTIONS' && method !== 'TRACE' && method !== 'CONNECT';\n}\nfunction write(client, request) {\n  if (client[kHTTPConnVersion] === 'h2') {\n    writeH2(client, client[kHTTP2Session], request);\n    return;\n  }\n  const {\n    body,\n    method,\n    path,\n    host,\n    upgrade,\n    headers,\n    blocking,\n    reset\n  } = request;\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = method === 'PUT' || method === 'POST' || method === 'PATCH';\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0);\n  }\n  const bodyLength = util.bodyLength(body);\n  let contentLength = bodyLength;\n  if (contentLength === null) {\n    contentLength = request.contentLength;\n  }\n  if (contentLength === 0 && !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null;\n  }\n\n  // https://github.com/nodejs/undici/issues/2046\n  // A user agent may send a Content-Length header with 0 value, this should be allowed.\n  if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      errorRequest(client, request, new RequestContentLengthMismatchError());\n      return false;\n    }\n    process.emitWarning(new RequestContentLengthMismatchError());\n  }\n  const socket = client[kSocket];\n  try {\n    request.onConnect(err => {\n      if (request.aborted || request.completed) {\n        return;\n      }\n      errorRequest(client, request, err || new RequestAbortedError());\n      util.destroy(socket, new InformationalError('aborted'));\n    });\n  } catch (err) {\n    errorRequest(client, request, err);\n  }\n  if (request.aborted) {\n    return false;\n  }\n  if (method === 'HEAD') {\n    // https://github.com/mcollina/undici/issues/258\n    // Close after a HEAD request to interop with misbehaving servers\n    // that may send a body in the response.\n\n    socket[kReset] = true;\n  }\n  if (upgrade || method === 'CONNECT') {\n    // On CONNECT or upgrade, block pipeline from dispatching further\n    // requests on this connection.\n\n    socket[kReset] = true;\n  }\n  if (reset != null) {\n    socket[kReset] = reset;\n  }\n  if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n    socket[kReset] = true;\n  }\n  if (blocking) {\n    socket[kBlocking] = true;\n  }\n  let header = `${method} ${path} HTTP/1.1\\r\\n`;\n  if (typeof host === 'string') {\n    header += `host: ${host}\\r\\n`;\n  } else {\n    header += client[kHostHeader];\n  }\n  if (upgrade) {\n    header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`;\n  } else if (client[kPipelining] && !socket[kReset]) {\n    header += 'connection: keep-alive\\r\\n';\n  } else {\n    header += 'connection: close\\r\\n';\n  }\n  if (headers) {\n    header += headers;\n  }\n  if (channels.sendHeaders.hasSubscribers) {\n    channels.sendHeaders.publish({\n      request,\n      headers: header,\n      socket\n    });\n  }\n\n  /* istanbul ignore else: assertion */\n  if (!body || bodyLength === 0) {\n    if (contentLength === 0) {\n      socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1');\n    } else {\n      assert(contentLength === null, 'no body must not have content length');\n      socket.write(`${header}\\r\\n`, 'latin1');\n    }\n    request.onRequestSent();\n  } else if (util.isBuffer(body)) {\n    assert(contentLength === body.byteLength, 'buffer body must have content length');\n    socket.cork();\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1');\n    socket.write(body);\n    socket.uncork();\n    request.onBodySent(body);\n    request.onRequestSent();\n    if (!expectsPayload) {\n      socket[kReset] = true;\n    }\n  } else if (util.isBlobLike(body)) {\n    if (typeof body.stream === 'function') {\n      writeIterable({\n        body: body.stream(),\n        client,\n        request,\n        socket,\n        contentLength,\n        header,\n        expectsPayload\n      });\n    } else {\n      writeBlob({\n        body,\n        client,\n        request,\n        socket,\n        contentLength,\n        header,\n        expectsPayload\n      });\n    }\n  } else if (util.isStream(body)) {\n    writeStream({\n      body,\n      client,\n      request,\n      socket,\n      contentLength,\n      header,\n      expectsPayload\n    });\n  } else if (util.isIterable(body)) {\n    writeIterable({\n      body,\n      client,\n      request,\n      socket,\n      contentLength,\n      header,\n      expectsPayload\n    });\n  } else {\n    assert(false);\n  }\n  return true;\n}\nfunction writeH2(client, session, request) {\n  const {\n    body,\n    method,\n    path,\n    host,\n    upgrade,\n    expectContinue,\n    signal,\n    headers: reqHeaders\n  } = request;\n  let headers;\n  if (typeof reqHeaders === 'string') headers = Request[kHTTP2CopyHeaders](reqHeaders.trim());else headers = reqHeaders;\n  if (upgrade) {\n    errorRequest(client, request, new Error('Upgrade not supported for H2'));\n    return false;\n  }\n  try {\n    // TODO(HTTP/2): Should we call onConnect immediately or on stream ready event?\n    request.onConnect(err => {\n      if (request.aborted || request.completed) {\n        return;\n      }\n      errorRequest(client, request, err || new RequestAbortedError());\n    });\n  } catch (err) {\n    errorRequest(client, request, err);\n  }\n  if (request.aborted) {\n    return false;\n  }\n\n  /** @type {import('node:http2').ClientHttp2Stream} */\n  let stream;\n  const h2State = client[kHTTP2SessionState];\n  headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost];\n  headers[HTTP2_HEADER_METHOD] = method;\n  if (method === 'CONNECT') {\n    session.ref();\n    // we are already connected, streams are pending, first request\n    // will create a new stream. We trigger a request to create the stream and wait until\n    // `ready` event is triggered\n    // We disabled endStream to allow the user to write to the stream\n    stream = session.request(headers, {\n      endStream: false,\n      signal\n    });\n    if (stream.id && !stream.pending) {\n      request.onUpgrade(null, null, stream);\n      ++h2State.openStreams;\n    } else {\n      stream.once('ready', () => {\n        request.onUpgrade(null, null, stream);\n        ++h2State.openStreams;\n      });\n    }\n    stream.once('close', () => {\n      h2State.openStreams -= 1;\n      // TODO(HTTP/2): unref only if current streams count is 0\n      if (h2State.openStreams === 0) session.unref();\n    });\n    return true;\n  }\n\n  // https://tools.ietf.org/html/rfc7540#section-8.3\n  // :path and :scheme headers must be omited when sending CONNECT\n\n  headers[HTTP2_HEADER_PATH] = path;\n  headers[HTTP2_HEADER_SCHEME] = 'https';\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = method === 'PUT' || method === 'POST' || method === 'PATCH';\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0);\n  }\n  let contentLength = util.bodyLength(body);\n  if (contentLength == null) {\n    contentLength = request.contentLength;\n  }\n  if (contentLength === 0 || !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null;\n  }\n\n  // https://github.com/nodejs/undici/issues/2046\n  // A user agent may send a Content-Length header with 0 value, this should be allowed.\n  if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      errorRequest(client, request, new RequestContentLengthMismatchError());\n      return false;\n    }\n    process.emitWarning(new RequestContentLengthMismatchError());\n  }\n  if (contentLength != null) {\n    assert(body, 'no body must not have content length');\n    headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;\n  }\n  session.ref();\n  const shouldEndStream = method === 'GET' || method === 'HEAD';\n  if (expectContinue) {\n    headers[HTTP2_HEADER_EXPECT] = '100-continue';\n    stream = session.request(headers, {\n      endStream: shouldEndStream,\n      signal\n    });\n    stream.once('continue', writeBodyH2);\n  } else {\n    stream = session.request(headers, {\n      endStream: shouldEndStream,\n      signal\n    });\n    writeBodyH2();\n  }\n\n  // Increment counter as we have new several streams open\n  ++h2State.openStreams;\n  stream.once('response', headers => {\n    const {\n      [HTTP2_HEADER_STATUS]: statusCode,\n      ...realHeaders\n    } = headers;\n    if (request.onHeaders(Number(statusCode), realHeaders, stream.resume.bind(stream), '') === false) {\n      stream.pause();\n    }\n  });\n  stream.once('end', () => {\n    request.onComplete([]);\n  });\n  stream.on('data', chunk => {\n    if (request.onData(chunk) === false) {\n      stream.pause();\n    }\n  });\n  stream.once('close', () => {\n    h2State.openStreams -= 1;\n    // TODO(HTTP/2): unref only if current streams count is 0\n    if (h2State.openStreams === 0) {\n      session.unref();\n    }\n  });\n  stream.once('error', function (err) {\n    if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {\n      h2State.streams -= 1;\n      util.destroy(stream, err);\n    }\n  });\n  stream.once('frameError', (type, code) => {\n    const err = new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`);\n    errorRequest(client, request, err);\n    if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {\n      h2State.streams -= 1;\n      util.destroy(stream, err);\n    }\n  });\n\n  // stream.on('aborted', () => {\n  //   // TODO(HTTP/2): Support aborted\n  // })\n\n  // stream.on('timeout', () => {\n  //   // TODO(HTTP/2): Support timeout\n  // })\n\n  // stream.on('push', headers => {\n  //   // TODO(HTTP/2): Suppor push\n  // })\n\n  // stream.on('trailers', headers => {\n  //   // TODO(HTTP/2): Support trailers\n  // })\n\n  return true;\n  function writeBodyH2() {\n    /* istanbul ignore else: assertion */\n    if (!body) {\n      request.onRequestSent();\n    } else if (util.isBuffer(body)) {\n      assert(contentLength === body.byteLength, 'buffer body must have content length');\n      stream.cork();\n      stream.write(body);\n      stream.uncork();\n      stream.end();\n      request.onBodySent(body);\n      request.onRequestSent();\n    } else if (util.isBlobLike(body)) {\n      if (typeof body.stream === 'function') {\n        writeIterable({\n          client,\n          request,\n          contentLength,\n          h2stream: stream,\n          expectsPayload,\n          body: body.stream(),\n          socket: client[kSocket],\n          header: ''\n        });\n      } else {\n        writeBlob({\n          body,\n          client,\n          request,\n          contentLength,\n          expectsPayload,\n          h2stream: stream,\n          header: '',\n          socket: client[kSocket]\n        });\n      }\n    } else if (util.isStream(body)) {\n      writeStream({\n        body,\n        client,\n        request,\n        contentLength,\n        expectsPayload,\n        socket: client[kSocket],\n        h2stream: stream,\n        header: ''\n      });\n    } else if (util.isIterable(body)) {\n      writeIterable({\n        body,\n        client,\n        request,\n        contentLength,\n        expectsPayload,\n        header: '',\n        h2stream: stream,\n        socket: client[kSocket]\n      });\n    } else {\n      assert(false);\n    }\n  }\n}\nfunction writeStream({\n  h2stream,\n  body,\n  client,\n  request,\n  socket,\n  contentLength,\n  header,\n  expectsPayload\n}) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined');\n  if (client[kHTTPConnVersion] === 'h2') {\n    // For HTTP/2, is enough to pipe the stream\n    const pipe = pipeline(body, h2stream, err => {\n      if (err) {\n        util.destroy(body, err);\n        util.destroy(h2stream, err);\n      } else {\n        request.onRequestSent();\n      }\n    });\n    pipe.on('data', onPipeData);\n    pipe.once('end', () => {\n      pipe.removeListener('data', onPipeData);\n      util.destroy(pipe);\n    });\n    function onPipeData(chunk) {\n      request.onBodySent(chunk);\n    }\n    return;\n  }\n  let finished = false;\n  const writer = new AsyncWriter({\n    socket,\n    request,\n    contentLength,\n    client,\n    expectsPayload,\n    header\n  });\n  const onData = function (chunk) {\n    if (finished) {\n      return;\n    }\n    try {\n      if (!writer.write(chunk) && this.pause) {\n        this.pause();\n      }\n    } catch (err) {\n      util.destroy(this, err);\n    }\n  };\n  const onDrain = function () {\n    if (finished) {\n      return;\n    }\n    if (body.resume) {\n      body.resume();\n    }\n  };\n  const onAbort = function () {\n    if (finished) {\n      return;\n    }\n    const err = new RequestAbortedError();\n    queueMicrotask(() => onFinished(err));\n  };\n  const onFinished = function (err) {\n    if (finished) {\n      return;\n    }\n    finished = true;\n    assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);\n    socket.off('drain', onDrain).off('error', onFinished);\n    body.removeListener('data', onData).removeListener('end', onFinished).removeListener('error', onFinished).removeListener('close', onAbort);\n    if (!err) {\n      try {\n        writer.end();\n      } catch (er) {\n        err = er;\n      }\n    }\n    writer.destroy(err);\n    if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {\n      util.destroy(body, err);\n    } else {\n      util.destroy(body);\n    }\n  };\n  body.on('data', onData).on('end', onFinished).on('error', onFinished).on('close', onAbort);\n  if (body.resume) {\n    body.resume();\n  }\n  socket.on('drain', onDrain).on('error', onFinished);\n}\nasync function writeBlob({\n  h2stream,\n  body,\n  client,\n  request,\n  socket,\n  contentLength,\n  header,\n  expectsPayload\n}) {\n  assert(contentLength === body.size, 'blob body must have content length');\n  const isH2 = client[kHTTPConnVersion] === 'h2';\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError();\n    }\n    const buffer = Buffer.from(await body.arrayBuffer());\n    if (isH2) {\n      h2stream.cork();\n      h2stream.write(buffer);\n      h2stream.uncork();\n    } else {\n      socket.cork();\n      socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1');\n      socket.write(buffer);\n      socket.uncork();\n    }\n    request.onBodySent(buffer);\n    request.onRequestSent();\n    if (!expectsPayload) {\n      socket[kReset] = true;\n    }\n    resume(client);\n  } catch (err) {\n    util.destroy(isH2 ? h2stream : socket, err);\n  }\n}\nasync function writeIterable({\n  h2stream,\n  body,\n  client,\n  request,\n  socket,\n  contentLength,\n  header,\n  expectsPayload\n}) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined');\n  let callback = null;\n  function onDrain() {\n    if (callback) {\n      const cb = callback;\n      callback = null;\n      cb();\n    }\n  }\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null);\n    if (socket[kError]) {\n      reject(socket[kError]);\n    } else {\n      callback = resolve;\n    }\n  });\n  if (client[kHTTPConnVersion] === 'h2') {\n    h2stream.on('close', onDrain).on('drain', onDrain);\n    try {\n      // It's up to the user to somehow abort the async iterable.\n      for await (const chunk of body) {\n        if (socket[kError]) {\n          throw socket[kError];\n        }\n        const res = h2stream.write(chunk);\n        request.onBodySent(chunk);\n        if (!res) {\n          await waitForDrain();\n        }\n      }\n    } catch (err) {\n      h2stream.destroy(err);\n    } finally {\n      request.onRequestSent();\n      h2stream.end();\n      h2stream.off('close', onDrain).off('drain', onDrain);\n    }\n    return;\n  }\n  socket.on('close', onDrain).on('drain', onDrain);\n  const writer = new AsyncWriter({\n    socket,\n    request,\n    contentLength,\n    client,\n    expectsPayload,\n    header\n  });\n  try {\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError];\n      }\n      if (!writer.write(chunk)) {\n        await waitForDrain();\n      }\n    }\n    writer.end();\n  } catch (err) {\n    writer.destroy(err);\n  } finally {\n    socket.off('close', onDrain).off('drain', onDrain);\n  }\n}\nclass AsyncWriter {\n  constructor({\n    socket,\n    request,\n    contentLength,\n    client,\n    expectsPayload,\n    header\n  }) {\n    this.socket = socket;\n    this.request = request;\n    this.contentLength = contentLength;\n    this.client = client;\n    this.bytesWritten = 0;\n    this.expectsPayload = expectsPayload;\n    this.header = header;\n    socket[kWriting] = true;\n  }\n  write(chunk) {\n    const {\n      socket,\n      request,\n      contentLength,\n      client,\n      bytesWritten,\n      expectsPayload,\n      header\n    } = this;\n    if (socket[kError]) {\n      throw socket[kError];\n    }\n    if (socket.destroyed) {\n      return false;\n    }\n    const len = Buffer.byteLength(chunk);\n    if (!len) {\n      return true;\n    }\n\n    // We should defer writing chunks.\n    if (contentLength !== null && bytesWritten + len > contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError();\n      }\n      process.emitWarning(new RequestContentLengthMismatchError());\n    }\n    socket.cork();\n    if (bytesWritten === 0) {\n      if (!expectsPayload) {\n        socket[kReset] = true;\n      }\n      if (contentLength === null) {\n        socket.write(`${header}transfer-encoding: chunked\\r\\n`, 'latin1');\n      } else {\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1');\n      }\n    }\n    if (contentLength === null) {\n      socket.write(`\\r\\n${len.toString(16)}\\r\\n`, 'latin1');\n    }\n    this.bytesWritten += len;\n    const ret = socket.write(chunk);\n    socket.uncork();\n    request.onBodySent(chunk);\n    if (!ret) {\n      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n        // istanbul ignore else: only for jest\n        if (socket[kParser].timeout.refresh) {\n          socket[kParser].timeout.refresh();\n        }\n      }\n    }\n    return ret;\n  }\n  end() {\n    const {\n      socket,\n      contentLength,\n      client,\n      bytesWritten,\n      expectsPayload,\n      header,\n      request\n    } = this;\n    request.onRequestSent();\n    socket[kWriting] = false;\n    if (socket[kError]) {\n      throw socket[kError];\n    }\n    if (socket.destroyed) {\n      return;\n    }\n    if (bytesWritten === 0) {\n      if (expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD send a Content-Length in a request message when\n        // no Transfer-Encoding is sent and the request method defines a meaning\n        // for an enclosed payload body.\n\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1');\n      } else {\n        socket.write(`${header}\\r\\n`, 'latin1');\n      }\n    } else if (contentLength === null) {\n      socket.write('\\r\\n0\\r\\n\\r\\n', 'latin1');\n    }\n    if (contentLength !== null && bytesWritten !== contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError();\n      } else {\n        process.emitWarning(new RequestContentLengthMismatchError());\n      }\n    }\n    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n      // istanbul ignore else: only for jest\n      if (socket[kParser].timeout.refresh) {\n        socket[kParser].timeout.refresh();\n      }\n    }\n    resume(client);\n  }\n  destroy(err) {\n    const {\n      socket,\n      client\n    } = this;\n    socket[kWriting] = false;\n    if (err) {\n      assert(client[kRunning] <= 1, 'pipeline should only contain this request');\n      util.destroy(socket, err);\n    }\n  }\n}\nfunction errorRequest(client, request, err) {\n  try {\n    request.onError(err);\n    assert(request.aborted);\n  } catch (err) {\n    client.emit('error', err);\n  }\n}\nmodule.exports = Client;","map":{"version":3,"names":["assert","require","net","http","pipeline","util","timers","Request","DispatcherBase","RequestContentLengthMismatchError","ResponseContentLengthMismatchError","InvalidArgumentError","RequestAbortedError","HeadersTimeoutError","HeadersOverflowError","SocketError","InformationalError","BodyTimeoutError","HTTPParserError","ResponseExceededMaxSizeError","ClientDestroyedError","buildConnector","kUrl","kReset","kServerName","kClient","kBusy","kParser","kConnect","kBlocking","kResuming","kRunning","kPending","kSize","kWriting","kQueue","kConnected","kConnecting","kNeedDrain","kNoRef","kKeepAliveDefaultTimeout","kHostHeader","kPendingIdx","kRunningIdx","kError","kPipelining","kSocket","kKeepAliveTimeoutValue","kMaxHeadersSize","kKeepAliveMaxTimeout","kKeepAliveTimeoutThreshold","kHeadersTimeout","kBodyTimeout","kStrictContentLength","kConnector","kMaxRedirections","kMaxRequests","kCounter","kClose","kDestroy","kDispatch","kInterceptors","kLocalAddress","kMaxResponseSize","kHTTPConnVersion","kHost","kHTTP2Session","kHTTP2SessionState","kHTTP2BuildRequest","kHTTP2CopyHeaders","kHTTP1BuildRequest","http2","constants","HTTP2_HEADER_AUTHORITY","HTTP2_HEADER_METHOD","HTTP2_HEADER_PATH","HTTP2_HEADER_SCHEME","HTTP2_HEADER_CONTENT_LENGTH","HTTP2_HEADER_EXPECT","HTTP2_HEADER_STATUS","h2ExperimentalWarned","FastBuffer","Buffer","Symbol","species","kClosedResolve","channels","diagnosticsChannel","sendHeaders","channel","beforeConnect","connectError","connected","hasSubscribers","Client","constructor","url","interceptors","maxHeaderSize","headersTimeout","socketTimeout","requestTimeout","connectTimeout","bodyTimeout","idleTimeout","keepAlive","keepAliveTimeout","maxKeepAliveTimeout","keepAliveMaxTimeout","keepAliveTimeoutThreshold","socketPath","pipelining","tls","strictContentLength","maxCachedSessions","maxRedirections","connect","maxRequestsPerClient","localAddress","maxResponseSize","autoSelectFamily","autoSelectFamilyAttemptTimeout","allowH2","maxConcurrentStreams","undefined","Number","isFinite","isInteger","isIP","timeout","nodeHasAutoSelectFamily","Array","isArray","createRedirectInterceptor","parseOrigin","hostname","port","openStreams","value","resume","length","destroyed","socket","cb","once","opts","handler","origin","request","push","bodyLength","body","isIterable","process","nextTick","Promise","resolve","err","requests","splice","i","errorRequest","callback","destroy","queueMicrotask","on","onHttp2SessionError","code","onError","onHttp2FrameError","type","id","onHttp2SessionEnd","onHTTP2GoAway","client","emit","EMPTY_BUF","alloc","lazyllhttp","llhttpWasmData","env","JEST_WORKER_ID","mod","WebAssembly","compile","from","e","instantiate","wasm_on_url","p","at","len","wasm_on_status","strictEqual","currentParser","ptr","start","currentBufferPtr","currentBufferRef","byteOffset","onStatus","buffer","wasm_on_message_begin","onMessageBegin","wasm_on_header_field","onHeaderField","wasm_on_header_value","onHeaderValue","wasm_on_headers_complete","statusCode","upgrade","shouldKeepAlive","onHeadersComplete","Boolean","wasm_on_body","onBody","wasm_on_message_complete","onMessageComplete","llhttpInstance","llhttpPromise","catch","currentBufferSize","TIMEOUT_HEADERS","TIMEOUT_BODY","TIMEOUT_IDLE","Parser","exports","llhttp","llhttp_alloc","TYPE","RESPONSE","timeoutValue","timeoutType","statusText","headers","headersSize","headersMaxSize","paused","bind","bytesRead","contentLength","connection","setTimeout","clearTimeout","onParserTimeout","unref","refresh","llhttp_resume","execute","read","readMore","chunk","data","free","Math","ceil","malloc","Uint8Array","memory","set","ret","llhttp_execute","offset","llhttp_get_error_pos","ERROR","PAUSED_UPGRADE","onUpgrade","slice","PAUSED","unshift","OK","llhttp_get_error_reason","message","indexOf","toString","llhttp_free","buf","concat","trackHeader","key","toLowerCase","head","method","removeListener","onSocketError","onSocketReadable","onSocketEnd","onSocketClose","getSocketInfo","parseKeepAliveTimeout","min","pause","onHeaders","aborted","onData","parseInt","onComplete","setImmediate","parser","writableNeedDrain","host","protocol","idx","ip","substring","publish","connectParams","servername","connector","reject","isH2","alpnProtocol","emitWarning","session","createConnection","peerMaxConcurrentStreams","error","emitDrain","sync","_resume","ref","idempotent","isStream","isAsyncIterable","write","shouldSendContentLength","writeH2","path","blocking","reset","expectsPayload","onConnect","completed","header","onRequestSent","isBuffer","byteLength","cork","uncork","onBodySent","isBlobLike","stream","writeIterable","writeBlob","writeStream","expectContinue","signal","reqHeaders","trim","Error","h2State","endStream","pending","shouldEndStream","writeBodyH2","realHeaders","closed","streams","end","h2stream","pipe","onPipeData","finished","writer","AsyncWriter","onDrain","onAbort","onFinished","off","er","size","arrayBuffer","waitForDrain","res","bytesWritten","module"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/undici/lib/client.js"],"sourcesContent":["// @ts-check\n\n'use strict'\n\n/* global WebAssembly */\n\nconst assert = require('assert')\nconst net = require('net')\nconst http = require('http')\nconst { pipeline } = require('stream')\nconst util = require('./core/util')\nconst timers = require('./timers')\nconst Request = require('./core/request')\nconst DispatcherBase = require('./dispatcher-base')\nconst {\n  RequestContentLengthMismatchError,\n  ResponseContentLengthMismatchError,\n  InvalidArgumentError,\n  RequestAbortedError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  SocketError,\n  InformationalError,\n  BodyTimeoutError,\n  HTTPParserError,\n  ResponseExceededMaxSizeError,\n  ClientDestroyedError\n} = require('./core/errors')\nconst buildConnector = require('./core/connect')\nconst {\n  kUrl,\n  kReset,\n  kServerName,\n  kClient,\n  kBusy,\n  kParser,\n  kConnect,\n  kBlocking,\n  kResuming,\n  kRunning,\n  kPending,\n  kSize,\n  kWriting,\n  kQueue,\n  kConnected,\n  kConnecting,\n  kNeedDrain,\n  kNoRef,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kPipelining,\n  kSocket,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kConnector,\n  kMaxRedirections,\n  kMaxRequests,\n  kCounter,\n  kClose,\n  kDestroy,\n  kDispatch,\n  kInterceptors,\n  kLocalAddress,\n  kMaxResponseSize,\n  kHTTPConnVersion,\n  // HTTP2\n  kHost,\n  kHTTP2Session,\n  kHTTP2SessionState,\n  kHTTP2BuildRequest,\n  kHTTP2CopyHeaders,\n  kHTTP1BuildRequest\n} = require('./core/symbols')\n\n/** @type {import('http2')} */\nlet http2\ntry {\n  http2 = require('http2')\n} catch {\n  // @ts-ignore\n  http2 = { constants: {} }\n}\n\nconst {\n  constants: {\n    HTTP2_HEADER_AUTHORITY,\n    HTTP2_HEADER_METHOD,\n    HTTP2_HEADER_PATH,\n    HTTP2_HEADER_SCHEME,\n    HTTP2_HEADER_CONTENT_LENGTH,\n    HTTP2_HEADER_EXPECT,\n    HTTP2_HEADER_STATUS\n  }\n} = http2\n\n// Experimental\nlet h2ExperimentalWarned = false\n\nconst FastBuffer = Buffer[Symbol.species]\n\nconst kClosedResolve = Symbol('kClosedResolve')\n\nconst channels = {}\n\ntry {\n  const diagnosticsChannel = require('diagnostics_channel')\n  channels.sendHeaders = diagnosticsChannel.channel('undici:client:sendHeaders')\n  channels.beforeConnect = diagnosticsChannel.channel('undici:client:beforeConnect')\n  channels.connectError = diagnosticsChannel.channel('undici:client:connectError')\n  channels.connected = diagnosticsChannel.channel('undici:client:connected')\n} catch {\n  channels.sendHeaders = { hasSubscribers: false }\n  channels.beforeConnect = { hasSubscribers: false }\n  channels.connectError = { hasSubscribers: false }\n  channels.connected = { hasSubscribers: false }\n}\n\n/**\n * @type {import('../types/client').default}\n */\nclass Client extends DispatcherBase {\n  /**\n   *\n   * @param {string|URL} url\n   * @param {import('../types/client').Client.Options} options\n   */\n  constructor (url, {\n    interceptors,\n    maxHeaderSize,\n    headersTimeout,\n    socketTimeout,\n    requestTimeout,\n    connectTimeout,\n    bodyTimeout,\n    idleTimeout,\n    keepAlive,\n    keepAliveTimeout,\n    maxKeepAliveTimeout,\n    keepAliveMaxTimeout,\n    keepAliveTimeoutThreshold,\n    socketPath,\n    pipelining,\n    tls,\n    strictContentLength,\n    maxCachedSessions,\n    maxRedirections,\n    connect,\n    maxRequestsPerClient,\n    localAddress,\n    maxResponseSize,\n    autoSelectFamily,\n    autoSelectFamilyAttemptTimeout,\n    // h2\n    allowH2,\n    maxConcurrentStreams\n  } = {}) {\n    super()\n\n    if (keepAlive !== undefined) {\n      throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead')\n    }\n\n    if (socketTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (requestTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (idleTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead')\n    }\n\n    if (maxKeepAliveTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead')\n    }\n\n    if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {\n      throw new InvalidArgumentError('invalid maxHeaderSize')\n    }\n\n    if (socketPath != null && typeof socketPath !== 'string') {\n      throw new InvalidArgumentError('invalid socketPath')\n    }\n\n    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n      throw new InvalidArgumentError('invalid connectTimeout')\n    }\n\n    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeout')\n    }\n\n    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveMaxTimeout')\n    }\n\n    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold')\n    }\n\n    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('headersTimeout must be a positive integer or zero')\n    }\n\n    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n      throw new InvalidArgumentError('maxRequestsPerClient must be a positive number')\n    }\n\n    if (localAddress != null && (typeof localAddress !== 'string' || net.isIP(localAddress) === 0)) {\n      throw new InvalidArgumentError('localAddress must be valid string IP address')\n    }\n\n    if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {\n      throw new InvalidArgumentError('maxResponseSize must be a positive number')\n    }\n\n    if (\n      autoSelectFamilyAttemptTimeout != null &&\n      (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)\n    ) {\n      throw new InvalidArgumentError('autoSelectFamilyAttemptTimeout must be a positive number')\n    }\n\n    // h2\n    if (allowH2 != null && typeof allowH2 !== 'boolean') {\n      throw new InvalidArgumentError('allowH2 must be a valid boolean value')\n    }\n\n    if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== 'number' || maxConcurrentStreams < 1)) {\n      throw new InvalidArgumentError('maxConcurrentStreams must be a possitive integer, greater than 0')\n    }\n\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        allowH2,\n        socketPath,\n        timeout: connectTimeout,\n        ...(util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined),\n        ...connect\n      })\n    }\n\n    this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client)\n      ? interceptors.Client\n      : [createRedirectInterceptor({ maxRedirections })]\n    this[kUrl] = util.parseOrigin(url)\n    this[kConnector] = connect\n    this[kSocket] = null\n    this[kPipelining] = pipelining != null ? pipelining : 1\n    this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize\n    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout\n    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout\n    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold\n    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout]\n    this[kServerName] = null\n    this[kLocalAddress] = localAddress != null ? localAddress : null\n    this[kResuming] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kNeedDrain] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\\r\\n`\n    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300e3\n    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300e3\n    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength\n    this[kMaxRedirections] = maxRedirections\n    this[kMaxRequests] = maxRequestsPerClient\n    this[kClosedResolve] = null\n    this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1\n    this[kHTTPConnVersion] = 'h1'\n\n    // HTTP/2\n    this[kHTTP2Session] = null\n    this[kHTTP2SessionState] = !allowH2\n      ? null\n      : {\n        // streams: null, // Fixed queue of streams - For future support of `push`\n          openStreams: 0, // Keep track of them to decide wether or not unref the session\n          maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100 // Max peerConcurrentStreams for a Node h2 server\n        }\n    this[kHost] = `${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}`\n\n    // kQueue is built up of 3 sections separated by\n    // the kRunningIdx and kPendingIdx indices.\n    // |   complete   |   running   |   pending   |\n    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n    // kRunningIdx points to the first running element.\n    // kPendingIdx points to the first pending element.\n    // This implements a fast queue with an amortized\n    // time of O(1).\n\n    this[kQueue] = []\n    this[kRunningIdx] = 0\n    this[kPendingIdx] = 0\n  }\n\n  get pipelining () {\n    return this[kPipelining]\n  }\n\n  set pipelining (value) {\n    this[kPipelining] = value\n    resume(this, true)\n  }\n\n  get [kPending] () {\n    return this[kQueue].length - this[kPendingIdx]\n  }\n\n  get [kRunning] () {\n    return this[kPendingIdx] - this[kRunningIdx]\n  }\n\n  get [kSize] () {\n    return this[kQueue].length - this[kRunningIdx]\n  }\n\n  get [kConnected] () {\n    return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed\n  }\n\n  get [kBusy] () {\n    const socket = this[kSocket]\n    return (\n      (socket && (socket[kReset] || socket[kWriting] || socket[kBlocking])) ||\n      (this[kSize] >= (this[kPipelining] || 1)) ||\n      this[kPending] > 0\n    )\n  }\n\n  /* istanbul ignore: only used for test */\n  [kConnect] (cb) {\n    connect(this)\n    this.once('connect', cb)\n  }\n\n  [kDispatch] (opts, handler) {\n    const origin = opts.origin || this[kUrl].origin\n\n    const request = this[kHTTPConnVersion] === 'h2'\n      ? Request[kHTTP2BuildRequest](origin, opts, handler)\n      : Request[kHTTP1BuildRequest](origin, opts, handler)\n\n    this[kQueue].push(request)\n    if (this[kResuming]) {\n      // Do nothing.\n    } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {\n      // Wait a tick in case stream/iterator is ended in the same tick.\n      this[kResuming] = 1\n      process.nextTick(resume, this)\n    } else {\n      resume(this, true)\n    }\n\n    if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n      this[kNeedDrain] = 2\n    }\n\n    return this[kNeedDrain] < 2\n  }\n\n  async [kClose] () {\n    // TODO: for H2 we need to gracefully flush the remaining enqueued\n    // request and close each stream.\n    return new Promise((resolve) => {\n      if (!this[kSize]) {\n        resolve(null)\n      } else {\n        this[kClosedResolve] = resolve\n      }\n    })\n  }\n\n  async [kDestroy] (err) {\n    return new Promise((resolve) => {\n      const requests = this[kQueue].splice(this[kPendingIdx])\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i]\n        errorRequest(this, request, err)\n      }\n\n      const callback = () => {\n        if (this[kClosedResolve]) {\n          // TODO (fix): Should we error here with ClientDestroyedError?\n          this[kClosedResolve]()\n          this[kClosedResolve] = null\n        }\n        resolve()\n      }\n\n      if (this[kHTTP2Session] != null) {\n        util.destroy(this[kHTTP2Session], err)\n        this[kHTTP2Session] = null\n        this[kHTTP2SessionState] = null\n      }\n\n      if (!this[kSocket]) {\n        queueMicrotask(callback)\n      } else {\n        util.destroy(this[kSocket].on('close', callback), err)\n      }\n\n      resume(this)\n    })\n  }\n}\n\nfunction onHttp2SessionError (err) {\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n  this[kSocket][kError] = err\n\n  onError(this[kClient], err)\n}\n\nfunction onHttp2FrameError (type, code, id) {\n  const err = new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`)\n\n  if (id === 0) {\n    this[kSocket][kError] = err\n    onError(this[kClient], err)\n  }\n}\n\nfunction onHttp2SessionEnd () {\n  util.destroy(this, new SocketError('other side closed'))\n  util.destroy(this[kSocket], new SocketError('other side closed'))\n}\n\nfunction onHTTP2GoAway (code) {\n  const client = this[kClient]\n  const err = new InformationalError(`HTTP/2: \"GOAWAY\" frame received with code ${code}`)\n  client[kSocket] = null\n  client[kHTTP2Session] = null\n\n  if (client.destroyed) {\n    assert(this[kPending] === 0)\n\n    // Fail entire queue.\n    const requests = client[kQueue].splice(client[kRunningIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      errorRequest(this, request, err)\n    }\n  } else if (client[kRunning] > 0) {\n    // Fail head of pipeline.\n    const request = client[kQueue][client[kRunningIdx]]\n    client[kQueue][client[kRunningIdx]++] = null\n\n    errorRequest(client, request, err)\n  }\n\n  client[kPendingIdx] = client[kRunningIdx]\n\n  assert(client[kRunning] === 0)\n\n  client.emit('disconnect',\n    client[kUrl],\n    [client],\n    err\n  )\n\n  resume(client)\n}\n\nconst constants = require('./llhttp/constants')\nconst createRedirectInterceptor = require('./interceptor/redirectInterceptor')\nconst EMPTY_BUF = Buffer.alloc(0)\n\nasync function lazyllhttp () {\n  const llhttpWasmData = process.env.JEST_WORKER_ID ? require('./llhttp/llhttp-wasm.js') : undefined\n\n  let mod\n  try {\n    mod = await WebAssembly.compile(Buffer.from(require('./llhttp/llhttp_simd-wasm.js'), 'base64'))\n  } catch (e) {\n    /* istanbul ignore next */\n\n    // We could check if the error was caused by the simd option not\n    // being enabled, but the occurring of this other error\n    // * https://github.com/emscripten-core/emscripten/issues/11495\n    // got me to remove that check to avoid breaking Node 12.\n    mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require('./llhttp/llhttp-wasm.js'), 'base64'))\n  }\n\n  return await WebAssembly.instantiate(mod, {\n    env: {\n      /* eslint-disable camelcase */\n\n      wasm_on_url: (p, at, len) => {\n        /* istanbul ignore next */\n        return 0\n      },\n      wasm_on_status: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_message_begin: (p) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onMessageBegin() || 0\n      },\n      wasm_on_header_field: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_header_value: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0\n      },\n      wasm_on_body: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_message_complete: (p) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onMessageComplete() || 0\n      }\n\n      /* eslint-enable camelcase */\n    }\n  })\n}\n\nlet llhttpInstance = null\nlet llhttpPromise = lazyllhttp()\nllhttpPromise.catch()\n\nlet currentParser = null\nlet currentBufferRef = null\nlet currentBufferSize = 0\nlet currentBufferPtr = null\n\nconst TIMEOUT_HEADERS = 1\nconst TIMEOUT_BODY = 2\nconst TIMEOUT_IDLE = 3\n\nclass Parser {\n  constructor (client, socket, { exports }) {\n    assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0)\n\n    this.llhttp = exports\n    this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE)\n    this.client = client\n    this.socket = socket\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n    this.statusCode = null\n    this.statusText = ''\n    this.upgrade = false\n    this.headers = []\n    this.headersSize = 0\n    this.headersMaxSize = client[kMaxHeadersSize]\n    this.shouldKeepAlive = false\n    this.paused = false\n    this.resume = this.resume.bind(this)\n\n    this.bytesRead = 0\n\n    this.keepAlive = ''\n    this.contentLength = ''\n    this.connection = ''\n    this.maxResponseSize = client[kMaxResponseSize]\n  }\n\n  setTimeout (value, type) {\n    this.timeoutType = type\n    if (value !== this.timeoutValue) {\n      timers.clearTimeout(this.timeout)\n      if (value) {\n        this.timeout = timers.setTimeout(onParserTimeout, value, this)\n        // istanbul ignore else: only for jest\n        if (this.timeout.unref) {\n          this.timeout.unref()\n        }\n      } else {\n        this.timeout = null\n      }\n      this.timeoutValue = value\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n  }\n\n  resume () {\n    if (this.socket.destroyed || !this.paused) {\n      return\n    }\n\n    assert(this.ptr != null)\n    assert(currentParser == null)\n\n    this.llhttp.llhttp_resume(this.ptr)\n\n    assert(this.timeoutType === TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    this.paused = false\n    this.execute(this.socket.read() || EMPTY_BUF) // Flush parser.\n    this.readMore()\n  }\n\n  readMore () {\n    while (!this.paused && this.ptr) {\n      const chunk = this.socket.read()\n      if (chunk === null) {\n        break\n      }\n      this.execute(chunk)\n    }\n  }\n\n  execute (data) {\n    assert(this.ptr != null)\n    assert(currentParser == null)\n    assert(!this.paused)\n\n    const { socket, llhttp } = this\n\n    if (data.length > currentBufferSize) {\n      if (currentBufferPtr) {\n        llhttp.free(currentBufferPtr)\n      }\n      currentBufferSize = Math.ceil(data.length / 4096) * 4096\n      currentBufferPtr = llhttp.malloc(currentBufferSize)\n    }\n\n    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data)\n\n    // Call `execute` on the wasm parser.\n    // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n    // and finally the length of bytes to parse.\n    // The return value is an error code or `constants.ERROR.OK`.\n    try {\n      let ret\n\n      try {\n        currentBufferRef = data\n        currentParser = this\n        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length)\n        /* eslint-disable-next-line no-useless-catch */\n      } catch (err) {\n        /* istanbul ignore next: difficult to make a test case for */\n        throw err\n      } finally {\n        currentParser = null\n        currentBufferRef = null\n      }\n\n      const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr\n\n      if (ret === constants.ERROR.PAUSED_UPGRADE) {\n        this.onUpgrade(data.slice(offset))\n      } else if (ret === constants.ERROR.PAUSED) {\n        this.paused = true\n        socket.unshift(data.slice(offset))\n      } else if (ret !== constants.ERROR.OK) {\n        const ptr = llhttp.llhttp_get_error_reason(this.ptr)\n        let message = ''\n        /* istanbul ignore else: difficult to make a test case for */\n        if (ptr) {\n          const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0)\n          message =\n            'Response does not match the HTTP/1.1 protocol (' +\n            Buffer.from(llhttp.memory.buffer, ptr, len).toString() +\n            ')'\n        }\n        throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset))\n      }\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n  }\n\n  destroy () {\n    assert(this.ptr != null)\n    assert(currentParser == null)\n\n    this.llhttp.llhttp_free(this.ptr)\n    this.ptr = null\n\n    timers.clearTimeout(this.timeout)\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n\n    this.paused = false\n  }\n\n  onStatus (buf) {\n    this.statusText = buf.toString()\n  }\n\n  onMessageBegin () {\n    const { socket, client } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    if (!request) {\n      return -1\n    }\n  }\n\n  onHeaderField (buf) {\n    const len = this.headers.length\n\n    if ((len & 1) === 0) {\n      this.headers.push(buf)\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    this.trackHeader(buf.length)\n  }\n\n  onHeaderValue (buf) {\n    let len = this.headers.length\n\n    if ((len & 1) === 1) {\n      this.headers.push(buf)\n      len += 1\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    const key = this.headers[len - 2]\n    if (key.length === 10 && key.toString().toLowerCase() === 'keep-alive') {\n      this.keepAlive += buf.toString()\n    } else if (key.length === 10 && key.toString().toLowerCase() === 'connection') {\n      this.connection += buf.toString()\n    } else if (key.length === 14 && key.toString().toLowerCase() === 'content-length') {\n      this.contentLength += buf.toString()\n    }\n\n    this.trackHeader(buf.length)\n  }\n\n  trackHeader (len) {\n    this.headersSize += len\n    if (this.headersSize >= this.headersMaxSize) {\n      util.destroy(this.socket, new HeadersOverflowError())\n    }\n  }\n\n  onUpgrade (head) {\n    const { upgrade, client, socket, headers, statusCode } = this\n\n    assert(upgrade)\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert(!socket.destroyed)\n    assert(socket === client[kSocket])\n    assert(!this.paused)\n    assert(request.upgrade || request.method === 'CONNECT')\n\n    this.statusCode = null\n    this.statusText = ''\n    this.shouldKeepAlive = null\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    socket.unshift(head)\n\n    socket[kParser].destroy()\n    socket[kParser] = null\n\n    socket[kClient] = null\n    socket[kError] = null\n    socket\n      .removeListener('error', onSocketError)\n      .removeListener('readable', onSocketReadable)\n      .removeListener('end', onSocketEnd)\n      .removeListener('close', onSocketClose)\n\n    client[kSocket] = null\n    client[kQueue][client[kRunningIdx]++] = null\n    client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'))\n\n    try {\n      request.onUpgrade(statusCode, headers, socket)\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n\n    resume(client)\n  }\n\n  onHeadersComplete (statusCode, upgrade, shouldKeepAlive) {\n    const { client, socket, headers, statusText } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (!request) {\n      return -1\n    }\n\n    assert(!this.upgrade)\n    assert(this.statusCode < 200)\n\n    if (statusCode === 100) {\n      util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    /* this can only happen if server is misbehaving */\n    if (upgrade && !request.upgrade) {\n      util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS)\n\n    this.statusCode = statusCode\n    this.shouldKeepAlive = (\n      shouldKeepAlive ||\n      // Override llhttp value which does not allow keepAlive for HEAD.\n      (request.method === 'HEAD' && !socket[kReset] && this.connection.toLowerCase() === 'keep-alive')\n    )\n\n    if (this.statusCode >= 200) {\n      const bodyTimeout = request.bodyTimeout != null\n        ? request.bodyTimeout\n        : client[kBodyTimeout]\n      this.setTimeout(bodyTimeout, TIMEOUT_BODY)\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    if (request.method === 'CONNECT') {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    if (upgrade) {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    if (this.shouldKeepAlive && client[kPipelining]) {\n      const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null\n\n      if (keepAliveTimeout != null) {\n        const timeout = Math.min(\n          keepAliveTimeout - client[kKeepAliveTimeoutThreshold],\n          client[kKeepAliveMaxTimeout]\n        )\n        if (timeout <= 0) {\n          socket[kReset] = true\n        } else {\n          client[kKeepAliveTimeoutValue] = timeout\n        }\n      } else {\n        client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout]\n      }\n    } else {\n      // Stop more requests from being dispatched.\n      socket[kReset] = true\n    }\n\n    const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false\n\n    if (request.aborted) {\n      return -1\n    }\n\n    if (request.method === 'HEAD') {\n      return 1\n    }\n\n    if (statusCode < 200) {\n      return 1\n    }\n\n    if (socket[kBlocking]) {\n      socket[kBlocking] = false\n      resume(client)\n    }\n\n    return pause ? constants.ERROR.PAUSED : 0\n  }\n\n  onBody (buf) {\n    const { client, socket, statusCode, maxResponseSize } = this\n\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert.strictEqual(this.timeoutType, TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    assert(statusCode >= 200)\n\n    if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {\n      util.destroy(socket, new ResponseExceededMaxSizeError())\n      return -1\n    }\n\n    this.bytesRead += buf.length\n\n    if (request.onData(buf) === false) {\n      return constants.ERROR.PAUSED\n    }\n  }\n\n  onMessageComplete () {\n    const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this\n\n    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n      return -1\n    }\n\n    if (upgrade) {\n      return\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert(statusCode >= 100)\n\n    this.statusCode = null\n    this.statusText = ''\n    this.bytesRead = 0\n    this.contentLength = ''\n    this.keepAlive = ''\n    this.connection = ''\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    if (statusCode < 200) {\n      return\n    }\n\n    /* istanbul ignore next: should be handled by llhttp? */\n    if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n      util.destroy(socket, new ResponseContentLengthMismatchError())\n      return -1\n    }\n\n    request.onComplete(headers)\n\n    client[kQueue][client[kRunningIdx]++] = null\n\n    if (socket[kWriting]) {\n      assert.strictEqual(client[kRunning], 0)\n      // Response completed before request.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (!shouldKeepAlive) {\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (socket[kReset] && client[kRunning] === 0) {\n      // Destroy socket once all requests have completed.\n      // The request at the tail of the pipeline is the one\n      // that requested reset and no further requests should\n      // have been queued since then.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (client[kPipelining] === 1) {\n      // We must wait a full event loop cycle to reuse this socket to make sure\n      // that non-spec compliant servers are not closing the connection even if they\n      // said they won't.\n      setImmediate(resume, client)\n    } else {\n      resume(client)\n    }\n  }\n}\n\nfunction onParserTimeout (parser) {\n  const { socket, timeoutType, client } = parser\n\n  /* istanbul ignore else */\n  if (timeoutType === TIMEOUT_HEADERS) {\n    if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {\n      assert(!parser.paused, 'cannot be paused while waiting for headers')\n      util.destroy(socket, new HeadersTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_BODY) {\n    if (!parser.paused) {\n      util.destroy(socket, new BodyTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_IDLE) {\n    assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue])\n    util.destroy(socket, new InformationalError('socket idle timeout'))\n  }\n}\n\nfunction onSocketReadable () {\n  const { [kParser]: parser } = this\n  if (parser) {\n    parser.readMore()\n  }\n}\n\nfunction onSocketError (err) {\n  const { [kClient]: client, [kParser]: parser } = this\n\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n  if (client[kHTTPConnVersion] !== 'h2') {\n    // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n    // to the user.\n    if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {\n      // We treat all incoming data so for as a valid response.\n      parser.onMessageComplete()\n      return\n    }\n  }\n\n  this[kError] = err\n\n  onError(this[kClient], err)\n}\n\nfunction onError (client, err) {\n  if (\n    client[kRunning] === 0 &&\n    err.code !== 'UND_ERR_INFO' &&\n    err.code !== 'UND_ERR_SOCKET'\n  ) {\n    // Error is not caused by running request and not a recoverable\n    // socket error.\n\n    assert(client[kPendingIdx] === client[kRunningIdx])\n\n    const requests = client[kQueue].splice(client[kRunningIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      errorRequest(client, request, err)\n    }\n    assert(client[kSize] === 0)\n  }\n}\n\nfunction onSocketEnd () {\n  const { [kParser]: parser, [kClient]: client } = this\n\n  if (client[kHTTPConnVersion] !== 'h2') {\n    if (parser.statusCode && !parser.shouldKeepAlive) {\n      // We treat all incoming data so far as a valid response.\n      parser.onMessageComplete()\n      return\n    }\n  }\n\n  util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)))\n}\n\nfunction onSocketClose () {\n  const { [kClient]: client, [kParser]: parser } = this\n\n  if (client[kHTTPConnVersion] === 'h1' && parser) {\n    if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {\n      // We treat all incoming data so far as a valid response.\n      parser.onMessageComplete()\n    }\n\n    this[kParser].destroy()\n    this[kParser] = null\n  }\n\n  const err = this[kError] || new SocketError('closed', util.getSocketInfo(this))\n\n  client[kSocket] = null\n\n  if (client.destroyed) {\n    assert(client[kPending] === 0)\n\n    // Fail entire queue.\n    const requests = client[kQueue].splice(client[kRunningIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      errorRequest(client, request, err)\n    }\n  } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {\n    // Fail head of pipeline.\n    const request = client[kQueue][client[kRunningIdx]]\n    client[kQueue][client[kRunningIdx]++] = null\n\n    errorRequest(client, request, err)\n  }\n\n  client[kPendingIdx] = client[kRunningIdx]\n\n  assert(client[kRunning] === 0)\n\n  client.emit('disconnect', client[kUrl], [client], err)\n\n  resume(client)\n}\n\nasync function connect (client) {\n  assert(!client[kConnecting])\n  assert(!client[kSocket])\n\n  let { host, hostname, protocol, port } = client[kUrl]\n\n  // Resolve ipv6\n  if (hostname[0] === '[') {\n    const idx = hostname.indexOf(']')\n\n    assert(idx !== -1)\n    const ip = hostname.substring(1, idx)\n\n    assert(net.isIP(ip))\n    hostname = ip\n  }\n\n  client[kConnecting] = true\n\n  if (channels.beforeConnect.hasSubscribers) {\n    channels.beforeConnect.publish({\n      connectParams: {\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      },\n      connector: client[kConnector]\n    })\n  }\n\n  try {\n    const socket = await new Promise((resolve, reject) => {\n      client[kConnector]({\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      }, (err, socket) => {\n        if (err) {\n          reject(err)\n        } else {\n          resolve(socket)\n        }\n      })\n    })\n\n    if (client.destroyed) {\n      util.destroy(socket.on('error', () => {}), new ClientDestroyedError())\n      return\n    }\n\n    client[kConnecting] = false\n\n    assert(socket)\n\n    const isH2 = socket.alpnProtocol === 'h2'\n    if (isH2) {\n      if (!h2ExperimentalWarned) {\n        h2ExperimentalWarned = true\n        process.emitWarning('H2 support is experimental, expect them to change at any time.', {\n          code: 'UNDICI-H2'\n        })\n      }\n\n      const session = http2.connect(client[kUrl], {\n        createConnection: () => socket,\n        peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams\n      })\n\n      client[kHTTPConnVersion] = 'h2'\n      session[kClient] = client\n      session[kSocket] = socket\n      session.on('error', onHttp2SessionError)\n      session.on('frameError', onHttp2FrameError)\n      session.on('end', onHttp2SessionEnd)\n      session.on('goaway', onHTTP2GoAway)\n      session.on('close', onSocketClose)\n      session.unref()\n\n      client[kHTTP2Session] = session\n      socket[kHTTP2Session] = session\n    } else {\n      if (!llhttpInstance) {\n        llhttpInstance = await llhttpPromise\n        llhttpPromise = null\n      }\n\n      socket[kNoRef] = false\n      socket[kWriting] = false\n      socket[kReset] = false\n      socket[kBlocking] = false\n      socket[kParser] = new Parser(client, socket, llhttpInstance)\n    }\n\n    socket[kCounter] = 0\n    socket[kMaxRequests] = client[kMaxRequests]\n    socket[kClient] = client\n    socket[kError] = null\n\n    socket\n      .on('error', onSocketError)\n      .on('readable', onSocketReadable)\n      .on('end', onSocketEnd)\n      .on('close', onSocketClose)\n\n    client[kSocket] = socket\n\n    if (channels.connected.hasSubscribers) {\n      channels.connected.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        socket\n      })\n    }\n    client.emit('connect', client[kUrl], [client])\n  } catch (err) {\n    if (client.destroyed) {\n      return\n    }\n\n    client[kConnecting] = false\n\n    if (channels.connectError.hasSubscribers) {\n      channels.connectError.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        error: err\n      })\n    }\n\n    if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n      assert(client[kRunning] === 0)\n      while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {\n        const request = client[kQueue][client[kPendingIdx]++]\n        errorRequest(client, request, err)\n      }\n    } else {\n      onError(client, err)\n    }\n\n    client.emit('connectionError', client[kUrl], [client], err)\n  }\n\n  resume(client)\n}\n\nfunction emitDrain (client) {\n  client[kNeedDrain] = 0\n  client.emit('drain', client[kUrl], [client])\n}\n\nfunction resume (client, sync) {\n  if (client[kResuming] === 2) {\n    return\n  }\n\n  client[kResuming] = 2\n\n  _resume(client, sync)\n  client[kResuming] = 0\n\n  if (client[kRunningIdx] > 256) {\n    client[kQueue].splice(0, client[kRunningIdx])\n    client[kPendingIdx] -= client[kRunningIdx]\n    client[kRunningIdx] = 0\n  }\n}\n\nfunction _resume (client, sync) {\n  while (true) {\n    if (client.destroyed) {\n      assert(client[kPending] === 0)\n      return\n    }\n\n    if (client[kClosedResolve] && !client[kSize]) {\n      client[kClosedResolve]()\n      client[kClosedResolve] = null\n      return\n    }\n\n    const socket = client[kSocket]\n\n    if (socket && !socket.destroyed && socket.alpnProtocol !== 'h2') {\n      if (client[kSize] === 0) {\n        if (!socket[kNoRef] && socket.unref) {\n          socket.unref()\n          socket[kNoRef] = true\n        }\n      } else if (socket[kNoRef] && socket.ref) {\n        socket.ref()\n        socket[kNoRef] = false\n      }\n\n      if (client[kSize] === 0) {\n        if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {\n          socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE)\n        }\n      } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n        if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n          const request = client[kQueue][client[kRunningIdx]]\n          const headersTimeout = request.headersTimeout != null\n            ? request.headersTimeout\n            : client[kHeadersTimeout]\n          socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS)\n        }\n      }\n    }\n\n    if (client[kBusy]) {\n      client[kNeedDrain] = 2\n    } else if (client[kNeedDrain] === 2) {\n      if (sync) {\n        client[kNeedDrain] = 1\n        process.nextTick(emitDrain, client)\n      } else {\n        emitDrain(client)\n      }\n      continue\n    }\n\n    if (client[kPending] === 0) {\n      return\n    }\n\n    if (client[kRunning] >= (client[kPipelining] || 1)) {\n      return\n    }\n\n    const request = client[kQueue][client[kPendingIdx]]\n\n    if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {\n      if (client[kRunning] > 0) {\n        return\n      }\n\n      client[kServerName] = request.servername\n\n      if (socket && socket.servername !== request.servername) {\n        util.destroy(socket, new InformationalError('servername changed'))\n        return\n      }\n    }\n\n    if (client[kConnecting]) {\n      return\n    }\n\n    if (!socket && !client[kHTTP2Session]) {\n      connect(client)\n      return\n    }\n\n    if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n      return\n    }\n\n    if (client[kRunning] > 0 && !request.idempotent) {\n      // Non-idempotent request cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return\n    }\n\n    if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {\n      // Don't dispatch an upgrade until all preceding requests have completed.\n      // A misbehaving server might upgrade the connection before all pipelined\n      // request has completed.\n      return\n    }\n\n    if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 &&\n      (util.isStream(request.body) || util.isAsyncIterable(request.body))) {\n      // Request with stream or iterator body can error while other requests\n      // are inflight and indirectly error those as well.\n      // Ensure this doesn't happen by waiting for inflight\n      // to complete before dispatching.\n\n      // Request with stream or iterator body cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return\n    }\n\n    if (!request.aborted && write(client, request)) {\n      client[kPendingIdx]++\n    } else {\n      client[kQueue].splice(client[kPendingIdx], 1)\n    }\n  }\n}\n\n// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2\nfunction shouldSendContentLength (method) {\n  return method !== 'GET' && method !== 'HEAD' && method !== 'OPTIONS' && method !== 'TRACE' && method !== 'CONNECT'\n}\n\nfunction write (client, request) {\n  if (client[kHTTPConnVersion] === 'h2') {\n    writeH2(client, client[kHTTP2Session], request)\n    return\n  }\n\n  const { body, method, path, host, upgrade, headers, blocking, reset } = request\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = (\n    method === 'PUT' ||\n    method === 'POST' ||\n    method === 'PATCH'\n  )\n\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0)\n  }\n\n  const bodyLength = util.bodyLength(body)\n\n  let contentLength = bodyLength\n\n  if (contentLength === null) {\n    contentLength = request.contentLength\n  }\n\n  if (contentLength === 0 && !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null\n  }\n\n  // https://github.com/nodejs/undici/issues/2046\n  // A user agent may send a Content-Length header with 0 value, this should be allowed.\n  if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      errorRequest(client, request, new RequestContentLengthMismatchError())\n      return false\n    }\n\n    process.emitWarning(new RequestContentLengthMismatchError())\n  }\n\n  const socket = client[kSocket]\n\n  try {\n    request.onConnect((err) => {\n      if (request.aborted || request.completed) {\n        return\n      }\n\n      errorRequest(client, request, err || new RequestAbortedError())\n\n      util.destroy(socket, new InformationalError('aborted'))\n    })\n  } catch (err) {\n    errorRequest(client, request, err)\n  }\n\n  if (request.aborted) {\n    return false\n  }\n\n  if (method === 'HEAD') {\n    // https://github.com/mcollina/undici/issues/258\n    // Close after a HEAD request to interop with misbehaving servers\n    // that may send a body in the response.\n\n    socket[kReset] = true\n  }\n\n  if (upgrade || method === 'CONNECT') {\n    // On CONNECT or upgrade, block pipeline from dispatching further\n    // requests on this connection.\n\n    socket[kReset] = true\n  }\n\n  if (reset != null) {\n    socket[kReset] = reset\n  }\n\n  if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n    socket[kReset] = true\n  }\n\n  if (blocking) {\n    socket[kBlocking] = true\n  }\n\n  let header = `${method} ${path} HTTP/1.1\\r\\n`\n\n  if (typeof host === 'string') {\n    header += `host: ${host}\\r\\n`\n  } else {\n    header += client[kHostHeader]\n  }\n\n  if (upgrade) {\n    header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`\n  } else if (client[kPipelining] && !socket[kReset]) {\n    header += 'connection: keep-alive\\r\\n'\n  } else {\n    header += 'connection: close\\r\\n'\n  }\n\n  if (headers) {\n    header += headers\n  }\n\n  if (channels.sendHeaders.hasSubscribers) {\n    channels.sendHeaders.publish({ request, headers: header, socket })\n  }\n\n  /* istanbul ignore else: assertion */\n  if (!body || bodyLength === 0) {\n    if (contentLength === 0) {\n      socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1')\n    } else {\n      assert(contentLength === null, 'no body must not have content length')\n      socket.write(`${header}\\r\\n`, 'latin1')\n    }\n    request.onRequestSent()\n  } else if (util.isBuffer(body)) {\n    assert(contentLength === body.byteLength, 'buffer body must have content length')\n\n    socket.cork()\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n    socket.write(body)\n    socket.uncork()\n    request.onBodySent(body)\n    request.onRequestSent()\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n  } else if (util.isBlobLike(body)) {\n    if (typeof body.stream === 'function') {\n      writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload })\n    } else {\n      writeBlob({ body, client, request, socket, contentLength, header, expectsPayload })\n    }\n  } else if (util.isStream(body)) {\n    writeStream({ body, client, request, socket, contentLength, header, expectsPayload })\n  } else if (util.isIterable(body)) {\n    writeIterable({ body, client, request, socket, contentLength, header, expectsPayload })\n  } else {\n    assert(false)\n  }\n\n  return true\n}\n\nfunction writeH2 (client, session, request) {\n  const { body, method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request\n\n  let headers\n  if (typeof reqHeaders === 'string') headers = Request[kHTTP2CopyHeaders](reqHeaders.trim())\n  else headers = reqHeaders\n\n  if (upgrade) {\n    errorRequest(client, request, new Error('Upgrade not supported for H2'))\n    return false\n  }\n\n  try {\n    // TODO(HTTP/2): Should we call onConnect immediately or on stream ready event?\n    request.onConnect((err) => {\n      if (request.aborted || request.completed) {\n        return\n      }\n\n      errorRequest(client, request, err || new RequestAbortedError())\n    })\n  } catch (err) {\n    errorRequest(client, request, err)\n  }\n\n  if (request.aborted) {\n    return false\n  }\n\n  /** @type {import('node:http2').ClientHttp2Stream} */\n  let stream\n  const h2State = client[kHTTP2SessionState]\n\n  headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost]\n  headers[HTTP2_HEADER_METHOD] = method\n\n  if (method === 'CONNECT') {\n    session.ref()\n    // we are already connected, streams are pending, first request\n    // will create a new stream. We trigger a request to create the stream and wait until\n    // `ready` event is triggered\n    // We disabled endStream to allow the user to write to the stream\n    stream = session.request(headers, { endStream: false, signal })\n\n    if (stream.id && !stream.pending) {\n      request.onUpgrade(null, null, stream)\n      ++h2State.openStreams\n    } else {\n      stream.once('ready', () => {\n        request.onUpgrade(null, null, stream)\n        ++h2State.openStreams\n      })\n    }\n\n    stream.once('close', () => {\n      h2State.openStreams -= 1\n      // TODO(HTTP/2): unref only if current streams count is 0\n      if (h2State.openStreams === 0) session.unref()\n    })\n\n    return true\n  }\n\n  // https://tools.ietf.org/html/rfc7540#section-8.3\n  // :path and :scheme headers must be omited when sending CONNECT\n\n  headers[HTTP2_HEADER_PATH] = path\n  headers[HTTP2_HEADER_SCHEME] = 'https'\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = (\n    method === 'PUT' ||\n    method === 'POST' ||\n    method === 'PATCH'\n  )\n\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0)\n  }\n\n  let contentLength = util.bodyLength(body)\n\n  if (contentLength == null) {\n    contentLength = request.contentLength\n  }\n\n  if (contentLength === 0 || !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null\n  }\n\n  // https://github.com/nodejs/undici/issues/2046\n  // A user agent may send a Content-Length header with 0 value, this should be allowed.\n  if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      errorRequest(client, request, new RequestContentLengthMismatchError())\n      return false\n    }\n\n    process.emitWarning(new RequestContentLengthMismatchError())\n  }\n\n  if (contentLength != null) {\n    assert(body, 'no body must not have content length')\n    headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`\n  }\n\n  session.ref()\n\n  const shouldEndStream = method === 'GET' || method === 'HEAD'\n  if (expectContinue) {\n    headers[HTTP2_HEADER_EXPECT] = '100-continue'\n    stream = session.request(headers, { endStream: shouldEndStream, signal })\n\n    stream.once('continue', writeBodyH2)\n  } else {\n    stream = session.request(headers, {\n      endStream: shouldEndStream,\n      signal\n    })\n    writeBodyH2()\n  }\n\n  // Increment counter as we have new several streams open\n  ++h2State.openStreams\n\n  stream.once('response', headers => {\n    const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers\n\n    if (request.onHeaders(Number(statusCode), realHeaders, stream.resume.bind(stream), '') === false) {\n      stream.pause()\n    }\n  })\n\n  stream.once('end', () => {\n    request.onComplete([])\n  })\n\n  stream.on('data', (chunk) => {\n    if (request.onData(chunk) === false) {\n      stream.pause()\n    }\n  })\n\n  stream.once('close', () => {\n    h2State.openStreams -= 1\n    // TODO(HTTP/2): unref only if current streams count is 0\n    if (h2State.openStreams === 0) {\n      session.unref()\n    }\n  })\n\n  stream.once('error', function (err) {\n    if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {\n      h2State.streams -= 1\n      util.destroy(stream, err)\n    }\n  })\n\n  stream.once('frameError', (type, code) => {\n    const err = new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`)\n    errorRequest(client, request, err)\n\n    if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {\n      h2State.streams -= 1\n      util.destroy(stream, err)\n    }\n  })\n\n  // stream.on('aborted', () => {\n  //   // TODO(HTTP/2): Support aborted\n  // })\n\n  // stream.on('timeout', () => {\n  //   // TODO(HTTP/2): Support timeout\n  // })\n\n  // stream.on('push', headers => {\n  //   // TODO(HTTP/2): Suppor push\n  // })\n\n  // stream.on('trailers', headers => {\n  //   // TODO(HTTP/2): Support trailers\n  // })\n\n  return true\n\n  function writeBodyH2 () {\n    /* istanbul ignore else: assertion */\n    if (!body) {\n      request.onRequestSent()\n    } else if (util.isBuffer(body)) {\n      assert(contentLength === body.byteLength, 'buffer body must have content length')\n      stream.cork()\n      stream.write(body)\n      stream.uncork()\n      stream.end()\n      request.onBodySent(body)\n      request.onRequestSent()\n    } else if (util.isBlobLike(body)) {\n      if (typeof body.stream === 'function') {\n        writeIterable({\n          client,\n          request,\n          contentLength,\n          h2stream: stream,\n          expectsPayload,\n          body: body.stream(),\n          socket: client[kSocket],\n          header: ''\n        })\n      } else {\n        writeBlob({\n          body,\n          client,\n          request,\n          contentLength,\n          expectsPayload,\n          h2stream: stream,\n          header: '',\n          socket: client[kSocket]\n        })\n      }\n    } else if (util.isStream(body)) {\n      writeStream({\n        body,\n        client,\n        request,\n        contentLength,\n        expectsPayload,\n        socket: client[kSocket],\n        h2stream: stream,\n        header: ''\n      })\n    } else if (util.isIterable(body)) {\n      writeIterable({\n        body,\n        client,\n        request,\n        contentLength,\n        expectsPayload,\n        header: '',\n        h2stream: stream,\n        socket: client[kSocket]\n      })\n    } else {\n      assert(false)\n    }\n  }\n}\n\nfunction writeStream ({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined')\n\n  if (client[kHTTPConnVersion] === 'h2') {\n    // For HTTP/2, is enough to pipe the stream\n    const pipe = pipeline(\n      body,\n      h2stream,\n      (err) => {\n        if (err) {\n          util.destroy(body, err)\n          util.destroy(h2stream, err)\n        } else {\n          request.onRequestSent()\n        }\n      }\n    )\n\n    pipe.on('data', onPipeData)\n    pipe.once('end', () => {\n      pipe.removeListener('data', onPipeData)\n      util.destroy(pipe)\n    })\n\n    function onPipeData (chunk) {\n      request.onBodySent(chunk)\n    }\n\n    return\n  }\n\n  let finished = false\n\n  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header })\n\n  const onData = function (chunk) {\n    if (finished) {\n      return\n    }\n\n    try {\n      if (!writer.write(chunk) && this.pause) {\n        this.pause()\n      }\n    } catch (err) {\n      util.destroy(this, err)\n    }\n  }\n  const onDrain = function () {\n    if (finished) {\n      return\n    }\n\n    if (body.resume) {\n      body.resume()\n    }\n  }\n  const onAbort = function () {\n    if (finished) {\n      return\n    }\n    const err = new RequestAbortedError()\n    queueMicrotask(() => onFinished(err))\n  }\n  const onFinished = function (err) {\n    if (finished) {\n      return\n    }\n\n    finished = true\n\n    assert(socket.destroyed || (socket[kWriting] && client[kRunning] <= 1))\n\n    socket\n      .off('drain', onDrain)\n      .off('error', onFinished)\n\n    body\n      .removeListener('data', onData)\n      .removeListener('end', onFinished)\n      .removeListener('error', onFinished)\n      .removeListener('close', onAbort)\n\n    if (!err) {\n      try {\n        writer.end()\n      } catch (er) {\n        err = er\n      }\n    }\n\n    writer.destroy(err)\n\n    if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {\n      util.destroy(body, err)\n    } else {\n      util.destroy(body)\n    }\n  }\n\n  body\n    .on('data', onData)\n    .on('end', onFinished)\n    .on('error', onFinished)\n    .on('close', onAbort)\n\n  if (body.resume) {\n    body.resume()\n  }\n\n  socket\n    .on('drain', onDrain)\n    .on('error', onFinished)\n}\n\nasync function writeBlob ({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength === body.size, 'blob body must have content length')\n\n  const isH2 = client[kHTTPConnVersion] === 'h2'\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError()\n    }\n\n    const buffer = Buffer.from(await body.arrayBuffer())\n\n    if (isH2) {\n      h2stream.cork()\n      h2stream.write(buffer)\n      h2stream.uncork()\n    } else {\n      socket.cork()\n      socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n      socket.write(buffer)\n      socket.uncork()\n    }\n\n    request.onBodySent(buffer)\n    request.onRequestSent()\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    resume(client)\n  } catch (err) {\n    util.destroy(isH2 ? h2stream : socket, err)\n  }\n}\n\nasync function writeIterable ({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined')\n\n  let callback = null\n  function onDrain () {\n    if (callback) {\n      const cb = callback\n      callback = null\n      cb()\n    }\n  }\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null)\n\n    if (socket[kError]) {\n      reject(socket[kError])\n    } else {\n      callback = resolve\n    }\n  })\n\n  if (client[kHTTPConnVersion] === 'h2') {\n    h2stream\n      .on('close', onDrain)\n      .on('drain', onDrain)\n\n    try {\n      // It's up to the user to somehow abort the async iterable.\n      for await (const chunk of body) {\n        if (socket[kError]) {\n          throw socket[kError]\n        }\n\n        const res = h2stream.write(chunk)\n        request.onBodySent(chunk)\n        if (!res) {\n          await waitForDrain()\n        }\n      }\n    } catch (err) {\n      h2stream.destroy(err)\n    } finally {\n      request.onRequestSent()\n      h2stream.end()\n      h2stream\n        .off('close', onDrain)\n        .off('drain', onDrain)\n    }\n\n    return\n  }\n\n  socket\n    .on('close', onDrain)\n    .on('drain', onDrain)\n\n  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header })\n  try {\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError]\n      }\n\n      if (!writer.write(chunk)) {\n        await waitForDrain()\n      }\n    }\n\n    writer.end()\n  } catch (err) {\n    writer.destroy(err)\n  } finally {\n    socket\n      .off('close', onDrain)\n      .off('drain', onDrain)\n  }\n}\n\nclass AsyncWriter {\n  constructor ({ socket, request, contentLength, client, expectsPayload, header }) {\n    this.socket = socket\n    this.request = request\n    this.contentLength = contentLength\n    this.client = client\n    this.bytesWritten = 0\n    this.expectsPayload = expectsPayload\n    this.header = header\n\n    socket[kWriting] = true\n  }\n\n  write (chunk) {\n    const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return false\n    }\n\n    const len = Buffer.byteLength(chunk)\n    if (!len) {\n      return true\n    }\n\n    // We should defer writing chunks.\n    if (contentLength !== null && bytesWritten + len > contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      }\n\n      process.emitWarning(new RequestContentLengthMismatchError())\n    }\n\n    socket.cork()\n\n    if (bytesWritten === 0) {\n      if (!expectsPayload) {\n        socket[kReset] = true\n      }\n\n      if (contentLength === null) {\n        socket.write(`${header}transfer-encoding: chunked\\r\\n`, 'latin1')\n      } else {\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n      }\n    }\n\n    if (contentLength === null) {\n      socket.write(`\\r\\n${len.toString(16)}\\r\\n`, 'latin1')\n    }\n\n    this.bytesWritten += len\n\n    const ret = socket.write(chunk)\n\n    socket.uncork()\n\n    request.onBodySent(chunk)\n\n    if (!ret) {\n      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n        // istanbul ignore else: only for jest\n        if (socket[kParser].timeout.refresh) {\n          socket[kParser].timeout.refresh()\n        }\n      }\n    }\n\n    return ret\n  }\n\n  end () {\n    const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this\n    request.onRequestSent()\n\n    socket[kWriting] = false\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return\n    }\n\n    if (bytesWritten === 0) {\n      if (expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD send a Content-Length in a request message when\n        // no Transfer-Encoding is sent and the request method defines a meaning\n        // for an enclosed payload body.\n\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1')\n      } else {\n        socket.write(`${header}\\r\\n`, 'latin1')\n      }\n    } else if (contentLength === null) {\n      socket.write('\\r\\n0\\r\\n\\r\\n', 'latin1')\n    }\n\n    if (contentLength !== null && bytesWritten !== contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      } else {\n        process.emitWarning(new RequestContentLengthMismatchError())\n      }\n    }\n\n    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n      // istanbul ignore else: only for jest\n      if (socket[kParser].timeout.refresh) {\n        socket[kParser].timeout.refresh()\n      }\n    }\n\n    resume(client)\n  }\n\n  destroy (err) {\n    const { socket, client } = this\n\n    socket[kWriting] = false\n\n    if (err) {\n      assert(client[kRunning] <= 1, 'pipeline should only contain this request')\n      util.destroy(socket, err)\n    }\n  }\n}\n\nfunction errorRequest (client, request, err) {\n  try {\n    request.onError(err)\n    assert(request.aborted)\n  } catch (err) {\n    client.emit('error', err)\n  }\n}\n\nmodule.exports = Client\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}