{"ast":null,"code":"import * as API from '@ucanto/interface';\n\n/**\n * @typedef {`${Lowercase<string>}/${Lowercase<string>}`|`${Lowercase<string>}/${Lowercase<string>}+${Lowercase<string>}`} ContentType\n * @typedef {`${Lowercase<string>}/${Lowercase<string>}`|`${Lowercase<string>}/${Lowercase<string>};q=${number}.${number}`} MediaType\n * @param {object} source\n * @param {Record<ContentType, API.Transport.RequestDecoder>} source.decoders\n * @param {Record<MediaType, API.Transport.ResponseEncoder>} source.encoders\n * @returns {API.InboundCodec}\n */\nexport const inbound = source => new Inbound(source);\n\n/**\n * @implements {API.InboundCodec}\n */\nclass Inbound {\n  /**\n   * @param {API.HTTPRequest} request\n   * @returns {API.Result<API.InboundAcceptCodec, API.HTTPError>} transport\n   */\n  accept({\n    headers\n  }) {\n    const contentType = headers['content-type'] || headers['Content-Type'];\n    const decoder = this.decoders[contentType];\n    if (!decoder) {\n      return {\n        error: {\n          status: 415,\n          message: `The server cannot process the request because the payload format is not supported. Please check the content-type header and try again with a supported media type.`,\n          headers: {\n            accept: Object.keys(this.decoders).join(', ')\n          }\n        }\n      };\n    }\n    const accept = parseAcceptHeader(headers.accept || headers.Accept || '*/*');\n    for (const {\n      category,\n      type\n    } of accept) {\n      for (const encoder of this.encoders) {\n        const select = (category === '*' || category === encoder.category) && (type === '*' || type === encoder.type);\n        if (select) {\n          return {\n            ok: {\n              ...encoder,\n              decoder\n            }\n          };\n        }\n      }\n    }\n    return {\n      error: {\n        status: 406,\n        message: `The requested resource cannot be served in the requested content type. Please specify a supported content type using the Accept header.`,\n        headers: {\n          accept: formatAcceptHeader(Object.values(this.encoders))\n        }\n      }\n    };\n  }\n\n  /**\n   * @param {object} source\n   * @param {Record<string, API.Transport.RequestDecoder>} source.decoders\n   * @param {Record<string, API.Transport.ResponseEncoder>} source.encoders\n   */\n  constructor({\n    decoders = {},\n    encoders = {}\n  }) {\n    this.decoders = decoders;\n    if (Object.keys(decoders).length === 0) {\n      throw new Error('At least one decoder MUST be provided');\n    }\n\n    // We sort the encoders by preference, so that we can pick the most\n    // preferred one when client accepts multiple content types.\n    this.encoders = Object.entries(encoders).map(([mediaType, encoder]) => {\n      return {\n        ...parseMediaType(mediaType),\n        encoder\n      };\n    }).sort((a, b) => b.preference - a.preference);\n    if (this.encoders.length === 0) {\n      throw new Error('At least one encoder MUST be provided');\n    }\n  }\n}\n\n/**\n * @param {object} source\n * @param {Record<MediaType, API.Transport.RequestEncoder>} source.encoders\n * @param {Record<ContentType, API.Transport.ResponseDecoder>} source.decoders\n * @returns {API.OutboundCodec}\n */\nexport const outbound = source => new Outbound(source);\n\n/**\n * @implements {API.OutboundCodec}\n */\nclass Outbound {\n  /**\n   * @param {object} source\n   * @param {Record<string, API.Transport.RequestEncoder>} source.encoders\n   * @param {Record<string, API.Transport.ResponseDecoder>} source.decoders\n   */\n  constructor({\n    decoders = {},\n    encoders = {}\n  }) {\n    this.decoders = decoders;\n    if (Object.keys(decoders).length === 0) {\n      throw new Error('At least one decoder MUST be provided');\n    }\n\n    // We sort the encoders by preference, so that we can pick the most\n    // preferred one when client accepts multiple content types.\n    this.encoders = Object.entries(encoders).map(([mediaType, encoder]) => {\n      return {\n        ...parseMediaType(mediaType),\n        encoder\n      };\n    }).sort((a, b) => b.preference - a.preference);\n    this.acceptType = formatAcceptHeader(this.encoders);\n    if (this.encoders.length === 0) {\n      throw new Error('At least one encoder MUST be provided');\n    }\n    this.encoder = this.encoders[0].encoder;\n  }\n\n  /**\n   * @template {API.AgentMessage} Message\n   * @param {Message} message\n   */\n  encode(message) {\n    return this.encoder.encode(message, {\n      accept: this.acceptType\n    });\n  }\n  /**\n   * @template {API.AgentMessage} Message\n   * @param {API.HTTPResponse<Message>} response\n   * @returns {API.Await<Message>}\n   */\n  decode(response) {\n    const {\n      headers\n    } = response;\n    const contentType = headers['content-type'] || headers['Content-Type'];\n    const decoder = this.decoders[contentType] || this.decoders['*/*'];\n    switch (response.status) {\n      case 415:\n      case 406:\n        throw Object.assign(new RangeError(new TextDecoder().decode(response.body)), {\n          status: response.status,\n          headers: response.headers\n        });\n    }\n    if (!decoder) {\n      throw Object.assign(TypeError(`Can not decode response with content-type '${contentType}' because no matching transport decoder is configured.`), {\n        error: true\n      });\n    }\n    return decoder.decode(response);\n  }\n}\n\n/**\n * @typedef {{ category: string, type: string, preference: number }} Media\n * @param {string} source\n * @returns {Media}\n */\nexport const parseMediaType = source => {\n  const [mediaType = '*/*', mediaRange = ''] = source.trim().split(';');\n  const [category = '*', type = '*'] = mediaType.split('/');\n  const params = new URLSearchParams(mediaRange);\n  const preference = parseFloat(params.get('q') || '0');\n  return {\n    category,\n    type,\n    /* c8 ignore next */\n    preference: isNaN(preference) ? 0 : preference\n  };\n};\n\n/**\n * @param {Media} media\n */\nexport const formatMediaType = ({\n  category,\n  type,\n  preference\n}) => ( /** @type {MediaType}  */\n`${category}/${type}${preference ? `;q=${preference}` : ''}`);\n\n/**\n * @param {string} source\n */\nexport const parseAcceptHeader = source => source.split(',').map(parseMediaType).sort((a, b) => b.preference - a.preference);\n\n/**\n * @param {Media[]} source\n */\nexport const formatAcceptHeader = source => source.map(formatMediaType).join(', ');","map":{"version":3,"names":["API","inbound","source","Inbound","accept","headers","contentType","decoder","decoders","error","status","message","Object","keys","join","parseAcceptHeader","Accept","category","type","encoder","encoders","select","ok","formatAcceptHeader","values","constructor","length","Error","entries","map","mediaType","parseMediaType","sort","a","b","preference","outbound","Outbound","acceptType","encode","decode","response","assign","RangeError","TextDecoder","body","TypeError","mediaRange","trim","split","params","URLSearchParams","parseFloat","get","isNaN","formatMediaType"],"sources":["C:/FACULTATE/Proiect/node_modules/@ucanto/transport/src/codec.js"],"sourcesContent":["import * as API from '@ucanto/interface'\n\n/**\n * @typedef {`${Lowercase<string>}/${Lowercase<string>}`|`${Lowercase<string>}/${Lowercase<string>}+${Lowercase<string>}`} ContentType\n * @typedef {`${Lowercase<string>}/${Lowercase<string>}`|`${Lowercase<string>}/${Lowercase<string>};q=${number}.${number}`} MediaType\n * @param {object} source\n * @param {Record<ContentType, API.Transport.RequestDecoder>} source.decoders\n * @param {Record<MediaType, API.Transport.ResponseEncoder>} source.encoders\n * @returns {API.InboundCodec}\n */\nexport const inbound = source => new Inbound(source)\n\n/**\n * @implements {API.InboundCodec}\n */\nclass Inbound {\n  /**\n   * @param {API.HTTPRequest} request\n   * @returns {API.Result<API.InboundAcceptCodec, API.HTTPError>} transport\n   */\n  accept({ headers }) {\n    const contentType = headers['content-type'] || headers['Content-Type']\n    const decoder = this.decoders[contentType]\n    if (!decoder) {\n      return {\n        error: {\n          status: 415,\n          message: `The server cannot process the request because the payload format is not supported. Please check the content-type header and try again with a supported media type.`,\n          headers: {\n            accept: Object.keys(this.decoders).join(', '),\n          },\n        },\n      }\n    }\n\n    const accept = parseAcceptHeader(headers.accept || headers.Accept || '*/*')\n    for (const { category, type } of accept) {\n      for (const encoder of this.encoders) {\n        const select =\n          (category === '*' || category === encoder.category) &&\n          (type === '*' || type === encoder.type)\n\n        if (select) {\n          return { ok: { ...encoder, decoder } }\n        }\n      }\n    }\n\n    return {\n      error: {\n        status: 406,\n        message: `The requested resource cannot be served in the requested content type. Please specify a supported content type using the Accept header.`,\n        headers: {\n          accept: formatAcceptHeader(Object.values(this.encoders)),\n        },\n      },\n    }\n  }\n\n  /**\n   * @param {object} source\n   * @param {Record<string, API.Transport.RequestDecoder>} source.decoders\n   * @param {Record<string, API.Transport.ResponseEncoder>} source.encoders\n   */\n  constructor({ decoders = {}, encoders = {} }) {\n    this.decoders = decoders\n\n    if (Object.keys(decoders).length === 0) {\n      throw new Error('At least one decoder MUST be provided')\n    }\n\n    // We sort the encoders by preference, so that we can pick the most\n    // preferred one when client accepts multiple content types.\n    this.encoders = Object.entries(encoders)\n      .map(([mediaType, encoder]) => {\n        return { ...parseMediaType(mediaType), encoder }\n      })\n      .sort((a, b) => b.preference - a.preference)\n\n    if (this.encoders.length === 0) {\n      throw new Error('At least one encoder MUST be provided')\n    }\n  }\n}\n\n/**\n * @param {object} source\n * @param {Record<MediaType, API.Transport.RequestEncoder>} source.encoders\n * @param {Record<ContentType, API.Transport.ResponseDecoder>} source.decoders\n * @returns {API.OutboundCodec}\n */\nexport const outbound = source => new Outbound(source)\n\n/**\n * @implements {API.OutboundCodec}\n */\nclass Outbound {\n  /**\n   * @param {object} source\n   * @param {Record<string, API.Transport.RequestEncoder>} source.encoders\n   * @param {Record<string, API.Transport.ResponseDecoder>} source.decoders\n   */\n  constructor({ decoders = {}, encoders = {} }) {\n    this.decoders = decoders\n\n    if (Object.keys(decoders).length === 0) {\n      throw new Error('At least one decoder MUST be provided')\n    }\n\n    // We sort the encoders by preference, so that we can pick the most\n    // preferred one when client accepts multiple content types.\n    this.encoders = Object.entries(encoders)\n      .map(([mediaType, encoder]) => {\n        return { ...parseMediaType(mediaType), encoder }\n      })\n      .sort((a, b) => b.preference - a.preference)\n\n    this.acceptType = formatAcceptHeader(this.encoders)\n\n    if (this.encoders.length === 0) {\n      throw new Error('At least one encoder MUST be provided')\n    }\n\n    this.encoder = this.encoders[0].encoder\n  }\n\n  /**\n   * @template {API.AgentMessage} Message\n   * @param {Message} message\n   */\n  encode(message) {\n    return this.encoder.encode(message, {\n      accept: this.acceptType,\n    })\n  }\n  /**\n   * @template {API.AgentMessage} Message\n   * @param {API.HTTPResponse<Message>} response\n   * @returns {API.Await<Message>}\n   */\n  decode(response) {\n    const { headers } = response\n    const contentType = headers['content-type'] || headers['Content-Type']\n    const decoder = this.decoders[contentType] || this.decoders['*/*']\n    switch (response.status) {\n      case 415:\n      case 406:\n        throw Object.assign(\n          new RangeError(new TextDecoder().decode(response.body)),\n          {\n            status: response.status,\n            headers: response.headers,\n          }\n        )\n    }\n    if (!decoder) {\n      throw Object.assign(\n        TypeError(\n          `Can not decode response with content-type '${contentType}' because no matching transport decoder is configured.`\n        ),\n        {\n          error: true,\n        }\n      )\n    }\n\n    return decoder.decode(response)\n  }\n}\n\n/**\n * @typedef {{ category: string, type: string, preference: number }} Media\n * @param {string} source\n * @returns {Media}\n */\nexport const parseMediaType = source => {\n  const [mediaType = '*/*', mediaRange = ''] = source.trim().split(';')\n  const [category = '*', type = '*'] = mediaType.split('/')\n  const params = new URLSearchParams(mediaRange)\n  const preference = parseFloat(params.get('q') || '0')\n  return {\n    category,\n    type,\n    /* c8 ignore next */\n    preference: isNaN(preference) ? 0 : preference,\n  }\n}\n\n/**\n * @param {Media} media\n */\nexport const formatMediaType = ({ category, type, preference }) =>\n  /** @type {MediaType}  */ (\n    `${category}/${type}${preference ? `;q=${preference}` : ''}`\n  )\n\n/**\n * @param {string} source\n */\nexport const parseAcceptHeader = source =>\n  source\n    .split(',')\n    .map(parseMediaType)\n    .sort((a, b) => b.preference - a.preference)\n\n/**\n * @param {Media[]} source\n */\nexport const formatAcceptHeader = source =>\n  source.map(formatMediaType).join(', ')\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}