{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});","map":{"version":3,"names":[],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\types\\runtime.ts"],"sourcesContent":["import { Artifacts } from \"./artifacts\";\nimport { HardhatConfig, HardhatUserConfig, NetworkConfig } from \"./config\";\nimport { EIP1193Provider, EthereumProvider } from \"./provider\";\n\n/**\n * This class is used to dynamically validate task's argument types.\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport interface ArgumentType<T> {\n  /**\n   * The type's name.\n   */\n  name: string;\n\n  /**\n   * Check if argument value is of type <T>.\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param argumentValue - value to be validated\n   *\n   * @throws HH301 if value is not of type <t>\n   */\n  validate(argName: string, argumentValue: any): void;\n}\n\n/**\n * This is a special case of ArgumentType.\n *\n * These types must have a human-friendly string representation, so that they\n * can be used as command line arguments.\n */\nexport interface CLIArgumentType<T> extends ArgumentType<T> {\n  /**\n   * Parses strValue into T. This function MUST throw HH301 if it\n   * can parse the given value.\n   *\n   * @param argName argument's name - used for context in case of error.\n   * @param strValue argument's string value to be parsed.\n   */\n  parse(argName: string, strValue: string): T;\n}\n\nexport interface ConfigurableTaskDefinition {\n  setDescription(description: string): this;\n\n  setAction(action: ActionType<TaskArguments>): this;\n\n  addParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;\n\n  addOptionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>\n  ): this;\n\n  addPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;\n\n  addOptionalPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T,\n    type?: ArgumentType<T>\n  ): this;\n\n  addVariadicPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T[],\n    type?: ArgumentType<T>,\n    isOptional?: boolean\n  ): this;\n\n  addOptionalVariadicPositionalParam<T>(\n    name: string,\n    description?: string,\n    defaultValue?: T[],\n    type?: ArgumentType<T>\n  ): this;\n\n  addFlag(name: string, description?: string): this;\n}\n\n// type alias to get the overloaded function type\n// for 'task` and 'subtask'\ndeclare function addTask<TaskArgumentsT extends TaskArguments>(\n  name: string,\n  description?: string,\n  action?: ActionType<TaskArgumentsT>\n): ConfigurableTaskDefinition;\ndeclare function addTask<TaskArgumentsT extends TaskArguments>(\n  name: string,\n  action: ActionType<TaskArgumentsT>\n): ConfigurableTaskDefinition;\ntype AddConfigurableTaskFunction = typeof addTask;\n\nexport interface ConfigurableScopeDefinition {\n  setDescription(description: string): this;\n\n  task: AddConfigurableTaskFunction;\n  subtask: AddConfigurableTaskFunction;\n}\n\nexport interface ParamDefinition<T> {\n  name: string;\n  defaultValue?: T;\n  type: ArgumentType<T>;\n  description?: string;\n  isOptional: boolean;\n  isFlag: boolean;\n  isVariadic: boolean;\n}\n\nexport interface OptionalParamDefinition<T> extends ParamDefinition<T> {\n  defaultValue: T;\n  isOptional: true;\n}\n\nexport interface CLIOptionalParamDefinition<T>\n  extends OptionalParamDefinition<T> {\n  type: CLIArgumentType<T>;\n}\n\nexport interface ParamDefinitionsMap {\n  [paramName: string]: ParamDefinition<any>;\n}\n\nexport interface TaskDefinition extends ConfigurableTaskDefinition {\n  readonly scope?: string;\n  readonly name: string;\n  readonly description?: string;\n  readonly action: ActionType<TaskArguments>;\n  readonly isSubtask: boolean;\n\n  // TODO: Rename this to something better. It doesn't include the positional\n  // params, and that's not clear.\n  readonly paramDefinitions: ParamDefinitionsMap;\n\n  readonly positionalParamDefinitions: Array<ParamDefinition<any>>;\n}\n\nexport interface ScopeDefinition extends ConfigurableScopeDefinition {\n  readonly name: string;\n  readonly description?: string;\n  readonly tasks: TasksMap;\n}\n\nexport type TaskIdentifier = string | { scope?: string; task: string };\n\n/**\n * @type TaskArguments {object-like} - the input arguments for a task.\n *\n * TaskArguments type is set to 'any' because it's interface is dynamic.\n * It's impossible in TypeScript to statically specify a variadic\n * number of fields and at the same time define specific types for\\\n * the argument values.\n *\n * For example, we could define:\n * type TaskArguments = Record<string, any>;\n *\n * ...but then, we couldn't narrow the actual argument value's type in compile time,\n * thus we have no other option than forcing it to be just 'any'.\n */\nexport type TaskArguments = any;\n\nexport interface SubtaskArguments {\n  [subtaskName: string]: TaskArguments;\n}\n\nexport interface RunSuperFunction<TaskArgumentsT extends TaskArguments> {\n  (\n    taskArguments?: TaskArgumentsT,\n    subtaskArguments?: SubtaskArguments\n  ): Promise<any>;\n  isDefined: boolean;\n}\n\nexport type ActionType<TaskArgumentsT extends TaskArguments> = (\n  taskArgs: TaskArgumentsT,\n  env: HardhatRuntimeEnvironment,\n  runSuper: RunSuperFunction<TaskArgumentsT>\n) => Promise<any>;\n\nexport interface HardhatArguments {\n  network?: string;\n  showStackTraces: boolean;\n  version: boolean;\n  help: boolean;\n  emoji: boolean;\n  config?: string;\n  verbose: boolean;\n  maxMemory?: number;\n  tsconfig?: string;\n  flamegraph?: boolean;\n  typecheck?: boolean;\n}\n\nexport type HardhatParamDefinitions = {\n  [param in keyof Required<HardhatArguments>]: CLIOptionalParamDefinition<\n    HardhatArguments[param]\n  >;\n};\n\nexport interface TasksMap {\n  [name: string]: TaskDefinition;\n}\n\nexport interface ScopesMap {\n  [scopeName: string]: ScopeDefinition;\n}\n\nexport type RunTaskFunction = (\n  taskIdentifier: TaskIdentifier,\n  taskArguments?: TaskArguments,\n  subtaskArguments?: SubtaskArguments\n) => Promise<any>;\n\nexport interface HardhatRuntimeEnvironment {\n  readonly config: HardhatConfig;\n  readonly userConfig: HardhatUserConfig;\n  readonly hardhatArguments: HardhatArguments;\n  readonly tasks: TasksMap;\n  readonly scopes: ScopesMap;\n  readonly run: RunTaskFunction;\n  readonly network: Network;\n  readonly artifacts: Artifacts;\n  readonly version: string;\n}\n\nexport interface Network {\n  name: string;\n  config: NetworkConfig;\n  provider: EthereumProvider;\n}\n\n/**\n * A function that receives a HardhatRuntimeEnvironment and\n * modify its properties or add new ones.\n */\nexport type EnvironmentExtender = (env: HardhatRuntimeEnvironment) => void;\n\n/**\n * A function that receives a provider, crafts and returns a new one.\n * Adding and modifying the current provider is preferred over ignoring it and returning a new instance.\n */\nexport type ProviderExtender = (\n  provider: EIP1193Provider,\n  config: HardhatConfig,\n  network: string\n) => EIP1193Provider | Promise<EIP1193Provider>;\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}