{"ast":null,"code":"import * as UCAN from '@ipld/dag-ucan';\nimport * as API from '@ucanto/interface';\nimport * as Link from './link.js';\nimport * as DAG from './dag.js';\nimport * as CAR from './car.js';\nimport * as CBOR from './cbor.js';\nimport * as Schema from './schema.js';\nimport { ok, error } from './result.js';\n\n/**\n * @deprecated\n * Import `isLink` from module directly\n */\nexport const isLink = /** @type {(value:API.Proof) => value is API.UCANLink} */\nLink.isLink;\n\n/**\n *\n * @param {API.Proof} proof\n * @return {proof is API.Delegation}\n */\nexport const isDelegation = proof => !Link.isLink(proof);\n\n/**\n * Takes one or more delegations and returns all delegated capabilities in\n * UCAN 0.10 format, expanding all the special forms like `with: ucan:*` and\n * `can: *` to explicit forms.\n *\n * Note that this function only considers included proofs and ignores linked\n * proofs. It is up to the user of this function to resolve whatever proofs it\n * needs and build delegation with them before calling this function.\n *\n * Also note that this function does not validate the delegations and may\n * produce result containing capabilities that escalate, which for the validator\n * perspective is no different from not including such capabilities.\n *\n * @template {[API.Delegation, ...API.Delegation[]]} T\n * @param {T} delegations\n * @returns {API.InferAllowedFromDelegations<T>}\n */\nexport const allows = (...delegations) => {\n  /** @type {API.Allows} */\n  let allow = {};\n  for (const delegation of delegations) {\n    for (const {\n      with: uri,\n      can,\n      nb\n    } of iterateCapabilities(delegation)) {\n      const resource = allow[uri] || (allow[uri] = {});\n      const abilities = resource[can] || (resource[can] = []);\n      abilities.push({\n        ...nb\n      });\n    }\n  }\n  return /** @type {API.InferAllowedFromDelegations<T>} */allow;\n};\n\n/**\n * Function takes a delegation and iterates over all the capabilities expanding\n * all the special forms like `with: ucan:*` and `can: *`.\n *\n * Note that this function only considers proofs that are included in the\n * delegation, linked proofs will not be resolved nor considered. It is up to\n * the user of this function to resolve whatever proofs it needs to consider\n * before calling this function.\n *\n * @param {API.Delegation} delegation\n * @returns {Iterable<API.Capability>}\n */\nconst iterateCapabilities = function* ({\n  issuer,\n  capabilities,\n  proofs\n}) {\n  for (const own of capabilities) {\n    // If `with` field is set to  `ucan:*` it implies re-delegation of all own\n    // and delegated capabilities.\n    if (own.with === 'ucan:*') {\n      // Fist we include own capabilities. Note that we can not expand `can`\n      // because it implicitly covers all possible options in the universe.\n      yield {\n        ...own,\n        with: issuer.did()\n      };\n\n      // Next we iterate over all delegated capabilities including ones that\n      // match ability in the `own.can` field.\n      for (const proof of proofs) {\n        // We only consider proofs that are included and ignore linked proofs.\n        if (isDelegation(proof)) {\n          for (const capability of iterateCapabilities(proof)) {\n            // We attempt to match `capability.can` against `own.can` field\n            // if there is a match we include the capability otherwise we skip\n            const can = matchAbility(capability.can, own.can);\n            if (can) {\n              yield {\n                ...capability,\n                can,\n                // We do not know capability semantics so it is impossible\n                // for us to eliminate capabilities that do not satisfy imposed\n                // caveats (`own.nb`). Therefore we optimistically assume that\n                // `own.nb` further constraints `capability.nb` and do a shallow\n                // merge of the two. As a result we may include capabilities\n                // that during validation will be considered invalid due to\n                // constraint violations. While that is not ideal validator\n                // will treat them as if they were omitted and therefore it\n                // is a reasonable compromise.\n                nb: {\n                  ...capability.nb,\n                  ...Object(own.nb)\n                }\n              };\n            }\n          }\n        }\n      }\n    } else {\n      yield own;\n    }\n  }\n};\n\n/**\n * Function takes `can` field from the delegated capability and attempts to\n * match it against `can` field of the claimed capability. If there is a match\n * the function returns more specific `can` field of two, otherwise it returns\n * `null`.\n *\n * @param {API.Ability} provided\n * @param {API.Ability} claimed\n */\nconst matchAbility = (provided, claimed) => {\n  // If provided capability delegates all abilities we can derive any `can`\n  // from it so we return `claimed` as is.\n  if (provided === '*') {\n    return claimed;\n  }\n  // If claimed capability delegates all abilities that includes any `can`\n  // so we return `provided` as is.\n  if (claimed === '*') {\n    return provided;\n  }\n  // If claimed `can` is a pattern that includes `provided` `can` we return\n  // `provided` as is.\n  if (claimed.endsWith('/*') && provided.startsWith(claimed.slice(0, -1))) {\n    return provided;\n  }\n  // If provided `can` is a pattern that includes `claimed` `can` we can derive\n  // `claimed` from it so we return `claimed` as is.\n  if (provided.endsWith('/*') && claimed.startsWith(provided.slice(0, -1))) {\n    return claimed;\n  }\n  // If `can` fields are concrete and the same we have a match and can return it.\n  if (provided === claimed) {\n    return provided;\n  }\n  // otherwise two are incompatible and we return null.\n  return null;\n};\n\n/**\n * Represents UCAN chain view over the set of DAG UCAN nodes. You can think of\n * this as UCAN interface of the CAR.\n *\n * @template {API.Capabilities} C\n * @implements {API.Delegation<C>}\n * @extends {DelegationView<C>}\n */\nexport class Delegation {\n  /**\n   * @param {API.UCANBlock<C>} root\n   * @param {DAG.BlockStore} [blocks]\n   */\n  constructor(root, blocks = new Map()) {\n    this.root = root;\n    this.blocks = blocks;\n    Object.defineProperties(this, {\n      blocks: {\n        enumerable: false\n      }\n    });\n  }\n\n  /**\n   * @returns {API.AttachedLinkSet}\n   */\n  get attachedLinks() {\n    const _attachedLinks = new Set();\n    const ucanView = this.data;\n\n    // Get links from capabilities nb\n    for (const capability of ucanView.capabilities) {\n      /** @type {Link[]} */\n      const links = getLinksFromObject(capability);\n      for (const link of links) {\n        _attachedLinks.add(`${link}`);\n      }\n    }\n\n    // Get links from facts values\n    for (const fact of ucanView.facts) {\n      if (Link.isLink(fact)) {\n        _attachedLinks.add(`${fact}`);\n      } else {\n        /** @type {Link[]} */\n        // @ts-expect-error isLink does not infer value type\n        const links = Object.values(fact).filter(e => Link.isLink(e));\n        for (const link of links) {\n          _attachedLinks.add(`${link}`);\n        }\n      }\n    }\n    return _attachedLinks;\n  }\n  get version() {\n    return this.data.version;\n  }\n  get signature() {\n    return this.data.signature;\n  }\n  get cid() {\n    return this.root.cid;\n  }\n  link() {\n    return this.root.cid;\n  }\n  get asCID() {\n    return this.cid;\n  }\n  get bytes() {\n    return this.root.bytes;\n  }\n  get data() {\n    const data = decode(this.root);\n    Object.defineProperties(this, {\n      data: {\n        value: data,\n        enumerable: false\n      }\n    });\n    return data;\n  }\n  /**\n   * Attach a block to the delegation DAG so it would be included in the\n   * block iterator.\n   * ⚠️ You can only attach blocks that are referenced from the `capabilities`\n   * or `facts`.\n   *\n   * @param {API.Block} block\n   */\n  attach(block) {\n    if (!this.attachedLinks.has(`${block.cid.link()}`)) {\n      throw new Error(`given block with ${block.cid} is not an attached link`);\n    }\n    this.blocks.set(`${block.cid}`, block);\n  }\n  export() {\n    return exportDAG(this.root, this.blocks, this.attachedLinks);\n  }\n\n  /**\n   * @returns {API.Await<API.Result<Uint8Array, Error>>}\n   */\n  archive() {\n    return archive(this);\n  }\n  iterateIPLDBlocks() {\n    return exportDAG(this.root, this.blocks, this.attachedLinks);\n  }\n\n  /**\n   * @type {API.Proof[]}\n   */\n  get proofs() {\n    return proofs(this);\n  }\n\n  /**\n   * @type {API.Principal}\n   */\n  get issuer() {\n    return this.data.issuer;\n  }\n\n  /**\n   * @type {API.Principal}\n   */\n  get audience() {\n    return this.data.audience;\n  }\n\n  /**\n   * @returns {C}\n   */\n  get capabilities() {\n    return /** @type {C} */this.data.capabilities;\n  }\n\n  /**\n   * @returns {number}\n   */\n  get expiration() {\n    return this.data.expiration;\n  }\n\n  /**\n   * @returns {undefined|number}\n   */\n  get notBefore() {\n    return this.data.notBefore;\n  }\n\n  /**\n   * @returns {undefined|string}\n   */\n\n  get nonce() {\n    return this.data.nonce;\n  }\n\n  /**\n   * @returns {API.Fact[]}\n   */\n  get facts() {\n    return this.data.facts;\n  }\n\n  /**\n   * Iterate over the proofs\n   *\n   * @returns {IterableIterator<API.Delegation>}\n   */\n  iterate() {\n    return it(this);\n  }\n  delegate() {\n    return this;\n  }\n  buildIPLDView() {\n    return this;\n  }\n\n  /**\n   * @returns {API.DelegationJSON<this>}\n   */\n  toJSON() {\n    return /** @type {any} */{\n      ...this.data.toJSON(),\n      '/': this.cid.toString(),\n      prf: this.proofs.map(proof => isDelegation(proof) ? proof : {\n        '/': proof.toString()\n      })\n    };\n  }\n}\n\n/**\n * Writes given `Delegation` chain into a content addressed archive (CAR)\n * buffer and returns it.\n *\n * @param {API.Delegation} delegation}\n * @returns {Promise<API.Result<Uint8Array, Error>>}\n */\nexport const archive = async delegation => {\n  try {\n    // Iterate over all of the blocks in the DAG and add them to the\n    // block store.\n    const store = new Map();\n    for (const block of delegation.iterateIPLDBlocks()) {\n      store.set(`${block.cid}`, block);\n    }\n\n    // Then we we create a descriptor block to describe what this DAG represents\n    // and it to the block store as well.\n    const variant = await CBOR.write({\n      [`ucan@${delegation.version}`]: delegation.root.cid\n    });\n    store.set(`${variant.cid}`, variant);\n\n    // And finally we encode the whole thing into a CAR.\n    const bytes = CAR.encode({\n      roots: [variant],\n      blocks: store\n    });\n    return ok(bytes);\n  } catch (cause) {\n    return error( /** @type {Error} */cause);\n  }\n};\nexport const ArchiveSchema = Schema.variant({\n  'ucan@0.9.1': ( /** @type {Schema.Schema<API.UCANLink>} */\n  Schema.link({\n    version: 1\n  }))\n});\n\n/**\n * Extracts a `Delegation` chain from a given content addressed archive (CAR)\n * buffer. Assumes that the CAR contains a single root block corresponding to\n * the delegation variant.\n *\n * @param {Uint8Array} archive\n */\nexport const extract = async archive => {\n  try {\n    const {\n      roots,\n      blocks\n    } = CAR.decode(archive);\n    const [root] = roots;\n    if (root == null) {\n      return Schema.error('CAR archive does not contain a root block');\n    }\n    const {\n      bytes\n    } = root;\n    const variant = CBOR.decode(bytes);\n    const [, link] = ArchiveSchema.match(variant);\n    return ok(view({\n      root: link,\n      blocks\n    }));\n  } catch (cause) {\n    return error( /** @type {Error} */cause);\n  }\n};\n\n/**\n * @param {API.Delegation} delegation\n * @returns {IterableIterator<API.Delegation>}\n */\nconst it = function* (delegation) {\n  for (const proof of delegation.proofs) {\n    if (isDelegation(proof)) {\n      yield* it(proof);\n      yield proof;\n    }\n  }\n};\nconst decodeCache = new WeakMap();\n/**\n * @template {API.Capabilities} C\n * @param {API.UCANBlock<C>} block\n * @returns {UCAN.View<C>}\n */\nconst decode = ({\n  bytes\n}) => {\n  const data = decodeCache.get(bytes);\n  if (!data) {\n    const data = UCAN.decode(bytes);\n    decodeCache.set(bytes, data);\n    return data;\n  }\n  return data;\n};\n\n/**\n * Creates a new signed token with a given `options.issuer`. If expiration is\n * not set it defaults to 30 seconds from now. Returns UCAN in primary - IPLD\n * representation.\n *\n * @template {API.Capabilities} C\n * @param {API.DelegationOptions<C>} data\n * @param {API.EncodeOptions} [options]\n * @returns {Promise<API.Delegation<C>>}\n */\n\nexport const delegate = async ({\n  issuer,\n  audience,\n  proofs = [],\n  attachedBlocks = new Map(),\n  ...input\n}, options) => {\n  const links = [];\n  const blocks = new Map();\n  for (const proof of proofs) {\n    if (!isDelegation(proof)) {\n      links.push(proof);\n    } else {\n      links.push(proof.cid);\n      for (const block of proof.export()) {\n        blocks.set(block.cid.toString(), block);\n      }\n    }\n  }\n  const data = await UCAN.issue({\n    ...input,\n    issuer,\n    audience,\n    proofs: links\n  });\n  const {\n    cid,\n    bytes\n  } = await UCAN.write(data, options);\n  decodeCache.set(cid, data);\n\n  /** @type {API.Delegation<C>} */\n  const delegation = new Delegation({\n    cid,\n    bytes\n  }, blocks);\n  Object.defineProperties(delegation, {\n    proofs: {\n      value: proofs\n    }\n  });\n  for (const block of attachedBlocks.values()) {\n    delegation.attach(block);\n  }\n  return delegation;\n};\n\n/**\n * @template {API.Capabilities} C\n * @param {API.UCANBlock<C>} root\n * @param {DAG.BlockStore} blocks\n * @param {API.AttachedLinkSet} attachedLinks\n * @returns {IterableIterator<API.Block>}\n */\n\nexport const exportDAG = function* (root, blocks, attachedLinks) {\n  for (const link of decode(root).proofs) {\n    // Check if block is included in this delegation\n    const root = /** @type {UCAN.Block} */blocks.get(`${link}`);\n    if (root) {\n      yield* exportSubDAG(root, blocks);\n    }\n  }\n  for (const link of attachedLinks.values()) {\n    const block = blocks.get(link);\n    if (block) {\n      // @ts-expect-error can get blocks with v0 and v1\n      yield block;\n    }\n  }\n  yield root;\n};\n\n/**\n * @template {API.Capabilities} C\n * @param {API.UCANBlock<C>} root\n * @param {DAG.BlockStore} blocks\n * @returns {IterableIterator<API.Block>}\n */\nconst exportSubDAG = function* (root, blocks) {\n  for (const link of decode(root).proofs) {\n    // Check if block is included in this delegation\n    const root = /** @type {UCAN.Block} */blocks.get(`${link}`);\n    if (root) {\n      yield* exportSubDAG(root, blocks);\n    }\n  }\n  yield root;\n};\n\n/**\n * @template {API.Capabilities} C\n * @param {Iterable<API.Block>} dag\n * @returns {API.Delegation<C>}\n */\nexport const importDAG = dag => {\n  /** @type {Array<[string, API.Block]>} */\n  let entries = [];\n  for (const block of dag) {\n    entries.push([block.cid.toString(), block]);\n  }\n  const last = entries.pop();\n  if (!last) {\n    throw new RangeError('Empty DAG can not be turned into a delegation');\n  } else {\n    const [, root] = last;\n    return new Delegation( /** @type {API.UCANBlock<C>} */root, new Map(entries));\n  }\n};\n\n/**\n * @template {API.Capabilities} C\n * @param {object} dag\n * @param {API.UCANBlock<C>} dag.root\n * @param {DAG.BlockStore} [dag.blocks]\n * @returns {API.Delegation<C>}\n */\nexport const create = ({\n  root,\n  blocks\n}) => new Delegation(root, blocks);\n\n/**\n * @template {API.Capabilities} C\n * @template [E=never]\n * @param {object} dag\n * @param {API.UCANLink<C>} dag.root\n * @param {DAG.BlockStore} dag.blocks\n * @param {E} [fallback]\n * @returns {API.Delegation<C>|E}\n */\nexport const view = ({\n  root,\n  blocks\n}, fallback) => {\n  const block = DAG.get(root, blocks, null);\n  if (block == null) {\n    return fallback !== undefined ? fallback : DAG.notFound(root);\n  }\n  return create({\n    root: block,\n    blocks\n  });\n};\n\n/**\n * @param {API.Delegation} delegation\n */\nconst proofs = delegation => {\n  /** @type {API.Proof[]} */\n  const proofs = [];\n  const {\n    root,\n    blocks\n  } = delegation;\n  // Iterate over proof links and materialize Delegation views.\n  for (const link of decode(root).proofs) {\n    // Check if linked proof is included in our blocks if so create delegation\n    // view otherwise use a link\n    const root = /** @type {UCAN.Block} */blocks.get(link.toString());\n    proofs.push(root ? create({\n      root,\n      blocks\n    }) : link);\n  }\n\n  // we cache result of this computation as this property may get accessed\n  // more than once.\n  Object.defineProperty(delegation, 'proofs', {\n    value: proofs\n  });\n  return proofs;\n};\n\n/**\n * @param {API.Capability<API.Ability, `${string}:${string}`, unknown>} obj\n */\nfunction getLinksFromObject(obj) {\n  /** @type {Link[]} */\n  const links = [];\n\n  /**\n   * @param {object} obj\n   */\n  function recurse(obj) {\n    for (const key in obj) {\n      // @ts-expect-error record type not inferred\n      const value = obj[key];\n      if (Link.isLink(value)) {\n        // @ts-expect-error isLink does not infer value type\n        links.push(value);\n      } else if (value && typeof value === 'object') {\n        recurse(value);\n      }\n    }\n  }\n  recurse(obj);\n  return links;\n}\nexport { Delegation as View };","map":{"version":3,"names":["UCAN","API","Link","DAG","CAR","CBOR","Schema","ok","error","isLink","isDelegation","proof","allows","delegations","allow","delegation","with","uri","can","nb","iterateCapabilities","resource","abilities","push","issuer","capabilities","proofs","own","did","capability","matchAbility","Object","provided","claimed","endsWith","startsWith","slice","Delegation","constructor","root","blocks","Map","defineProperties","enumerable","attachedLinks","_attachedLinks","Set","ucanView","data","links","getLinksFromObject","link","add","fact","facts","values","filter","e","version","signature","cid","asCID","bytes","decode","value","attach","block","has","Error","set","export","exportDAG","archive","iterateIPLDBlocks","audience","expiration","notBefore","nonce","iterate","it","delegate","buildIPLDView","toJSON","toString","prf","map","store","variant","write","encode","roots","cause","ArchiveSchema","extract","match","view","decodeCache","WeakMap","get","attachedBlocks","input","options","issue","exportSubDAG","importDAG","dag","entries","last","pop","RangeError","create","fallback","undefined","notFound","defineProperty","obj","recurse","key","View"],"sources":["C:/FACULTATE/Proiect/node_modules/@ucanto/core/src/delegation.js"],"sourcesContent":["import * as UCAN from '@ipld/dag-ucan'\nimport * as API from '@ucanto/interface'\nimport * as Link from './link.js'\nimport * as DAG from './dag.js'\nimport * as CAR from './car.js'\nimport * as CBOR from './cbor.js'\nimport * as Schema from './schema.js'\nimport { ok, error } from './result.js'\n\n/**\n * @deprecated\n * Import `isLink` from module directly\n */\nexport const isLink =\n  /** @type {(value:API.Proof) => value is API.UCANLink} */\n  (Link.isLink)\n\n/**\n *\n * @param {API.Proof} proof\n * @return {proof is API.Delegation}\n */\nexport const isDelegation = proof => !Link.isLink(proof)\n\n/**\n * Takes one or more delegations and returns all delegated capabilities in\n * UCAN 0.10 format, expanding all the special forms like `with: ucan:*` and\n * `can: *` to explicit forms.\n *\n * Note that this function only considers included proofs and ignores linked\n * proofs. It is up to the user of this function to resolve whatever proofs it\n * needs and build delegation with them before calling this function.\n *\n * Also note that this function does not validate the delegations and may\n * produce result containing capabilities that escalate, which for the validator\n * perspective is no different from not including such capabilities.\n *\n * @template {[API.Delegation, ...API.Delegation[]]} T\n * @param {T} delegations\n * @returns {API.InferAllowedFromDelegations<T>}\n */\nexport const allows = (...delegations) => {\n  /** @type {API.Allows} */\n  let allow = {}\n  for (const delegation of delegations) {\n    for (const { with: uri, can, nb } of iterateCapabilities(delegation)) {\n      const resource = allow[uri] || (allow[uri] = {})\n      const abilities = resource[can] || (resource[can] = [])\n      abilities.push({ ...nb })\n    }\n  }\n\n  return /** @type {API.InferAllowedFromDelegations<T>} */ (allow)\n}\n\n/**\n * Function takes a delegation and iterates over all the capabilities expanding\n * all the special forms like `with: ucan:*` and `can: *`.\n *\n * Note that this function only considers proofs that are included in the\n * delegation, linked proofs will not be resolved nor considered. It is up to\n * the user of this function to resolve whatever proofs it needs to consider\n * before calling this function.\n *\n * @param {API.Delegation} delegation\n * @returns {Iterable<API.Capability>}\n */\nconst iterateCapabilities = function* ({ issuer, capabilities, proofs }) {\n  for (const own of capabilities) {\n    // If `with` field is set to  `ucan:*` it implies re-delegation of all own\n    // and delegated capabilities.\n    if (own.with === 'ucan:*') {\n      // Fist we include own capabilities. Note that we can not expand `can`\n      // because it implicitly covers all possible options in the universe.\n      yield {\n        ...own,\n        with: issuer.did(),\n      }\n\n      // Next we iterate over all delegated capabilities including ones that\n      // match ability in the `own.can` field.\n      for (const proof of proofs) {\n        // We only consider proofs that are included and ignore linked proofs.\n        if (isDelegation(proof)) {\n          for (const capability of iterateCapabilities(proof)) {\n            // We attempt to match `capability.can` against `own.can` field\n            // if there is a match we include the capability otherwise we skip\n            const can = matchAbility(capability.can, own.can)\n            if (can) {\n              yield {\n                ...capability,\n                can,\n                // We do not know capability semantics so it is impossible\n                // for us to eliminate capabilities that do not satisfy imposed\n                // caveats (`own.nb`). Therefore we optimistically assume that\n                // `own.nb` further constraints `capability.nb` and do a shallow\n                // merge of the two. As a result we may include capabilities\n                // that during validation will be considered invalid due to\n                // constraint violations. While that is not ideal validator\n                // will treat them as if they were omitted and therefore it\n                // is a reasonable compromise.\n                nb: { ...capability.nb, ...Object(own.nb) },\n              }\n            }\n          }\n        }\n      }\n    } else {\n      yield own\n    }\n  }\n}\n\n/**\n * Function takes `can` field from the delegated capability and attempts to\n * match it against `can` field of the claimed capability. If there is a match\n * the function returns more specific `can` field of two, otherwise it returns\n * `null`.\n *\n * @param {API.Ability} provided\n * @param {API.Ability} claimed\n */\nconst matchAbility = (provided, claimed) => {\n  // If provided capability delegates all abilities we can derive any `can`\n  // from it so we return `claimed` as is.\n  if (provided === '*') {\n    return claimed\n  }\n  // If claimed capability delegates all abilities that includes any `can`\n  // so we return `provided` as is.\n  if (claimed === '*') {\n    return provided\n  }\n  // If claimed `can` is a pattern that includes `provided` `can` we return\n  // `provided` as is.\n  if (claimed.endsWith('/*') && provided.startsWith(claimed.slice(0, -1))) {\n    return provided\n  }\n  // If provided `can` is a pattern that includes `claimed` `can` we can derive\n  // `claimed` from it so we return `claimed` as is.\n  if (provided.endsWith('/*') && claimed.startsWith(provided.slice(0, -1))) {\n    return claimed\n  }\n  // If `can` fields are concrete and the same we have a match and can return it.\n  if (provided === claimed) {\n    return provided\n  }\n  // otherwise two are incompatible and we return null.\n  return null\n}\n\n/**\n * Represents UCAN chain view over the set of DAG UCAN nodes. You can think of\n * this as UCAN interface of the CAR.\n *\n * @template {API.Capabilities} C\n * @implements {API.Delegation<C>}\n * @extends {DelegationView<C>}\n */\nexport class Delegation {\n  /**\n   * @param {API.UCANBlock<C>} root\n   * @param {DAG.BlockStore} [blocks]\n   */\n  constructor(root, blocks = new Map()) {\n    this.root = root\n    this.blocks = blocks\n\n    Object.defineProperties(this, {\n      blocks: {\n        enumerable: false,\n      },\n    })\n  }\n\n  /**\n   * @returns {API.AttachedLinkSet}\n   */\n  get attachedLinks() {\n    const _attachedLinks = new Set()\n    const ucanView = this.data\n\n    // Get links from capabilities nb\n    for (const capability of ucanView.capabilities) {\n      /** @type {Link[]} */\n      const links = getLinksFromObject(capability)\n\n      for (const link of links) {\n        _attachedLinks.add(`${link}`)\n      }\n    }\n\n    // Get links from facts values\n    for (const fact of ucanView.facts) {\n      if (Link.isLink(fact)) {\n        _attachedLinks.add(`${fact}`)\n      } else {\n        /** @type {Link[]} */\n        // @ts-expect-error isLink does not infer value type\n        const links = Object.values(fact).filter(e => Link.isLink(e))\n\n        for (const link of links) {\n          _attachedLinks.add(`${link}`)\n        }\n      }\n    }\n\n    return _attachedLinks\n  }\n\n  get version() {\n    return this.data.version\n  }\n  get signature() {\n    return this.data.signature\n  }\n  get cid() {\n    return this.root.cid\n  }\n  link() {\n    return this.root.cid\n  }\n  get asCID() {\n    return this.cid\n  }\n  get bytes() {\n    return this.root.bytes\n  }\n  get data() {\n    const data = decode(this.root)\n    Object.defineProperties(this, { data: { value: data, enumerable: false } })\n    return data\n  }\n  /**\n   * Attach a block to the delegation DAG so it would be included in the\n   * block iterator.\n   * ⚠️ You can only attach blocks that are referenced from the `capabilities`\n   * or `facts`.\n   *\n   * @param {API.Block} block\n   */\n  attach(block) {\n    if (!this.attachedLinks.has(`${block.cid.link()}`)) {\n      throw new Error(`given block with ${block.cid} is not an attached link`)\n    }\n    this.blocks.set(`${block.cid}`, block)\n  }\n  export() {\n    return exportDAG(this.root, this.blocks, this.attachedLinks)\n  }\n\n  /**\n   * @returns {API.Await<API.Result<Uint8Array, Error>>}\n   */\n  archive() {\n    return archive(this)\n  }\n\n  iterateIPLDBlocks() {\n    return exportDAG(this.root, this.blocks, this.attachedLinks)\n  }\n\n  /**\n   * @type {API.Proof[]}\n   */\n  get proofs() {\n    return proofs(this)\n  }\n\n  /**\n   * @type {API.Principal}\n   */\n  get issuer() {\n    return this.data.issuer\n  }\n\n  /**\n   * @type {API.Principal}\n   */\n  get audience() {\n    return this.data.audience\n  }\n\n  /**\n   * @returns {C}\n   */\n  get capabilities() {\n    return /** @type {C} */ (this.data.capabilities)\n  }\n\n  /**\n   * @returns {number}\n   */\n  get expiration() {\n    return this.data.expiration\n  }\n\n  /**\n   * @returns {undefined|number}\n   */\n  get notBefore() {\n    return this.data.notBefore\n  }\n\n  /**\n   * @returns {undefined|string}\n   */\n\n  get nonce() {\n    return this.data.nonce\n  }\n\n  /**\n   * @returns {API.Fact[]}\n   */\n  get facts() {\n    return this.data.facts\n  }\n\n  /**\n   * Iterate over the proofs\n   *\n   * @returns {IterableIterator<API.Delegation>}\n   */\n  iterate() {\n    return it(this)\n  }\n\n  delegate() {\n    return this\n  }\n\n  buildIPLDView() {\n    return this\n  }\n\n  /**\n   * @returns {API.DelegationJSON<this>}\n   */\n  toJSON() {\n    return /** @type {any} */ ({\n      ...this.data.toJSON(),\n      '/': this.cid.toString(),\n      prf: this.proofs.map(proof =>\n        isDelegation(proof) ? proof : { '/': proof.toString() }\n      ),\n    })\n  }\n}\n\n/**\n * Writes given `Delegation` chain into a content addressed archive (CAR)\n * buffer and returns it.\n *\n * @param {API.Delegation} delegation}\n * @returns {Promise<API.Result<Uint8Array, Error>>}\n */\nexport const archive = async delegation => {\n  try {\n    // Iterate over all of the blocks in the DAG and add them to the\n    // block store.\n    const store = new Map()\n    for (const block of delegation.iterateIPLDBlocks()) {\n      store.set(`${block.cid}`, block)\n    }\n\n    // Then we we create a descriptor block to describe what this DAG represents\n    // and it to the block store as well.\n    const variant = await CBOR.write({\n      [`ucan@${delegation.version}`]: delegation.root.cid,\n    })\n    store.set(`${variant.cid}`, variant)\n\n    // And finally we encode the whole thing into a CAR.\n    const bytes = CAR.encode({\n      roots: [variant],\n      blocks: store,\n    })\n\n    return ok(bytes)\n  } catch (cause) {\n    return error(/** @type {Error} */ (cause))\n  }\n}\n\nexport const ArchiveSchema = Schema.variant({\n  'ucan@0.9.1': /** @type {Schema.Schema<API.UCANLink>} */ (\n    Schema.link({ version: 1 })\n  ),\n})\n\n/**\n * Extracts a `Delegation` chain from a given content addressed archive (CAR)\n * buffer. Assumes that the CAR contains a single root block corresponding to\n * the delegation variant.\n *\n * @param {Uint8Array} archive\n */\nexport const extract = async archive => {\n  try {\n    const { roots, blocks } = CAR.decode(archive)\n    const [root] = roots\n    if (root == null) {\n      return Schema.error('CAR archive does not contain a root block')\n    }\n    const { bytes } = root\n    const variant = CBOR.decode(bytes)\n    const [, link] = ArchiveSchema.match(variant)\n    return ok(view({ root: link, blocks }))\n  } catch (cause) {\n    return error(/** @type {Error} */ (cause))\n  }\n}\n\n/**\n * @param {API.Delegation} delegation\n * @returns {IterableIterator<API.Delegation>}\n */\nconst it = function* (delegation) {\n  for (const proof of delegation.proofs) {\n    if (isDelegation(proof)) {\n      yield* it(proof)\n      yield proof\n    }\n  }\n}\n\nconst decodeCache = new WeakMap()\n/**\n * @template {API.Capabilities} C\n * @param {API.UCANBlock<C>} block\n * @returns {UCAN.View<C>}\n */\nconst decode = ({ bytes }) => {\n  const data = decodeCache.get(bytes)\n  if (!data) {\n    const data = UCAN.decode(bytes)\n    decodeCache.set(bytes, data)\n    return data\n  }\n  return data\n}\n\n/**\n * Creates a new signed token with a given `options.issuer`. If expiration is\n * not set it defaults to 30 seconds from now. Returns UCAN in primary - IPLD\n * representation.\n *\n * @template {API.Capabilities} C\n * @param {API.DelegationOptions<C>} data\n * @param {API.EncodeOptions} [options]\n * @returns {Promise<API.Delegation<C>>}\n */\n\nexport const delegate = async (\n  { issuer, audience, proofs = [], attachedBlocks = new Map(), ...input },\n  options\n) => {\n  const links = []\n  const blocks = new Map()\n  for (const proof of proofs) {\n    if (!isDelegation(proof)) {\n      links.push(proof)\n    } else {\n      links.push(proof.cid)\n      for (const block of proof.export()) {\n        blocks.set(block.cid.toString(), block)\n      }\n    }\n  }\n\n  const data = await UCAN.issue({\n    ...input,\n    issuer,\n    audience,\n    proofs: links,\n  })\n  const { cid, bytes } = await UCAN.write(data, options)\n  decodeCache.set(cid, data)\n\n  /** @type {API.Delegation<C>} */\n  const delegation = new Delegation({ cid, bytes }, blocks)\n  Object.defineProperties(delegation, { proofs: { value: proofs } })\n\n  for (const block of attachedBlocks.values()) {\n    delegation.attach(block)\n  }\n\n  return delegation\n}\n\n/**\n * @template {API.Capabilities} C\n * @param {API.UCANBlock<C>} root\n * @param {DAG.BlockStore} blocks\n * @param {API.AttachedLinkSet} attachedLinks\n * @returns {IterableIterator<API.Block>}\n */\n\nexport const exportDAG = function* (root, blocks, attachedLinks) {\n  for (const link of decode(root).proofs) {\n    // Check if block is included in this delegation\n    const root = /** @type {UCAN.Block} */ (blocks.get(`${link}`))\n    if (root) {\n      yield* exportSubDAG(root, blocks)\n    }\n  }\n\n  for (const link of attachedLinks.values()) {\n    const block = blocks.get(link)\n\n    if (block) {\n      // @ts-expect-error can get blocks with v0 and v1\n      yield block\n    }\n  }\n\n  yield root\n}\n\n/**\n * @template {API.Capabilities} C\n * @param {API.UCANBlock<C>} root\n * @param {DAG.BlockStore} blocks\n * @returns {IterableIterator<API.Block>}\n */\nconst exportSubDAG = function* (root, blocks) {\n  for (const link of decode(root).proofs) {\n    // Check if block is included in this delegation\n    const root = /** @type {UCAN.Block} */ (blocks.get(`${link}`))\n    if (root) {\n      yield* exportSubDAG(root, blocks)\n    }\n  }\n\n  yield root\n}\n\n/**\n * @template {API.Capabilities} C\n * @param {Iterable<API.Block>} dag\n * @returns {API.Delegation<C>}\n */\nexport const importDAG = dag => {\n  /** @type {Array<[string, API.Block]>} */\n  let entries = []\n  for (const block of dag) {\n    entries.push([block.cid.toString(), block])\n  }\n\n  const last = entries.pop()\n  if (!last) {\n    throw new RangeError('Empty DAG can not be turned into a delegation')\n  } else {\n    const [, root] = last\n\n    return new Delegation(\n      /** @type {API.UCANBlock<C>} */ (root),\n      new Map(entries)\n    )\n  }\n}\n\n/**\n * @template {API.Capabilities} C\n * @param {object} dag\n * @param {API.UCANBlock<C>} dag.root\n * @param {DAG.BlockStore} [dag.blocks]\n * @returns {API.Delegation<C>}\n */\nexport const create = ({ root, blocks }) => new Delegation(root, blocks)\n\n/**\n * @template {API.Capabilities} C\n * @template [E=never]\n * @param {object} dag\n * @param {API.UCANLink<C>} dag.root\n * @param {DAG.BlockStore} dag.blocks\n * @param {E} [fallback]\n * @returns {API.Delegation<C>|E}\n */\nexport const view = ({ root, blocks }, fallback) => {\n  const block = DAG.get(root, blocks, null)\n  if (block == null) {\n    return fallback !== undefined ? fallback : DAG.notFound(root)\n  }\n  return create({ root: block, blocks })\n}\n\n/**\n * @param {API.Delegation} delegation\n */\nconst proofs = delegation => {\n  /** @type {API.Proof[]} */\n  const proofs = []\n  const { root, blocks } = delegation\n  // Iterate over proof links and materialize Delegation views.\n  for (const link of decode(root).proofs) {\n    // Check if linked proof is included in our blocks if so create delegation\n    // view otherwise use a link\n    const root = /** @type {UCAN.Block} */ (blocks.get(link.toString()))\n    proofs.push(root ? create({ root, blocks }) : link)\n  }\n\n  // we cache result of this computation as this property may get accessed\n  // more than once.\n  Object.defineProperty(delegation, 'proofs', { value: proofs })\n  return proofs\n}\n\n/**\n * @param {API.Capability<API.Ability, `${string}:${string}`, unknown>} obj\n */\nfunction getLinksFromObject(obj) {\n  /** @type {Link[]} */\n  const links = []\n\n  /**\n   * @param {object} obj\n   */\n  function recurse(obj) {\n    for (const key in obj) {\n      // @ts-expect-error record type not inferred\n      const value = obj[key]\n      if (Link.isLink(value)) {\n        // @ts-expect-error isLink does not infer value type\n        links.push(value)\n      } else if (value && typeof value === 'object') {\n        recurse(value)\n      }\n    }\n  }\n\n  recurse(obj)\n\n  return links\n}\n\nexport { Delegation as View }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}