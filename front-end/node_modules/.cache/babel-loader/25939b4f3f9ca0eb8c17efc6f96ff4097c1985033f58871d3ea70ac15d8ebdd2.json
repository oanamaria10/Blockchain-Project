{"ast":null,"code":"/**\n * @template {string|boolean|number|[unknown, ...unknown[]]} T\n * @param {T} value\n * @returns {T}\n */\nexport const the = value => value;\n\n/**\n * @template {{}} O\n * @param {O} object\n * @returns {({ [K in keyof O]: [K, O[K]][] }[keyof O])|[[never, never]]}\n */\n\nexport const entries = object => ( /** @type {any} */Object.entries(object));\n\n/**\n * @template T\n * @param {T[][]} dataset\n * @returns {T[][]}\n */\nexport const combine = ([first, ...rest]) => {\n  const results = first.map(value => [value]);\n  for (const values of rest) {\n    const tuples = results.splice(0);\n    for (const value of values) {\n      for (const tuple of tuples) {\n        results.push([...tuple, value]);\n      }\n    }\n  }\n  return results;\n};\n\n/**\n * @template T\n * @param {T[]} left\n * @param {T[]} right\n * @returns {T[]}\n */\nexport const intersection = (left, right) => {\n  const [result, other] = left.length < right.length ? [new Set(left), new Set(right)] : [new Set(right), new Set(left)];\n  for (const item of result) {\n    if (!other.has(item)) {\n      result.delete(item);\n    }\n  }\n  return [...result];\n};","map":{"version":3,"names":["the","value","entries","object","Object","combine","first","rest","results","map","values","tuples","splice","tuple","push","intersection","left","right","result","other","length","Set","item","has","delete"],"sources":["C:/FACULTATE/Proiect/node_modules/@ucanto/validator/src/util.js"],"sourcesContent":["/**\n * @template {string|boolean|number|[unknown, ...unknown[]]} T\n * @param {T} value\n * @returns {T}\n */\nexport const the = value => value\n\n/**\n * @template {{}} O\n * @param {O} object\n * @returns {({ [K in keyof O]: [K, O[K]][] }[keyof O])|[[never, never]]}\n */\n\nexport const entries = object => /** @type {any} */ (Object.entries(object))\n\n/**\n * @template T\n * @param {T[][]} dataset\n * @returns {T[][]}\n */\nexport const combine = ([first, ...rest]) => {\n  const results = first.map(value => [value])\n  for (const values of rest) {\n    const tuples = results.splice(0)\n    for (const value of values) {\n      for (const tuple of tuples) {\n        results.push([...tuple, value])\n      }\n    }\n  }\n  return results\n}\n\n/**\n * @template T\n * @param {T[]} left\n * @param {T[]} right\n * @returns {T[]}\n */\nexport const intersection = (left, right) => {\n  const [result, other] =\n    left.length < right.length\n      ? [new Set(left), new Set(right)]\n      : [new Set(right), new Set(left)]\n\n  for (const item of result) {\n    if (!other.has(item)) {\n      result.delete(item)\n    }\n  }\n\n  return [...result]\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,GAAG,GAAGC,KAAK,IAAIA,KAAK;;AAEjC;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAMC,OAAO,GAAGC,MAAM,MAAI,kBAAoBC,MAAM,CAACF,OAAO,CAACC,MAAM,CAAC,CAAC;;AAE5E;AACA;AACA;AACA;AACA;AACA,OAAO,MAAME,OAAO,GAAGA,CAAC,CAACC,KAAK,EAAE,GAAGC,IAAI,CAAC,KAAK;EAC3C,MAAMC,OAAO,GAAGF,KAAK,CAACG,GAAG,CAACR,KAAK,IAAI,CAACA,KAAK,CAAC,CAAC;EAC3C,KAAK,MAAMS,MAAM,IAAIH,IAAI,EAAE;IACzB,MAAMI,MAAM,GAAGH,OAAO,CAACI,MAAM,CAAC,CAAC,CAAC;IAChC,KAAK,MAAMX,KAAK,IAAIS,MAAM,EAAE;MAC1B,KAAK,MAAMG,KAAK,IAAIF,MAAM,EAAE;QAC1BH,OAAO,CAACM,IAAI,CAAC,CAAC,GAAGD,KAAK,EAAEZ,KAAK,CAAC,CAAC;MACjC;IACF;EACF;EACA,OAAOO,OAAO;AAChB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMO,YAAY,GAAGA,CAACC,IAAI,EAAEC,KAAK,KAAK;EAC3C,MAAM,CAACC,MAAM,EAAEC,KAAK,CAAC,GACnBH,IAAI,CAACI,MAAM,GAAGH,KAAK,CAACG,MAAM,GACtB,CAAC,IAAIC,GAAG,CAACL,IAAI,CAAC,EAAE,IAAIK,GAAG,CAACJ,KAAK,CAAC,CAAC,GAC/B,CAAC,IAAII,GAAG,CAACJ,KAAK,CAAC,EAAE,IAAII,GAAG,CAACL,IAAI,CAAC,CAAC;EAErC,KAAK,MAAMM,IAAI,IAAIJ,MAAM,EAAE;IACzB,IAAI,CAACC,KAAK,CAACI,GAAG,CAACD,IAAI,CAAC,EAAE;MACpBJ,MAAM,CAACM,MAAM,CAACF,IAAI,CAAC;IACrB;EACF;EAEA,OAAO,CAAC,GAAGJ,MAAM,CAAC;AACpB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}