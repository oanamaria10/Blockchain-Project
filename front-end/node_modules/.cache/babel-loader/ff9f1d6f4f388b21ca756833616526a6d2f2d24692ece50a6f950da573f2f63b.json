{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.runScriptWithHardhat = exports.runScript = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst path_1 = __importDefault(require(\"path\"));\nconst execution_mode_1 = require(\"../core/execution-mode\");\nconst env_variables_1 = require(\"../core/params/env-variables\");\nconst log = (0, debug_1.default)(\"hardhat:core:scripts-runner\");\nasync function runScript(scriptPath, scriptArgs = [], extraNodeArgs = [], extraEnvVars = {}) {\n  const {\n    fork\n  } = await Promise.resolve().then(() => __importStar(require(\"child_process\")));\n  return new Promise((resolve, reject) => {\n    const processExecArgv = withFixedInspectArg(process.execArgv);\n    const nodeArgs = [...processExecArgv, ...getTsNodeArgsIfNeeded(scriptPath, extraEnvVars.HARDHAT_TYPECHECK === \"true\"), ...extraNodeArgs];\n    const envVars = {\n      ...process.env,\n      ...extraEnvVars\n    };\n    const childProcess = fork(scriptPath, scriptArgs, {\n      stdio: \"inherit\",\n      execArgv: nodeArgs,\n      env: envVars\n    });\n    childProcess.once(\"close\", status => {\n      log(`Script ${scriptPath} exited with status code ${status ?? \"null\"}`);\n      resolve(status);\n    });\n    childProcess.once(\"error\", reject);\n  });\n}\nexports.runScript = runScript;\nasync function runScriptWithHardhat(hardhatArguments, scriptPath, scriptArgs = [], extraNodeArgs = [], extraEnvVars = {}) {\n  log(`Creating Hardhat subprocess to run ${scriptPath}`);\n  return runScript(scriptPath, scriptArgs, [...extraNodeArgs, \"--require\", path_1.default.join(__dirname, \"..\", \"..\", \"register\")], {\n    ...(0, env_variables_1.getEnvVariablesMap)(hardhatArguments),\n    ...extraEnvVars\n  });\n}\nexports.runScriptWithHardhat = runScriptWithHardhat;\n/**\n * Fix debugger \"inspect\" arg from process.argv, if present.\n *\n * When running this process with a debugger, a debugger port\n * is specified via the \"--inspect-brk=\" arg param in some IDEs/setups.\n *\n * This normally works, but if we do a fork afterwards, we'll get an error stating\n * that the port is already in use (since the fork would also use the same args,\n * therefore the same port number). To prevent this issue, we could replace the port number with\n * a different free one, or simply use the port-agnostic --inspect\" flag, and leave the debugger\n * port selection to the Node process itself, which will pick an empty AND valid one.\n *\n * This way, we can properly use the debugger for this process AND for the executed\n * script itself - even if it's compiled using ts-node.\n */\nfunction withFixedInspectArg(argv) {\n  const fixIfInspectArg = arg => {\n    if (arg.toLowerCase().includes(\"--inspect-brk=\")) {\n      return \"--inspect\";\n    }\n    return arg;\n  };\n  return argv.map(fixIfInspectArg);\n}\nfunction getTsNodeArgsIfNeeded(scriptPath, shouldTypecheck) {\n  if (process.execArgv.includes(\"ts-node/register\")) {\n    return [];\n  }\n  // if we are running the tests we only want to transpile, or these tests\n  // take forever\n  if ((0, execution_mode_1.isRunningHardhatCoreTests)()) {\n    return [\"--require\", \"ts-node/register/transpile-only\"];\n  }\n  // If the script we are going to run is .ts we need ts-node\n  if (/\\.tsx?$/i.test(scriptPath)) {\n    return [\"--require\", `ts-node/register${shouldTypecheck ? \"\" : \"/transpile-only\"}`];\n  }\n  return [];\n}","map":{"version":3,"names":["debug_1","__importDefault","require","path_1","execution_mode_1","env_variables_1","log","default","runScript","scriptPath","scriptArgs","extraNodeArgs","extraEnvVars","fork","Promise","resolve","then","__importStar","reject","processExecArgv","withFixedInspectArg","process","execArgv","nodeArgs","getTsNodeArgsIfNeeded","HARDHAT_TYPECHECK","envVars","env","childProcess","stdio","once","status","exports","runScriptWithHardhat","hardhatArguments","join","__dirname","getEnvVariablesMap","argv","fixIfInspectArg","arg","toLowerCase","includes","map","shouldTypecheck","isRunningHardhatCoreTests","test"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\internal\\util\\scripts-runner.ts"],"sourcesContent":["import debug from \"debug\";\nimport path from \"path\";\n\nimport { HardhatArguments } from \"../../types\";\nimport { isRunningHardhatCoreTests } from \"../core/execution-mode\";\nimport { getEnvVariablesMap } from \"../core/params/env-variables\";\n\nconst log = debug(\"hardhat:core:scripts-runner\");\n\nexport async function runScript(\n  scriptPath: string,\n  scriptArgs: string[] = [],\n  extraNodeArgs: string[] = [],\n  extraEnvVars: { [name: string]: string } = {}\n): Promise<number> {\n  const { fork } = await import(\"child_process\");\n\n  return new Promise((resolve, reject) => {\n    const processExecArgv = withFixedInspectArg(process.execArgv);\n\n    const nodeArgs = [\n      ...processExecArgv,\n      ...getTsNodeArgsIfNeeded(\n        scriptPath,\n        extraEnvVars.HARDHAT_TYPECHECK === \"true\"\n      ),\n      ...extraNodeArgs,\n    ];\n\n    const envVars = { ...process.env, ...extraEnvVars };\n\n    const childProcess = fork(scriptPath, scriptArgs, {\n      stdio: \"inherit\",\n      execArgv: nodeArgs,\n      env: envVars,\n    });\n\n    childProcess.once(\"close\", (status) => {\n      log(`Script ${scriptPath} exited with status code ${status ?? \"null\"}`);\n\n      resolve(status as number);\n    });\n    childProcess.once(\"error\", reject);\n  });\n}\n\nexport async function runScriptWithHardhat(\n  hardhatArguments: HardhatArguments,\n  scriptPath: string,\n  scriptArgs: string[] = [],\n  extraNodeArgs: string[] = [],\n  extraEnvVars: { [name: string]: string } = {}\n): Promise<number> {\n  log(`Creating Hardhat subprocess to run ${scriptPath}`);\n\n  return runScript(\n    scriptPath,\n    scriptArgs,\n    [\n      ...extraNodeArgs,\n      \"--require\",\n      path.join(__dirname, \"..\", \"..\", \"register\"),\n    ],\n    {\n      ...getEnvVariablesMap(hardhatArguments),\n      ...extraEnvVars,\n    }\n  );\n}\n\n/**\n * Fix debugger \"inspect\" arg from process.argv, if present.\n *\n * When running this process with a debugger, a debugger port\n * is specified via the \"--inspect-brk=\" arg param in some IDEs/setups.\n *\n * This normally works, but if we do a fork afterwards, we'll get an error stating\n * that the port is already in use (since the fork would also use the same args,\n * therefore the same port number). To prevent this issue, we could replace the port number with\n * a different free one, or simply use the port-agnostic --inspect\" flag, and leave the debugger\n * port selection to the Node process itself, which will pick an empty AND valid one.\n *\n * This way, we can properly use the debugger for this process AND for the executed\n * script itself - even if it's compiled using ts-node.\n */\nfunction withFixedInspectArg(argv: string[]) {\n  const fixIfInspectArg = (arg: string) => {\n    if (arg.toLowerCase().includes(\"--inspect-brk=\")) {\n      return \"--inspect\";\n    }\n    return arg;\n  };\n  return argv.map(fixIfInspectArg);\n}\n\nfunction getTsNodeArgsIfNeeded(\n  scriptPath: string,\n  shouldTypecheck: boolean\n): string[] {\n  if (process.execArgv.includes(\"ts-node/register\")) {\n    return [];\n  }\n\n  // if we are running the tests we only want to transpile, or these tests\n  // take forever\n  if (isRunningHardhatCoreTests()) {\n    return [\"--require\", \"ts-node/register/transpile-only\"];\n  }\n\n  // If the script we are going to run is .ts we need ts-node\n  if (/\\.tsx?$/i.test(scriptPath)) {\n    return [\n      \"--require\",\n      `ts-node/register${shouldTypecheck ? \"\" : \"/transpile-only\"}`,\n    ];\n  }\n\n  return [];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}