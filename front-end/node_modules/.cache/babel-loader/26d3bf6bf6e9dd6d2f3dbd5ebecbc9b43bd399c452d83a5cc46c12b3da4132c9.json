{"ast":null,"code":"import * as API from '../api.js';\nimport { Size as NodeSize } from '../node.js';\nimport * as Proof from '../proof.js';\nexport { computeNode } from '../proof.js';\n\n// The value is an unsigned, 32-bit integer that is always numerically greater\n// than the highest index in the array. This means our tree can represent a\n// piece up to 128 GiB in size.\nexport const MAX_LEAF_COUNT = 2 ** 32 - 1;\n\n/**\n * Allocates a tree for a given amount of leafs.\n *\n * The construction rounds the amount of leafs up to the nearest two-power with\n * zeroed nodes to ensure that the tree is perfect and hence all internal node's\n * have well-defined children.\n *\n * @param {number} leafs\n */\nexport function allocate(leafs) {\n  const adjustedLeafs = 2 ** Math.ceil(Math.log2(leafs));\n  if (adjustedLeafs > MAX_LEAF_COUNT) {\n    throw new RangeError(`too many leafs ${adjustedLeafs} exceeds ${MAX_LEAF_COUNT} limit`);\n  }\n  const height = Math.ceil(Math.log2(adjustedLeafs));\n  const nodes = new Array(height + 1);\n  for (const level of nodes.keys()) {\n    nodes[level] = new Array(1 << level);\n  }\n  return new PieceTree({\n    nodes,\n    height\n  });\n}\n\n/**\n * @param {API.TreeData} tree\n */\nconst depth = tree => {\n  return tree.nodes.length;\n};\n\n/**\n *\n * @param {API.TreeData} tree\n * @returns {API.MerkleTreeNode}\n */\nexport const root = tree => {\n  return tree.nodes[0][0];\n};\n\n/**\n * @param {Uint8Array} source\n * @returns {API.MerkleTreeNode[]}\n */\nexport const split = source => {\n  const count = source.length / NodeSize;\n  const chunks = new Array(count);\n  for (let n = 0; n < count; n++) {\n    const offset = n * NodeSize;\n    const chunk = source.subarray(offset, offset + NodeSize);\n    chunks[n] = chunk;\n  }\n  return chunks;\n};\n\n/**\n * @param {API.Fr23Padded} source\n */\nexport const build = source => fromChunks(split(source));\n\n/**\n * @param {API.MerkleTreeNode[]} chunks\n */\nexport const fromChunks = chunks => {\n  if (chunks.length === 0) {\n    throw new RangeError('Empty source');\n  }\n  const leafs = chunks; //await Promise.all(chunks.map(truncatedHash))\n  return fromLeafs(leafs);\n};\n\n/**\n * @param {API.MerkleTreeNode[]} leafs\n * @returns {API.PieceTree}\n */\nexport const fromLeafs = leafs => {\n  const tree = allocate(leafs.length);\n  // Set the padded leaf nodes\n  tree.nodes[depth(tree) - 1] = padLeafs(leafs);\n  let parentNodes = tree.nodes[depth(tree) - 1];\n  // Construct the Merkle tree bottom-up, starting from the leafs\n  // Note the -1 due to 0-indexing the root level\n  for (let level = depth(tree) - 2; level >= 0; level--) {\n    /** @type {API.MerkleTreeNode[]} */\n    const currentLevel = new Array(Math.ceil(parentNodes.length / 2));\n    // Traverse the level left to right\n    for (let i = 0; i + 1 < parentNodes.length; i = i + 2) {\n      currentLevel[Math.floor(i / 2)] = Proof.computeNode(parentNodes[i], parentNodes[i + 1]);\n    }\n    tree.nodes[level] = currentLevel;\n    parentNodes = currentLevel;\n  }\n  return new PieceTree(tree);\n};\n\n/**\n * @param {API.MerkleTreeNode[]} leafs\n * @returns {API.MerkleTreeNode[]}\n */\nexport const padLeafs = leafs => {\n  const paddingAmount = (1 << Math.ceil(Math.log2(leafs.length))) - leafs.length;\n  // arrays are zeroed by default in JS\n  const paddingLeafs = new Array(paddingAmount);\n  return [...leafs, ...paddingLeafs];\n};\n\n/**\n * @implements {API.PieceTree}\n */\nclass PieceTree {\n  /**\n   * @param {object} data\n   * @param {API.MerkleTreeNode[][]} data.nodes\n   * @param {number} data.height\n   */\n  constructor({\n    nodes,\n    height\n  }) {\n    this.nodes = nodes;\n    this.height = height;\n  }\n  get root() {\n    return root(this);\n  }\n  get leafs() {\n    const {\n      nodes\n    } = this;\n    return nodes[nodes.length - 1];\n  }\n  get leafCount() {\n    return 2 ** this.height;\n  }\n  /**\n   *\n   * @param {number} level\n   * @param {number} index\n   */\n  node(level, index) {\n    const {\n      nodes\n    } = this;\n    return nodes[level][index];\n  }\n}","map":{"version":3,"names":["API","Size","NodeSize","Proof","computeNode","MAX_LEAF_COUNT","allocate","leafs","adjustedLeafs","Math","ceil","log2","RangeError","height","nodes","Array","level","keys","PieceTree","depth","tree","length","root","split","source","count","chunks","n","offset","chunk","subarray","build","fromChunks","fromLeafs","padLeafs","parentNodes","currentLevel","i","floor","paddingAmount","paddingLeafs","constructor","leafCount","node","index"],"sources":["C:/FACULTATE/Proiect/node_modules/@web3-storage/data-segment/src/piece/tree.js"],"sourcesContent":["import * as API from '../api.js'\nimport { Size as NodeSize } from '../node.js'\nimport * as Proof from '../proof.js'\nexport { computeNode } from '../proof.js'\n\n// The value is an unsigned, 32-bit integer that is always numerically greater\n// than the highest index in the array. This means our tree can represent a\n// piece up to 128 GiB in size.\nexport const MAX_LEAF_COUNT = 2 ** 32 - 1\n\n/**\n * Allocates a tree for a given amount of leafs.\n *\n * The construction rounds the amount of leafs up to the nearest two-power with\n * zeroed nodes to ensure that the tree is perfect and hence all internal node's\n * have well-defined children.\n *\n * @param {number} leafs\n */\nexport function allocate(leafs) {\n  const adjustedLeafs = 2 ** Math.ceil(Math.log2(leafs))\n\n  if (adjustedLeafs > MAX_LEAF_COUNT) {\n    throw new RangeError(\n      `too many leafs ${adjustedLeafs} exceeds ${MAX_LEAF_COUNT} limit`\n    )\n  }\n\n  const height = Math.ceil(Math.log2(adjustedLeafs))\n  const nodes = new Array(height + 1)\n\n  for (const level of nodes.keys()) {\n    nodes[level] = new Array(1 << level)\n  }\n\n  return new PieceTree({ nodes, height })\n}\n\n/**\n * @param {API.TreeData} tree\n */\nconst depth = (tree) => {\n  return tree.nodes.length\n}\n\n/**\n *\n * @param {API.TreeData} tree\n * @returns {API.MerkleTreeNode}\n */\nexport const root = (tree) => {\n  return tree.nodes[0][0]\n}\n\n/**\n * @param {Uint8Array} source\n * @returns {API.MerkleTreeNode[]}\n */\nexport const split = (source) => {\n  const count = source.length / NodeSize\n  const chunks = new Array(count)\n  for (let n = 0; n < count; n++) {\n    const offset = n * NodeSize\n    const chunk = source.subarray(offset, offset + NodeSize)\n    chunks[n] = chunk\n  }\n  return chunks\n}\n\n/**\n * @param {API.Fr23Padded} source\n */\nexport const build = (source) => fromChunks(split(source))\n\n/**\n * @param {API.MerkleTreeNode[]} chunks\n */\nexport const fromChunks = (chunks) => {\n  if (chunks.length === 0) {\n    throw new RangeError('Empty source')\n  }\n\n  const leafs = chunks //await Promise.all(chunks.map(truncatedHash))\n  return fromLeafs(leafs)\n}\n\n/**\n * @param {API.MerkleTreeNode[]} leafs\n * @returns {API.PieceTree}\n */\nexport const fromLeafs = (leafs) => {\n  const tree = allocate(leafs.length)\n  // Set the padded leaf nodes\n  tree.nodes[depth(tree) - 1] = padLeafs(leafs)\n  let parentNodes = tree.nodes[depth(tree) - 1]\n  // Construct the Merkle tree bottom-up, starting from the leafs\n  // Note the -1 due to 0-indexing the root level\n  for (let level = depth(tree) - 2; level >= 0; level--) {\n    /** @type {API.MerkleTreeNode[]} */\n    const currentLevel = new Array(Math.ceil(parentNodes.length / 2))\n    // Traverse the level left to right\n    for (let i = 0; i + 1 < parentNodes.length; i = i + 2) {\n      currentLevel[Math.floor(i / 2)] = Proof.computeNode(\n        parentNodes[i],\n        parentNodes[i + 1]\n      )\n    }\n    tree.nodes[level] = currentLevel\n    parentNodes = currentLevel\n  }\n\n  return new PieceTree(tree)\n}\n\n/**\n * @param {API.MerkleTreeNode[]} leafs\n * @returns {API.MerkleTreeNode[]}\n */\nexport const padLeafs = (leafs) => {\n  const paddingAmount = (1 << Math.ceil(Math.log2(leafs.length))) - leafs.length\n  // arrays are zeroed by default in JS\n  const paddingLeafs = new Array(paddingAmount)\n\n  return [...leafs, ...paddingLeafs]\n}\n\n/**\n * @implements {API.PieceTree}\n */\nclass PieceTree {\n  /**\n   * @param {object} data\n   * @param {API.MerkleTreeNode[][]} data.nodes\n   * @param {number} data.height\n   */\n  constructor({ nodes, height }) {\n    this.nodes = nodes\n    this.height = height\n  }\n\n  get root() {\n    return root(this)\n  }\n  get leafs() {\n    const { nodes } = this\n    return nodes[nodes.length - 1]\n  }\n  get leafCount() {\n    return 2 ** this.height\n  }\n  /**\n   *\n   * @param {number} level\n   * @param {number} index\n   */\n  node(level, index) {\n    const { nodes } = this\n    return nodes[level][index]\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}