{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createHardhatNetworkProvider = exports.EdrProviderWrapper = exports.getNodeConfig = exports.getGlobalEdrContext = exports.DEFAULT_COINBASE = void 0;\nconst edr_1 = require(\"@nomicfoundation/edr\");\nconst chalk_1 = __importDefault(require(\"chalk\"));\nconst debug_1 = __importDefault(require(\"debug\"));\nconst events_1 = require(\"events\");\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\nconst t = __importStar(require(\"io-ts\"));\nconst semver_1 = __importDefault(require(\"semver\"));\nconst constants_1 = require(\"../../constants\");\nconst solc_1 = require(\"../../core/jsonrpc/types/input/solc\");\nconst validation_1 = require(\"../../core/jsonrpc/types/input/validation\");\nconst errors_1 = require(\"../../core/providers/errors\");\nconst http_1 = require(\"../../core/providers/http\");\nconst hardforks_1 = require(\"../../util/hardforks\");\nconst compiler_to_model_1 = require(\"../stack-traces/compiler-to-model\");\nconst consoleLogger_1 = require(\"../stack-traces/consoleLogger\");\nconst contracts_identifier_1 = require(\"../stack-traces/contracts-identifier\");\nconst vm_trace_decoder_1 = require(\"../stack-traces/vm-trace-decoder\");\nconst constants_2 = require(\"../stack-traces/constants\");\nconst solidity_errors_1 = require(\"../stack-traces/solidity-errors\");\nconst solidityTracer_1 = require(\"../stack-traces/solidityTracer\");\nconst vm_tracer_1 = require(\"../stack-traces/vm-tracer\");\nconst packageInfo_1 = require(\"../../util/packageInfo\");\nconst convertToEdr_1 = require(\"./utils/convertToEdr\");\nconst makeCommon_1 = require(\"./utils/makeCommon\");\nconst logger_1 = require(\"./modules/logger\");\nconst minimal_vm_1 = require(\"./vm/minimal-vm\");\nconst log = (0, debug_1.default)(\"hardhat:core:hardhat-network:provider\");\n/* eslint-disable @nomicfoundation/hardhat-internal-rules/only-hardhat-error */\nexports.DEFAULT_COINBASE = \"0xc014ba5ec014ba5ec014ba5ec014ba5ec014ba5e\";\nlet _globalEdrContext;\n// Lazy initialize the global EDR context.\nfunction getGlobalEdrContext() {\n  if (_globalEdrContext === undefined) {\n    // Only one is allowed to exist\n    _globalEdrContext = new edr_1.EdrContext();\n  }\n  return _globalEdrContext;\n}\nexports.getGlobalEdrContext = getGlobalEdrContext;\nfunction getNodeConfig(config, tracingConfig) {\n  return {\n    automine: config.automine,\n    blockGasLimit: config.blockGasLimit,\n    minGasPrice: config.minGasPrice,\n    genesisAccounts: config.genesisAccounts,\n    allowUnlimitedContractSize: config.allowUnlimitedContractSize,\n    tracingConfig,\n    initialBaseFeePerGas: config.initialBaseFeePerGas,\n    mempoolOrder: config.mempoolOrder,\n    hardfork: config.hardfork,\n    chainId: config.chainId,\n    networkId: config.networkId,\n    initialDate: config.initialDate,\n    forkConfig: config.forkConfig,\n    forkCachePath: config.forkConfig !== undefined ? config.forkCachePath : undefined,\n    coinbase: config.coinbase ?? exports.DEFAULT_COINBASE,\n    chains: config.chains,\n    allowBlocksWithSameTimestamp: config.allowBlocksWithSameTimestamp,\n    enableTransientStorage: config.enableTransientStorage\n  };\n}\nexports.getNodeConfig = getNodeConfig;\nclass EdrProviderEventAdapter extends events_1.EventEmitter {}\nclass EdrProviderWrapper extends events_1.EventEmitter {\n  constructor(_provider,\n  // we add this for backwards-compatibility with plugins like solidity-coverage\n  _node, _eventAdapter, _vmTraceDecoder, _rawTraceCallbacks,\n  // The common configuration for EthereumJS VM is not used by EDR, but tests expect it as part of the provider.\n  _common, tracingConfig) {\n    super();\n    this._provider = _provider;\n    this._node = _node;\n    this._eventAdapter = _eventAdapter;\n    this._vmTraceDecoder = _vmTraceDecoder;\n    this._rawTraceCallbacks = _rawTraceCallbacks;\n    this._common = _common;\n    this._failedStackTraces = 0;\n    if (tracingConfig !== undefined) {\n      (0, vm_trace_decoder_1.initializeVmTraceDecoder)(this._vmTraceDecoder, tracingConfig);\n    }\n  }\n  static async create(config, loggerConfig, rawTraceCallbacks, tracingConfig) {\n    const {\n      Provider\n    } = require(\"@nomicfoundation/edr\");\n    const coinbase = config.coinbase ?? exports.DEFAULT_COINBASE;\n    let fork;\n    if (config.forkConfig !== undefined) {\n      fork = {\n        jsonRpcUrl: config.forkConfig.jsonRpcUrl,\n        blockNumber: config.forkConfig.blockNumber !== undefined ? BigInt(config.forkConfig.blockNumber) : undefined\n      };\n    }\n    const initialDate = config.initialDate !== undefined ? BigInt(Math.floor(config.initialDate.getTime() / 1000)) : undefined;\n    // To accomodate construction ordering, we need an adapter to forward events\n    // from the EdrProvider callback to the wrapper's listener\n    const eventAdapter = new EdrProviderEventAdapter();\n    const printLineFn = loggerConfig.printLineFn ?? logger_1.printLine;\n    const replaceLastLineFn = loggerConfig.replaceLastLineFn ?? logger_1.replaceLastLine;\n    const contractsIdentifier = new contracts_identifier_1.ContractsIdentifier();\n    const vmTraceDecoder = new vm_trace_decoder_1.VmTraceDecoder(contractsIdentifier);\n    const hardforkName = (0, hardforks_1.getHardforkName)(config.hardfork);\n    const provider = await Provider.withConfig(getGlobalEdrContext(), {\n      allowBlocksWithSameTimestamp: config.allowBlocksWithSameTimestamp ?? false,\n      allowUnlimitedContractSize: config.allowUnlimitedContractSize,\n      bailOnCallFailure: config.throwOnCallFailures,\n      bailOnTransactionFailure: config.throwOnTransactionFailures,\n      blockGasLimit: BigInt(config.blockGasLimit),\n      chainId: BigInt(config.chainId),\n      chains: Array.from(config.chains, ([chainId, hardforkConfig]) => {\n        return {\n          chainId: BigInt(chainId),\n          hardforks: Array.from(hardforkConfig.hardforkHistory, ([hardfork, blockNumber]) => {\n            return {\n              blockNumber: BigInt(blockNumber),\n              specId: (0, convertToEdr_1.ethereumsjsHardforkToEdrSpecId)((0, hardforks_1.getHardforkName)(hardfork))\n            };\n          })\n        };\n      }),\n      cacheDir: config.forkCachePath,\n      coinbase: Buffer.from(coinbase.slice(2), \"hex\"),\n      fork,\n      hardfork: (0, convertToEdr_1.ethereumsjsHardforkToEdrSpecId)(hardforkName),\n      genesisAccounts: config.genesisAccounts.map(account => {\n        return {\n          secretKey: account.privateKey,\n          balance: BigInt(account.balance)\n        };\n      }),\n      initialDate,\n      initialBaseFeePerGas: config.initialBaseFeePerGas !== undefined ? BigInt(config.initialBaseFeePerGas) : undefined,\n      minGasPrice: config.minGasPrice,\n      mining: {\n        autoMine: config.automine,\n        interval: (0, convertToEdr_1.ethereumjsIntervalMiningConfigToEdr)(config.intervalMining),\n        memPool: {\n          order: (0, convertToEdr_1.ethereumjsMempoolOrderToEdrMineOrdering)(config.mempoolOrder)\n        }\n      },\n      networkId: BigInt(config.networkId)\n    }, {\n      enable: loggerConfig.enabled,\n      decodeConsoleLogInputsCallback: inputs => {\n        const consoleLogger = new consoleLogger_1.ConsoleLogger();\n        return consoleLogger.getDecodedLogs(inputs);\n      },\n      getContractAndFunctionNameCallback: (code, calldata) => {\n        return vmTraceDecoder.getContractAndFunctionNamesForCall(code, calldata);\n      },\n      printLineCallback: (message, replace) => {\n        if (replace) {\n          replaceLastLineFn(message);\n        } else {\n          printLineFn(message);\n        }\n      }\n    }, event => {\n      eventAdapter.emit(\"ethEvent\", event);\n    });\n    const minimalEthereumJsNode = {\n      _vm: (0, minimal_vm_1.getMinimalEthereumJsVm)(provider)\n    };\n    const common = (0, makeCommon_1.makeCommon)(getNodeConfig(config));\n    const wrapper = new EdrProviderWrapper(provider, minimalEthereumJsNode, eventAdapter, vmTraceDecoder, rawTraceCallbacks, common, tracingConfig);\n    // Pass through all events from the provider\n    eventAdapter.addListener(\"ethEvent\", wrapper._ethEventListener.bind(wrapper));\n    return wrapper;\n  }\n  async request(args) {\n    if (args.params !== undefined && !Array.isArray(args.params)) {\n      throw new errors_1.InvalidInputError(\"Hardhat Network doesn't support JSON-RPC params sent as an object\");\n    }\n    const params = args.params ?? [];\n    if (args.method === \"hardhat_addCompilationResult\") {\n      return this._addCompilationResultAction(...this._addCompilationResultParams(params));\n    } else if (args.method === \"hardhat_getStackTraceFailuresCount\") {\n      return this._getStackTraceFailuresCountAction(...this._getStackTraceFailuresCountParams(params));\n    }\n    const stringifiedArgs = JSON.stringify({\n      method: args.method,\n      params\n    });\n    const responseObject = await this._provider.handleRequest(stringifiedArgs);\n    const response = JSON.parse(responseObject.json);\n    const rawTraces = responseObject.traces;\n    for (const rawTrace of rawTraces) {\n      const trace = rawTrace.trace();\n      for (const traceItem of trace) {\n        if (\"pc\" in traceItem) {\n          if (this._node._vm.evm.events.listenerCount(\"step\") > 0) {\n            this._node._vm.evm.events.emit(\"step\", (0, convertToEdr_1.edrTracingStepToMinimalInterpreterStep)(traceItem));\n          }\n          if (this._rawTraceCallbacks.onStep !== undefined) {\n            await this._rawTraceCallbacks.onStep(traceItem);\n          }\n        } else if (\"executionResult\" in traceItem) {\n          if (this._node._vm.evm.events.listenerCount(\"afterMessage\") > 0) {\n            this._node._vm.evm.events.emit(\"afterMessage\", (0, convertToEdr_1.edrTracingMessageResultToMinimalEVMResult)(traceItem));\n          }\n          if (this._rawTraceCallbacks.onAfterMessage !== undefined) {\n            await this._rawTraceCallbacks.onAfterMessage(traceItem.executionResult);\n          }\n        } else {\n          if (this._node._vm.evm.events.listenerCount(\"beforeMessage\") > 0) {\n            this._node._vm.evm.events.emit(\"beforeMessage\", (0, convertToEdr_1.edrTracingMessageToMinimalMessage)(traceItem));\n          }\n          if (this._rawTraceCallbacks.onBeforeMessage !== undefined) {\n            await this._rawTraceCallbacks.onBeforeMessage(traceItem);\n          }\n        }\n      }\n    }\n    if ((0, http_1.isErrorResponse)(response)) {\n      let error;\n      const solidityTrace = responseObject.solidityTrace;\n      let stackTrace;\n      if (solidityTrace !== null) {\n        stackTrace = await this._rawTraceToSolidityStackTrace(solidityTrace);\n      }\n      if (stackTrace !== undefined) {\n        error = (0, solidity_errors_1.encodeSolidityStackTrace)(response.error.message, stackTrace);\n        // Pass data and transaction hash from the original error\n        error.data = response.error.data?.data ?? undefined;\n        error.transactionHash = response.error.data?.transactionHash ?? undefined;\n      } else {\n        if (response.error.code === errors_1.InvalidArgumentsError.CODE) {\n          error = new errors_1.InvalidArgumentsError(response.error.message);\n        } else {\n          error = new errors_1.ProviderError(response.error.message, response.error.code);\n        }\n        error.data = response.error.data;\n      }\n      // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n    if (args.method === \"hardhat_reset\") {\n      this.emit(constants_1.HARDHAT_NETWORK_RESET_EVENT);\n    } else if (args.method === \"evm_revert\") {\n      this.emit(constants_1.HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT);\n    }\n    // Override EDR version string with Hardhat version string with EDR backend,\n    // e.g. `HardhatNetwork/2.19.0/@nomicfoundation/edr/0.2.0-dev`\n    if (args.method === \"web3_clientVersion\") {\n      return clientVersion(response.result);\n    } else if (args.method === \"debug_traceTransaction\" || args.method === \"debug_traceCall\") {\n      return (0, convertToEdr_1.edrRpcDebugTraceToHardhat)(response.result);\n    } else {\n      return response.result;\n    }\n  }\n  // temporarily added to make smock work with HH+EDR\n  _setCallOverrideCallback(callback) {\n    this._callOverrideCallback = callback;\n    this._provider.setCallOverrideCallback(async (address, data) => {\n      return this._callOverrideCallback?.(address, data);\n    });\n  }\n  _ethEventListener(event) {\n    const subscription = `0x${event.filterId.toString(16)}`;\n    const results = Array.isArray(event.result) ? event.result : [event.result];\n    for (const result of results) {\n      this._emitLegacySubscriptionEvent(subscription, result);\n      this._emitEip1193SubscriptionEvent(subscription, result);\n    }\n  }\n  _emitLegacySubscriptionEvent(subscription, result) {\n    this.emit(\"notification\", {\n      subscription,\n      result\n    });\n  }\n  _emitEip1193SubscriptionEvent(subscription, result) {\n    const message = {\n      type: \"eth_subscription\",\n      data: {\n        subscription,\n        result\n      }\n    };\n    this.emit(\"message\", message);\n  }\n  _addCompilationResultParams(params) {\n    return (0, validation_1.validateParams)(params, t.string, solc_1.rpcCompilerInput, solc_1.rpcCompilerOutput);\n  }\n  async _addCompilationResultAction(solcVersion, compilerInput, compilerOutput) {\n    let bytecodes;\n    try {\n      bytecodes = (0, compiler_to_model_1.createModelsAndDecodeBytecodes)(solcVersion, compilerInput, compilerOutput);\n    } catch (error) {\n      console.warn(chalk_1.default.yellow(\"The Hardhat Network tracing engine could not be updated. Run Hardhat with --verbose to learn more.\"));\n      log(\"ContractsIdentifier failed to be updated. Please report this to help us improve Hardhat.\\n\", error);\n      return false;\n    }\n    for (const bytecode of bytecodes) {\n      this._vmTraceDecoder.addBytecode(bytecode);\n    }\n    return true;\n  }\n  _getStackTraceFailuresCountParams(params) {\n    return (0, validation_1.validateParams)(params);\n  }\n  _getStackTraceFailuresCountAction() {\n    return this._failedStackTraces;\n  }\n  async _rawTraceToSolidityStackTrace(rawTrace) {\n    const vmTracer = new vm_tracer_1.VMTracer(false);\n    const trace = rawTrace.trace();\n    for (const traceItem of trace) {\n      if (\"pc\" in traceItem) {\n        await vmTracer.addStep(traceItem);\n      } else if (\"executionResult\" in traceItem) {\n        await vmTracer.addAfterMessage(traceItem.executionResult);\n      } else {\n        await vmTracer.addBeforeMessage(traceItem);\n      }\n    }\n    let vmTrace = vmTracer.getLastTopLevelMessageTrace();\n    const vmTracerError = vmTracer.getLastError();\n    if (vmTrace !== undefined) {\n      vmTrace = this._vmTraceDecoder.tryToDecodeMessageTrace(vmTrace);\n    }\n    try {\n      if (vmTrace === undefined || vmTracerError !== undefined) {\n        throw vmTracerError;\n      }\n      const solidityTracer = new solidityTracer_1.SolidityTracer();\n      return solidityTracer.getStackTrace(vmTrace);\n    } catch (err) {\n      this._failedStackTraces += 1;\n      log(\"Could not generate stack trace. Please report this to help us improve Hardhat.\\n\", err);\n    }\n  }\n}\nexports.EdrProviderWrapper = EdrProviderWrapper;\nasync function clientVersion(edrClientVersion) {\n  const hardhatPackage = await (0, packageInfo_1.getPackageJson)();\n  const edrVersion = edrClientVersion.split(\"/\")[1];\n  return `HardhatNetwork/${hardhatPackage.version}/@nomicfoundation/edr/${edrVersion}`;\n}\nasync function createHardhatNetworkProvider(hardhatNetworkProviderConfig, loggerConfig, artifacts) {\n  return EdrProviderWrapper.create(hardhatNetworkProviderConfig, loggerConfig, {}, await makeTracingConfig(artifacts));\n}\nexports.createHardhatNetworkProvider = createHardhatNetworkProvider;\nasync function makeTracingConfig(artifacts) {\n  if (artifacts !== undefined) {\n    const buildInfos = [];\n    const buildInfoFiles = await artifacts.getBuildInfoPaths();\n    try {\n      for (const buildInfoFile of buildInfoFiles) {\n        const buildInfo = await fs_extra_1.default.readJson(buildInfoFile);\n        if (semver_1.default.gte(buildInfo.solcVersion, constants_2.FIRST_SOLC_VERSION_SUPPORTED)) {\n          buildInfos.push(buildInfo);\n        }\n      }\n      return {\n        buildInfos\n      };\n    } catch (error) {\n      console.warn(chalk_1.default.yellow(\"Stack traces engine could not be initialized. Run Hardhat with --verbose to learn more.\"));\n      log(\"Solidity stack traces disabled: Failed to read solc's input and output files. Please report this to help us improve Hardhat.\\n\", error);\n    }\n  }\n}","map":{"version":3,"names":["edr_1","require","chalk_1","__importDefault","debug_1","events_1","fs_extra_1","t","__importStar","semver_1","constants_1","solc_1","validation_1","errors_1","http_1","hardforks_1","compiler_to_model_1","consoleLogger_1","contracts_identifier_1","vm_trace_decoder_1","constants_2","solidity_errors_1","solidityTracer_1","vm_tracer_1","packageInfo_1","convertToEdr_1","makeCommon_1","logger_1","minimal_vm_1","log","default","exports","DEFAULT_COINBASE","_globalEdrContext","getGlobalEdrContext","undefined","EdrContext","getNodeConfig","config","tracingConfig","automine","blockGasLimit","minGasPrice","genesisAccounts","allowUnlimitedContractSize","initialBaseFeePerGas","mempoolOrder","hardfork","chainId","networkId","initialDate","forkConfig","forkCachePath","coinbase","chains","allowBlocksWithSameTimestamp","enableTransientStorage","EdrProviderEventAdapter","EventEmitter","EdrProviderWrapper","constructor","_provider","_node","_eventAdapter","_vmTraceDecoder","_rawTraceCallbacks","_common","_failedStackTraces","initializeVmTraceDecoder","create","loggerConfig","rawTraceCallbacks","Provider","fork","jsonRpcUrl","blockNumber","BigInt","Math","floor","getTime","eventAdapter","printLineFn","printLine","replaceLastLineFn","replaceLastLine","contractsIdentifier","ContractsIdentifier","vmTraceDecoder","VmTraceDecoder","hardforkName","getHardforkName","provider","withConfig","bailOnCallFailure","throwOnCallFailures","bailOnTransactionFailure","throwOnTransactionFailures","Array","from","hardforkConfig","hardforks","hardforkHistory","specId","ethereumsjsHardforkToEdrSpecId","cacheDir","Buffer","slice","map","account","secretKey","privateKey","balance","mining","autoMine","interval","ethereumjsIntervalMiningConfigToEdr","intervalMining","memPool","order","ethereumjsMempoolOrderToEdrMineOrdering","enable","enabled","decodeConsoleLogInputsCallback","inputs","consoleLogger","ConsoleLogger","getDecodedLogs","getContractAndFunctionNameCallback","code","calldata","getContractAndFunctionNamesForCall","printLineCallback","message","replace","event","emit","minimalEthereumJsNode","_vm","getMinimalEthereumJsVm","common","makeCommon","wrapper","addListener","_ethEventListener","bind","request","args","params","isArray","InvalidInputError","method","_addCompilationResultAction","_addCompilationResultParams","_getStackTraceFailuresCountAction","_getStackTraceFailuresCountParams","stringifiedArgs","JSON","stringify","responseObject","handleRequest","response","parse","json","rawTraces","traces","rawTrace","trace","traceItem","evm","events","listenerCount","edrTracingStepToMinimalInterpreterStep","onStep","edrTracingMessageResultToMinimalEVMResult","onAfterMessage","executionResult","edrTracingMessageToMinimalMessage","onBeforeMessage","isErrorResponse","error","solidityTrace","stackTrace","_rawTraceToSolidityStackTrace","encodeSolidityStackTrace","data","transactionHash","InvalidArgumentsError","CODE","ProviderError","HARDHAT_NETWORK_RESET_EVENT","HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT","clientVersion","result","edrRpcDebugTraceToHardhat","_setCallOverrideCallback","callback","_callOverrideCallback","setCallOverrideCallback","address","subscription","filterId","toString","results","_emitLegacySubscriptionEvent","_emitEip1193SubscriptionEvent","type","validateParams","string","rpcCompilerInput","rpcCompilerOutput","solcVersion","compilerInput","compilerOutput","bytecodes","createModelsAndDecodeBytecodes","console","warn","yellow","bytecode","addBytecode","vmTracer","VMTracer","addStep","addAfterMessage","addBeforeMessage","vmTrace","getLastTopLevelMessageTrace","vmTracerError","getLastError","tryToDecodeMessageTrace","solidityTracer","SolidityTracer","getStackTrace","err","edrClientVersion","hardhatPackage","getPackageJson","edrVersion","split","version","createHardhatNetworkProvider","hardhatNetworkProviderConfig","artifacts","makeTracingConfig","buildInfos","buildInfoFiles","getBuildInfoPaths","buildInfoFile","buildInfo","readJson","gte","FIRST_SOLC_VERSION_SUPPORTED","push"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\internal\\hardhat-network\\provider\\provider.ts"],"sourcesContent":["import type {\n  Artifacts,\n  BoundExperimentalHardhatNetworkMessageTraceHook,\n  CompilerInput,\n  CompilerOutput,\n  EIP1193Provider,\n  EthSubscription,\n  HardhatNetworkChainsConfig,\n  RequestArguments,\n} from \"../../../types\";\n\nimport {\n  EdrContext,\n  Provider as EdrProviderT,\n  ExecutionResult,\n  RawTrace,\n  Response,\n  SubscriptionEvent,\n  TracingMessage,\n  TracingStep,\n} from \"@nomicfoundation/edr\";\nimport { Common } from \"@nomicfoundation/ethereumjs-common\";\nimport chalk from \"chalk\";\nimport debug from \"debug\";\nimport { EventEmitter } from \"events\";\nimport fsExtra from \"fs-extra\";\nimport * as t from \"io-ts\";\nimport semver from \"semver\";\n\nimport {\n  HARDHAT_NETWORK_RESET_EVENT,\n  HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT,\n} from \"../../constants\";\nimport {\n  rpcCompilerInput,\n  rpcCompilerOutput,\n} from \"../../core/jsonrpc/types/input/solc\";\nimport { validateParams } from \"../../core/jsonrpc/types/input/validation\";\nimport {\n  InvalidArgumentsError,\n  InvalidInputError,\n  ProviderError,\n} from \"../../core/providers/errors\";\nimport { isErrorResponse } from \"../../core/providers/http\";\nimport { getHardforkName } from \"../../util/hardforks\";\nimport { createModelsAndDecodeBytecodes } from \"../stack-traces/compiler-to-model\";\nimport { ConsoleLogger } from \"../stack-traces/consoleLogger\";\nimport { ContractsIdentifier } from \"../stack-traces/contracts-identifier\";\nimport {\n  VmTraceDecoder,\n  initializeVmTraceDecoder,\n} from \"../stack-traces/vm-trace-decoder\";\nimport { FIRST_SOLC_VERSION_SUPPORTED } from \"../stack-traces/constants\";\nimport { encodeSolidityStackTrace } from \"../stack-traces/solidity-errors\";\nimport { SolidityStackTrace } from \"../stack-traces/solidity-stack-trace\";\nimport { SolidityTracer } from \"../stack-traces/solidityTracer\";\nimport { VMTracer } from \"../stack-traces/vm-tracer\";\n\nimport { getPackageJson } from \"../../util/packageInfo\";\nimport {\n  ForkConfig,\n  GenesisAccount,\n  IntervalMiningConfig,\n  MempoolOrder,\n  NodeConfig,\n  TracingConfig,\n} from \"./node-types\";\nimport {\n  edrRpcDebugTraceToHardhat,\n  edrTracingMessageResultToMinimalEVMResult,\n  edrTracingMessageToMinimalMessage,\n  edrTracingStepToMinimalInterpreterStep,\n  ethereumjsIntervalMiningConfigToEdr,\n  ethereumjsMempoolOrderToEdrMineOrdering,\n  ethereumsjsHardforkToEdrSpecId,\n} from \"./utils/convertToEdr\";\nimport { makeCommon } from \"./utils/makeCommon\";\nimport { LoggerConfig, printLine, replaceLastLine } from \"./modules/logger\";\nimport { MinimalEthereumJsVm, getMinimalEthereumJsVm } from \"./vm/minimal-vm\";\n\nconst log = debug(\"hardhat:core:hardhat-network:provider\");\n\n/* eslint-disable @nomicfoundation/hardhat-internal-rules/only-hardhat-error */\n\nexport const DEFAULT_COINBASE = \"0xc014ba5ec014ba5ec014ba5ec014ba5ec014ba5e\";\nlet _globalEdrContext: EdrContext | undefined;\n\n// Lazy initialize the global EDR context.\nexport function getGlobalEdrContext(): EdrContext {\n  if (_globalEdrContext === undefined) {\n    // Only one is allowed to exist\n    _globalEdrContext = new EdrContext();\n  }\n\n  return _globalEdrContext;\n}\n\ninterface HardhatNetworkProviderConfig {\n  hardfork: string;\n  chainId: number;\n  networkId: number;\n  blockGasLimit: number;\n  minGasPrice: bigint;\n  automine: boolean;\n  intervalMining: IntervalMiningConfig;\n  mempoolOrder: MempoolOrder;\n  chains: HardhatNetworkChainsConfig;\n  genesisAccounts: GenesisAccount[];\n  allowUnlimitedContractSize: boolean;\n  throwOnTransactionFailures: boolean;\n  throwOnCallFailures: boolean;\n  allowBlocksWithSameTimestamp: boolean;\n\n  initialBaseFeePerGas?: number;\n  initialDate?: Date;\n  coinbase?: string;\n  experimentalHardhatNetworkMessageTraceHooks?: BoundExperimentalHardhatNetworkMessageTraceHook[];\n  forkConfig?: ForkConfig;\n  forkCachePath?: string;\n  enableTransientStorage: boolean;\n}\n\nexport function getNodeConfig(\n  config: HardhatNetworkProviderConfig,\n  tracingConfig?: TracingConfig\n): NodeConfig {\n  return {\n    automine: config.automine,\n    blockGasLimit: config.blockGasLimit,\n    minGasPrice: config.minGasPrice,\n    genesisAccounts: config.genesisAccounts,\n    allowUnlimitedContractSize: config.allowUnlimitedContractSize,\n    tracingConfig,\n    initialBaseFeePerGas: config.initialBaseFeePerGas,\n    mempoolOrder: config.mempoolOrder,\n    hardfork: config.hardfork,\n    chainId: config.chainId,\n    networkId: config.networkId,\n    initialDate: config.initialDate,\n    forkConfig: config.forkConfig,\n    forkCachePath:\n      config.forkConfig !== undefined ? config.forkCachePath : undefined,\n    coinbase: config.coinbase ?? DEFAULT_COINBASE,\n    chains: config.chains,\n    allowBlocksWithSameTimestamp: config.allowBlocksWithSameTimestamp,\n    enableTransientStorage: config.enableTransientStorage,\n  };\n}\n\nexport interface RawTraceCallbacks {\n  onStep?: (messageTrace: TracingStep) => Promise<void>;\n  onBeforeMessage?: (messageTrace: TracingMessage) => Promise<void>;\n  onAfterMessage?: (messageTrace: ExecutionResult) => Promise<void>;\n}\n\nclass EdrProviderEventAdapter extends EventEmitter {}\n\ntype CallOverrideCallback = (\n  address: Buffer,\n  data: Buffer\n) => Promise<\n  { result: Buffer; shouldRevert: boolean; gas: bigint } | undefined\n>;\n\nexport class EdrProviderWrapper\n  extends EventEmitter\n  implements EIP1193Provider\n{\n  private _failedStackTraces = 0;\n\n  // temporarily added to make smock work with HH+EDR\n  private _callOverrideCallback?: CallOverrideCallback;\n\n  private constructor(\n    private readonly _provider: EdrProviderT,\n    // we add this for backwards-compatibility with plugins like solidity-coverage\n    private readonly _node: {\n      _vm: MinimalEthereumJsVm;\n    },\n    private readonly _eventAdapter: EdrProviderEventAdapter,\n    private readonly _vmTraceDecoder: VmTraceDecoder,\n    private readonly _rawTraceCallbacks: RawTraceCallbacks,\n    // The common configuration for EthereumJS VM is not used by EDR, but tests expect it as part of the provider.\n    private readonly _common: Common,\n    tracingConfig?: TracingConfig\n  ) {\n    super();\n\n    if (tracingConfig !== undefined) {\n      initializeVmTraceDecoder(this._vmTraceDecoder, tracingConfig);\n    }\n  }\n\n  public static async create(\n    config: HardhatNetworkProviderConfig,\n    loggerConfig: LoggerConfig,\n    rawTraceCallbacks: RawTraceCallbacks,\n    tracingConfig?: TracingConfig\n  ): Promise<EdrProviderWrapper> {\n    const { Provider } =\n      require(\"@nomicfoundation/edr\") as typeof import(\"@nomicfoundation/edr\");\n\n    const coinbase = config.coinbase ?? DEFAULT_COINBASE;\n\n    let fork;\n    if (config.forkConfig !== undefined) {\n      fork = {\n        jsonRpcUrl: config.forkConfig.jsonRpcUrl,\n        blockNumber:\n          config.forkConfig.blockNumber !== undefined\n            ? BigInt(config.forkConfig.blockNumber)\n            : undefined,\n      };\n    }\n\n    const initialDate =\n      config.initialDate !== undefined\n        ? BigInt(Math.floor(config.initialDate.getTime() / 1000))\n        : undefined;\n\n    // To accomodate construction ordering, we need an adapter to forward events\n    // from the EdrProvider callback to the wrapper's listener\n    const eventAdapter = new EdrProviderEventAdapter();\n\n    const printLineFn = loggerConfig.printLineFn ?? printLine;\n    const replaceLastLineFn = loggerConfig.replaceLastLineFn ?? replaceLastLine;\n\n    const contractsIdentifier = new ContractsIdentifier();\n    const vmTraceDecoder = new VmTraceDecoder(contractsIdentifier);\n\n    const hardforkName = getHardforkName(config.hardfork);\n\n    const provider = await Provider.withConfig(\n      getGlobalEdrContext(),\n      {\n        allowBlocksWithSameTimestamp:\n          config.allowBlocksWithSameTimestamp ?? false,\n        allowUnlimitedContractSize: config.allowUnlimitedContractSize,\n        bailOnCallFailure: config.throwOnCallFailures,\n        bailOnTransactionFailure: config.throwOnTransactionFailures,\n        blockGasLimit: BigInt(config.blockGasLimit),\n        chainId: BigInt(config.chainId),\n        chains: Array.from(config.chains, ([chainId, hardforkConfig]) => {\n          return {\n            chainId: BigInt(chainId),\n            hardforks: Array.from(\n              hardforkConfig.hardforkHistory,\n              ([hardfork, blockNumber]) => {\n                return {\n                  blockNumber: BigInt(blockNumber),\n                  specId: ethereumsjsHardforkToEdrSpecId(\n                    getHardforkName(hardfork)\n                  ),\n                };\n              }\n            ),\n          };\n        }),\n        cacheDir: config.forkCachePath,\n        coinbase: Buffer.from(coinbase.slice(2), \"hex\"),\n        fork,\n        hardfork: ethereumsjsHardforkToEdrSpecId(hardforkName),\n        genesisAccounts: config.genesisAccounts.map((account) => {\n          return {\n            secretKey: account.privateKey,\n            balance: BigInt(account.balance),\n          };\n        }),\n        initialDate,\n        initialBaseFeePerGas:\n          config.initialBaseFeePerGas !== undefined\n            ? BigInt(config.initialBaseFeePerGas!)\n            : undefined,\n        minGasPrice: config.minGasPrice,\n        mining: {\n          autoMine: config.automine,\n          interval: ethereumjsIntervalMiningConfigToEdr(config.intervalMining),\n          memPool: {\n            order: ethereumjsMempoolOrderToEdrMineOrdering(config.mempoolOrder),\n          },\n        },\n        networkId: BigInt(config.networkId),\n      },\n      {\n        enable: loggerConfig.enabled,\n        decodeConsoleLogInputsCallback: (inputs: Buffer[]) => {\n          const consoleLogger = new ConsoleLogger();\n          return consoleLogger.getDecodedLogs(inputs);\n        },\n        getContractAndFunctionNameCallback: (\n          code: Buffer,\n          calldata?: Buffer\n        ) => {\n          return vmTraceDecoder.getContractAndFunctionNamesForCall(\n            code,\n            calldata\n          );\n        },\n        printLineCallback: (message: string, replace: boolean) => {\n          if (replace) {\n            replaceLastLineFn(message);\n          } else {\n            printLineFn(message);\n          }\n        },\n      },\n      (event: SubscriptionEvent) => {\n        eventAdapter.emit(\"ethEvent\", event);\n      }\n    );\n\n    const minimalEthereumJsNode = {\n      _vm: getMinimalEthereumJsVm(provider),\n    };\n\n    const common = makeCommon(getNodeConfig(config));\n    const wrapper = new EdrProviderWrapper(\n      provider,\n      minimalEthereumJsNode,\n      eventAdapter,\n      vmTraceDecoder,\n      rawTraceCallbacks,\n      common,\n      tracingConfig\n    );\n\n    // Pass through all events from the provider\n    eventAdapter.addListener(\n      \"ethEvent\",\n      wrapper._ethEventListener.bind(wrapper)\n    );\n\n    return wrapper;\n  }\n\n  public async request(args: RequestArguments): Promise<unknown> {\n    if (args.params !== undefined && !Array.isArray(args.params)) {\n      throw new InvalidInputError(\n        \"Hardhat Network doesn't support JSON-RPC params sent as an object\"\n      );\n    }\n\n    const params = args.params ?? [];\n\n    if (args.method === \"hardhat_addCompilationResult\") {\n      return this._addCompilationResultAction(\n        ...this._addCompilationResultParams(params)\n      );\n    } else if (args.method === \"hardhat_getStackTraceFailuresCount\") {\n      return this._getStackTraceFailuresCountAction(\n        ...this._getStackTraceFailuresCountParams(params)\n      );\n    }\n\n    const stringifiedArgs = JSON.stringify({\n      method: args.method,\n      params,\n    });\n\n    const responseObject: Response = await this._provider.handleRequest(\n      stringifiedArgs\n    );\n    const response = JSON.parse(responseObject.json);\n\n    const rawTraces = responseObject.traces;\n    for (const rawTrace of rawTraces) {\n      const trace = rawTrace.trace();\n      for (const traceItem of trace) {\n        if (\"pc\" in traceItem) {\n          if (this._node._vm.evm.events.listenerCount(\"step\") > 0) {\n            this._node._vm.evm.events.emit(\n              \"step\",\n              edrTracingStepToMinimalInterpreterStep(traceItem)\n            );\n          }\n          if (this._rawTraceCallbacks.onStep !== undefined) {\n            await this._rawTraceCallbacks.onStep(traceItem);\n          }\n        } else if (\"executionResult\" in traceItem) {\n          if (this._node._vm.evm.events.listenerCount(\"afterMessage\") > 0) {\n            this._node._vm.evm.events.emit(\n              \"afterMessage\",\n              edrTracingMessageResultToMinimalEVMResult(traceItem)\n            );\n          }\n          if (this._rawTraceCallbacks.onAfterMessage !== undefined) {\n            await this._rawTraceCallbacks.onAfterMessage(\n              traceItem.executionResult\n            );\n          }\n        } else {\n          if (this._node._vm.evm.events.listenerCount(\"beforeMessage\") > 0) {\n            this._node._vm.evm.events.emit(\n              \"beforeMessage\",\n              edrTracingMessageToMinimalMessage(traceItem)\n            );\n          }\n          if (this._rawTraceCallbacks.onBeforeMessage !== undefined) {\n            await this._rawTraceCallbacks.onBeforeMessage(traceItem);\n          }\n        }\n      }\n    }\n\n    if (isErrorResponse(response)) {\n      let error;\n\n      const solidityTrace = responseObject.solidityTrace;\n      let stackTrace: SolidityStackTrace | undefined;\n      if (solidityTrace !== null) {\n        stackTrace = await this._rawTraceToSolidityStackTrace(solidityTrace);\n      }\n\n      if (stackTrace !== undefined) {\n        error = encodeSolidityStackTrace(response.error.message, stackTrace);\n        // Pass data and transaction hash from the original error\n        (error as any).data = response.error.data?.data ?? undefined;\n        (error as any).transactionHash =\n          response.error.data?.transactionHash ?? undefined;\n      } else {\n        if (response.error.code === InvalidArgumentsError.CODE) {\n          error = new InvalidArgumentsError(response.error.message);\n        } else {\n          error = new ProviderError(\n            response.error.message,\n            response.error.code\n          );\n        }\n        error.data = response.error.data;\n      }\n\n      // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n\n    if (args.method === \"hardhat_reset\") {\n      this.emit(HARDHAT_NETWORK_RESET_EVENT);\n    } else if (args.method === \"evm_revert\") {\n      this.emit(HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT);\n    }\n\n    // Override EDR version string with Hardhat version string with EDR backend,\n    // e.g. `HardhatNetwork/2.19.0/@nomicfoundation/edr/0.2.0-dev`\n    if (args.method === \"web3_clientVersion\") {\n      return clientVersion(response.result);\n    } else if (\n      args.method === \"debug_traceTransaction\" ||\n      args.method === \"debug_traceCall\"\n    ) {\n      return edrRpcDebugTraceToHardhat(response.result);\n    } else {\n      return response.result;\n    }\n  }\n\n  // temporarily added to make smock work with HH+EDR\n  private _setCallOverrideCallback(callback: CallOverrideCallback) {\n    this._callOverrideCallback = callback;\n\n    this._provider.setCallOverrideCallback(\n      async (address: Buffer, data: Buffer) => {\n        return this._callOverrideCallback?.(address, data);\n      }\n    );\n  }\n\n  private _ethEventListener(event: SubscriptionEvent) {\n    const subscription = `0x${event.filterId.toString(16)}`;\n    const results = Array.isArray(event.result) ? event.result : [event.result];\n    for (const result of results) {\n      this._emitLegacySubscriptionEvent(subscription, result);\n      this._emitEip1193SubscriptionEvent(subscription, result);\n    }\n  }\n\n  private _emitLegacySubscriptionEvent(subscription: string, result: any) {\n    this.emit(\"notification\", {\n      subscription,\n      result,\n    });\n  }\n\n  private _emitEip1193SubscriptionEvent(subscription: string, result: unknown) {\n    const message: EthSubscription = {\n      type: \"eth_subscription\",\n      data: {\n        subscription,\n        result,\n      },\n    };\n\n    this.emit(\"message\", message);\n  }\n\n  private _addCompilationResultParams(\n    params: any[]\n  ): [string, CompilerInput, CompilerOutput] {\n    return validateParams(\n      params,\n      t.string,\n      rpcCompilerInput,\n      rpcCompilerOutput\n    );\n  }\n\n  private async _addCompilationResultAction(\n    solcVersion: string,\n    compilerInput: CompilerInput,\n    compilerOutput: CompilerOutput\n  ): Promise<boolean> {\n    let bytecodes;\n    try {\n      bytecodes = createModelsAndDecodeBytecodes(\n        solcVersion,\n        compilerInput,\n        compilerOutput\n      );\n    } catch (error) {\n      console.warn(\n        chalk.yellow(\n          \"The Hardhat Network tracing engine could not be updated. Run Hardhat with --verbose to learn more.\"\n        )\n      );\n\n      log(\n        \"ContractsIdentifier failed to be updated. Please report this to help us improve Hardhat.\\n\",\n        error\n      );\n\n      return false;\n    }\n\n    for (const bytecode of bytecodes) {\n      this._vmTraceDecoder.addBytecode(bytecode);\n    }\n\n    return true;\n  }\n\n  private _getStackTraceFailuresCountParams(params: any[]): [] {\n    return validateParams(params);\n  }\n\n  private _getStackTraceFailuresCountAction(): number {\n    return this._failedStackTraces;\n  }\n\n  private async _rawTraceToSolidityStackTrace(\n    rawTrace: RawTrace\n  ): Promise<SolidityStackTrace | undefined> {\n    const vmTracer = new VMTracer(false);\n\n    const trace = rawTrace.trace();\n    for (const traceItem of trace) {\n      if (\"pc\" in traceItem) {\n        await vmTracer.addStep(traceItem);\n      } else if (\"executionResult\" in traceItem) {\n        await vmTracer.addAfterMessage(traceItem.executionResult);\n      } else {\n        await vmTracer.addBeforeMessage(traceItem);\n      }\n    }\n\n    let vmTrace = vmTracer.getLastTopLevelMessageTrace();\n    const vmTracerError = vmTracer.getLastError();\n\n    if (vmTrace !== undefined) {\n      vmTrace = this._vmTraceDecoder.tryToDecodeMessageTrace(vmTrace);\n    }\n\n    try {\n      if (vmTrace === undefined || vmTracerError !== undefined) {\n        throw vmTracerError;\n      }\n\n      const solidityTracer = new SolidityTracer();\n      return solidityTracer.getStackTrace(vmTrace);\n    } catch (err) {\n      this._failedStackTraces += 1;\n      log(\n        \"Could not generate stack trace. Please report this to help us improve Hardhat.\\n\",\n        err\n      );\n    }\n  }\n}\n\nasync function clientVersion(edrClientVersion: string): Promise<string> {\n  const hardhatPackage = await getPackageJson();\n  const edrVersion = edrClientVersion.split(\"/\")[1];\n  return `HardhatNetwork/${hardhatPackage.version}/@nomicfoundation/edr/${edrVersion}`;\n}\n\nexport async function createHardhatNetworkProvider(\n  hardhatNetworkProviderConfig: HardhatNetworkProviderConfig,\n  loggerConfig: LoggerConfig,\n  artifacts?: Artifacts\n): Promise<EIP1193Provider> {\n  return EdrProviderWrapper.create(\n    hardhatNetworkProviderConfig,\n    loggerConfig,\n    {},\n    await makeTracingConfig(artifacts)\n  );\n}\n\nasync function makeTracingConfig(\n  artifacts: Artifacts | undefined\n): Promise<TracingConfig | undefined> {\n  if (artifacts !== undefined) {\n    const buildInfos = [];\n\n    const buildInfoFiles = await artifacts.getBuildInfoPaths();\n\n    try {\n      for (const buildInfoFile of buildInfoFiles) {\n        const buildInfo = await fsExtra.readJson(buildInfoFile);\n        if (semver.gte(buildInfo.solcVersion, FIRST_SOLC_VERSION_SUPPORTED)) {\n          buildInfos.push(buildInfo);\n        }\n      }\n\n      return {\n        buildInfos,\n      };\n    } catch (error) {\n      console.warn(\n        chalk.yellow(\n          \"Stack traces engine could not be initialized. Run Hardhat with --verbose to learn more.\"\n        )\n      );\n\n      log(\n        \"Solidity stack traces disabled: Failed to read solc's input and output files. Please report this to help us improve Hardhat.\\n\",\n        error\n      );\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}