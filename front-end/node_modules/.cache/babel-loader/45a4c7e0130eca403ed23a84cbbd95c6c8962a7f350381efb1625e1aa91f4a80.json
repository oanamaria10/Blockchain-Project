{"ast":null,"code":"import { keccak256 } from 'ethereum-cryptography/keccak.js';\nimport { ecdsaRecover, ecdsaSign, publicKeyConvert } from 'ethereum-cryptography/secp256k1';\nimport { bytesToBigInt, bytesToHex, bytesToInt, concatBytes, setLengthLeft, toBytes } from './bytes.js';\nimport { BIGINT_0, BIGINT_1, BIGINT_2, BIGINT_27, SECP256K1_ORDER, SECP256K1_ORDER_DIV_2 } from './constants.js';\nimport { assertIsBytes } from './helpers.js';\n/**\n * Returns the ECDSA signature of a message hash.\n *\n * If `chainId` is provided assume an EIP-155-style signature and calculate the `v` value\n * accordingly, otherwise return a \"static\" `v` just derived from the `recovery` bit\n */\nexport function ecsign(msgHash, privateKey, chainId) {\n  const {\n    signature,\n    recid: recovery\n  } = ecdsaSign(msgHash, privateKey);\n  const r = Buffer.from(signature.slice(0, 32));\n  const s = Buffer.from(signature.slice(32, 64));\n  const v = chainId === undefined ? BigInt(recovery + 27) : BigInt(recovery + 35) + BigInt(chainId) * BigInt(2);\n  return {\n    r,\n    s,\n    v\n  };\n}\nexport function calculateSigRecovery(v, chainId) {\n  if (v === BIGINT_0 || v === BIGINT_1) return v;\n  if (chainId === undefined) {\n    return v - BIGINT_27;\n  }\n  return v - (chainId * BIGINT_2 + BigInt(35));\n}\nfunction isValidSigRecovery(recovery) {\n  return recovery === BIGINT_0 || recovery === BIGINT_1;\n}\n/**\n * ECDSA public key recovery from signature.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Recovered public key\n */\nexport const ecrecover = function (msgHash, v, r, s, chainId) {\n  const signature = concatBytes(setLengthLeft(r, 32), setLengthLeft(s, 32));\n  const recovery = calculateSigRecovery(v, chainId);\n  if (!isValidSigRecovery(recovery)) {\n    throw new Error('Invalid signature v value');\n  }\n  const senderPubKey = ecdsaRecover(signature, Number(recovery), msgHash);\n  return Buffer.from(publicKeyConvert(senderPubKey, false).slice(1));\n};\n/**\n * Convert signature parameters into the format of `eth_sign` RPC method.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Signature\n */\nexport const toRpcSig = function (v, r, s, chainId) {\n  const recovery = calculateSigRecovery(v, chainId);\n  if (!isValidSigRecovery(recovery)) {\n    throw new Error('Invalid signature v value');\n  }\n  // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin\n  return bytesToHex(concatBytes(setLengthLeft(r, 32), setLengthLeft(s, 32), toBytes(v)));\n};\n/**\n * Convert signature parameters into the format of Compact Signature Representation (EIP-2098).\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Signature\n */\nexport const toCompactSig = function (v, r, s, chainId) {\n  const recovery = calculateSigRecovery(v, chainId);\n  if (!isValidSigRecovery(recovery)) {\n    throw new Error('Invalid signature v value');\n  }\n  const ss = Uint8Array.from([...s]);\n  if (v > BigInt(28) && v % BIGINT_2 === BIGINT_1 || v === BIGINT_1 || v === BigInt(28)) {\n    ss[0] |= 0x80;\n  }\n  return bytesToHex(concatBytes(setLengthLeft(r, 32), setLengthLeft(ss, 32)));\n};\n/**\n * Convert signature format of the `eth_sign` RPC method to signature parameters\n *\n * NOTE: For an extracted `v` value < 27 (see Geth bug https://github.com/ethereum/go-ethereum/issues/2053)\n * `v + 27` is returned for the `v` value\n * NOTE: After EIP1559, `v` could be `0` or `1` but this function assumes\n * it's a signed message (EIP-191 or EIP-712) adding `27` at the end. Remove if needed.\n */\nexport const fromRpcSig = function (sig) {\n  const bytes = toBytes(sig);\n  let r;\n  let s;\n  let v;\n  if (bytes.length >= 65) {\n    r = bytes.subarray(0, 32);\n    s = bytes.subarray(32, 64);\n    v = bytesToBigInt(bytes.subarray(64));\n  } else if (bytes.length === 64) {\n    // Compact Signature Representation (https://eips.ethereum.org/EIPS/eip-2098)\n    r = bytes.subarray(0, 32);\n    s = bytes.subarray(32, 64);\n    v = BigInt(bytesToInt(bytes.subarray(32, 33)) >> 7);\n    s[0] &= 0x7f;\n  } else {\n    throw new Error('Invalid signature length');\n  }\n  // support both versions of `eth_sign` responses\n  if (v < 27) {\n    v = v + BIGINT_27;\n  }\n  return {\n    v,\n    r,\n    s\n  };\n};\n/**\n * Validate a ECDSA signature.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one\n */\nexport const isValidSignature = function (v, r, s, homesteadOrLater = true, chainId) {\n  if (r.length !== 32 || s.length !== 32) {\n    return false;\n  }\n  if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {\n    return false;\n  }\n  const rBigInt = bytesToBigInt(r);\n  const sBigInt = bytesToBigInt(s);\n  if (rBigInt === BIGINT_0 || rBigInt >= SECP256K1_ORDER || sBigInt === BIGINT_0 || sBigInt >= SECP256K1_ORDER) {\n    return false;\n  }\n  if (homesteadOrLater && sBigInt >= SECP256K1_ORDER_DIV_2) {\n    return false;\n  }\n  return true;\n};\n/**\n * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.\n * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`\n * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key\n * used to produce the signature.\n */\nexport const hashPersonalMessage = function (message) {\n  assertIsBytes(message);\n  const prefix = Buffer.from(`\\u0019Ethereum Signed Message:\\n${message.length}`, 'utf-8');\n  return Buffer.from(keccak256(Buffer.concat([prefix, message])));\n};","map":{"version":3,"names":["keccak256","ecdsaRecover","ecdsaSign","publicKeyConvert","bytesToBigInt","bytesToHex","bytesToInt","concatBytes","setLengthLeft","toBytes","BIGINT_0","BIGINT_1","BIGINT_2","BIGINT_27","SECP256K1_ORDER","SECP256K1_ORDER_DIV_2","assertIsBytes","ecsign","msgHash","privateKey","chainId","signature","recid","recovery","r","Buffer","from","slice","s","v","undefined","BigInt","calculateSigRecovery","isValidSigRecovery","ecrecover","Error","senderPubKey","Number","toRpcSig","toCompactSig","ss","Uint8Array","fromRpcSig","sig","bytes","length","subarray","isValidSignature","homesteadOrLater","rBigInt","sBigInt","hashPersonalMessage","message","prefix","concat"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\@nomicfoundation\\ethereumjs-util\\src\\signature.ts"],"sourcesContent":["import { keccak256 } from 'ethereum-cryptography/keccak.js'\nimport { ecdsaRecover, ecdsaSign, publicKeyConvert } from 'ethereum-cryptography/secp256k1'\n\nimport {\n  bytesToBigInt,\n  bytesToHex,\n  bytesToInt,\n  concatBytes,\n  setLengthLeft,\n  toBytes,\n} from './bytes.js'\nimport {\n  BIGINT_0,\n  BIGINT_1,\n  BIGINT_2,\n  BIGINT_27,\n  SECP256K1_ORDER,\n  SECP256K1_ORDER_DIV_2,\n} from './constants.js'\nimport { assertIsBytes } from './helpers.js'\n\nexport interface ECDSASignature {\n  v: bigint\n  r: Uint8Array\n  s: Uint8Array\n}\n\n/**\n * Returns the ECDSA signature of a message hash.\n *\n * If `chainId` is provided assume an EIP-155-style signature and calculate the `v` value\n * accordingly, otherwise return a \"static\" `v` just derived from the `recovery` bit\n */\nexport function ecsign(\n  msgHash: Uint8Array,\n  privateKey: Uint8Array,\n  chainId?: bigint\n): ECDSASignature {\n  const { signature, recid: recovery } = ecdsaSign(msgHash, privateKey)\n\n  const r = Buffer.from(signature.slice(0, 32))\n  const s = Buffer.from(signature.slice(32, 64))\n\n  const v =\n    chainId === undefined\n      ? BigInt(recovery + 27)\n      : BigInt(recovery + 35) + BigInt(chainId) * BigInt(2)\n\n  return { r, s, v }\n}\n\nexport function calculateSigRecovery(v: bigint, chainId?: bigint): bigint {\n  if (v === BIGINT_0 || v === BIGINT_1) return v\n\n  if (chainId === undefined) {\n    return v - BIGINT_27\n  }\n  return v - (chainId * BIGINT_2 + BigInt(35))\n}\n\nfunction isValidSigRecovery(recovery: bigint): boolean {\n  return recovery === BIGINT_0 || recovery === BIGINT_1\n}\n\n/**\n * ECDSA public key recovery from signature.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Recovered public key\n */\nexport const ecrecover = function (\n  msgHash: Uint8Array,\n  v: bigint,\n  r: Uint8Array,\n  s: Uint8Array,\n  chainId?: bigint\n): Uint8Array {\n  const signature = concatBytes(setLengthLeft(r, 32), setLengthLeft(s, 32))\n  const recovery = calculateSigRecovery(v, chainId)\n  if (!isValidSigRecovery(recovery)) {\n    throw new Error('Invalid signature v value')\n  }\n\n  const senderPubKey = ecdsaRecover(signature, Number(recovery), msgHash)\n  return Buffer.from(publicKeyConvert(senderPubKey, false).slice(1))\n}\n\n/**\n * Convert signature parameters into the format of `eth_sign` RPC method.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Signature\n */\nexport const toRpcSig = function (\n  v: bigint,\n  r: Uint8Array,\n  s: Uint8Array,\n  chainId?: bigint\n): string {\n  const recovery = calculateSigRecovery(v, chainId)\n  if (!isValidSigRecovery(recovery)) {\n    throw new Error('Invalid signature v value')\n  }\n\n  // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin\n\n  return bytesToHex(concatBytes(setLengthLeft(r, 32), setLengthLeft(s, 32), toBytes(v)))\n}\n\n/**\n * Convert signature parameters into the format of Compact Signature Representation (EIP-2098).\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Signature\n */\nexport const toCompactSig = function (\n  v: bigint,\n  r: Uint8Array,\n  s: Uint8Array,\n  chainId?: bigint\n): string {\n  const recovery = calculateSigRecovery(v, chainId)\n  if (!isValidSigRecovery(recovery)) {\n    throw new Error('Invalid signature v value')\n  }\n\n  const ss = Uint8Array.from([...s])\n  if ((v > BigInt(28) && v % BIGINT_2 === BIGINT_1) || v === BIGINT_1 || v === BigInt(28)) {\n    ss[0] |= 0x80\n  }\n\n  return bytesToHex(concatBytes(setLengthLeft(r, 32), setLengthLeft(ss, 32)))\n}\n\n/**\n * Convert signature format of the `eth_sign` RPC method to signature parameters\n *\n * NOTE: For an extracted `v` value < 27 (see Geth bug https://github.com/ethereum/go-ethereum/issues/2053)\n * `v + 27` is returned for the `v` value\n * NOTE: After EIP1559, `v` could be `0` or `1` but this function assumes\n * it's a signed message (EIP-191 or EIP-712) adding `27` at the end. Remove if needed.\n */\nexport const fromRpcSig = function (sig: string): ECDSASignature {\n  const bytes: Uint8Array = toBytes(sig)\n\n  let r: Uint8Array\n  let s: Uint8Array\n  let v: bigint\n  if (bytes.length >= 65) {\n    r = bytes.subarray(0, 32)\n    s = bytes.subarray(32, 64)\n    v = bytesToBigInt(bytes.subarray(64))\n  } else if (bytes.length === 64) {\n    // Compact Signature Representation (https://eips.ethereum.org/EIPS/eip-2098)\n    r = bytes.subarray(0, 32)\n    s = bytes.subarray(32, 64)\n    v = BigInt(bytesToInt(bytes.subarray(32, 33)) >> 7)\n    s[0] &= 0x7f\n  } else {\n    throw new Error('Invalid signature length')\n  }\n\n  // support both versions of `eth_sign` responses\n  if (v < 27) {\n    v = v + BIGINT_27\n  }\n\n  return {\n    v,\n    r,\n    s,\n  }\n}\n\n/**\n * Validate a ECDSA signature.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one\n */\nexport const isValidSignature = function (\n  v: bigint,\n  r: Uint8Array,\n  s: Uint8Array,\n  homesteadOrLater: boolean = true,\n  chainId?: bigint\n): boolean {\n  if (r.length !== 32 || s.length !== 32) {\n    return false\n  }\n\n  if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {\n    return false\n  }\n\n  const rBigInt = bytesToBigInt(r)\n  const sBigInt = bytesToBigInt(s)\n\n  if (\n    rBigInt === BIGINT_0 ||\n    rBigInt >= SECP256K1_ORDER ||\n    sBigInt === BIGINT_0 ||\n    sBigInt >= SECP256K1_ORDER\n  ) {\n    return false\n  }\n\n  if (homesteadOrLater && sBigInt >= SECP256K1_ORDER_DIV_2) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.\n * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`\n * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key\n * used to produce the signature.\n */\nexport const hashPersonalMessage = function (message: Uint8Array): Uint8Array {\n  assertIsBytes(message)\n  const prefix = Buffer.from(`\\u0019Ethereum Signed Message:\\n${message.length}`, 'utf-8')\n  return Buffer.from(keccak256(Buffer.concat([prefix, message])))\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}