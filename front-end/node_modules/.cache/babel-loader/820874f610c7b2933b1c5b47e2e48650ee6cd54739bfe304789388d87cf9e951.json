{"ast":null,"code":"// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\";\nimport { CID, format, toJSON, fromJSON } from './cid.js';\n// This way TS will also expose all the types from module\nexport * from './link/interface.js';\nconst DAG_PB_CODE = 0x70;\n// eslint-disable-next-line\nconst SHA_256_CODE = 0x12;\n\n/**\n * Simplified version of `create` for CIDv0.\n *\n * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n * @returns {API.LegacyLink}\n */\nexport const createLegacy = digest => CID.create(0, DAG_PB_CODE, digest);\n\n/**\n * Simplified version of `create` for CIDv1.\n *\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @param {Code} code - Content encoding format code.\n * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n * @returns {API.Link<Data, Code, Alg>}\n */\nexport const create = (code, digest) => CID.create(1, code, digest);\n\n/**\n * Type predicate returns true if value is the link.\n *\n * @template {API.Link<unknown, number, number, 0|1>} L\n * @param {unknown|L} value\n * @returns {value is L & CID}\n */\nexport const isLink = value => {\n  if (value == null) {\n    return false;\n  }\n  const withSlash = /** @type {{'/'?: Uint8Array, bytes: Uint8Array}} */value;\n  if (withSlash['/'] != null && withSlash['/'] === withSlash.bytes) {\n    return true;\n  }\n  const withAsCID = /** @type {{'asCID'?: unknown}} */value;\n  if (withAsCID.asCID === value) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * Takes cid in a string representation and creates an instance. If `base`\n * decoder is not provided will use a default from the configuration. It will\n * throw an error if encoding of the CID is not compatible with supplied (or\n * a default decoder).\n *\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {API.Link<Data, Code, Alg, Ver>}\n */\nexport const parse = (source, base) => CID.parse(source, base);\nexport { format, toJSON, fromJSON };\n\n/**\n * Decoded a CID from its binary representation. The byte array must contain\n * only the CID with no additional bytes.\n *\n * An error will be thrown if the bytes provided do not contain a valid\n * binary representation of a CID.\n *\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n * @returns {API.Link<Data, Code, Alg, Ver>}\n */\nexport const decode = bytes => CID.decode(bytes);","map":{"version":3,"names":["API","CID","format","toJSON","fromJSON","DAG_PB_CODE","SHA_256_CODE","createLegacy","digest","create","code","isLink","value","withSlash","bytes","withAsCID","asCID","parse","source","base","decode"],"sources":["C:/FACULTATE/Proiect/node_modules/@ipld/dag-ucan/node_modules/multiformats/src/link.js"],"sourcesContent":["// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\nimport { CID, format, toJSON, fromJSON } from './cid.js'\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\nconst DAG_PB_CODE = 0x70\n// eslint-disable-next-line\nconst SHA_256_CODE = 0x12\n\n/**\n * Simplified version of `create` for CIDv0.\n *\n * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n * @returns {API.LegacyLink}\n */\nexport const createLegacy = digest => CID.create(0, DAG_PB_CODE, digest)\n\n/**\n * Simplified version of `create` for CIDv1.\n *\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @param {Code} code - Content encoding format code.\n * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n * @returns {API.Link<Data, Code, Alg>}\n */\nexport const create = (code, digest) => CID.create(1, code, digest)\n\n/**\n * Type predicate returns true if value is the link.\n *\n * @template {API.Link<unknown, number, number, 0|1>} L\n * @param {unknown|L} value\n * @returns {value is L & CID}\n */\nexport const isLink = value => {\n  if (value == null) {\n    return false\n  }\n\n  const withSlash = /** @type {{'/'?: Uint8Array, bytes: Uint8Array}} */ (value)\n\n  if (withSlash['/'] != null && withSlash['/'] === withSlash.bytes) {\n    return true\n  }\n\n  const withAsCID = /** @type {{'asCID'?: unknown}} */ (value)\n\n  if (withAsCID.asCID === value) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Takes cid in a string representation and creates an instance. If `base`\n * decoder is not provided will use a default from the configuration. It will\n * throw an error if encoding of the CID is not compatible with supplied (or\n * a default decoder).\n *\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {API.Link<Data, Code, Alg, Ver>}\n */\nexport const parse = (source, base) => CID.parse(source, base)\n\nexport { format, toJSON, fromJSON }\n\n/**\n * Decoded a CID from its binary representation. The byte array must contain\n * only the CID with no additional bytes.\n *\n * An error will be thrown if the bytes provided do not contain a valid\n * binary representation of a CID.\n *\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n * @returns {API.Link<Data, Code, Alg, Ver>}\n */\nexport const decode = bytes => CID.decode(bytes)\n"],"mappings":"AAAA;AACA;AACA,OAAO,KAAKA,GAAG,MAAM,qBAAqB;AAC1C,SAASC,GAAG,EAAEC,MAAM,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,UAAU;AACxD;AACA,cAAc,qBAAqB;AAEnC,MAAMC,WAAW,GAAG,IAAI;AACxB;AACA,MAAMC,YAAY,GAAG,IAAI;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,YAAY,GAAGC,MAAM,IAAIP,GAAG,CAACQ,MAAM,CAAC,CAAC,EAAEJ,WAAW,EAAEG,MAAM,CAAC;;AAExE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,MAAM,GAAGA,CAACC,IAAI,EAAEF,MAAM,KAAKP,GAAG,CAACQ,MAAM,CAAC,CAAC,EAAEC,IAAI,EAAEF,MAAM,CAAC;;AAEnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMG,MAAM,GAAGC,KAAK,IAAI;EAC7B,IAAIA,KAAK,IAAI,IAAI,EAAE;IACjB,OAAO,KAAK;EACd;EAEA,MAAMC,SAAS,GAAG,oDAAsDD,KAAM;EAE9E,IAAIC,SAAS,CAAC,GAAG,CAAC,IAAI,IAAI,IAAIA,SAAS,CAAC,GAAG,CAAC,KAAKA,SAAS,CAACC,KAAK,EAAE;IAChE,OAAO,IAAI;EACb;EAEA,MAAMC,SAAS,GAAG,kCAAoCH,KAAM;EAE5D,IAAIG,SAAS,CAACC,KAAK,KAAKJ,KAAK,EAAE;IAC7B,OAAO,IAAI;EACb;EAEA,OAAO,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMK,KAAK,GAAGA,CAACC,MAAM,EAAEC,IAAI,KAAKlB,GAAG,CAACgB,KAAK,CAACC,MAAM,EAAEC,IAAI,CAAC;AAE9D,SAASjB,MAAM,EAAEC,MAAM,EAAEC,QAAQ;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMgB,MAAM,GAAGN,KAAK,IAAIb,GAAG,CAACmB,MAAM,CAACN,KAAK,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}