{"ast":null,"code":"'use strict';\n\nconst {\n  maxNameValuePairSize,\n  maxAttributeValueSize\n} = require('./constants');\nconst {\n  isCTLExcludingHtab\n} = require('./util');\nconst {\n  collectASequenceOfCodePointsFast\n} = require('../fetch/dataURL');\nconst assert = require('assert');\n\n/**\n * @description Parses the field-value attributes of a set-cookie header string.\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} header\n * @returns if the header is invalid, null will be returned\n */\nfunction parseSetCookie(header) {\n  // 1. If the set-cookie-string contains a %x00-08 / %x0A-1F / %x7F\n  //    character (CTL characters excluding HTAB): Abort these steps and\n  //    ignore the set-cookie-string entirely.\n  if (isCTLExcludingHtab(header)) {\n    return null;\n  }\n  let nameValuePair = '';\n  let unparsedAttributes = '';\n  let name = '';\n  let value = '';\n\n  // 2. If the set-cookie-string contains a %x3B (\";\") character:\n  if (header.includes(';')) {\n    // 1. The name-value-pair string consists of the characters up to,\n    //    but not including, the first %x3B (\";\"), and the unparsed-\n    //    attributes consist of the remainder of the set-cookie-string\n    //    (including the %x3B (\";\") in question).\n    const position = {\n      position: 0\n    };\n    nameValuePair = collectASequenceOfCodePointsFast(';', header, position);\n    unparsedAttributes = header.slice(position.position);\n  } else {\n    // Otherwise:\n\n    // 1. The name-value-pair string consists of all the characters\n    //    contained in the set-cookie-string, and the unparsed-\n    //    attributes is the empty string.\n    nameValuePair = header;\n  }\n\n  // 3. If the name-value-pair string lacks a %x3D (\"=\") character, then\n  //    the name string is empty, and the value string is the value of\n  //    name-value-pair.\n  if (!nameValuePair.includes('=')) {\n    value = nameValuePair;\n  } else {\n    //    Otherwise, the name string consists of the characters up to, but\n    //    not including, the first %x3D (\"=\") character, and the (possibly\n    //    empty) value string consists of the characters after the first\n    //    %x3D (\"=\") character.\n    const position = {\n      position: 0\n    };\n    name = collectASequenceOfCodePointsFast('=', nameValuePair, position);\n    value = nameValuePair.slice(position.position + 1);\n  }\n\n  // 4. Remove any leading or trailing WSP characters from the name\n  //    string and the value string.\n  name = name.trim();\n  value = value.trim();\n\n  // 5. If the sum of the lengths of the name string and the value string\n  //    is more than 4096 octets, abort these steps and ignore the set-\n  //    cookie-string entirely.\n  if (name.length + value.length > maxNameValuePairSize) {\n    return null;\n  }\n\n  // 6. The cookie-name is the name string, and the cookie-value is the\n  //    value string.\n  return {\n    name,\n    value,\n    ...parseUnparsedAttributes(unparsedAttributes)\n  };\n}\n\n/**\n * Parses the remaining attributes of a set-cookie header\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} unparsedAttributes\n * @param {[Object.<string, unknown>]={}} cookieAttributeList\n */\nfunction parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {\n  // 1. If the unparsed-attributes string is empty, skip the rest of\n  //    these steps.\n  if (unparsedAttributes.length === 0) {\n    return cookieAttributeList;\n  }\n\n  // 2. Discard the first character of the unparsed-attributes (which\n  //    will be a %x3B (\";\") character).\n  assert(unparsedAttributes[0] === ';');\n  unparsedAttributes = unparsedAttributes.slice(1);\n  let cookieAv = '';\n\n  // 3. If the remaining unparsed-attributes contains a %x3B (\";\")\n  //    character:\n  if (unparsedAttributes.includes(';')) {\n    // 1. Consume the characters of the unparsed-attributes up to, but\n    //    not including, the first %x3B (\";\") character.\n    cookieAv = collectASequenceOfCodePointsFast(';', unparsedAttributes, {\n      position: 0\n    });\n    unparsedAttributes = unparsedAttributes.slice(cookieAv.length);\n  } else {\n    // Otherwise:\n\n    // 1. Consume the remainder of the unparsed-attributes.\n    cookieAv = unparsedAttributes;\n    unparsedAttributes = '';\n  }\n\n  // Let the cookie-av string be the characters consumed in this step.\n\n  let attributeName = '';\n  let attributeValue = '';\n\n  // 4. If the cookie-av string contains a %x3D (\"=\") character:\n  if (cookieAv.includes('=')) {\n    // 1. The (possibly empty) attribute-name string consists of the\n    //    characters up to, but not including, the first %x3D (\"=\")\n    //    character, and the (possibly empty) attribute-value string\n    //    consists of the characters after the first %x3D (\"=\")\n    //    character.\n    const position = {\n      position: 0\n    };\n    attributeName = collectASequenceOfCodePointsFast('=', cookieAv, position);\n    attributeValue = cookieAv.slice(position.position + 1);\n  } else {\n    // Otherwise:\n\n    // 1. The attribute-name string consists of the entire cookie-av\n    //    string, and the attribute-value string is empty.\n    attributeName = cookieAv;\n  }\n\n  // 5. Remove any leading or trailing WSP characters from the attribute-\n  //    name string and the attribute-value string.\n  attributeName = attributeName.trim();\n  attributeValue = attributeValue.trim();\n\n  // 6. If the attribute-value is longer than 1024 octets, ignore the\n  //    cookie-av string and return to Step 1 of this algorithm.\n  if (attributeValue.length > maxAttributeValueSize) {\n    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);\n  }\n\n  // 7. Process the attribute-name and attribute-value according to the\n  //    requirements in the following subsections.  (Notice that\n  //    attributes with unrecognized attribute-names are ignored.)\n  const attributeNameLowercase = attributeName.toLowerCase();\n\n  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.1\n  // If the attribute-name case-insensitively matches the string\n  // \"Expires\", the user agent MUST process the cookie-av as follows.\n  if (attributeNameLowercase === 'expires') {\n    // 1. Let the expiry-time be the result of parsing the attribute-value\n    //    as cookie-date (see Section 5.1.1).\n    const expiryTime = new Date(attributeValue);\n\n    // 2. If the attribute-value failed to parse as a cookie date, ignore\n    //    the cookie-av.\n\n    cookieAttributeList.expires = expiryTime;\n  } else if (attributeNameLowercase === 'max-age') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.2\n    // If the attribute-name case-insensitively matches the string \"Max-\n    // Age\", the user agent MUST process the cookie-av as follows.\n\n    // 1. If the first character of the attribute-value is not a DIGIT or a\n    //    \"-\" character, ignore the cookie-av.\n    const charCode = attributeValue.charCodeAt(0);\n    if ((charCode < 48 || charCode > 57) && attributeValue[0] !== '-') {\n      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);\n    }\n\n    // 2. If the remainder of attribute-value contains a non-DIGIT\n    //    character, ignore the cookie-av.\n    if (!/^\\d+$/.test(attributeValue)) {\n      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);\n    }\n\n    // 3. Let delta-seconds be the attribute-value converted to an integer.\n    const deltaSeconds = Number(attributeValue);\n\n    // 4. Let cookie-age-limit be the maximum age of the cookie (which\n    //    SHOULD be 400 days or less, see Section 4.1.2.2).\n\n    // 5. Set delta-seconds to the smaller of its present value and cookie-\n    //    age-limit.\n    // deltaSeconds = Math.min(deltaSeconds * 1000, maxExpiresMs)\n\n    // 6. If delta-seconds is less than or equal to zero (0), let expiry-\n    //    time be the earliest representable date and time.  Otherwise, let\n    //    the expiry-time be the current date and time plus delta-seconds\n    //    seconds.\n    // const expiryTime = deltaSeconds <= 0 ? Date.now() : Date.now() + deltaSeconds\n\n    // 7. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of Max-Age and an attribute-value of expiry-time.\n    cookieAttributeList.maxAge = deltaSeconds;\n  } else if (attributeNameLowercase === 'domain') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.3\n    // If the attribute-name case-insensitively matches the string \"Domain\",\n    // the user agent MUST process the cookie-av as follows.\n\n    // 1. Let cookie-domain be the attribute-value.\n    let cookieDomain = attributeValue;\n\n    // 2. If cookie-domain starts with %x2E (\".\"), let cookie-domain be\n    //    cookie-domain without its leading %x2E (\".\").\n    if (cookieDomain[0] === '.') {\n      cookieDomain = cookieDomain.slice(1);\n    }\n\n    // 3. Convert the cookie-domain to lower case.\n    cookieDomain = cookieDomain.toLowerCase();\n\n    // 4. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of Domain and an attribute-value of cookie-domain.\n    cookieAttributeList.domain = cookieDomain;\n  } else if (attributeNameLowercase === 'path') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.4\n    // If the attribute-name case-insensitively matches the string \"Path\",\n    // the user agent MUST process the cookie-av as follows.\n\n    // 1. If the attribute-value is empty or if the first character of the\n    //    attribute-value is not %x2F (\"/\"):\n    let cookiePath = '';\n    if (attributeValue.length === 0 || attributeValue[0] !== '/') {\n      // 1. Let cookie-path be the default-path.\n      cookiePath = '/';\n    } else {\n      // Otherwise:\n\n      // 1. Let cookie-path be the attribute-value.\n      cookiePath = attributeValue;\n    }\n\n    // 2. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of Path and an attribute-value of cookie-path.\n    cookieAttributeList.path = cookiePath;\n  } else if (attributeNameLowercase === 'secure') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.5\n    // If the attribute-name case-insensitively matches the string \"Secure\",\n    // the user agent MUST append an attribute to the cookie-attribute-list\n    // with an attribute-name of Secure and an empty attribute-value.\n\n    cookieAttributeList.secure = true;\n  } else if (attributeNameLowercase === 'httponly') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.6\n    // If the attribute-name case-insensitively matches the string\n    // \"HttpOnly\", the user agent MUST append an attribute to the cookie-\n    // attribute-list with an attribute-name of HttpOnly and an empty\n    // attribute-value.\n\n    cookieAttributeList.httpOnly = true;\n  } else if (attributeNameLowercase === 'samesite') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.7\n    // If the attribute-name case-insensitively matches the string\n    // \"SameSite\", the user agent MUST process the cookie-av as follows:\n\n    // 1. Let enforcement be \"Default\".\n    let enforcement = 'Default';\n    const attributeValueLowercase = attributeValue.toLowerCase();\n    // 2. If cookie-av's attribute-value is a case-insensitive match for\n    //    \"None\", set enforcement to \"None\".\n    if (attributeValueLowercase.includes('none')) {\n      enforcement = 'None';\n    }\n\n    // 3. If cookie-av's attribute-value is a case-insensitive match for\n    //    \"Strict\", set enforcement to \"Strict\".\n    if (attributeValueLowercase.includes('strict')) {\n      enforcement = 'Strict';\n    }\n\n    // 4. If cookie-av's attribute-value is a case-insensitive match for\n    //    \"Lax\", set enforcement to \"Lax\".\n    if (attributeValueLowercase.includes('lax')) {\n      enforcement = 'Lax';\n    }\n\n    // 5. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of \"SameSite\" and an attribute-value of\n    //    enforcement.\n    cookieAttributeList.sameSite = enforcement;\n  } else {\n    cookieAttributeList.unparsed ??= [];\n    cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);\n  }\n\n  // 8. Return to Step 1 of this algorithm.\n  return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);\n}\nmodule.exports = {\n  parseSetCookie,\n  parseUnparsedAttributes\n};","map":{"version":3,"names":["maxNameValuePairSize","maxAttributeValueSize","require","isCTLExcludingHtab","collectASequenceOfCodePointsFast","assert","parseSetCookie","header","nameValuePair","unparsedAttributes","name","value","includes","position","slice","trim","length","parseUnparsedAttributes","cookieAttributeList","cookieAv","attributeName","attributeValue","attributeNameLowercase","toLowerCase","expiryTime","Date","expires","charCode","charCodeAt","test","deltaSeconds","Number","maxAge","cookieDomain","domain","cookiePath","path","secure","httpOnly","enforcement","attributeValueLowercase","sameSite","unparsed","push","module","exports"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/undici/lib/cookies/parse.js"],"sourcesContent":["'use strict'\n\nconst { maxNameValuePairSize, maxAttributeValueSize } = require('./constants')\nconst { isCTLExcludingHtab } = require('./util')\nconst { collectASequenceOfCodePointsFast } = require('../fetch/dataURL')\nconst assert = require('assert')\n\n/**\n * @description Parses the field-value attributes of a set-cookie header string.\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} header\n * @returns if the header is invalid, null will be returned\n */\nfunction parseSetCookie (header) {\n  // 1. If the set-cookie-string contains a %x00-08 / %x0A-1F / %x7F\n  //    character (CTL characters excluding HTAB): Abort these steps and\n  //    ignore the set-cookie-string entirely.\n  if (isCTLExcludingHtab(header)) {\n    return null\n  }\n\n  let nameValuePair = ''\n  let unparsedAttributes = ''\n  let name = ''\n  let value = ''\n\n  // 2. If the set-cookie-string contains a %x3B (\";\") character:\n  if (header.includes(';')) {\n    // 1. The name-value-pair string consists of the characters up to,\n    //    but not including, the first %x3B (\";\"), and the unparsed-\n    //    attributes consist of the remainder of the set-cookie-string\n    //    (including the %x3B (\";\") in question).\n    const position = { position: 0 }\n\n    nameValuePair = collectASequenceOfCodePointsFast(';', header, position)\n    unparsedAttributes = header.slice(position.position)\n  } else {\n    // Otherwise:\n\n    // 1. The name-value-pair string consists of all the characters\n    //    contained in the set-cookie-string, and the unparsed-\n    //    attributes is the empty string.\n    nameValuePair = header\n  }\n\n  // 3. If the name-value-pair string lacks a %x3D (\"=\") character, then\n  //    the name string is empty, and the value string is the value of\n  //    name-value-pair.\n  if (!nameValuePair.includes('=')) {\n    value = nameValuePair\n  } else {\n    //    Otherwise, the name string consists of the characters up to, but\n    //    not including, the first %x3D (\"=\") character, and the (possibly\n    //    empty) value string consists of the characters after the first\n    //    %x3D (\"=\") character.\n    const position = { position: 0 }\n    name = collectASequenceOfCodePointsFast(\n      '=',\n      nameValuePair,\n      position\n    )\n    value = nameValuePair.slice(position.position + 1)\n  }\n\n  // 4. Remove any leading or trailing WSP characters from the name\n  //    string and the value string.\n  name = name.trim()\n  value = value.trim()\n\n  // 5. If the sum of the lengths of the name string and the value string\n  //    is more than 4096 octets, abort these steps and ignore the set-\n  //    cookie-string entirely.\n  if (name.length + value.length > maxNameValuePairSize) {\n    return null\n  }\n\n  // 6. The cookie-name is the name string, and the cookie-value is the\n  //    value string.\n  return {\n    name, value, ...parseUnparsedAttributes(unparsedAttributes)\n  }\n}\n\n/**\n * Parses the remaining attributes of a set-cookie header\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} unparsedAttributes\n * @param {[Object.<string, unknown>]={}} cookieAttributeList\n */\nfunction parseUnparsedAttributes (unparsedAttributes, cookieAttributeList = {}) {\n  // 1. If the unparsed-attributes string is empty, skip the rest of\n  //    these steps.\n  if (unparsedAttributes.length === 0) {\n    return cookieAttributeList\n  }\n\n  // 2. Discard the first character of the unparsed-attributes (which\n  //    will be a %x3B (\";\") character).\n  assert(unparsedAttributes[0] === ';')\n  unparsedAttributes = unparsedAttributes.slice(1)\n\n  let cookieAv = ''\n\n  // 3. If the remaining unparsed-attributes contains a %x3B (\";\")\n  //    character:\n  if (unparsedAttributes.includes(';')) {\n    // 1. Consume the characters of the unparsed-attributes up to, but\n    //    not including, the first %x3B (\";\") character.\n    cookieAv = collectASequenceOfCodePointsFast(\n      ';',\n      unparsedAttributes,\n      { position: 0 }\n    )\n    unparsedAttributes = unparsedAttributes.slice(cookieAv.length)\n  } else {\n    // Otherwise:\n\n    // 1. Consume the remainder of the unparsed-attributes.\n    cookieAv = unparsedAttributes\n    unparsedAttributes = ''\n  }\n\n  // Let the cookie-av string be the characters consumed in this step.\n\n  let attributeName = ''\n  let attributeValue = ''\n\n  // 4. If the cookie-av string contains a %x3D (\"=\") character:\n  if (cookieAv.includes('=')) {\n    // 1. The (possibly empty) attribute-name string consists of the\n    //    characters up to, but not including, the first %x3D (\"=\")\n    //    character, and the (possibly empty) attribute-value string\n    //    consists of the characters after the first %x3D (\"=\")\n    //    character.\n    const position = { position: 0 }\n\n    attributeName = collectASequenceOfCodePointsFast(\n      '=',\n      cookieAv,\n      position\n    )\n    attributeValue = cookieAv.slice(position.position + 1)\n  } else {\n    // Otherwise:\n\n    // 1. The attribute-name string consists of the entire cookie-av\n    //    string, and the attribute-value string is empty.\n    attributeName = cookieAv\n  }\n\n  // 5. Remove any leading or trailing WSP characters from the attribute-\n  //    name string and the attribute-value string.\n  attributeName = attributeName.trim()\n  attributeValue = attributeValue.trim()\n\n  // 6. If the attribute-value is longer than 1024 octets, ignore the\n  //    cookie-av string and return to Step 1 of this algorithm.\n  if (attributeValue.length > maxAttributeValueSize) {\n    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n  }\n\n  // 7. Process the attribute-name and attribute-value according to the\n  //    requirements in the following subsections.  (Notice that\n  //    attributes with unrecognized attribute-names are ignored.)\n  const attributeNameLowercase = attributeName.toLowerCase()\n\n  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.1\n  // If the attribute-name case-insensitively matches the string\n  // \"Expires\", the user agent MUST process the cookie-av as follows.\n  if (attributeNameLowercase === 'expires') {\n    // 1. Let the expiry-time be the result of parsing the attribute-value\n    //    as cookie-date (see Section 5.1.1).\n    const expiryTime = new Date(attributeValue)\n\n    // 2. If the attribute-value failed to parse as a cookie date, ignore\n    //    the cookie-av.\n\n    cookieAttributeList.expires = expiryTime\n  } else if (attributeNameLowercase === 'max-age') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.2\n    // If the attribute-name case-insensitively matches the string \"Max-\n    // Age\", the user agent MUST process the cookie-av as follows.\n\n    // 1. If the first character of the attribute-value is not a DIGIT or a\n    //    \"-\" character, ignore the cookie-av.\n    const charCode = attributeValue.charCodeAt(0)\n\n    if ((charCode < 48 || charCode > 57) && attributeValue[0] !== '-') {\n      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n    }\n\n    // 2. If the remainder of attribute-value contains a non-DIGIT\n    //    character, ignore the cookie-av.\n    if (!/^\\d+$/.test(attributeValue)) {\n      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n    }\n\n    // 3. Let delta-seconds be the attribute-value converted to an integer.\n    const deltaSeconds = Number(attributeValue)\n\n    // 4. Let cookie-age-limit be the maximum age of the cookie (which\n    //    SHOULD be 400 days or less, see Section 4.1.2.2).\n\n    // 5. Set delta-seconds to the smaller of its present value and cookie-\n    //    age-limit.\n    // deltaSeconds = Math.min(deltaSeconds * 1000, maxExpiresMs)\n\n    // 6. If delta-seconds is less than or equal to zero (0), let expiry-\n    //    time be the earliest representable date and time.  Otherwise, let\n    //    the expiry-time be the current date and time plus delta-seconds\n    //    seconds.\n    // const expiryTime = deltaSeconds <= 0 ? Date.now() : Date.now() + deltaSeconds\n\n    // 7. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of Max-Age and an attribute-value of expiry-time.\n    cookieAttributeList.maxAge = deltaSeconds\n  } else if (attributeNameLowercase === 'domain') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.3\n    // If the attribute-name case-insensitively matches the string \"Domain\",\n    // the user agent MUST process the cookie-av as follows.\n\n    // 1. Let cookie-domain be the attribute-value.\n    let cookieDomain = attributeValue\n\n    // 2. If cookie-domain starts with %x2E (\".\"), let cookie-domain be\n    //    cookie-domain without its leading %x2E (\".\").\n    if (cookieDomain[0] === '.') {\n      cookieDomain = cookieDomain.slice(1)\n    }\n\n    // 3. Convert the cookie-domain to lower case.\n    cookieDomain = cookieDomain.toLowerCase()\n\n    // 4. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of Domain and an attribute-value of cookie-domain.\n    cookieAttributeList.domain = cookieDomain\n  } else if (attributeNameLowercase === 'path') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.4\n    // If the attribute-name case-insensitively matches the string \"Path\",\n    // the user agent MUST process the cookie-av as follows.\n\n    // 1. If the attribute-value is empty or if the first character of the\n    //    attribute-value is not %x2F (\"/\"):\n    let cookiePath = ''\n    if (attributeValue.length === 0 || attributeValue[0] !== '/') {\n      // 1. Let cookie-path be the default-path.\n      cookiePath = '/'\n    } else {\n      // Otherwise:\n\n      // 1. Let cookie-path be the attribute-value.\n      cookiePath = attributeValue\n    }\n\n    // 2. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of Path and an attribute-value of cookie-path.\n    cookieAttributeList.path = cookiePath\n  } else if (attributeNameLowercase === 'secure') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.5\n    // If the attribute-name case-insensitively matches the string \"Secure\",\n    // the user agent MUST append an attribute to the cookie-attribute-list\n    // with an attribute-name of Secure and an empty attribute-value.\n\n    cookieAttributeList.secure = true\n  } else if (attributeNameLowercase === 'httponly') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.6\n    // If the attribute-name case-insensitively matches the string\n    // \"HttpOnly\", the user agent MUST append an attribute to the cookie-\n    // attribute-list with an attribute-name of HttpOnly and an empty\n    // attribute-value.\n\n    cookieAttributeList.httpOnly = true\n  } else if (attributeNameLowercase === 'samesite') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.7\n    // If the attribute-name case-insensitively matches the string\n    // \"SameSite\", the user agent MUST process the cookie-av as follows:\n\n    // 1. Let enforcement be \"Default\".\n    let enforcement = 'Default'\n\n    const attributeValueLowercase = attributeValue.toLowerCase()\n    // 2. If cookie-av's attribute-value is a case-insensitive match for\n    //    \"None\", set enforcement to \"None\".\n    if (attributeValueLowercase.includes('none')) {\n      enforcement = 'None'\n    }\n\n    // 3. If cookie-av's attribute-value is a case-insensitive match for\n    //    \"Strict\", set enforcement to \"Strict\".\n    if (attributeValueLowercase.includes('strict')) {\n      enforcement = 'Strict'\n    }\n\n    // 4. If cookie-av's attribute-value is a case-insensitive match for\n    //    \"Lax\", set enforcement to \"Lax\".\n    if (attributeValueLowercase.includes('lax')) {\n      enforcement = 'Lax'\n    }\n\n    // 5. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of \"SameSite\" and an attribute-value of\n    //    enforcement.\n    cookieAttributeList.sameSite = enforcement\n  } else {\n    cookieAttributeList.unparsed ??= []\n\n    cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`)\n  }\n\n  // 8. Return to Step 1 of this algorithm.\n  return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n}\n\nmodule.exports = {\n  parseSetCookie,\n  parseUnparsedAttributes\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}