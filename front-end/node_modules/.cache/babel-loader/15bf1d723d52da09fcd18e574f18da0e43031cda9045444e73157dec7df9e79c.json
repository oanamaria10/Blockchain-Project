{"ast":null,"code":"import * as UCAN from \"../ucan.js\";\nimport * as CBOR from \"@ipld/dag-cbor\";\nimport { readPayload, readVersion, readSignature } from \"../schema.js\";\nimport { format } from \"../formatter.js\";\nimport * as Signature from \"../signature.js\";\nimport { View } from \"../view.js\";\nexport const name = \"dag-ucan\";\nexport const code = CBOR.code;\n\n/**\n * Creates a UCAN view from the underlying data model. Please note that this\n * function does no verification of the model and it is callers responsibility\n * to ensure that:\n *\n * 1. Data model is correct contains all the field etc...\n * 2. Payload of the signature will match paylodad when model is serialized\n *    with DAG-JSON.\n *\n * In other words you should never use this function unless you've parsed or\n * decoded a valid UCAN and want to wrap it into a view.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.FromModel<C>} model\n * @returns {UCAN.View<C>}\n */\nexport const from = model => new CBORView(model);\n\n/**\n * Encodes given UCAN (in either IPLD or JWT representation) and encodes it into\n * corresponding bytes representation. UCAN in IPLD representation is encoded as\n * DAG-CBOR which JWT representation is encoded as raw bytes of JWT string.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.Model<C>} model\n * @returns {UCAN.ByteView<UCAN.Model<C>>}\n */\nexport const encode = model => {\n  const {\n    fct,\n    nnc,\n    nbf,\n    ...payload\n  } = readPayload(model);\n  return /** @type {Uint8Array} */(\n    CBOR.encode({\n      // leave out optionals unless they are set\n      ...(fct.length > 0 && {\n        fct\n      }),\n      ...(nnc != null && {\n        nnc\n      }),\n      ...(nbf && {\n        nbf\n      }),\n      ...payload,\n      // add version and signature\n      v: readVersion(model.v, \"v\"),\n      s: encodeSignature(model.s, \"s\")\n    })\n  );\n};\n\n/**\n * @param {UCAN.Signature} signature\n * @param {string} context\n */\nconst encodeSignature = (signature, context) => {\n  try {\n    return Signature.encode(signature);\n  } catch (cause) {\n    throw new Error(`Expected signature ${context}, instead got ${JSON.stringify(signature)}`,\n    // @ts-expect-error - types don't know about second arg\n    {\n      cause\n    });\n  }\n};\n\n/**\n * Decodes UCAN in primary CBOR representation. It does not validate UCAN, it's\n * signature or proof chain. This is to say decoded UCAN may be invalid.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.ByteView<UCAN.Model<C>>} bytes\n * @returns {UCAN.View<C>}\n */\nexport const decode = bytes => {\n  const model = CBOR.decode(bytes);\n  return new CBORView({\n    ...readPayload(model),\n    v: readVersion(model.v, \"v\"),\n    s: readSignature(model.s)\n  });\n};\nexport { format };\n\n/**\n * @template {UCAN.Capabilities} C\n * @extends {View<C>}\n */\nclass CBORView extends View {\n  get code() {\n    return code;\n  }\n  format() {\n    return format(this.model);\n  }\n  encode() {\n    return encode(this.model);\n  }\n}","map":{"version":3,"names":["UCAN","CBOR","readPayload","readVersion","readSignature","format","Signature","View","name","code","from","model","CBORView","encode","fct","nnc","nbf","payload","length","v","s","encodeSignature","signature","context","cause","Error","JSON","stringify","decode","bytes"],"sources":["C:/FACULTATE/Proiect/node_modules/@ipld/dag-ucan/src/codec/cbor.js"],"sourcesContent":["import * as UCAN from \"../ucan.js\"\nimport * as CBOR from \"@ipld/dag-cbor\"\nimport { readPayload, readVersion, readSignature } from \"../schema.js\"\nimport { format } from \"../formatter.js\"\nimport * as Signature from \"../signature.js\"\nimport { View } from \"../view.js\"\n\nexport const name = \"dag-ucan\"\nexport const code = CBOR.code\n\n/**\n * Creates a UCAN view from the underlying data model. Please note that this\n * function does no verification of the model and it is callers responsibility\n * to ensure that:\n *\n * 1. Data model is correct contains all the field etc...\n * 2. Payload of the signature will match paylodad when model is serialized\n *    with DAG-JSON.\n *\n * In other words you should never use this function unless you've parsed or\n * decoded a valid UCAN and want to wrap it into a view.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.FromModel<C>} model\n * @returns {UCAN.View<C>}\n */\nexport const from = model => new CBORView(model)\n\n/**\n * Encodes given UCAN (in either IPLD or JWT representation) and encodes it into\n * corresponding bytes representation. UCAN in IPLD representation is encoded as\n * DAG-CBOR which JWT representation is encoded as raw bytes of JWT string.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.Model<C>} model\n * @returns {UCAN.ByteView<UCAN.Model<C>>}\n */\nexport const encode = model => {\n  const { fct, nnc, nbf, ...payload } = readPayload(model)\n\n  return /** @type {Uint8Array} */ (\n    CBOR.encode({\n      // leave out optionals unless they are set\n      ...(fct.length > 0 && { fct }),\n      ...(nnc != null && { nnc }),\n      ...(nbf && { nbf }),\n      ...payload,\n      // add version and signature\n      v: readVersion(model.v, \"v\"),\n      s: encodeSignature(model.s, \"s\"),\n    })\n  )\n}\n\n/**\n * @param {UCAN.Signature} signature\n * @param {string} context\n */\nconst encodeSignature = (signature, context) => {\n  try {\n    return Signature.encode(signature)\n  } catch (cause) {\n    throw new Error(\n      `Expected signature ${context}, instead got ${JSON.stringify(signature)}`,\n      // @ts-expect-error - types don't know about second arg\n      { cause }\n    )\n  }\n}\n\n/**\n * Decodes UCAN in primary CBOR representation. It does not validate UCAN, it's\n * signature or proof chain. This is to say decoded UCAN may be invalid.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.ByteView<UCAN.Model<C>>} bytes\n * @returns {UCAN.View<C>}\n */\nexport const decode = bytes => {\n  const model = CBOR.decode(bytes)\n  return new CBORView({\n    ...readPayload(model),\n    v: readVersion(model.v, \"v\"),\n    s: readSignature(model.s),\n  })\n}\n\nexport { format }\n\n/**\n * @template {UCAN.Capabilities} C\n * @extends {View<C>}\n */\nclass CBORView extends View {\n  get code() {\n    return code\n  }\n  format() {\n    return format(this.model)\n  }\n  encode() {\n    return encode(this.model)\n  }\n}\n"],"mappings":"AAAA,OAAO,KAAKA,IAAI,MAAM,YAAY;AAClC,OAAO,KAAKC,IAAI,MAAM,gBAAgB;AACtC,SAASC,WAAW,EAAEC,WAAW,EAAEC,aAAa,QAAQ,cAAc;AACtE,SAASC,MAAM,QAAQ,iBAAiB;AACxC,OAAO,KAAKC,SAAS,MAAM,iBAAiB;AAC5C,SAASC,IAAI,QAAQ,YAAY;AAEjC,OAAO,MAAMC,IAAI,GAAG,UAAU;AAC9B,OAAO,MAAMC,IAAI,GAAGR,IAAI,CAACQ,IAAI;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,IAAI,GAAGC,KAAK,IAAI,IAAIC,QAAQ,CAACD,KAAK,CAAC;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAME,MAAM,GAAGF,KAAK,IAAI;EAC7B,MAAM;IAAEG,GAAG;IAAEC,GAAG;IAAEC,GAAG;IAAE,GAAGC;EAAQ,CAAC,GAAGf,WAAW,CAACS,KAAK,CAAC;EAExD,OAAO;IACLV,IAAI,CAACY,MAAM,CAAC;MACV;MACA,IAAIC,GAAG,CAACI,MAAM,GAAG,CAAC,IAAI;QAAEJ;MAAI,CAAC,CAAC;MAC9B,IAAIC,GAAG,IAAI,IAAI,IAAI;QAAEA;MAAI,CAAC,CAAC;MAC3B,IAAIC,GAAG,IAAI;QAAEA;MAAI,CAAC,CAAC;MACnB,GAAGC,OAAO;MACV;MACAE,CAAC,EAAEhB,WAAW,CAACQ,KAAK,CAACQ,CAAC,EAAE,GAAG,CAAC;MAC5BC,CAAC,EAAEC,eAAe,CAACV,KAAK,CAACS,CAAC,EAAE,GAAG;IACjC,CAAC;EAAC;AAEN,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMC,eAAe,GAAGA,CAACC,SAAS,EAAEC,OAAO,KAAK;EAC9C,IAAI;IACF,OAAOjB,SAAS,CAACO,MAAM,CAACS,SAAS,CAAC;EACpC,CAAC,CAAC,OAAOE,KAAK,EAAE;IACd,MAAM,IAAIC,KAAK,CACZ,sBAAqBF,OAAQ,iBAAgBG,IAAI,CAACC,SAAS,CAACL,SAAS,CAAE,EAAC;IACzE;IACA;MAAEE;IAAM,CACV,CAAC;EACH;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMI,MAAM,GAAGC,KAAK,IAAI;EAC7B,MAAMlB,KAAK,GAAGV,IAAI,CAAC2B,MAAM,CAACC,KAAK,CAAC;EAChC,OAAO,IAAIjB,QAAQ,CAAC;IAClB,GAAGV,WAAW,CAACS,KAAK,CAAC;IACrBQ,CAAC,EAAEhB,WAAW,CAACQ,KAAK,CAACQ,CAAC,EAAE,GAAG,CAAC;IAC5BC,CAAC,EAAEhB,aAAa,CAACO,KAAK,CAACS,CAAC;EAC1B,CAAC,CAAC;AACJ,CAAC;AAED,SAASf,MAAM;;AAEf;AACA;AACA;AACA;AACA,MAAMO,QAAQ,SAASL,IAAI,CAAC;EAC1B,IAAIE,IAAIA,CAAA,EAAG;IACT,OAAOA,IAAI;EACb;EACAJ,MAAMA,CAAA,EAAG;IACP,OAAOA,MAAM,CAAC,IAAI,CAACM,KAAK,CAAC;EAC3B;EACAE,MAAMA,CAAA,EAAG;IACP,OAAOA,MAAM,CAAC,IAAI,CAACF,KAAK,CAAC;EAC3B;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}