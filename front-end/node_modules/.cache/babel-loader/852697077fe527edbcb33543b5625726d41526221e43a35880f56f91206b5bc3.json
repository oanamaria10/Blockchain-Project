{"ast":null,"code":"import * as API from '@ucanto/interface';\n\n/**\n * @typedef {{\n * ok: boolean\n * arrayBuffer():API.Await<ArrayBuffer>\n * headers: {\n *  entries?: () => Iterable<[string, string]>\n * } | Headers\n * status?: number\n * statusText?: string\n * url?: string\n * }} FetchResponse\n * @typedef {(url:string, init:API.HTTPRequest) => API.Await<FetchResponse>} Fetcher\n */\n/**\n * @template S\n * @param {object} options\n * @param {URL} options.url\n * @param {(url:string, init:API.HTTPRequest) => API.Await<FetchResponse>} [options.fetch]\n * @param {string} [options.method]\n * @returns {API.Channel<S>}\n */\nexport const open = ({\n  url,\n  method = 'POST',\n  fetch\n}) => {\n  /* c8 ignore next 9 */\n  if (!fetch) {\n    if (typeof globalThis.fetch !== 'undefined') {\n      fetch = globalThis.fetch.bind(globalThis);\n    } else {\n      throw new TypeError(`ucanto HTTP transport got undefined \\`fetch\\`. Try passing in a \\`fetch\\` implementation explicitly.`);\n    }\n  }\n  return new Channel({\n    url,\n    method,\n    fetch\n  });\n};\n\n/**\n * @template {Record<string, any>} S\n * @implements {API.Channel<S>}\n */\nclass Channel {\n  /**\n   * @param {object} options\n   * @param {URL} options.url\n   * @param {Fetcher} options.fetch\n   * @param {string} [options.method]\n   */\n  constructor({\n    url,\n    fetch,\n    method\n  }) {\n    this.fetch = fetch;\n    this.method = method;\n    this.url = url;\n  }\n  /**\n   * @template {API.Tuple<API.ServiceInvocation<API.Capability, S>>} I\n   * @param {API.HTTPRequest<API.AgentMessage<{ In: API.InferInvocations<I>, Out: API.Tuple<API.Receipt> }>>} request\n   * @returns {Promise<API.HTTPResponse<API.AgentMessage<{ Out: API.InferReceipts<I, S>, In: API.Tuple<API.Invocation> }>>>}\n   */\n  async request({\n    headers,\n    body\n  }) {\n    const response = await this.fetch(this.url.href, {\n      headers,\n      body,\n      method: this.method\n    });\n    const buffer = response.ok ? await response.arrayBuffer() : HTTPError.throw(`HTTP Request failed. ${this.method} ${this.url.href} → ${response.status}`, response);\n    return {\n      headers: response.headers.entries ? Object.fromEntries(response.headers.entries()) : /* c8 ignore next */\n      {},\n      body: new Uint8Array(buffer)\n    };\n  }\n}\n\n/**\n * @typedef {{\n * status?: number\n * statusText?: string\n * url?: string\n * }} Options\n */\nclass HTTPError extends Error {\n  /**\n   * @param {string} message\n   * @param {Options} options\n   * @returns {never}\n   */\n  static throw(message, options) {\n    throw new this(message, options);\n  }\n  /**\n   * @param {string} message\n   * @param {Options} options\n   */\n  constructor(message, {\n    url,\n    status = 500,\n    statusText = 'Server error'\n  }) {\n    super(message);\n    /** @type {'HTTPError'} */\n    this.name = 'HTTPError';\n    this.url = url;\n    this.status = status;\n    this.statusText = statusText;\n  }\n}","map":{"version":3,"names":["API","open","url","method","fetch","globalThis","bind","TypeError","Channel","constructor","request","headers","body","response","href","buffer","ok","arrayBuffer","HTTPError","throw","status","entries","Object","fromEntries","Uint8Array","Error","message","options","statusText","name"],"sources":["C:/FACULTATE/Proiect/node_modules/@ucanto/transport/src/http.js"],"sourcesContent":["import * as API from '@ucanto/interface'\n\n/**\n * @typedef {{\n * ok: boolean\n * arrayBuffer():API.Await<ArrayBuffer>\n * headers: {\n *  entries?: () => Iterable<[string, string]>\n * } | Headers\n * status?: number\n * statusText?: string\n * url?: string\n * }} FetchResponse\n * @typedef {(url:string, init:API.HTTPRequest) => API.Await<FetchResponse>} Fetcher\n */\n/**\n * @template S\n * @param {object} options\n * @param {URL} options.url\n * @param {(url:string, init:API.HTTPRequest) => API.Await<FetchResponse>} [options.fetch]\n * @param {string} [options.method]\n * @returns {API.Channel<S>}\n */\nexport const open = ({ url, method = 'POST', fetch }) => {\n  /* c8 ignore next 9 */\n  if (!fetch) {\n    if (typeof globalThis.fetch !== 'undefined') {\n      fetch = globalThis.fetch.bind(globalThis)\n    } else {\n      throw new TypeError(\n        `ucanto HTTP transport got undefined \\`fetch\\`. Try passing in a \\`fetch\\` implementation explicitly.`\n      )\n    }\n  }\n  return new Channel({ url, method, fetch })\n}\n\n/**\n * @template {Record<string, any>} S\n * @implements {API.Channel<S>}\n */\nclass Channel {\n  /**\n   * @param {object} options\n   * @param {URL} options.url\n   * @param {Fetcher} options.fetch\n   * @param {string} [options.method]\n   */\n  constructor({ url, fetch, method }) {\n    this.fetch = fetch\n    this.method = method\n    this.url = url\n  }\n  /**\n   * @template {API.Tuple<API.ServiceInvocation<API.Capability, S>>} I\n   * @param {API.HTTPRequest<API.AgentMessage<{ In: API.InferInvocations<I>, Out: API.Tuple<API.Receipt> }>>} request\n   * @returns {Promise<API.HTTPResponse<API.AgentMessage<{ Out: API.InferReceipts<I, S>, In: API.Tuple<API.Invocation> }>>>}\n   */\n  async request({ headers, body }) {\n    const response = await this.fetch(this.url.href, {\n      headers,\n      body,\n      method: this.method,\n    })\n\n    const buffer = response.ok\n      ? await response.arrayBuffer()\n      : HTTPError.throw(`HTTP Request failed. ${this.method} ${this.url.href} → ${response.status}`, response)\n\n    return {\n      headers: response.headers.entries\n        ? Object.fromEntries(response.headers.entries())\n        : /* c8 ignore next */\n          {},\n      body: new Uint8Array(buffer),\n    }\n  }\n}\n\n/**\n * @typedef {{\n * status?: number\n * statusText?: string\n * url?: string\n * }} Options\n */\nclass HTTPError extends Error {\n  /**\n   * @param {string} message\n   * @param {Options} options\n   * @returns {never}\n   */\n  static throw(message, options) {\n    throw new this(message, options)\n  }\n  /**\n   * @param {string} message\n   * @param {Options} options\n   */\n  constructor(message, { url, status = 500, statusText = 'Server error' }) {\n    super(message)\n    /** @type {'HTTPError'} */\n    this.name = 'HTTPError'\n    this.url = url\n    this.status = status\n    this.statusText = statusText\n  }\n}\n"],"mappings":"AAAA,OAAO,KAAKA,GAAG,MAAM,mBAAmB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,IAAI,GAAGA,CAAC;EAAEC,GAAG;EAAEC,MAAM,GAAG,MAAM;EAAEC;AAAM,CAAC,KAAK;EACvD;EACA,IAAI,CAACA,KAAK,EAAE;IACV,IAAI,OAAOC,UAAU,CAACD,KAAK,KAAK,WAAW,EAAE;MAC3CA,KAAK,GAAGC,UAAU,CAACD,KAAK,CAACE,IAAI,CAACD,UAAU,CAAC;IAC3C,CAAC,MAAM;MACL,MAAM,IAAIE,SAAS,CAChB,sGACH,CAAC;IACH;EACF;EACA,OAAO,IAAIC,OAAO,CAAC;IAAEN,GAAG;IAAEC,MAAM;IAAEC;EAAM,CAAC,CAAC;AAC5C,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMI,OAAO,CAAC;EACZ;AACF;AACA;AACA;AACA;AACA;EACEC,WAAWA,CAAC;IAAEP,GAAG;IAAEE,KAAK;IAAED;EAAO,CAAC,EAAE;IAClC,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACD,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACD,GAAG,GAAGA,GAAG;EAChB;EACA;AACF;AACA;AACA;AACA;EACE,MAAMQ,OAAOA,CAAC;IAAEC,OAAO;IAAEC;EAAK,CAAC,EAAE;IAC/B,MAAMC,QAAQ,GAAG,MAAM,IAAI,CAACT,KAAK,CAAC,IAAI,CAACF,GAAG,CAACY,IAAI,EAAE;MAC/CH,OAAO;MACPC,IAAI;MACJT,MAAM,EAAE,IAAI,CAACA;IACf,CAAC,CAAC;IAEF,MAAMY,MAAM,GAAGF,QAAQ,CAACG,EAAE,GACtB,MAAMH,QAAQ,CAACI,WAAW,CAAC,CAAC,GAC5BC,SAAS,CAACC,KAAK,CAAE,wBAAuB,IAAI,CAAChB,MAAO,IAAG,IAAI,CAACD,GAAG,CAACY,IAAK,MAAKD,QAAQ,CAACO,MAAO,EAAC,EAAEP,QAAQ,CAAC;IAE1G,OAAO;MACLF,OAAO,EAAEE,QAAQ,CAACF,OAAO,CAACU,OAAO,GAC7BC,MAAM,CAACC,WAAW,CAACV,QAAQ,CAACF,OAAO,CAACU,OAAO,CAAC,CAAC,CAAC,GAC9C;MACA,CAAC,CAAC;MACNT,IAAI,EAAE,IAAIY,UAAU,CAACT,MAAM;IAC7B,CAAC;EACH;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMG,SAAS,SAASO,KAAK,CAAC;EAC5B;AACF;AACA;AACA;AACA;EACE,OAAON,KAAKA,CAACO,OAAO,EAAEC,OAAO,EAAE;IAC7B,MAAM,IAAI,IAAI,CAACD,OAAO,EAAEC,OAAO,CAAC;EAClC;EACA;AACF;AACA;AACA;EACElB,WAAWA,CAACiB,OAAO,EAAE;IAAExB,GAAG;IAAEkB,MAAM,GAAG,GAAG;IAAEQ,UAAU,GAAG;EAAe,CAAC,EAAE;IACvE,KAAK,CAACF,OAAO,CAAC;IACd;IACA,IAAI,CAACG,IAAI,GAAG,WAAW;IACvB,IAAI,CAAC3B,GAAG,GAAGA,GAAG;IACd,IAAI,CAACkB,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACQ,UAAU,GAAGA,UAAU;EAC9B;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}