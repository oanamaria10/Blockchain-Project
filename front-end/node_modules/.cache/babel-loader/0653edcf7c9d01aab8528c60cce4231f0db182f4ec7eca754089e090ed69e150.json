{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LazyInitializationProviderAdapter = void 0;\nconst events_1 = require(\"events\");\nconst errors_1 = require(\"../errors\");\nconst errors_list_1 = require(\"../errors-list\");\n/**\n * A class that delays the (async) creation of its internal provider until the first call\n * to a JSON RPC method via request/send/sendAsync or the init method is called.\n */\nclass LazyInitializationProviderAdapter {\n  constructor(_providerFactory) {\n    this._providerFactory = _providerFactory;\n    this._emitter = new events_1.EventEmitter();\n  }\n  /**\n   * Gets the internal wrapped provider.\n   * Using it directly is discouraged and should be done with care,\n   * use the public methods from the class like `request` and all event emitter methods instead\n   */\n  get _wrapped() {\n    if (this.provider === undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.UNINITIALIZED_PROVIDER);\n    }\n    return this.provider;\n  }\n  async init() {\n    if (this.provider === undefined) {\n      if (this._initializingPromise === undefined) {\n        this._initializingPromise = this._providerFactory();\n      }\n      this.provider = await this._initializingPromise;\n    }\n    return this.provider;\n  }\n  // Provider methods\n  async request(args) {\n    const provider = await this._getOrInitProvider();\n    return provider.request(args);\n  }\n  async send(method, params) {\n    const provider = await this._getOrInitProvider();\n    return provider.send(method, params);\n  }\n  sendAsync(payload, callback) {\n    this._getOrInitProvider().then(provider => {\n      provider.sendAsync(payload, callback);\n    }, e => {\n      callback(e, null);\n    });\n  }\n  // EventEmitter methods\n  addListener(event, listener) {\n    this._getEmitter().addListener(event, listener);\n    return this;\n  }\n  on(event, listener) {\n    this._getEmitter().on(event, listener);\n    return this;\n  }\n  once(event, listener) {\n    this._getEmitter().once(event, listener);\n    return this;\n  }\n  prependListener(event, listener) {\n    this._getEmitter().prependListener(event, listener);\n    return this;\n  }\n  prependOnceListener(event, listener) {\n    this._getEmitter().prependOnceListener(event, listener);\n    return this;\n  }\n  removeListener(event, listener) {\n    this._getEmitter().removeListener(event, listener);\n    return this;\n  }\n  off(event, listener) {\n    this._getEmitter().off(event, listener);\n    return this;\n  }\n  removeAllListeners(event) {\n    this._getEmitter().removeAllListeners(event);\n    return this;\n  }\n  setMaxListeners(n) {\n    this._getEmitter().setMaxListeners(n);\n    return this;\n  }\n  getMaxListeners() {\n    return this._getEmitter().getMaxListeners();\n  }\n  // disable ban-types to satisfy the EventEmitter interface\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  listeners(event) {\n    return this._getEmitter().listeners(event);\n  }\n  // disable ban-types to satisfy the EventEmitter interface\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  rawListeners(event) {\n    return this._getEmitter().rawListeners(event);\n  }\n  emit(event, ...args) {\n    return this._getEmitter().emit(event, ...args);\n  }\n  eventNames() {\n    return this._getEmitter().eventNames();\n  }\n  listenerCount(type) {\n    return this._getEmitter().listenerCount(type);\n  }\n  _getEmitter() {\n    return this.provider === undefined ? this._emitter : this.provider;\n  }\n  async _getOrInitProvider() {\n    // This is here to avoid multiple calls to send async stacking and re-creating the provider\n    // over and over again. It shouldn't run for request or send\n    if (this._initializingPromise !== undefined) {\n      await this._initializingPromise;\n    }\n    if (this.provider === undefined) {\n      this.provider = await this.init();\n      // Copy any event emitter events before initialization over to the provider\n      const recordedEvents = this._emitter.eventNames();\n      for (const event of recordedEvents) {\n        const listeners = this._emitter.rawListeners(event);\n        for (const listener of listeners) {\n          this.provider.on(event, listener);\n          this._emitter.removeListener(event, listener);\n        }\n      }\n      this.provider.setMaxListeners(this._emitter.getMaxListeners());\n    }\n    return this.provider;\n  }\n}\nexports.LazyInitializationProviderAdapter = LazyInitializationProviderAdapter;","map":{"version":3,"names":["events_1","require","errors_1","errors_list_1","LazyInitializationProviderAdapter","constructor","_providerFactory","_emitter","EventEmitter","_wrapped","provider","undefined","HardhatError","ERRORS","GENERAL","UNINITIALIZED_PROVIDER","init","_initializingPromise","request","args","_getOrInitProvider","send","method","params","sendAsync","payload","callback","then","e","addListener","event","listener","_getEmitter","on","once","prependListener","prependOnceListener","removeListener","off","removeAllListeners","setMaxListeners","n","getMaxListeners","listeners","rawListeners","emit","eventNames","listenerCount","type","recordedEvents","exports"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\internal\\core\\providers\\lazy-initialization.ts"],"sourcesContent":["import { EventEmitter } from \"events\";\nimport {\n  EthereumProvider,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  RequestArguments,\n} from \"../../../types\";\nimport { HardhatError } from \"../errors\";\nimport { ERRORS } from \"../errors-list\";\n\nexport type ProviderFactory = () => Promise<EthereumProvider>;\nexport type Listener = (...args: any[]) => void;\n\n/**\n * A class that delays the (async) creation of its internal provider until the first call\n * to a JSON RPC method via request/send/sendAsync or the init method is called.\n */\nexport class LazyInitializationProviderAdapter implements EthereumProvider {\n  protected provider: EthereumProvider | undefined;\n  private _emitter: EventEmitter = new EventEmitter();\n  private _initializingPromise: Promise<EthereumProvider> | undefined;\n\n  constructor(private _providerFactory: ProviderFactory) {}\n\n  /**\n   * Gets the internal wrapped provider.\n   * Using it directly is discouraged and should be done with care,\n   * use the public methods from the class like `request` and all event emitter methods instead\n   */\n  public get _wrapped(): EventEmitter {\n    if (this.provider === undefined) {\n      throw new HardhatError(ERRORS.GENERAL.UNINITIALIZED_PROVIDER);\n    }\n    return this.provider;\n  }\n\n  public async init(): Promise<EthereumProvider> {\n    if (this.provider === undefined) {\n      if (this._initializingPromise === undefined) {\n        this._initializingPromise = this._providerFactory();\n      }\n      this.provider = await this._initializingPromise;\n    }\n    return this.provider;\n  }\n\n  // Provider methods\n\n  public async request(args: RequestArguments): Promise<unknown> {\n    const provider = await this._getOrInitProvider();\n    return provider.request(args);\n  }\n\n  public async send(method: string, params?: any[]): Promise<any> {\n    const provider = await this._getOrInitProvider();\n    return provider.send(method, params);\n  }\n\n  public sendAsync(\n    payload: JsonRpcRequest,\n    callback: (error: any, response: JsonRpcResponse) => void\n  ): void {\n    this._getOrInitProvider().then(\n      (provider) => {\n        provider.sendAsync(payload, callback);\n      },\n      (e) => {\n        callback(e, null as any);\n      }\n    );\n  }\n\n  // EventEmitter methods\n\n  public addListener(event: string | symbol, listener: EventListener): this {\n    this._getEmitter().addListener(event, listener);\n    return this;\n  }\n\n  public on(event: string | symbol, listener: EventListener): this {\n    this._getEmitter().on(event, listener);\n    return this;\n  }\n\n  public once(event: string | symbol, listener: Listener): this {\n    this._getEmitter().once(event, listener);\n    return this;\n  }\n\n  public prependListener(event: string | symbol, listener: Listener): this {\n    this._getEmitter().prependListener(event, listener);\n    return this;\n  }\n\n  public prependOnceListener(event: string | symbol, listener: Listener): this {\n    this._getEmitter().prependOnceListener(event, listener);\n    return this;\n  }\n\n  public removeListener(event: string | symbol, listener: Listener): this {\n    this._getEmitter().removeListener(event, listener);\n    return this;\n  }\n\n  public off(event: string | symbol, listener: Listener): this {\n    this._getEmitter().off(event, listener);\n    return this;\n  }\n\n  public removeAllListeners(event?: string | symbol | undefined): this {\n    this._getEmitter().removeAllListeners(event);\n    return this;\n  }\n\n  public setMaxListeners(n: number): this {\n    this._getEmitter().setMaxListeners(n);\n    return this;\n  }\n\n  public getMaxListeners(): number {\n    return this._getEmitter().getMaxListeners();\n  }\n\n  // disable ban-types to satisfy the EventEmitter interface\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  public listeners(event: string | symbol): Function[] {\n    return this._getEmitter().listeners(event);\n  }\n\n  // disable ban-types to satisfy the EventEmitter interface\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  public rawListeners(event: string | symbol): Function[] {\n    return this._getEmitter().rawListeners(event);\n  }\n\n  public emit(event: string | symbol, ...args: any[]): boolean {\n    return this._getEmitter().emit(event, ...args);\n  }\n\n  public eventNames(): Array<string | symbol> {\n    return this._getEmitter().eventNames();\n  }\n\n  public listenerCount(type: string | symbol): number {\n    return this._getEmitter().listenerCount(type);\n  }\n\n  private _getEmitter(): EventEmitter {\n    return this.provider === undefined ? this._emitter : this.provider;\n  }\n\n  private async _getOrInitProvider(): Promise<EthereumProvider> {\n    // This is here to avoid multiple calls to send async stacking and re-creating the provider\n    // over and over again. It shouldn't run for request or send\n    if (this._initializingPromise !== undefined) {\n      await this._initializingPromise;\n    }\n\n    if (this.provider === undefined) {\n      this.provider = await this.init();\n\n      // Copy any event emitter events before initialization over to the provider\n      const recordedEvents = this._emitter.eventNames();\n\n      for (const event of recordedEvents) {\n        const listeners = this._emitter.rawListeners(event) as Listener[];\n        for (const listener of listeners) {\n          this.provider.on(event, listener);\n          this._emitter.removeListener(event, listener);\n        }\n      }\n\n      this.provider.setMaxListeners(this._emitter.getMaxListeners());\n    }\n\n    return this.provider;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}