{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { existsSync, readFileSync } from 'fs';\nimport { dirname, join } from 'path';\nvar moduleCache;\n/** Extract information about paths */\nfunction getPaths() {\n  try {\n    return require.cache ? Object.keys(require.cache) : [];\n  } catch (e) {\n    return [];\n  }\n}\n/** Extract information about package.json modules */\nfunction collectModules() {\n  var mainPaths = require.main && require.main.paths || [];\n  var paths = getPaths();\n  var infos = {};\n  var seen = {};\n  paths.forEach(function (path) {\n    var dir = path;\n    /** Traverse directories upward in the search of package.json file */\n    var updir = function () {\n      var orig = dir;\n      dir = dirname(orig);\n      if (!dir || orig === dir || seen[orig]) {\n        return undefined;\n      }\n      if (mainPaths.indexOf(dir) < 0) {\n        return updir();\n      }\n      var pkgfile = join(orig, 'package.json');\n      seen[orig] = true;\n      if (!existsSync(pkgfile)) {\n        return updir();\n      }\n      try {\n        var info = JSON.parse(readFileSync(pkgfile, 'utf8'));\n        infos[info.name] = info.version;\n      } catch (_oO) {\n        // no-empty\n      }\n    };\n    updir();\n  });\n  return infos;\n}\n/** Add node modules / packages to the event */\nvar Modules = /** @class */function () {\n  function Modules() {\n    /**\n     * @inheritDoc\n     */\n    this.name = Modules.id;\n  }\n  /**\n   * @inheritDoc\n   */\n  Modules.prototype.setupOnce = function (addGlobalEventProcessor, getCurrentHub) {\n    var _this = this;\n    addGlobalEventProcessor(function (event) {\n      if (!getCurrentHub().getIntegration(Modules)) {\n        return event;\n      }\n      return __assign(__assign({}, event), {\n        modules: _this._getModules()\n      });\n    });\n  };\n  /** Fetches the list of modules and the versions loaded by the entry file for your node.js app. */\n  Modules.prototype._getModules = function () {\n    if (!moduleCache) {\n      moduleCache = collectModules();\n    }\n    return moduleCache;\n  };\n  /**\n   * @inheritDoc\n   */\n  Modules.id = 'Modules';\n  return Modules;\n}();\nexport { Modules };","map":{"version":3,"names":["existsSync","readFileSync","dirname","join","moduleCache","getPaths","require","cache","Object","keys","e","collectModules","mainPaths","main","paths","infos","seen","forEach","path","dir","updir","orig","undefined","indexOf","pkgfile","info","JSON","parse","name","version","_oO","Modules","id","prototype","setupOnce","addGlobalEventProcessor","getCurrentHub","_this","event","getIntegration","__assign","modules","_getModules"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\@sentry\\node\\src\\integrations\\modules.ts"],"sourcesContent":["import { EventProcessor, Hub, Integration } from '@sentry/types';\nimport { existsSync, readFileSync } from 'fs';\nimport { dirname, join } from 'path';\n\nlet moduleCache: { [key: string]: string };\n\n/** Extract information about paths */\nfunction getPaths(): string[] {\n  try {\n    return require.cache ? Object.keys(require.cache as Record<string, unknown>) : [];\n  } catch (e) {\n    return [];\n  }\n}\n\n/** Extract information about package.json modules */\nfunction collectModules(): {\n  [name: string]: string;\n} {\n  const mainPaths = (require.main && require.main.paths) || [];\n  const paths = getPaths();\n  const infos: {\n    [name: string]: string;\n  } = {};\n  const seen: {\n    [path: string]: boolean;\n  } = {};\n\n  paths.forEach(path => {\n    let dir = path;\n\n    /** Traverse directories upward in the search of package.json file */\n    const updir = (): void | (() => void) => {\n      const orig = dir;\n      dir = dirname(orig);\n\n      if (!dir || orig === dir || seen[orig]) {\n        return undefined;\n      }\n      if (mainPaths.indexOf(dir) < 0) {\n        return updir();\n      }\n\n      const pkgfile = join(orig, 'package.json');\n      seen[orig] = true;\n\n      if (!existsSync(pkgfile)) {\n        return updir();\n      }\n\n      try {\n        const info = JSON.parse(readFileSync(pkgfile, 'utf8')) as {\n          name: string;\n          version: string;\n        };\n        infos[info.name] = info.version;\n      } catch (_oO) {\n        // no-empty\n      }\n    };\n\n    updir();\n  });\n\n  return infos;\n}\n\n/** Add node modules / packages to the event */\nexport class Modules implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Modules';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Modules.id;\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    addGlobalEventProcessor(event => {\n      if (!getCurrentHub().getIntegration(Modules)) {\n        return event;\n      }\n      return {\n        ...event,\n        modules: this._getModules(),\n      };\n    });\n  }\n\n  /** Fetches the list of modules and the versions loaded by the entry file for your node.js app. */\n  private _getModules(): { [key: string]: string } {\n    if (!moduleCache) {\n      moduleCache = collectModules();\n    }\n    return moduleCache;\n  }\n}\n"],"mappings":";AACA,SAASA,UAAU,EAAEC,YAAY,QAAQ,IAAI;AAC7C,SAASC,OAAO,EAAEC,IAAI,QAAQ,MAAM;AAEpC,IAAIC,WAAsC;AAE1C;AACA,SAASC,QAAQA,CAAA;EACf,IAAI;IACF,OAAOC,OAAO,CAACC,KAAK,GAAGC,MAAM,CAACC,IAAI,CAACH,OAAO,CAACC,KAAgC,CAAC,GAAG,EAAE;GAClF,CAAC,OAAOG,CAAC,EAAE;IACV,OAAO,EAAE;;AAEb;AAEA;AACA,SAASC,cAAcA,CAAA;EAGrB,IAAMC,SAAS,GAAIN,OAAO,CAACO,IAAI,IAAIP,OAAO,CAACO,IAAI,CAACC,KAAK,IAAK,EAAE;EAC5D,IAAMA,KAAK,GAAGT,QAAQ,EAAE;EACxB,IAAMU,KAAK,GAEP,EAAE;EACN,IAAMC,IAAI,GAEN,EAAE;EAENF,KAAK,CAACG,OAAO,CAAC,UAAAC,IAAI;IAChB,IAAIC,GAAG,GAAGD,IAAI;IAEd;IACA,IAAME,KAAK,GAAG,SAAAA,CAAA;MACZ,IAAMC,IAAI,GAAGF,GAAG;MAChBA,GAAG,GAAGjB,OAAO,CAACmB,IAAI,CAAC;MAEnB,IAAI,CAACF,GAAG,IAAIE,IAAI,KAAKF,GAAG,IAAIH,IAAI,CAACK,IAAI,CAAC,EAAE;QACtC,OAAOC,SAAS;;MAElB,IAAIV,SAAS,CAACW,OAAO,CAACJ,GAAG,CAAC,GAAG,CAAC,EAAE;QAC9B,OAAOC,KAAK,EAAE;;MAGhB,IAAMI,OAAO,GAAGrB,IAAI,CAACkB,IAAI,EAAE,cAAc,CAAC;MAC1CL,IAAI,CAACK,IAAI,CAAC,GAAG,IAAI;MAEjB,IAAI,CAACrB,UAAU,CAACwB,OAAO,CAAC,EAAE;QACxB,OAAOJ,KAAK,EAAE;;MAGhB,IAAI;QACF,IAAMK,IAAI,GAAGC,IAAI,CAACC,KAAK,CAAC1B,YAAY,CAACuB,OAAO,EAAE,MAAM,CAAC,CAGpD;QACDT,KAAK,CAACU,IAAI,CAACG,IAAI,CAAC,GAAGH,IAAI,CAACI,OAAO;OAChC,CAAC,OAAOC,GAAG,EAAE;QACZ;MAAA;IAEJ,CAAC;IAEDV,KAAK,EAAE;EACT,CAAC,CAAC;EAEF,OAAOL,KAAK;AACd;AAEA;AACA,IAAAgB,OAAA;EAAA,SAAAA,QAAA;IAME;;;IAGO,KAAAH,IAAI,GAAWG,OAAO,CAACC,EAAE;EAwBlC;EAtBE;;;EAGOD,OAAA,CAAAE,SAAA,CAAAC,SAAS,GAAhB,UAAiBC,uBAA2D,EAAEC,aAAwB;IAAtG,IAAAC,KAAA;IACEF,uBAAuB,CAAC,UAAAG,KAAK;MAC3B,IAAI,CAACF,aAAa,EAAE,CAACG,cAAc,CAACR,OAAO,CAAC,EAAE;QAC5C,OAAOO,KAAK;;MAEd,OAAAE,QAAA,CAAAA,QAAA,KACKF,KAAK;QACRG,OAAO,EAAEJ,KAAI,CAACK,WAAW;MAAE;IAE/B,CAAC,CAAC;EACJ,CAAC;EAED;EACQX,OAAA,CAAAE,SAAA,CAAAS,WAAW,GAAnB;IACE,IAAI,CAACtC,WAAW,EAAE;MAChBA,WAAW,GAAGO,cAAc,EAAE;;IAEhC,OAAOP,WAAW;EACpB,CAAC;EA/BD;;;EAGc2B,OAAA,CAAAC,EAAE,GAAW,SAAS;EA6BtC,OAAAD,OAAC;CAAA,CAjCD;SAAaA,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}