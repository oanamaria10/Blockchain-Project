{"ast":null,"code":"/**\n * A client library for the https://web3.storage/ service. It provides a convenient\n * interface for working with the [Raw HTTP API](https://web3.storage/#api-docs)\n * from a web browser or [Node.js](https://nodejs.org/) and comes bundled with\n * TS for out-of-the box type inference and better IntelliSense.\n *\n * @example\n * ```js\n * import { Web3Storage, File } from 'web3.storage'\n * const client = new Web3Storage({ token: API_TOKEN })\n *\n * const cid = await client.put([new File(['hello world'], 'hello.txt', { type: 'text/plain' })])\n * ```\n * @module\n */\nimport { transform } from 'streaming-iterables';\nimport pRetry, { AbortError } from 'p-retry';\nimport { pack } from 'ipfs-car/pack';\nimport { parseLinkHeader } from '@web3-storage/parse-link-header';\nimport { unpackStream } from 'ipfs-car/unpack';\nimport { TreewalkCarSplitter } from 'carbites/treewalk';\nimport { CarReader } from '@ipld/car';\nimport { filesFromPath, getFilesFromPath } from 'files-from-path';\nimport throttledQueue from 'throttled-queue';\nimport { fetch as _fetch, File, Blob, Blockstore } from './platform.js';\nconst MAX_PUT_RETRIES = 5;\nconst MAX_CONCURRENT_UPLOADS = 3;\nconst DEFAULT_CHUNK_SIZE = 1024 * 1024 * 50; // chunk to ~50MB CARs\nconst MAX_BLOCK_SIZE = 1048576;\nconst MAX_CHUNK_SIZE = 104857600;\n// These match what is enforced server-side\nconst RATE_LIMIT_REQUESTS = 30;\nconst RATE_LIMIT_PERIOD = 10 * 1000;\n\n/** @typedef { import('./lib/interface.js').API } API */\n/** @typedef { import('./lib/interface.js').Status} Status */\n/** @typedef { import('./lib/interface.js').Upload} Upload */\n/** @typedef { import('./lib/interface.js').Deal} Deal */\n/** @typedef { import('./lib/interface.js').Pin} Pin */\n/** @typedef { import('./lib/interface.js').Service } Service */\n/** @typedef { import('./lib/interface.js').Web3File} Web3File */\n/** @typedef { import('./lib/interface.js').Filelike } Filelike */\n/** @typedef { import('./lib/interface.js').CIDString} CIDString */\n/** @typedef { import('./lib/interface.js').RequestOptions} RequestOptions */\n/** @typedef { import('./lib/interface.js').PutOptions} PutOptions */\n/** @typedef { import('./lib/interface.js').PutCarOptions} PutCarOptions */\n/** @typedef { import('./lib/interface.js').ListOptions} ListOptions */\n/** @typedef { import('./lib/interface.js').RateLimiter } RateLimiter */\n/** @typedef { import('./lib/interface.js').UnixFSEntry} UnixFSEntry */\n/** @typedef { import('./lib/interface.js').Web3Response} Web3Response */\n\n/**\n * Creates a rate limiter which limits at the same rate as is enforced\n * server-side, to allow the client to avoid exceeding the requests limit and\n * being blocked for 30 seconds.\n * @returns {RateLimiter}\n */\nexport function createRateLimiter() {\n  const throttle = throttledQueue(RATE_LIMIT_REQUESTS, RATE_LIMIT_PERIOD);\n  return () => throttle(() => {});\n}\n\n/**\n * Rate limiter used by static API if no rate limiter is passed. Note that each\n * instance of the Web3Storage class gets it's own limiter if none is passed.\n * This is because rate limits are enforced per API token.\n */\nconst globalRateLimiter = createRateLimiter();\n\n/**\n * @implements Service\n */\nclass Web3Storage {\n  /**\n   * Constructs a client bound to the given `options.token` and\n   * `options.endpoint`.\n   *\n   * @example\n   * ```js\n   * import { Web3Storage } from 'web3.storage'\n   * const client = new Web3Storage({ token: API_TOKEN })\n   * ```\n   *\n    @param {Service} options\n   */\n  constructor({\n    token,\n    endpoint = new URL('https://api.web3.storage'),\n    rateLimiter,\n    fetch = _fetch\n  }) {\n    /**\n     * Authorization token.\n     *\n     * @readonly\n     */\n    this.token = token;\n    /**\n     * Service API endpoint `URL`.\n     * @readonly\n     */\n    this.endpoint = endpoint;\n    /**\n     * @readonly\n     */\n    this.rateLimiter = rateLimiter || createRateLimiter();\n    /**\n     * Optional custom fetch function. Defaults to global fetch in browsers or @web-std/fetch on node.\n     * @readonly\n     */\n    this.fetch = fetch;\n  }\n\n  /**\n   * @hidden\n   * @param {string} token\n   * @returns {Record<string, string>}\n   */\n  static headers(token) {\n    if (!token) throw new Error('missing token');\n    return {\n      Authorization: `Bearer ${token}`,\n      'X-Client': 'web3.storage/js'\n    };\n  }\n\n  /**\n   * @param {Service} service\n   * @param {Iterable<Filelike>} files\n   * @param {PutOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async put({\n    endpoint,\n    token,\n    rateLimiter = globalRateLimiter,\n    fetch = _fetch\n  }, files, {\n    onRootCidReady,\n    onStoredChunk,\n    maxRetries = MAX_PUT_RETRIES,\n    maxChunkSize = DEFAULT_CHUNK_SIZE,\n    wrapWithDirectory = true,\n    name,\n    signal\n  } = {}) {\n    if (maxChunkSize >= MAX_CHUNK_SIZE || maxChunkSize < MAX_BLOCK_SIZE) {\n      throw new Error('maximum chunk size must be less than 100MiB and greater than or equal to 1MB');\n    }\n    const blockstore = new Blockstore();\n    try {\n      const {\n        out,\n        root\n      } = await pack({\n        input: Array.from(files).map(toImportCandidate),\n        blockstore,\n        wrapWithDirectory,\n        maxChunkSize: MAX_BLOCK_SIZE,\n        maxChildrenPerNode: 1024\n      });\n      onRootCidReady && onRootCidReady(root.toString());\n      const car = await CarReader.fromIterable(out);\n      return await Web3Storage.putCar({\n        endpoint,\n        token,\n        rateLimiter,\n        fetch\n      }, car, {\n        onStoredChunk,\n        maxRetries,\n        maxChunkSize,\n        name,\n        signal\n      });\n    } finally {\n      await blockstore.close();\n    }\n  }\n\n  /**\n   * @param {Service} service\n   * @param {import('@ipld/car/api').CarReader} car\n   * @param {PutCarOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async putCar({\n    endpoint,\n    token,\n    rateLimiter = globalRateLimiter,\n    fetch = _fetch\n  }, car, {\n    name,\n    onStoredChunk,\n    maxRetries = MAX_PUT_RETRIES,\n    maxChunkSize = DEFAULT_CHUNK_SIZE,\n    decoders,\n    signal\n  } = {}) {\n    if (maxChunkSize >= MAX_CHUNK_SIZE || maxChunkSize < MAX_BLOCK_SIZE) {\n      throw new Error('maximum chunk size must be less than 100MiB and greater than or equal to 1MB');\n    }\n    const targetSize = maxChunkSize;\n    const url = new URL('car', endpoint);\n    const headers = {\n      ...Web3Storage.headers(token),\n      'Content-Type': 'application/vnd.ipld.car',\n      ...(name ? {\n        'X-Name': encodeURIComponent(name)\n      } : {})\n    };\n    const roots = await car.getRoots();\n    if (roots[0] == null) {\n      throw new Error('missing root CID');\n    }\n    if (roots.length > 1) {\n      throw new Error('too many roots');\n    }\n    const carRoot = roots[0].toString();\n    const splitter = new TreewalkCarSplitter(car, targetSize, {\n      decoders\n    });\n\n    /**\n     * @param {AsyncIterable<Uint8Array>} car\n     * @returns {Promise<CIDString>}\n     */\n    const onCarChunk = async car => {\n      const carParts = [];\n      for await (const part of car) {\n        carParts.push(part);\n      }\n      const carFile = new Blob(carParts, {\n        type: 'application/vnd.ipld.car'\n      });\n\n      /** @type {Blob|ArrayBuffer} */\n      let body = carFile;\n      // FIXME: should not be necessary to await arrayBuffer()!\n      // Node.js 20 hangs reading the stream (it never ends) but in\n      // older node versions and the browser it is fine to pass a blob.\n      /* c8 ignore next 3 */\n      if (parseInt(globalThis.process?.versions?.node) > 18) {\n        body = await body.arrayBuffer();\n      }\n      const res = await pRetry(async () => {\n        await rateLimiter();\n        /** @type {Response} */\n        let response;\n        try {\n          response = await fetch(url.toString(), {\n            method: 'POST',\n            headers,\n            body,\n            signal\n          });\n        } catch ( /** @type {any} */err) {\n          throw signal && signal.aborted ? new AbortError(err) : err;\n        }\n        /* c8 ignore next 3 */\n        if (response.status === 429) {\n          throw new Error('rate limited');\n        }\n        const res = await response.json();\n        if (!response.ok) {\n          throw new Error(res.message);\n        }\n        if (res.cid !== carRoot) {\n          throw new Error(`root CID mismatch, expected: ${carRoot}, received: ${res.cid}`);\n        }\n        return res.cid;\n      }, {\n        retries: maxRetries\n      });\n      onStoredChunk && onStoredChunk(carFile.size);\n      return res;\n    };\n    const upload = transform(MAX_CONCURRENT_UPLOADS, onCarChunk);\n    for await (const _ of upload(splitter.cars())) {} // eslint-disable-line\n    return carRoot;\n  }\n\n  /**\n   * @param {Service} service\n   * @param {CIDString} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<Web3Response | null>}\n   */\n  static async get({\n    endpoint,\n    token,\n    rateLimiter = globalRateLimiter,\n    fetch = _fetch\n  }, cid, options = {}) {\n    const url = new URL(`car/${cid}`, endpoint);\n    await rateLimiter();\n    const res = await fetch(url.toString(), {\n      method: 'GET',\n      headers: Web3Storage.headers(token),\n      signal: options.signal\n    });\n    /* c8 ignore next 3 */\n    if (res.status === 429) {\n      throw new Error('rate limited');\n    }\n    return toWeb3Response(res);\n  }\n\n  /**\n   * @param {Service} service\n   * @param {CIDString} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  /* c8 ignore next 4 */\n  static async delete({\n    endpoint,\n    token,\n    rateLimiter = globalRateLimiter\n  }, cid, options = {}) {\n    console.log('Not deleting', cid, endpoint, token, rateLimiter, options);\n    throw Error('.delete not implemented yet');\n  }\n\n  /**\n   * @param {Service} service\n   * @param {CIDString} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<Status | undefined>}\n   */\n  static async status({\n    endpoint,\n    token,\n    rateLimiter = globalRateLimiter,\n    fetch = _fetch\n  }, cid, options = {}) {\n    const url = new URL(`status/${cid}`, endpoint);\n    await rateLimiter();\n    const res = await fetch(url.toString(), {\n      method: 'GET',\n      headers: Web3Storage.headers(token),\n      signal: options.signal\n    });\n    /* c8 ignore next 3 */\n    if (res.status === 429) {\n      throw new Error('rate limited');\n    }\n    if (res.status === 404) {\n      return undefined;\n    }\n    if (!res.ok) {\n      throw new Error(res.statusText);\n    }\n    return res.json();\n  }\n\n  /**\n   * @param {Service} service\n   * @param {ListOptions} [opts]\n   * @returns {AsyncIterable<Upload>}\n   */\n  static async *list(service, {\n    before = new Date().toISOString(),\n    maxResults = Infinity,\n    signal\n  } = {}) {\n    /**\n     * @param {Service} service\n     * @param {{before: string, size: number}} opts\n     * @returns {Promise<Response>}\n     */\n    async function listPage({\n      endpoint,\n      token,\n      rateLimiter = globalRateLimiter,\n      fetch = _fetch\n    }, {\n      before,\n      size\n    }) {\n      const search = new URLSearchParams({\n        before,\n        size: size.toString()\n      });\n      const url = new URL(`user/uploads?${search}`, endpoint);\n      await rateLimiter();\n      return fetch(url.toString(), {\n        method: 'GET',\n        headers: {\n          ...Web3Storage.headers(token),\n          'Access-Control-Request-Headers': 'Link'\n        },\n        signal\n      });\n    }\n    let count = 0;\n    const size = maxResults > 100 ? 100 : maxResults;\n    for await (const res of paginator(listPage, service, {\n      before,\n      size\n    })) {\n      if (!res.ok) {\n        /* c8 ignore next 3 */\n        if (res.status === 429) {\n          throw new Error('rate limited');\n        }\n\n        /* c8 ignore next 2 */\n        const errorMessage = await res.json();\n        throw new Error(`${res.status} ${res.statusText} ${errorMessage ? '- ' + errorMessage.message : ''}`);\n      }\n      const page = await res.json();\n      for (const upload of page) {\n        if (++count > maxResults) {\n          return;\n        }\n        yield upload;\n      }\n    }\n  }\n\n  // Just a sugar so you don't have to pass around endpoint and token around.\n\n  /**\n   * Uploads files to web3.storage. Files are hashed in the client and uploaded as a single\n   * [Content Addressed Archive(CAR)](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md).\n   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n   *\n   * Returns the corresponding Content Identifier (CID).\n   *\n   * @example\n   * ```js\n   * const file = new File(['hello world'], 'hello.txt', { type: 'text/plain' })\n   * const cid = await client.put([file])\n   * ```\n   * @param {Iterable<Filelike>} files\n   * @param {PutOptions} [options]\n   */\n  put(files, options) {\n    return Web3Storage.put(this, files, options);\n  }\n\n  /**\n   * Uploads a CAR ([Content Addressed Archive](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md)) file to web3.storage.\n   * Takes a CarReader interface from @ipld/car\n   *\n   * Returns the corresponding Content Identifier (CID).\n   *\n   * @example\n   * ```js\n   * import fs from 'fs'\n   * import { Readable } from 'stream'\n   * import { CarReader, CarWriter } from '@ipld/car'\n   * import * as raw from 'multiformats/codecs/raw'\n   * import { CID } from 'multiformats/cid'\n   * import { sha256 } from 'multiformats/hashes/sha2'\n   *\n   * async function getCar() {\n   *    const bytes = new TextEncoder().encode('random meaningless bytes')\n   *    const hash = await sha256.digest(raw.encode(bytes))\n   *    const cid = CID.create(1, raw.code, hash)\n   *\n   *    // create the writer and set the header with a single root\n   *    const { writer, out } = await CarWriter.create([cid])\n   *    Readable.from(out).pipe(fs.createWriteStream('example.car'))\n    *    // store a new block, creates a new file entry in the CAR archive\n   *    await writer.put({ cid, bytes })\n   *    await writer.close()\n    *    const inStream = fs.createReadStream('example.car')\n   *    // read and parse the entire stream in one go, this will cache the contents of\n   *    // the car in memory so is not suitable for large files.\n   *    const reader = await CarReader.fromIterable(inStream)\n   *    return reader\n   * }\n   *\n   * const car = await getCar()\n   * const cid = await client.putCar(car)\n   * ```\n   * @param {import('@ipld/car/api').CarReader} car\n   * @param {PutCarOptions} [options]\n   */\n  putCar(car, options) {\n    return Web3Storage.putCar(this, car, options);\n  }\n\n  /**\n   * Fetch the Content Addressed Archive by its root CID.\n   * @param {CIDString} cid\n   * @param {RequestOptions} [options]\n   */\n  get(cid, options) {\n    return Web3Storage.get(this, cid, options);\n  }\n\n  /**\n   * @param {CIDString} cid\n   * @param {RequestOptions} [options]\n   */\n  /* c8 ignore next 3 */\n  delete(cid, options) {\n    return Web3Storage.delete(this, cid, options);\n  }\n\n  /**\n   * Fetch info on Filecoin deals and IPFS pins that a given CID is replicated in.\n   * @param {CIDString} cid\n   * @param {RequestOptions} [options]\n   */\n  status(cid, options) {\n    return Web3Storage.status(this, cid, options);\n  }\n\n  /**\n   * Find all uploads for this account. Use a `for await...of` loop to fetch them all.\n   * @example\n   * Fetch all the uploads\n   * ```js\n   * const uploads = []\n   * for await (const item of client.list()) {\n   *    uploads.push(item)\n   * }\n   * ```\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of\n   * @param {ListOptions} [opts]\n   * @returns {AsyncIterable<Upload>}\n   */\n  list(opts) {\n    return Web3Storage.list(this, opts);\n  }\n}\n\n/**\n * Map a UnixFSEntry to a File with a cid property.\n *\n * @param {UnixFSEntry} entry\n * @returns {Promise<Web3File>}\n */\nasync function toWeb3File({\n  content,\n  path,\n  cid\n}) {\n  const chunks = [];\n  for await (const chunk of content()) {\n    chunks.push(chunk);\n  }\n  const file = new File(chunks, toFilenameWithPath(path));\n  return Object.assign(file, {\n    cid: cid.toString()\n  });\n}\n\n/**\n * Trim the root cid from the path if there is anyting after it.\n * bafy...ic2q/path/to/pinpie.jpg => path/to/pinpie.jpg\n *         bafy...ic2q/pinpie.jpg => pinpie.jpg\n *                    bafk...52zy => bafk...52zy\n * @param {string} unixFsPath\n * @returns {string}\n */\nfunction toFilenameWithPath(unixFsPath) {\n  const slashIndex = unixFsPath.indexOf('/');\n  return slashIndex === -1 ? unixFsPath : unixFsPath.substring(slashIndex + 1);\n}\n\n/**\n * Add car unpacking smarts to the response object,\n * @param {Response} res\n * @returns {Web3Response}\n */\nfunction toWeb3Response(res) {\n  const response = Object.assign(res, {\n    unixFsIterator: async function* () {\n      if (!res.ok) {\n        throw new Error(`Response was not ok: ${res.status} ${res.statusText} - Check for { \"ok\": false } on the Response object before calling .unixFsIterator`);\n      }\n      /* c8 ignore next 3 */\n      if (!res.body) {\n        throw new Error('No body on response');\n      }\n      const blockstore = new Blockstore();\n      try {\n        for await (const entry of unpackStream(res.body, {\n          blockstore\n        })) {\n          yield entry;\n        }\n      } finally {\n        await blockstore.close();\n      }\n    },\n    files: async () => {\n      if (!res.ok) {\n        throw new Error(`Response was not ok: ${res.status} ${res.statusText} - Check for { \"ok\": false } on the Response object before calling .files`);\n      }\n      const files = [];\n      // @ts-ignore we're using the enriched response here\n      for await (const entry of response.unixFsIterator()) {\n        if (entry.type === 'directory') {\n          continue;\n        }\n        const file = await toWeb3File(entry);\n        files.push(file);\n      }\n      return files;\n    }\n  });\n  return response;\n}\n\n/**\n * Convert the passed file to an \"import candidate\" - an object suitable for\n * passing to the ipfs-unixfs-importer. Note: content is an accessor so that\n * the stream is only created when needed.\n *\n * @param {Filelike} file\n */\nfunction toImportCandidate(file) {\n  /** @type {ReadableStream} */\n  let stream;\n  return {\n    path: file.name,\n    get content() {\n      stream = stream || file.stream();\n      return stream;\n    }\n  };\n}\n\n/**\n * Follow Link headers on a Response, to fetch all the things.\n *\n * @param {(service: Service, opts: any) => Promise<Response>} fn\n * @param {Service} service\n * @param {{}} opts\n */\nasync function* paginator(fn, service, opts) {\n  let res = await fn(service, opts);\n  yield res;\n  let link = parseLinkHeader(res.headers.get('Link') || '');\n  // @ts-ignore\n  while (link && link.next) {\n    // @ts-ignore\n    res = await fn(service, link.next);\n    yield res;\n    link = parseLinkHeader(res.headers.get('Link') || '');\n  }\n}\nexport { Web3Storage, File, Blob, filesFromPath, getFilesFromPath };\n\n/**\n * Just to verify API compatibility.\n * TODO: convert lib to a regular class that can be type checked.\n * @type {API}\n */\nconst api = Web3Storage;\nvoid api; // eslint-disable-line no-void","map":{"version":3,"names":["transform","pRetry","AbortError","pack","parseLinkHeader","unpackStream","TreewalkCarSplitter","CarReader","filesFromPath","getFilesFromPath","throttledQueue","fetch","_fetch","File","Blob","Blockstore","MAX_PUT_RETRIES","MAX_CONCURRENT_UPLOADS","DEFAULT_CHUNK_SIZE","MAX_BLOCK_SIZE","MAX_CHUNK_SIZE","RATE_LIMIT_REQUESTS","RATE_LIMIT_PERIOD","createRateLimiter","throttle","globalRateLimiter","Web3Storage","constructor","token","endpoint","URL","rateLimiter","headers","Error","Authorization","put","files","onRootCidReady","onStoredChunk","maxRetries","maxChunkSize","wrapWithDirectory","name","signal","blockstore","out","root","input","Array","from","map","toImportCandidate","maxChildrenPerNode","toString","car","fromIterable","putCar","close","decoders","targetSize","url","encodeURIComponent","roots","getRoots","length","carRoot","splitter","onCarChunk","carParts","part","push","carFile","type","body","parseInt","globalThis","process","versions","node","arrayBuffer","res","response","method","err","aborted","status","json","ok","message","cid","retries","size","upload","_","cars","get","options","toWeb3Response","delete","console","log","undefined","statusText","list","service","before","Date","toISOString","maxResults","Infinity","listPage","search","URLSearchParams","count","paginator","errorMessage","page","opts","toWeb3File","content","path","chunks","chunk","file","toFilenameWithPath","Object","assign","unixFsPath","slashIndex","indexOf","substring","unixFsIterator","entry","stream","fn","link","next","api"],"sources":["C:/FACULTATE/Proiect/node_modules/web3.storage/src/lib.js"],"sourcesContent":["/**\n * A client library for the https://web3.storage/ service. It provides a convenient\n * interface for working with the [Raw HTTP API](https://web3.storage/#api-docs)\n * from a web browser or [Node.js](https://nodejs.org/) and comes bundled with\n * TS for out-of-the box type inference and better IntelliSense.\n *\n * @example\n * ```js\n * import { Web3Storage, File } from 'web3.storage'\n * const client = new Web3Storage({ token: API_TOKEN })\n *\n * const cid = await client.put([new File(['hello world'], 'hello.txt', { type: 'text/plain' })])\n * ```\n * @module\n */\nimport { transform } from 'streaming-iterables'\nimport pRetry, { AbortError } from 'p-retry'\nimport { pack } from 'ipfs-car/pack'\nimport { parseLinkHeader } from '@web3-storage/parse-link-header'\nimport { unpackStream } from 'ipfs-car/unpack'\nimport { TreewalkCarSplitter } from 'carbites/treewalk'\nimport { CarReader } from '@ipld/car'\nimport { filesFromPath, getFilesFromPath } from 'files-from-path'\nimport throttledQueue from 'throttled-queue'\nimport {\n  fetch as _fetch,\n  File,\n  Blob,\n  Blockstore\n} from './platform.js'\n\nconst MAX_PUT_RETRIES = 5\nconst MAX_CONCURRENT_UPLOADS = 3\nconst DEFAULT_CHUNK_SIZE = 1024 * 1024 * 50 // chunk to ~50MB CARs\nconst MAX_BLOCK_SIZE = 1048576\nconst MAX_CHUNK_SIZE = 104857600\n// These match what is enforced server-side\nconst RATE_LIMIT_REQUESTS = 30\nconst RATE_LIMIT_PERIOD = 10 * 1000\n\n/** @typedef { import('./lib/interface.js').API } API */\n/** @typedef { import('./lib/interface.js').Status} Status */\n/** @typedef { import('./lib/interface.js').Upload} Upload */\n/** @typedef { import('./lib/interface.js').Deal} Deal */\n/** @typedef { import('./lib/interface.js').Pin} Pin */\n/** @typedef { import('./lib/interface.js').Service } Service */\n/** @typedef { import('./lib/interface.js').Web3File} Web3File */\n/** @typedef { import('./lib/interface.js').Filelike } Filelike */\n/** @typedef { import('./lib/interface.js').CIDString} CIDString */\n/** @typedef { import('./lib/interface.js').RequestOptions} RequestOptions */\n/** @typedef { import('./lib/interface.js').PutOptions} PutOptions */\n/** @typedef { import('./lib/interface.js').PutCarOptions} PutCarOptions */\n/** @typedef { import('./lib/interface.js').ListOptions} ListOptions */\n/** @typedef { import('./lib/interface.js').RateLimiter } RateLimiter */\n/** @typedef { import('./lib/interface.js').UnixFSEntry} UnixFSEntry */\n/** @typedef { import('./lib/interface.js').Web3Response} Web3Response */\n\n/**\n * Creates a rate limiter which limits at the same rate as is enforced\n * server-side, to allow the client to avoid exceeding the requests limit and\n * being blocked for 30 seconds.\n * @returns {RateLimiter}\n */\nexport function createRateLimiter () {\n  const throttle = throttledQueue(RATE_LIMIT_REQUESTS, RATE_LIMIT_PERIOD)\n  return () => throttle(() => {})\n}\n\n/**\n * Rate limiter used by static API if no rate limiter is passed. Note that each\n * instance of the Web3Storage class gets it's own limiter if none is passed.\n * This is because rate limits are enforced per API token.\n */\nconst globalRateLimiter = createRateLimiter()\n\n/**\n * @implements Service\n */\nclass Web3Storage {\n  /**\n   * Constructs a client bound to the given `options.token` and\n   * `options.endpoint`.\n   *\n   * @example\n   * ```js\n   * import { Web3Storage } from 'web3.storage'\n   * const client = new Web3Storage({ token: API_TOKEN })\n   * ```\n   *\n    @param {Service} options\n   */\n  constructor ({\n    token,\n    endpoint = new URL('https://api.web3.storage'),\n    rateLimiter,\n    fetch = _fetch\n  }) {\n    /**\n     * Authorization token.\n     *\n     * @readonly\n     */\n    this.token = token\n    /**\n     * Service API endpoint `URL`.\n     * @readonly\n     */\n    this.endpoint = endpoint\n    /**\n     * @readonly\n     */\n    this.rateLimiter = rateLimiter || createRateLimiter()\n    /**\n     * Optional custom fetch function. Defaults to global fetch in browsers or @web-std/fetch on node.\n     * @readonly\n     */\n    this.fetch = fetch\n  }\n\n  /**\n   * @hidden\n   * @param {string} token\n   * @returns {Record<string, string>}\n   */\n  static headers (token) {\n    if (!token) throw new Error('missing token')\n    return {\n      Authorization: `Bearer ${token}`,\n      'X-Client': 'web3.storage/js'\n    }\n  }\n\n  /**\n   * @param {Service} service\n   * @param {Iterable<Filelike>} files\n   * @param {PutOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async put ({ endpoint, token, rateLimiter = globalRateLimiter, fetch = _fetch }, files, {\n    onRootCidReady,\n    onStoredChunk,\n    maxRetries = MAX_PUT_RETRIES,\n    maxChunkSize = DEFAULT_CHUNK_SIZE,\n    wrapWithDirectory = true,\n    name,\n    signal\n  } = {}) {\n    if (maxChunkSize >= MAX_CHUNK_SIZE || maxChunkSize < MAX_BLOCK_SIZE) {\n      throw new Error('maximum chunk size must be less than 100MiB and greater than or equal to 1MB')\n    }\n    const blockstore = new Blockstore()\n    try {\n      const { out, root } = await pack({\n        input: Array.from(files).map(toImportCandidate),\n        blockstore,\n        wrapWithDirectory,\n        maxChunkSize: MAX_BLOCK_SIZE,\n        maxChildrenPerNode: 1024\n      })\n      onRootCidReady && onRootCidReady(root.toString())\n      const car = await CarReader.fromIterable(out)\n      return await Web3Storage.putCar({ endpoint, token, rateLimiter, fetch }, car, { onStoredChunk, maxRetries, maxChunkSize, name, signal })\n    } finally {\n      await blockstore.close()\n    }\n  }\n\n  /**\n   * @param {Service} service\n   * @param {import('@ipld/car/api').CarReader} car\n   * @param {PutCarOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async putCar ({ endpoint, token, rateLimiter = globalRateLimiter, fetch = _fetch }, car, {\n    name,\n    onStoredChunk,\n    maxRetries = MAX_PUT_RETRIES,\n    maxChunkSize = DEFAULT_CHUNK_SIZE,\n    decoders,\n    signal\n  } = {}) {\n    if (maxChunkSize >= MAX_CHUNK_SIZE || maxChunkSize < MAX_BLOCK_SIZE) {\n      throw new Error('maximum chunk size must be less than 100MiB and greater than or equal to 1MB')\n    }\n    const targetSize = maxChunkSize\n    const url = new URL('car', endpoint)\n    const headers = {\n      ...Web3Storage.headers(token),\n      'Content-Type': 'application/vnd.ipld.car',\n      ...(name ? { 'X-Name': encodeURIComponent(name) } : {})\n    }\n\n    const roots = await car.getRoots()\n    if (roots[0] == null) {\n      throw new Error('missing root CID')\n    }\n    if (roots.length > 1) {\n      throw new Error('too many roots')\n    }\n\n    const carRoot = roots[0].toString()\n    const splitter = new TreewalkCarSplitter(car, targetSize, { decoders })\n\n    /**\n     * @param {AsyncIterable<Uint8Array>} car\n     * @returns {Promise<CIDString>}\n     */\n    const onCarChunk = async car => {\n      const carParts = []\n      for await (const part of car) {\n        carParts.push(part)\n      }\n\n      const carFile = new Blob(carParts, { type: 'application/vnd.ipld.car' })\n\n      /** @type {Blob|ArrayBuffer} */\n      let body = carFile\n      // FIXME: should not be necessary to await arrayBuffer()!\n      // Node.js 20 hangs reading the stream (it never ends) but in\n      // older node versions and the browser it is fine to pass a blob.\n      /* c8 ignore next 3 */\n      if (parseInt(globalThis.process?.versions?.node) > 18) {\n        body = await body.arrayBuffer()\n      }\n\n      const res = await pRetry(\n        async () => {\n          await rateLimiter()\n          /** @type {Response} */\n          let response\n          try {\n            response = await fetch(url.toString(), {\n              method: 'POST',\n              headers,\n              body,\n              signal\n            })\n          } catch (/** @type {any} */err) {\n            throw signal && signal.aborted ? new AbortError(err) : err\n          }\n          /* c8 ignore next 3 */\n          if (response.status === 429) {\n            throw new Error('rate limited')\n          }\n          const res = await response.json()\n          if (!response.ok) {\n            throw new Error(res.message)\n          }\n\n          if (res.cid !== carRoot) {\n            throw new Error(`root CID mismatch, expected: ${carRoot}, received: ${res.cid}`)\n          }\n          return res.cid\n        },\n        { retries: maxRetries }\n      )\n\n      onStoredChunk && onStoredChunk(carFile.size)\n      return res\n    }\n\n    const upload = transform(MAX_CONCURRENT_UPLOADS, onCarChunk)\n    for await (const _ of upload(splitter.cars())) {} // eslint-disable-line\n    return carRoot\n  }\n\n  /**\n   * @param {Service} service\n   * @param {CIDString} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<Web3Response | null>}\n   */\n  static async get ({ endpoint, token, rateLimiter = globalRateLimiter, fetch = _fetch }, cid, options = {}) {\n    const url = new URL(`car/${cid}`, endpoint)\n    await rateLimiter()\n    const res = await fetch(url.toString(), {\n      method: 'GET',\n      headers: Web3Storage.headers(token),\n      signal: options.signal\n    })\n    /* c8 ignore next 3 */\n    if (res.status === 429) {\n      throw new Error('rate limited')\n    }\n    return toWeb3Response(res)\n  }\n\n  /**\n   * @param {Service} service\n   * @param {CIDString} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  /* c8 ignore next 4 */\n  static async delete ({ endpoint, token, rateLimiter = globalRateLimiter }, cid, options = {}) {\n    console.log('Not deleting', cid, endpoint, token, rateLimiter, options)\n    throw Error('.delete not implemented yet')\n  }\n\n  /**\n   * @param {Service} service\n   * @param {CIDString} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<Status | undefined>}\n   */\n  static async status ({ endpoint, token, rateLimiter = globalRateLimiter, fetch = _fetch }, cid, options = {}) {\n    const url = new URL(`status/${cid}`, endpoint)\n    await rateLimiter()\n    const res = await fetch(url.toString(), {\n      method: 'GET',\n      headers: Web3Storage.headers(token),\n      signal: options.signal\n    })\n    /* c8 ignore next 3 */\n    if (res.status === 429) {\n      throw new Error('rate limited')\n    }\n    if (res.status === 404) {\n      return undefined\n    }\n    if (!res.ok) {\n      throw new Error(res.statusText)\n    }\n    return res.json()\n  }\n\n  /**\n   * @param {Service} service\n   * @param {ListOptions} [opts]\n   * @returns {AsyncIterable<Upload>}\n   */\n  static async * list (service, { before = new Date().toISOString(), maxResults = Infinity, signal } = {}) {\n    /**\n     * @param {Service} service\n     * @param {{before: string, size: number}} opts\n     * @returns {Promise<Response>}\n     */\n    async function listPage ({ endpoint, token, rateLimiter = globalRateLimiter, fetch = _fetch }, { before, size }) {\n      const search = new URLSearchParams({ before, size: size.toString() })\n      const url = new URL(`user/uploads?${search}`, endpoint)\n      await rateLimiter()\n      return fetch(url.toString(), {\n        method: 'GET',\n        headers: {\n          ...Web3Storage.headers(token),\n          'Access-Control-Request-Headers': 'Link'\n        },\n        signal\n      })\n    }\n    let count = 0\n    const size = maxResults > 100 ? 100 : maxResults\n    for await (const res of paginator(listPage, service, { before, size })) {\n      if (!res.ok) {\n        /* c8 ignore next 3 */\n        if (res.status === 429) {\n          throw new Error('rate limited')\n        }\n\n        /* c8 ignore next 2 */\n        const errorMessage = await res.json()\n        throw new Error(`${res.status} ${res.statusText} ${errorMessage ? '- ' + errorMessage.message : ''}`)\n      }\n      const page = await res.json()\n      for (const upload of page) {\n        if (++count > maxResults) {\n          return\n        }\n        yield upload\n      }\n    }\n  }\n\n  // Just a sugar so you don't have to pass around endpoint and token around.\n\n  /**\n   * Uploads files to web3.storage. Files are hashed in the client and uploaded as a single\n   * [Content Addressed Archive(CAR)](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md).\n   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n   *\n   * Returns the corresponding Content Identifier (CID).\n   *\n   * @example\n   * ```js\n   * const file = new File(['hello world'], 'hello.txt', { type: 'text/plain' })\n   * const cid = await client.put([file])\n   * ```\n   * @param {Iterable<Filelike>} files\n   * @param {PutOptions} [options]\n   */\n  put (files, options) {\n    return Web3Storage.put(this, files, options)\n  }\n\n  /**\n   * Uploads a CAR ([Content Addressed Archive](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md)) file to web3.storage.\n   * Takes a CarReader interface from @ipld/car\n   *\n   * Returns the corresponding Content Identifier (CID).\n   *\n   * @example\n   * ```js\n   * import fs from 'fs'\n   * import { Readable } from 'stream'\n   * import { CarReader, CarWriter } from '@ipld/car'\n   * import * as raw from 'multiformats/codecs/raw'\n   * import { CID } from 'multiformats/cid'\n   * import { sha256 } from 'multiformats/hashes/sha2'\n   *\n   * async function getCar() {\n   *    const bytes = new TextEncoder().encode('random meaningless bytes')\n   *    const hash = await sha256.digest(raw.encode(bytes))\n   *    const cid = CID.create(1, raw.code, hash)\n   *\n   *    // create the writer and set the header with a single root\n   *    const { writer, out } = await CarWriter.create([cid])\n   *    Readable.from(out).pipe(fs.createWriteStream('example.car'))\n\n   *    // store a new block, creates a new file entry in the CAR archive\n   *    await writer.put({ cid, bytes })\n   *    await writer.close()\n\n   *    const inStream = fs.createReadStream('example.car')\n   *    // read and parse the entire stream in one go, this will cache the contents of\n   *    // the car in memory so is not suitable for large files.\n   *    const reader = await CarReader.fromIterable(inStream)\n   *    return reader\n   * }\n   *\n   * const car = await getCar()\n   * const cid = await client.putCar(car)\n   * ```\n   * @param {import('@ipld/car/api').CarReader} car\n   * @param {PutCarOptions} [options]\n   */\n  putCar (car, options) {\n    return Web3Storage.putCar(this, car, options)\n  }\n\n  /**\n   * Fetch the Content Addressed Archive by its root CID.\n   * @param {CIDString} cid\n   * @param {RequestOptions} [options]\n   */\n  get (cid, options) {\n    return Web3Storage.get(this, cid, options)\n  }\n\n  /**\n   * @param {CIDString} cid\n   * @param {RequestOptions} [options]\n   */\n  /* c8 ignore next 3 */\n  delete (cid, options) {\n    return Web3Storage.delete(this, cid, options)\n  }\n\n  /**\n   * Fetch info on Filecoin deals and IPFS pins that a given CID is replicated in.\n   * @param {CIDString} cid\n   * @param {RequestOptions} [options]\n   */\n  status (cid, options) {\n    return Web3Storage.status(this, cid, options)\n  }\n\n  /**\n   * Find all uploads for this account. Use a `for await...of` loop to fetch them all.\n   * @example\n   * Fetch all the uploads\n   * ```js\n   * const uploads = []\n   * for await (const item of client.list()) {\n   *    uploads.push(item)\n   * }\n   * ```\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of\n   * @param {ListOptions} [opts]\n   * @returns {AsyncIterable<Upload>}\n   */\n  list (opts) {\n    return Web3Storage.list(this, opts)\n  }\n}\n\n/**\n * Map a UnixFSEntry to a File with a cid property.\n *\n * @param {UnixFSEntry} entry\n * @returns {Promise<Web3File>}\n */\nasync function toWeb3File ({ content, path, cid }) {\n  const chunks = []\n  for await (const chunk of content()) {\n    chunks.push(chunk)\n  }\n  const file = new File(chunks, toFilenameWithPath(path))\n  return Object.assign(file, { cid: cid.toString() })\n}\n\n/**\n * Trim the root cid from the path if there is anyting after it.\n * bafy...ic2q/path/to/pinpie.jpg => path/to/pinpie.jpg\n *         bafy...ic2q/pinpie.jpg => pinpie.jpg\n *                    bafk...52zy => bafk...52zy\n * @param {string} unixFsPath\n * @returns {string}\n */\nfunction toFilenameWithPath (unixFsPath) {\n  const slashIndex = unixFsPath.indexOf('/')\n  return slashIndex === -1 ? unixFsPath : unixFsPath.substring(slashIndex + 1)\n}\n\n/**\n * Add car unpacking smarts to the response object,\n * @param {Response} res\n * @returns {Web3Response}\n */\nfunction toWeb3Response (res) {\n  const response = Object.assign(res, {\n    unixFsIterator: async function * () {\n      if (!res.ok) {\n        throw new Error(`Response was not ok: ${res.status} ${res.statusText} - Check for { \"ok\": false } on the Response object before calling .unixFsIterator`)\n      }\n      /* c8 ignore next 3 */\n      if (!res.body) {\n        throw new Error('No body on response')\n      }\n      const blockstore = new Blockstore()\n      try {\n        for await (const entry of unpackStream(res.body, { blockstore })) {\n          yield entry\n        }\n      } finally {\n        await blockstore.close()\n      }\n    },\n    files: async () => {\n      if (!res.ok) {\n        throw new Error(`Response was not ok: ${res.status} ${res.statusText} - Check for { \"ok\": false } on the Response object before calling .files`)\n      }\n      const files = []\n      // @ts-ignore we're using the enriched response here\n      for await (const entry of response.unixFsIterator()) {\n        if (entry.type === 'directory') {\n          continue\n        }\n        const file = await toWeb3File(entry)\n        files.push(file)\n      }\n      return files\n    }\n  })\n  return response\n}\n\n/**\n * Convert the passed file to an \"import candidate\" - an object suitable for\n * passing to the ipfs-unixfs-importer. Note: content is an accessor so that\n * the stream is only created when needed.\n *\n * @param {Filelike} file\n */\nfunction toImportCandidate (file) {\n  /** @type {ReadableStream} */\n  let stream\n  return {\n    path: file.name,\n    get content () {\n      stream = stream || file.stream()\n      return stream\n    }\n  }\n}\n\n/**\n * Follow Link headers on a Response, to fetch all the things.\n *\n * @param {(service: Service, opts: any) => Promise<Response>} fn\n * @param {Service} service\n * @param {{}} opts\n */\nasync function * paginator (fn, service, opts) {\n  let res = await fn(service, opts)\n  yield res\n  let link = parseLinkHeader(res.headers.get('Link') || '')\n  // @ts-ignore\n  while (link && link.next) {\n    // @ts-ignore\n    res = await fn(service, link.next)\n    yield res\n    link = parseLinkHeader(res.headers.get('Link') || '')\n  }\n}\n\nexport { Web3Storage, File, Blob, filesFromPath, getFilesFromPath }\n\n/**\n * Just to verify API compatibility.\n * TODO: convert lib to a regular class that can be type checked.\n * @type {API}\n */\nconst api = Web3Storage\nvoid api // eslint-disable-line no-void\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}