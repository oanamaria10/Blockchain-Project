{"ast":null,"code":"import * as ED25519 from '@noble/ed25519';\nimport { varint } from 'multiformats';\nimport * as API from './type.js';\nimport * as Verifier from './verifier.js';\nimport { base64pad } from 'multiformats/bases/base64';\nimport * as Signature from '@ipld/dag-ucan/signature';\nimport * as Signer from '../signer.js';\nexport * from './type.js';\nexport const code = 0x1300;\nexport const name = Verifier.name;\n\n/** @type {'EdDSA'} */\nexport const signatureAlgorithm = Verifier.signatureAlgorithm;\nexport const signatureCode = Verifier.signatureCode;\nconst PRIVATE_TAG_SIZE = varint.encodingLength(code);\nconst PUBLIC_TAG_SIZE = varint.encodingLength(Verifier.code);\nconst KEY_SIZE = 32;\nconst SIZE = PRIVATE_TAG_SIZE + KEY_SIZE + PUBLIC_TAG_SIZE + KEY_SIZE;\nexport const PUB_KEY_OFFSET = PRIVATE_TAG_SIZE + KEY_SIZE;\n\n/**\n * Generates new issuer by generating underlying ED25519 keypair.\n * @returns {Promise<API.EdSigner>}\n */\nexport const generate = () => derive(ED25519.utils.randomPrivateKey());\n\n/**\n * Derives issuer from 32 byte long secret key.\n * @param {Uint8Array} secret\n * @returns {Promise<API.EdSigner>}\n */\nexport const derive = async secret => {\n  if (secret.byteLength !== KEY_SIZE) {\n    throw new Error(`Expected Uint8Array with byteLength of ${KEY_SIZE} instead not ${secret.byteLength}`);\n  }\n  const publicKey = await ED25519.getPublicKey(secret);\n  const signer = new Ed25519Signer(SIZE);\n  varint.encodeTo(code, signer, 0);\n  signer.set(secret, PRIVATE_TAG_SIZE);\n  varint.encodeTo(Verifier.code, signer, PRIVATE_TAG_SIZE + KEY_SIZE);\n  signer.set(publicKey, PRIVATE_TAG_SIZE + KEY_SIZE + PUBLIC_TAG_SIZE);\n  return signer;\n};\n\n/**\n * @param {API.SignerArchive<API.DID, typeof signatureCode>} archive\n * @returns {API.EdSigner}\n */\nexport const from = ({\n  id,\n  keys\n}) => {\n  if (id.startsWith('did:key:')) {\n    const key = keys[( /** @type {API.DIDKey} */id)];\n    if (key instanceof Uint8Array) {\n      return decode(key);\n    }\n  }\n  throw new TypeError(`Unsupported archive format`);\n};\n\n/**\n * @template {API.SignerImporter} O\n * @param {O} other\n */\nexport const or = other => Signer.or({\n  from\n}, other);\n\n/**\n * @param {Uint8Array} bytes\n * @returns {API.EdSigner}\n */\nexport const decode = bytes => {\n  if (bytes.byteLength !== SIZE) {\n    throw new Error(`Expected Uint8Array with byteLength of ${SIZE} instead not ${bytes.byteLength}`);\n  }\n  {\n    const [keyCode] = varint.decode(bytes);\n    if (keyCode !== code) {\n      throw new Error(`Given bytes must be a multiformat with ${code} tag`);\n    }\n  }\n  {\n    const [code] = varint.decode(bytes.subarray(PUB_KEY_OFFSET));\n    if (code !== Verifier.code) {\n      throw new Error(`Given bytes must contain public key in multiformats with ${Verifier.code} tag`);\n    }\n  }\n  return new Ed25519Signer(bytes);\n};\n\n/**\n * @param {API.EdSigner} signer\n * @return {API.ByteView<API.EdSigner & CryptoKeyPair>}\n */\nexport const encode = signer => signer.encode();\n\n/**\n * @template {string} Prefix\n * @param {API.EdSigner} signer\n * @param {API.MultibaseEncoder<Prefix>} [encoder]\n */\nexport const format = (signer, encoder) => (encoder || base64pad).encode(encode(signer));\n\n/**\n * @template {string} Prefix\n * @param {string} principal\n * @param {API.MultibaseDecoder<Prefix>} [decoder]\n * @returns {API.EdSigner}\n */\nexport const parse = (principal, decoder) => decode((decoder || base64pad).decode(principal));\n\n/**\n * @implements {API.EdSigner}\n */\nclass Ed25519Signer extends Uint8Array {\n  /** @type {typeof code} */\n  get code() {\n    return code;\n  }\n  get signer() {\n    return this;\n  }\n  /** @type {API.EdVerifier} */\n  get verifier() {\n    const bytes = new Uint8Array(this.buffer, PRIVATE_TAG_SIZE + KEY_SIZE);\n    const verifier = Verifier.decode(bytes);\n    Object.defineProperties(this, {\n      verifier: {\n        value: verifier\n      }\n    });\n    return verifier;\n  }\n\n  /**\n   * Raw public key without multiformat code.\n   */\n  get secret() {\n    const secret = new Uint8Array(this.buffer, PRIVATE_TAG_SIZE, KEY_SIZE);\n    Object.defineProperties(this, {\n      secret: {\n        value: secret\n      }\n    });\n    return secret;\n  }\n\n  /**\n   * DID of this principal in `did:key` format.\n   */\n  did() {\n    return this.verifier.did();\n  }\n  toDIDKey() {\n    return this.verifier.toDIDKey();\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   * @returns {API.Signer<ID, typeof Signature.EdDSA>}\n   */\n  withDID(id) {\n    return Signer.withDID(this, id);\n  }\n\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @returns {Promise<API.SignatureView<T, typeof Signature.EdDSA>>}\n   */\n  async sign(payload) {\n    const raw = await ED25519.sign(payload, this.secret);\n    return Signature.create(this.signatureCode, raw);\n  }\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, typeof this.signatureCode>} signature\n   */\n\n  verify(payload, signature) {\n    return this.verifier.verify(payload, signature);\n  }\n  get signatureAlgorithm() {\n    return signatureAlgorithm;\n  }\n  get signatureCode() {\n    return Signature.EdDSA;\n  }\n  encode() {\n    return this;\n  }\n  toArchive() {\n    const id = this.did();\n    return {\n      id,\n      keys: {\n        [id]: this.encode()\n      }\n    };\n  }\n}","map":{"version":3,"names":["ED25519","varint","API","Verifier","base64pad","Signature","Signer","code","name","signatureAlgorithm","signatureCode","PRIVATE_TAG_SIZE","encodingLength","PUBLIC_TAG_SIZE","KEY_SIZE","SIZE","PUB_KEY_OFFSET","generate","derive","utils","randomPrivateKey","secret","byteLength","Error","publicKey","getPublicKey","signer","Ed25519Signer","encodeTo","set","from","id","keys","startsWith","key","Uint8Array","decode","TypeError","or","other","bytes","keyCode","subarray","encode","format","encoder","parse","principal","decoder","verifier","buffer","Object","defineProperties","value","did","toDIDKey","withDID","sign","payload","raw","create","verify","signature","EdDSA","toArchive"],"sources":["C:/FACULTATE/Proiect/node_modules/@ucanto/principal/src/ed25519/signer.js"],"sourcesContent":["import * as ED25519 from '@noble/ed25519'\nimport { varint } from 'multiformats'\nimport * as API from './type.js'\nimport * as Verifier from './verifier.js'\nimport { base64pad } from 'multiformats/bases/base64'\nimport * as Signature from '@ipld/dag-ucan/signature'\nimport * as Signer from '../signer.js'\nexport * from './type.js'\n\nexport const code = 0x1300\nexport const name = Verifier.name\n\n/** @type {'EdDSA'} */\nexport const signatureAlgorithm = Verifier.signatureAlgorithm\nexport const signatureCode = Verifier.signatureCode\n\nconst PRIVATE_TAG_SIZE = varint.encodingLength(code)\nconst PUBLIC_TAG_SIZE = varint.encodingLength(Verifier.code)\nconst KEY_SIZE = 32\nconst SIZE = PRIVATE_TAG_SIZE + KEY_SIZE + PUBLIC_TAG_SIZE + KEY_SIZE\n\nexport const PUB_KEY_OFFSET = PRIVATE_TAG_SIZE + KEY_SIZE\n\n/**\n * Generates new issuer by generating underlying ED25519 keypair.\n * @returns {Promise<API.EdSigner>}\n */\nexport const generate = () => derive(ED25519.utils.randomPrivateKey())\n\n/**\n * Derives issuer from 32 byte long secret key.\n * @param {Uint8Array} secret\n * @returns {Promise<API.EdSigner>}\n */\nexport const derive = async secret => {\n  if (secret.byteLength !== KEY_SIZE) {\n    throw new Error(\n      `Expected Uint8Array with byteLength of ${KEY_SIZE} instead not ${secret.byteLength}`\n    )\n  }\n\n  const publicKey = await ED25519.getPublicKey(secret)\n  const signer = new Ed25519Signer(SIZE)\n\n  varint.encodeTo(code, signer, 0)\n  signer.set(secret, PRIVATE_TAG_SIZE)\n\n  varint.encodeTo(Verifier.code, signer, PRIVATE_TAG_SIZE + KEY_SIZE)\n  signer.set(publicKey, PRIVATE_TAG_SIZE + KEY_SIZE + PUBLIC_TAG_SIZE)\n\n  return signer\n}\n\n/**\n * @param {API.SignerArchive<API.DID, typeof signatureCode>} archive\n * @returns {API.EdSigner}\n */\nexport const from = ({ id, keys }) => {\n  if (id.startsWith('did:key:')) {\n    const key = keys[/** @type {API.DIDKey} */ (id)]\n    if (key instanceof Uint8Array) {\n      return decode(key)\n    }\n  }\n  throw new TypeError(`Unsupported archive format`)\n}\n\n/**\n * @template {API.SignerImporter} O\n * @param {O} other\n */\nexport const or = other => Signer.or({ from }, other)\n\n/**\n * @param {Uint8Array} bytes\n * @returns {API.EdSigner}\n */\nexport const decode = bytes => {\n  if (bytes.byteLength !== SIZE) {\n    throw new Error(\n      `Expected Uint8Array with byteLength of ${SIZE} instead not ${bytes.byteLength}`\n    )\n  }\n\n  {\n    const [keyCode] = varint.decode(bytes)\n    if (keyCode !== code) {\n      throw new Error(`Given bytes must be a multiformat with ${code} tag`)\n    }\n  }\n\n  {\n    const [code] = varint.decode(bytes.subarray(PUB_KEY_OFFSET))\n    if (code !== Verifier.code) {\n      throw new Error(\n        `Given bytes must contain public key in multiformats with ${Verifier.code} tag`\n      )\n    }\n  }\n\n  return new Ed25519Signer(bytes)\n}\n\n/**\n * @param {API.EdSigner} signer\n * @return {API.ByteView<API.EdSigner & CryptoKeyPair>}\n */\nexport const encode = signer => signer.encode()\n\n/**\n * @template {string} Prefix\n * @param {API.EdSigner} signer\n * @param {API.MultibaseEncoder<Prefix>} [encoder]\n */\nexport const format = (signer, encoder) =>\n  (encoder || base64pad).encode(encode(signer))\n\n/**\n * @template {string} Prefix\n * @param {string} principal\n * @param {API.MultibaseDecoder<Prefix>} [decoder]\n * @returns {API.EdSigner}\n */\nexport const parse = (principal, decoder) =>\n  decode((decoder || base64pad).decode(principal))\n\n/**\n * @implements {API.EdSigner}\n */\nclass Ed25519Signer extends Uint8Array {\n  /** @type {typeof code} */\n  get code() {\n    return code\n  }\n  get signer() {\n    return this\n  }\n  /** @type {API.EdVerifier} */\n  get verifier() {\n    const bytes = new Uint8Array(this.buffer, PRIVATE_TAG_SIZE + KEY_SIZE)\n    const verifier = Verifier.decode(bytes)\n\n    Object.defineProperties(this, {\n      verifier: {\n        value: verifier,\n      },\n    })\n\n    return verifier\n  }\n\n  /**\n   * Raw public key without multiformat code.\n   */\n  get secret() {\n    const secret = new Uint8Array(this.buffer, PRIVATE_TAG_SIZE, KEY_SIZE)\n    Object.defineProperties(this, {\n      secret: {\n        value: secret,\n      },\n    })\n\n    return secret\n  }\n\n  /**\n   * DID of this principal in `did:key` format.\n   */\n  did() {\n    return this.verifier.did()\n  }\n\n  toDIDKey() {\n    return this.verifier.toDIDKey()\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   * @returns {API.Signer<ID, typeof Signature.EdDSA>}\n   */\n  withDID(id) {\n    return Signer.withDID(this, id)\n  }\n\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @returns {Promise<API.SignatureView<T, typeof Signature.EdDSA>>}\n   */\n  async sign(payload) {\n    const raw = await ED25519.sign(payload, this.secret)\n\n    return Signature.create(this.signatureCode, raw)\n  }\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, typeof this.signatureCode>} signature\n   */\n\n  verify(payload, signature) {\n    return this.verifier.verify(payload, signature)\n  }\n\n  get signatureAlgorithm() {\n    return signatureAlgorithm\n  }\n  get signatureCode() {\n    return Signature.EdDSA\n  }\n\n  encode() {\n    return this\n  }\n\n  toArchive() {\n    const id = this.did()\n    return {\n      id,\n      keys: { [id]: this.encode() },\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}