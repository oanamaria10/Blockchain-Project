{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst chalk_1 = __importDefault(require(\"chalk\"));\nconst config_env_1 = require(\"../internal/core/config/config-env\");\nconst errors_1 = require(\"../internal/core/errors\");\nconst errors_list_1 = require(\"../internal/core/errors-list\");\nconst packageInfo_1 = require(\"../internal/util/packageInfo\");\nconst fs_utils_1 = require(\"../internal/util/fs-utils\");\nconst task_names_1 = require(\"./task-names\");\n// Match every group where a SPDX license is defined. The first captured group is the license.\nconst SPDX_LICENSES_REGEX = /^(?:\\/\\/|\\/\\*)\\s*SPDX-License-Identifier:\\s*([a-zA-Z\\d+.-]+).*/gm;\n// Match every group where a pragma directive is defined. The first captured group is the pragma directive.\nconst PRAGMA_DIRECTIVES_REGEX = /^(?: |\\t)*(pragma\\s*abicoder\\s*v(1|2)|pragma\\s*experimental\\s*ABIEncoderV2)\\s*;/gim;\nfunction getSortedFiles(dependenciesGraph) {\n  const tsort = require(\"tsort\");\n  const graph = tsort();\n  // sort the graph entries to make the results deterministic\n  const dependencies = dependenciesGraph.entries().sort(([a], [b]) => a.sourceName.localeCompare(b.sourceName));\n  const filesMap = {};\n  const resolvedFiles = dependencies.map(([file, _deps]) => file);\n  resolvedFiles.forEach(f => filesMap[f.sourceName] = f);\n  for (const [from, deps] of dependencies) {\n    // sort the dependencies to make the results deterministic\n    const sortedDeps = [...deps].sort((a, b) => a.sourceName.localeCompare(b.sourceName));\n    for (const to of sortedDeps) {\n      graph.add(to.sourceName, from.sourceName);\n    }\n  }\n  try {\n    const topologicalSortedNames = graph.sort();\n    // If an entry has no dependency it won't be included in the graph, so we\n    // add them and then dedup the array\n    const withEntries = topologicalSortedNames.concat(resolvedFiles.map(f => f.sourceName));\n    const sortedNames = [...new Set(withEntries)];\n    return sortedNames.map(n => filesMap[n]);\n  } catch (error) {\n    if (error instanceof Error) {\n      if (error.toString().includes(\"Error: There is a cycle in the graph.\")) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.FLATTEN_CYCLE, {}, error);\n      }\n    }\n    // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n}\nfunction getFileWithoutImports(resolvedFile) {\n  const IMPORT_SOLIDITY_REGEX = /^\\s*import(\\s+)[\\s\\S]*?;\\s*$/gm;\n  return resolvedFile.content.rawContent.replace(IMPORT_SOLIDITY_REGEX, \"\").trim();\n}\nfunction getLicensesInfo(sortedFiles) {\n  const licenses = new Set();\n  const filesWithoutLicenses = new Set();\n  for (const file of sortedFiles) {\n    const matches = [...file.content.rawContent.matchAll(SPDX_LICENSES_REGEX)];\n    if (matches.length === 0) {\n      filesWithoutLicenses.add(file.sourceName);\n      continue;\n    }\n    for (const groups of matches) {\n      licenses.add(groups[1]);\n    }\n  }\n  // Sort alphabetically\n  return [Array.from(licenses).sort(), Array.from(filesWithoutLicenses).sort()];\n}\nfunction getLicensesHeader(licenses) {\n  return licenses.length <= 0 ? \"\" : `\\n\\n// SPDX-License-Identifier: ${licenses.join(\" AND \")}`;\n}\nfunction removeUnnecessarySpaces(str) {\n  return str.replace(/\\s+/g, \" \").trim();\n}\nfunction getPragmaAbicoderDirectiveInfo(sortedFiles) {\n  let directive = \"\";\n  const directivesByImportance = [\"pragma abicoder v1\", \"pragma experimental ABIEncoderV2\", \"pragma abicoder v2\"];\n  const filesWithoutPragmaDirectives = new Set();\n  const filesWithMostImportantDirective = []; // Every array element has the structure: [ fileName, fileMostImportantDirective ]\n  for (const file of sortedFiles) {\n    const matches = [...file.content.rawContent.matchAll(PRAGMA_DIRECTIVES_REGEX)];\n    if (matches.length === 0) {\n      filesWithoutPragmaDirectives.add(file.sourceName);\n      continue;\n    }\n    let fileMostImportantDirective = \"\";\n    for (const groups of matches) {\n      const normalizedPragma = removeUnnecessarySpaces(groups[1]);\n      // Update the most important pragma directive among all the files\n      if (directivesByImportance.indexOf(normalizedPragma) > directivesByImportance.indexOf(directive)) {\n        directive = normalizedPragma;\n      }\n      // Update the most important pragma directive for the current file\n      if (directivesByImportance.indexOf(normalizedPragma) > directivesByImportance.indexOf(fileMostImportantDirective)) {\n        fileMostImportantDirective = normalizedPragma;\n      }\n    }\n    // Add in the array the most important directive for the current file\n    filesWithMostImportantDirective.push([file.sourceName, fileMostImportantDirective]);\n  }\n  // Add to the array the files that have a pragma directive which is not the same as the main one that\n  // is going to be used in the flatten file\n  const filesWithDifferentPragmaDirectives = filesWithMostImportantDirective.filter(([, fileDirective]) => fileDirective !== directive).map(([fileName]) => fileName);\n  // Sort alphabetically\n  return [directive, Array.from(filesWithoutPragmaDirectives).sort(), filesWithDifferentPragmaDirectives.sort()];\n}\nfunction getPragmaAbicoderDirectiveHeader(pragmaDirective) {\n  return pragmaDirective === \"\" ? \"\" : `\\n\\n${pragmaDirective};`;\n}\nfunction replaceLicenses(file) {\n  return file.replaceAll(SPDX_LICENSES_REGEX, (...groups) => `// Original license: SPDX_License_Identifier: ${groups[1]}`);\n}\nfunction replacePragmaAbicoderDirectives(file) {\n  return file.replaceAll(PRAGMA_DIRECTIVES_REGEX, (...groups) => {\n    return `// Original pragma directive: ${removeUnnecessarySpaces(groups[1])}`;\n  });\n}\n(0, config_env_1.subtask)(task_names_1.TASK_FLATTEN_GET_FLATTENED_SOURCE_AND_METADATA, \"Returns all contracts and their dependencies flattened. Also return metadata about pragma directives and SPDX licenses\").addOptionalParam(\"files\", undefined, undefined, config_env_1.types.any).setAction(async ({\n  files\n}, {\n  run\n}) => {\n  const dependencyGraph = await run(task_names_1.TASK_FLATTEN_GET_DEPENDENCY_GRAPH, {\n    files\n  });\n  let flattened = \"\";\n  if (dependencyGraph.getResolvedFiles().length === 0) {\n    return [flattened, null];\n  }\n  const packageJson = await (0, packageInfo_1.getPackageJson)();\n  flattened += `// Sources flattened with hardhat v${packageJson.version} https://hardhat.org`;\n  const sortedFiles = getSortedFiles(dependencyGraph);\n  const [licenses, filesWithoutLicenses] = getLicensesInfo(sortedFiles);\n  const [pragmaDirective, filesWithoutPragmaDirectives, filesWithDifferentPragmaDirectives] = getPragmaAbicoderDirectiveInfo(sortedFiles);\n  flattened += getLicensesHeader(licenses);\n  flattened += getPragmaAbicoderDirectiveHeader(pragmaDirective);\n  for (const file of sortedFiles) {\n    let tmpFile = getFileWithoutImports(file);\n    tmpFile = replaceLicenses(tmpFile);\n    tmpFile = replacePragmaAbicoderDirectives(tmpFile);\n    flattened += `\\n\\n// File ${file.getVersionedName()}\\n`;\n    flattened += `\\n${tmpFile}\\n`;\n  }\n  return [flattened.trim(), {\n    filesWithoutLicenses,\n    pragmaDirective,\n    filesWithoutPragmaDirectives,\n    filesWithDifferentPragmaDirectives\n  }];\n});\n// The following task is kept for backwards-compatibility reasons\n(0, config_env_1.subtask)(task_names_1.TASK_FLATTEN_GET_FLATTENED_SOURCE, \"Returns all contracts and their dependencies flattened\").addOptionalParam(\"files\", undefined, undefined, config_env_1.types.any).setAction(async ({\n  files\n}, {\n  run\n}) => {\n  return (await run(task_names_1.TASK_FLATTEN_GET_FLATTENED_SOURCE_AND_METADATA, {\n    files\n  }))[0];\n});\n(0, config_env_1.subtask)(task_names_1.TASK_FLATTEN_GET_DEPENDENCY_GRAPH).addOptionalParam(\"files\", undefined, undefined, config_env_1.types.any).setAction(async ({\n  files\n}, {\n  run\n}) => {\n  const sourcePaths = files === undefined ? await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS) : files.map(f => (0, fs_utils_1.getRealPathSync)(f));\n  const sourceNames = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES, {\n    sourcePaths\n  });\n  const dependencyGraph = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH, {\n    sourceNames\n  });\n  return dependencyGraph;\n});\n(0, config_env_1.task)(task_names_1.TASK_FLATTEN, \"Flattens and prints contracts and their dependencies. If no file is passed, all the contracts in the project will be flattened.\").addOptionalVariadicPositionalParam(\"files\", \"The files to flatten\", undefined, config_env_1.types.inputFile).setAction(async ({\n  files\n}, {\n  run\n}) => {\n  const [flattenedFile, metadata] = await run(task_names_1.TASK_FLATTEN_GET_FLATTENED_SOURCE_AND_METADATA, {\n    files\n  });\n  console.log(flattenedFile);\n  if (metadata === null) return;\n  if (metadata.filesWithoutLicenses.length > 0) {\n    console.warn(chalk_1.default.yellow(`\\nThe following file(s) do NOT specify SPDX licenses: ${metadata.filesWithoutLicenses.join(\", \")}`));\n  }\n  if (metadata.pragmaDirective !== \"\" && metadata.filesWithoutPragmaDirectives.length > 0) {\n    console.warn(chalk_1.default.yellow(`\\nPragma abicoder directives are defined in some files, but they are not defined in the following ones: ${metadata.filesWithoutPragmaDirectives.join(\", \")}`));\n  }\n  if (metadata.filesWithDifferentPragmaDirectives.length > 0) {\n    console.warn(chalk_1.default.yellow(`\\nThe flattened file is using the pragma abicoder directive '${metadata.pragmaDirective}' but these files have a different pragma abicoder directive: ${metadata.filesWithDifferentPragmaDirectives.join(\", \")}`));\n  }\n});","map":{"version":3,"names":["chalk_1","__importDefault","require","config_env_1","errors_1","errors_list_1","packageInfo_1","fs_utils_1","task_names_1","SPDX_LICENSES_REGEX","PRAGMA_DIRECTIVES_REGEX","getSortedFiles","dependenciesGraph","tsort","graph","dependencies","entries","sort","a","b","sourceName","localeCompare","filesMap","resolvedFiles","map","file","_deps","forEach","f","from","deps","sortedDeps","to","add","topologicalSortedNames","withEntries","concat","sortedNames","Set","n","error","Error","toString","includes","HardhatError","ERRORS","BUILTIN_TASKS","FLATTEN_CYCLE","getFileWithoutImports","resolvedFile","IMPORT_SOLIDITY_REGEX","content","rawContent","replace","trim","getLicensesInfo","sortedFiles","licenses","filesWithoutLicenses","matches","matchAll","length","groups","Array","getLicensesHeader","join","removeUnnecessarySpaces","str","getPragmaAbicoderDirectiveInfo","directive","directivesByImportance","filesWithoutPragmaDirectives","filesWithMostImportantDirective","fileMostImportantDirective","normalizedPragma","indexOf","push","filesWithDifferentPragmaDirectives","filter","fileDirective","fileName","getPragmaAbicoderDirectiveHeader","pragmaDirective","replaceLicenses","replaceAll","replacePragmaAbicoderDirectives","subtask","TASK_FLATTEN_GET_FLATTENED_SOURCE_AND_METADATA","addOptionalParam","undefined","types","any","setAction","files","run","dependencyGraph","TASK_FLATTEN_GET_DEPENDENCY_GRAPH","flattened","getResolvedFiles","packageJson","getPackageJson","version","tmpFile","getVersionedName","TASK_FLATTEN_GET_FLATTENED_SOURCE","sourcePaths","TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS","getRealPathSync","sourceNames","TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES","TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH","task","TASK_FLATTEN","addOptionalVariadicPositionalParam","inputFile","flattenedFile","metadata","console","log","warn","default","yellow"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\builtin-tasks\\flatten.ts"],"sourcesContent":["import chalk from \"chalk\";\nimport { subtask, task, types } from \"../internal/core/config/config-env\";\nimport { HardhatError } from \"../internal/core/errors\";\nimport { ERRORS } from \"../internal/core/errors-list\";\nimport { DependencyGraph } from \"../internal/solidity/dependencyGraph\";\nimport { ResolvedFile, ResolvedFilesMap } from \"../internal/solidity/resolver\";\nimport { getPackageJson } from \"../internal/util/packageInfo\";\n\nimport { getRealPathSync } from \"../internal/util/fs-utils\";\nimport {\n  TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH,\n  TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES,\n  TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS,\n  TASK_FLATTEN,\n  TASK_FLATTEN_GET_DEPENDENCY_GRAPH,\n  TASK_FLATTEN_GET_FLATTENED_SOURCE,\n  TASK_FLATTEN_GET_FLATTENED_SOURCE_AND_METADATA,\n} from \"./task-names\";\n\ninterface FlattenMetadata {\n  filesWithoutLicenses: string[];\n  pragmaDirective: string;\n  filesWithoutPragmaDirectives: string[];\n  filesWithDifferentPragmaDirectives: string[];\n}\n\n// Match every group where a SPDX license is defined. The first captured group is the license.\nconst SPDX_LICENSES_REGEX =\n  /^(?:\\/\\/|\\/\\*)\\s*SPDX-License-Identifier:\\s*([a-zA-Z\\d+.-]+).*/gm;\n// Match every group where a pragma directive is defined. The first captured group is the pragma directive.\nconst PRAGMA_DIRECTIVES_REGEX =\n  /^(?: |\\t)*(pragma\\s*abicoder\\s*v(1|2)|pragma\\s*experimental\\s*ABIEncoderV2)\\s*;/gim;\n\nfunction getSortedFiles(dependenciesGraph: DependencyGraph) {\n  const tsort = require(\"tsort\");\n  const graph = tsort();\n\n  // sort the graph entries to make the results deterministic\n  const dependencies = dependenciesGraph\n    .entries()\n    .sort(([a], [b]) => a.sourceName.localeCompare(b.sourceName));\n\n  const filesMap: ResolvedFilesMap = {};\n  const resolvedFiles = dependencies.map(([file, _deps]) => file);\n\n  resolvedFiles.forEach((f) => (filesMap[f.sourceName] = f));\n\n  for (const [from, deps] of dependencies) {\n    // sort the dependencies to make the results deterministic\n    const sortedDeps = [...deps].sort((a, b) =>\n      a.sourceName.localeCompare(b.sourceName)\n    );\n\n    for (const to of sortedDeps) {\n      graph.add(to.sourceName, from.sourceName);\n    }\n  }\n\n  try {\n    const topologicalSortedNames: string[] = graph.sort();\n\n    // If an entry has no dependency it won't be included in the graph, so we\n    // add them and then dedup the array\n    const withEntries = topologicalSortedNames.concat(\n      resolvedFiles.map((f) => f.sourceName)\n    );\n\n    const sortedNames = [...new Set(withEntries)];\n    return sortedNames.map((n) => filesMap[n]);\n  } catch (error) {\n    if (error instanceof Error) {\n      if (error.toString().includes(\"Error: There is a cycle in the graph.\")) {\n        throw new HardhatError(ERRORS.BUILTIN_TASKS.FLATTEN_CYCLE, {}, error);\n      }\n    }\n\n    // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n}\n\nfunction getFileWithoutImports(resolvedFile: ResolvedFile) {\n  const IMPORT_SOLIDITY_REGEX = /^\\s*import(\\s+)[\\s\\S]*?;\\s*$/gm;\n\n  return resolvedFile.content.rawContent\n    .replace(IMPORT_SOLIDITY_REGEX, \"\")\n    .trim();\n}\n\nfunction getLicensesInfo(sortedFiles: ResolvedFile[]): [string[], string[]] {\n  const licenses: Set<string> = new Set();\n  const filesWithoutLicenses: Set<string> = new Set();\n\n  for (const file of sortedFiles) {\n    const matches = [...file.content.rawContent.matchAll(SPDX_LICENSES_REGEX)];\n\n    if (matches.length === 0) {\n      filesWithoutLicenses.add(file.sourceName);\n      continue;\n    }\n\n    for (const groups of matches) {\n      licenses.add(groups[1]);\n    }\n  }\n\n  // Sort alphabetically\n  return [Array.from(licenses).sort(), Array.from(filesWithoutLicenses).sort()];\n}\n\nfunction getLicensesHeader(licenses: string[]): string {\n  return licenses.length <= 0\n    ? \"\"\n    : `\\n\\n// SPDX-License-Identifier: ${licenses.join(\" AND \")}`;\n}\n\nfunction removeUnnecessarySpaces(str: string): string {\n  return str.replace(/\\s+/g, \" \").trim();\n}\n\nfunction getPragmaAbicoderDirectiveInfo(\n  sortedFiles: ResolvedFile[]\n): [string, string[], string[]] {\n  let directive = \"\";\n  const directivesByImportance = [\n    \"pragma abicoder v1\",\n    \"pragma experimental ABIEncoderV2\",\n    \"pragma abicoder v2\",\n  ];\n  const filesWithoutPragmaDirectives: Set<string> = new Set();\n  const filesWithMostImportantDirective: Array<[string, string]> = []; // Every array element has the structure: [ fileName, fileMostImportantDirective ]\n\n  for (const file of sortedFiles) {\n    const matches = [\n      ...file.content.rawContent.matchAll(PRAGMA_DIRECTIVES_REGEX),\n    ];\n\n    if (matches.length === 0) {\n      filesWithoutPragmaDirectives.add(file.sourceName);\n      continue;\n    }\n\n    let fileMostImportantDirective = \"\";\n    for (const groups of matches) {\n      const normalizedPragma = removeUnnecessarySpaces(groups[1]);\n\n      // Update the most important pragma directive among all the files\n      if (\n        directivesByImportance.indexOf(normalizedPragma) >\n        directivesByImportance.indexOf(directive)\n      ) {\n        directive = normalizedPragma;\n      }\n\n      // Update the most important pragma directive for the current file\n      if (\n        directivesByImportance.indexOf(normalizedPragma) >\n        directivesByImportance.indexOf(fileMostImportantDirective)\n      ) {\n        fileMostImportantDirective = normalizedPragma;\n      }\n    }\n\n    // Add in the array the most important directive for the current file\n    filesWithMostImportantDirective.push([\n      file.sourceName,\n      fileMostImportantDirective,\n    ]);\n  }\n\n  // Add to the array the files that have a pragma directive which is not the same as the main one that\n  // is going to be used in the flatten file\n  const filesWithDifferentPragmaDirectives = filesWithMostImportantDirective\n    .filter(([, fileDirective]) => fileDirective !== directive)\n    .map(([fileName]) => fileName);\n\n  // Sort alphabetically\n  return [\n    directive,\n    Array.from(filesWithoutPragmaDirectives).sort(),\n    filesWithDifferentPragmaDirectives.sort(),\n  ];\n}\n\nfunction getPragmaAbicoderDirectiveHeader(pragmaDirective: string): string {\n  return pragmaDirective === \"\" ? \"\" : `\\n\\n${pragmaDirective};`;\n}\n\nfunction replaceLicenses(file: string): string {\n  return file.replaceAll(\n    SPDX_LICENSES_REGEX,\n    (...groups) => `// Original license: SPDX_License_Identifier: ${groups[1]}`\n  );\n}\n\nfunction replacePragmaAbicoderDirectives(file: string): string {\n  return file.replaceAll(PRAGMA_DIRECTIVES_REGEX, (...groups) => {\n    return `// Original pragma directive: ${removeUnnecessarySpaces(\n      groups[1]\n    )}`;\n  });\n}\n\nsubtask(\n  TASK_FLATTEN_GET_FLATTENED_SOURCE_AND_METADATA,\n  \"Returns all contracts and their dependencies flattened. Also return metadata about pragma directives and SPDX licenses\"\n)\n  .addOptionalParam(\"files\", undefined, undefined, types.any)\n  .setAction(\n    async (\n      { files }: { files?: string[] },\n      { run }\n    ): Promise<[string, FlattenMetadata | null]> => {\n      const dependencyGraph: DependencyGraph = await run(\n        TASK_FLATTEN_GET_DEPENDENCY_GRAPH,\n        { files }\n      );\n\n      let flattened = \"\";\n\n      if (dependencyGraph.getResolvedFiles().length === 0) {\n        return [flattened, null];\n      }\n\n      const packageJson = await getPackageJson();\n      flattened += `// Sources flattened with hardhat v${packageJson.version} https://hardhat.org`;\n\n      const sortedFiles = getSortedFiles(dependencyGraph);\n\n      const [licenses, filesWithoutLicenses] = getLicensesInfo(sortedFiles);\n      const [\n        pragmaDirective,\n        filesWithoutPragmaDirectives,\n        filesWithDifferentPragmaDirectives,\n      ] = getPragmaAbicoderDirectiveInfo(sortedFiles);\n\n      flattened += getLicensesHeader(licenses);\n      flattened += getPragmaAbicoderDirectiveHeader(pragmaDirective);\n\n      for (const file of sortedFiles) {\n        let tmpFile = getFileWithoutImports(file);\n        tmpFile = replaceLicenses(tmpFile);\n        tmpFile = replacePragmaAbicoderDirectives(tmpFile);\n\n        flattened += `\\n\\n// File ${file.getVersionedName()}\\n`;\n        flattened += `\\n${tmpFile}\\n`;\n      }\n\n      return [\n        flattened.trim(),\n        {\n          filesWithoutLicenses,\n          pragmaDirective,\n          filesWithoutPragmaDirectives,\n          filesWithDifferentPragmaDirectives,\n        },\n      ];\n    }\n  );\n\n// The following task is kept for backwards-compatibility reasons\nsubtask(\n  TASK_FLATTEN_GET_FLATTENED_SOURCE,\n  \"Returns all contracts and their dependencies flattened\"\n)\n  .addOptionalParam(\"files\", undefined, undefined, types.any)\n  .setAction(async ({ files }: { files?: string[] }, { run }) => {\n    return (\n      await run(TASK_FLATTEN_GET_FLATTENED_SOURCE_AND_METADATA, { files })\n    )[0];\n  });\n\nsubtask(TASK_FLATTEN_GET_DEPENDENCY_GRAPH)\n  .addOptionalParam(\"files\", undefined, undefined, types.any)\n  .setAction(async ({ files }: { files: string[] | undefined }, { run }) => {\n    const sourcePaths: string[] =\n      files === undefined\n        ? await run(TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS)\n        : files.map((f) => getRealPathSync(f));\n\n    const sourceNames: string[] = await run(\n      TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES,\n      {\n        sourcePaths,\n      }\n    );\n\n    const dependencyGraph: DependencyGraph = await run(\n      TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH,\n      { sourceNames }\n    );\n\n    return dependencyGraph;\n  });\n\ntask(\n  TASK_FLATTEN,\n  \"Flattens and prints contracts and their dependencies. If no file is passed, all the contracts in the project will be flattened.\"\n)\n  .addOptionalVariadicPositionalParam(\n    \"files\",\n    \"The files to flatten\",\n    undefined,\n    types.inputFile\n  )\n  .setAction(async ({ files }: { files: string[] | undefined }, { run }) => {\n    const [flattenedFile, metadata]: [string, FlattenMetadata | null] =\n      await run(TASK_FLATTEN_GET_FLATTENED_SOURCE_AND_METADATA, { files });\n\n    console.log(flattenedFile);\n\n    if (metadata === null) return;\n\n    if (metadata.filesWithoutLicenses.length > 0) {\n      console.warn(\n        chalk.yellow(\n          `\\nThe following file(s) do NOT specify SPDX licenses: ${metadata.filesWithoutLicenses.join(\n            \", \"\n          )}`\n        )\n      );\n    }\n\n    if (\n      metadata.pragmaDirective !== \"\" &&\n      metadata.filesWithoutPragmaDirectives.length > 0\n    ) {\n      console.warn(\n        chalk.yellow(\n          `\\nPragma abicoder directives are defined in some files, but they are not defined in the following ones: ${metadata.filesWithoutPragmaDirectives.join(\n            \", \"\n          )}`\n        )\n      );\n    }\n\n    if (metadata.filesWithDifferentPragmaDirectives.length > 0) {\n      console.warn(\n        chalk.yellow(\n          `\\nThe flattened file is using the pragma abicoder directive '${\n            metadata.pragmaDirective\n          }' but these files have a different pragma abicoder directive: ${metadata.filesWithDifferentPragmaDirectives.join(\n            \", \"\n          )}`\n        )\n      );\n    }\n  });\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}