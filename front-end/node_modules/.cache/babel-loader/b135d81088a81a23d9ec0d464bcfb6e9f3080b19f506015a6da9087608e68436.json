{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createProviderProxy = void 0;\nconst constants_1 = require(\"hardhat/internal/constants\");\nconst ethers_provider_wrapper_1 = require(\"./ethers-provider-wrapper\");\nconst updatable_target_proxy_1 = require(\"./updatable-target-proxy\");\n/**\n * This method returns a proxy that uses an underlying provider for everything.\n *\n * This underlying provider is replaced by a new one after a successful hardhat_reset,\n * because ethers providers can have internal state that returns wrong results after\n * the network is reset.\n */\nfunction createProviderProxy(hardhatProvider) {\n  const initialProvider = new ethers_provider_wrapper_1.EthersProviderWrapper(hardhatProvider);\n  const {\n    proxy: providerProxy,\n    setTarget\n  } = (0, updatable_target_proxy_1.createUpdatableTargetProxy)(initialProvider);\n  hardhatProvider.on(constants_1.HARDHAT_NETWORK_RESET_EVENT, () => {\n    setTarget(new ethers_provider_wrapper_1.EthersProviderWrapper(hardhatProvider));\n  });\n  hardhatProvider.on(constants_1.HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT, () => {\n    setTarget(new ethers_provider_wrapper_1.EthersProviderWrapper(hardhatProvider));\n  });\n  return providerProxy;\n}\nexports.createProviderProxy = createProviderProxy;","map":{"version":3,"names":["constants_1","require","ethers_provider_wrapper_1","updatable_target_proxy_1","createProviderProxy","hardhatProvider","initialProvider","EthersProviderWrapper","proxy","providerProxy","setTarget","createUpdatableTargetProxy","on","HARDHAT_NETWORK_RESET_EVENT","HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT","exports"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\@nomiclabs\\hardhat-ethers\\src\\internal\\provider-proxy.ts"],"sourcesContent":["import {\n  HARDHAT_NETWORK_RESET_EVENT,\n  HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT,\n} from \"hardhat/internal/constants\";\nimport { EthereumProvider } from \"hardhat/types\";\n\nimport { EthersProviderWrapper } from \"./ethers-provider-wrapper\";\nimport { createUpdatableTargetProxy } from \"./updatable-target-proxy\";\n\n/**\n * This method returns a proxy that uses an underlying provider for everything.\n *\n * This underlying provider is replaced by a new one after a successful hardhat_reset,\n * because ethers providers can have internal state that returns wrong results after\n * the network is reset.\n */\nexport function createProviderProxy(\n  hardhatProvider: EthereumProvider\n): EthersProviderWrapper {\n  const initialProvider = new EthersProviderWrapper(hardhatProvider);\n\n  const { proxy: providerProxy, setTarget } =\n    createUpdatableTargetProxy(initialProvider);\n\n  hardhatProvider.on(HARDHAT_NETWORK_RESET_EVENT, () => {\n    setTarget(new EthersProviderWrapper(hardhatProvider));\n  });\n  hardhatProvider.on(HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT, () => {\n    setTarget(new EthersProviderWrapper(hardhatProvider));\n  });\n\n  return providerProxy;\n}\n"],"mappings":";;;;;;AAAA,MAAAA,WAAA,GAAAC,OAAA;AAMA,MAAAC,yBAAA,GAAAD,OAAA;AACA,MAAAE,wBAAA,GAAAF,OAAA;AAEA;;;;;;;AAOA,SAAgBG,mBAAmBA,CACjCC,eAAiC;EAEjC,MAAMC,eAAe,GAAG,IAAIJ,yBAAA,CAAAK,qBAAqB,CAACF,eAAe,CAAC;EAElE,MAAM;IAAEG,KAAK,EAAEC,aAAa;IAAEC;EAAS,CAAE,GACvC,IAAAP,wBAAA,CAAAQ,0BAA0B,EAACL,eAAe,CAAC;EAE7CD,eAAe,CAACO,EAAE,CAACZ,WAAA,CAAAa,2BAA2B,EAAE,MAAK;IACnDH,SAAS,CAAC,IAAIR,yBAAA,CAAAK,qBAAqB,CAACF,eAAe,CAAC,CAAC;EACvD,CAAC,CAAC;EACFA,eAAe,CAACO,EAAE,CAACZ,WAAA,CAAAc,qCAAqC,EAAE,MAAK;IAC7DJ,SAAS,CAAC,IAAIR,yBAAA,CAAAK,qBAAqB,CAACF,eAAe,CAAC,CAAC;EACvD,CAAC,CAAC;EAEF,OAAOI,aAAa;AACtB;AAhBAM,OAAA,CAAAX,mBAAA,GAAAA,mBAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}