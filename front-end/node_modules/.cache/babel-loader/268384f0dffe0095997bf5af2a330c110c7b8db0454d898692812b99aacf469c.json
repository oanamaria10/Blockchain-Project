{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSubprocessTransport = void 0;\nconst child_process_1 = require(\"child_process\");\nconst path = __importStar(require(\"path\"));\n// This class is wrapped in a function to avoid having to\n// import @sentry/node just for the BaseTransport base class\nfunction getSubprocessTransport() {\n  const {\n    Status,\n    Transports\n  } = require(\"@sentry/node\");\n  class SubprocessTransport extends Transports.BaseTransport {\n    async sendEvent(event) {\n      const extra = event.extra ?? {};\n      const {\n        verbose = false,\n        configPath\n      } = extra;\n      // don't send user's full config path for privacy reasons\n      delete event.extra?.configPath;\n      // we don't care about the verbose setting\n      delete event.extra?.verbose;\n      const serializedEvent = JSON.stringify(event);\n      const env = {\n        HARDHAT_SENTRY_EVENT: serializedEvent,\n        HARDHAT_SENTRY_VERBOSE: verbose.toString()\n      };\n      if (configPath !== undefined) {\n        env.HARDHAT_SENTRY_CONFIG_PATH = configPath;\n      }\n      const subprocessPath = path.join(__dirname, \"subprocess\");\n      const subprocess = (0, child_process_1.spawn)(process.execPath, [subprocessPath], {\n        detached: true,\n        env,\n        stdio: verbose ? \"inherit\" : \"ignore\"\n      });\n      subprocess.unref();\n      return {\n        status: Status.Success\n      };\n    }\n  }\n  return SubprocessTransport;\n}\nexports.getSubprocessTransport = getSubprocessTransport;","map":{"version":3,"names":["child_process_1","require","path","__importStar","getSubprocessTransport","Status","Transports","SubprocessTransport","BaseTransport","sendEvent","event","extra","verbose","configPath","serializedEvent","JSON","stringify","env","HARDHAT_SENTRY_EVENT","HARDHAT_SENTRY_VERBOSE","toString","undefined","HARDHAT_SENTRY_CONFIG_PATH","subprocessPath","join","__dirname","subprocess","spawn","process","execPath","detached","stdio","unref","status","Success","exports"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\internal\\sentry\\transport.ts"],"sourcesContent":["import type { Event, Response } from \"@sentry/node\";\nimport { spawn } from \"child_process\";\nimport * as path from \"path\";\n\n// This class is wrapped in a function to avoid having to\n// import @sentry/node just for the BaseTransport base class\nexport function getSubprocessTransport(): any {\n  const { Status, Transports } = require(\"@sentry/node\");\n\n  class SubprocessTransport extends Transports.BaseTransport {\n    public async sendEvent(event: Event): Promise<Response> {\n      const extra: { verbose?: boolean; configPath?: string } =\n        event.extra ?? {};\n      const { verbose = false, configPath } = extra;\n\n      // don't send user's full config path for privacy reasons\n      delete event.extra?.configPath;\n\n      // we don't care about the verbose setting\n      delete event.extra?.verbose;\n\n      const serializedEvent = JSON.stringify(event);\n\n      const env: Record<string, string> = {\n        HARDHAT_SENTRY_EVENT: serializedEvent,\n        HARDHAT_SENTRY_VERBOSE: verbose.toString(),\n      };\n\n      if (configPath !== undefined) {\n        env.HARDHAT_SENTRY_CONFIG_PATH = configPath;\n      }\n\n      const subprocessPath = path.join(__dirname, \"subprocess\");\n\n      const subprocess = spawn(process.execPath, [subprocessPath], {\n        detached: true,\n        env,\n        stdio: (verbose ? \"inherit\" : \"ignore\") as any,\n      });\n\n      subprocess.unref();\n\n      return {\n        status: Status.Success,\n      };\n    }\n  }\n\n  return SubprocessTransport;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,MAAAA,eAAA,GAAAC,OAAA;AACA,MAAAC,IAAA,GAAAC,YAAA,CAAAF,OAAA;AAEA;AACA;AACA,SAAgBG,sBAAsBA,CAAA;EACpC,MAAM;IAAEC,MAAM;IAAEC;EAAU,CAAE,GAAGL,OAAO,CAAC,cAAc,CAAC;EAEtD,MAAMM,mBAAoB,SAAQD,UAAU,CAACE,aAAa;IACjD,MAAMC,SAASA,CAACC,KAAY;MACjC,MAAMC,KAAK,GACTD,KAAK,CAACC,KAAK,IAAI,EAAE;MACnB,MAAM;QAAEC,OAAO,GAAG,KAAK;QAAEC;MAAU,CAAE,GAAGF,KAAK;MAE7C;MACA,OAAOD,KAAK,CAACC,KAAK,EAAEE,UAAU;MAE9B;MACA,OAAOH,KAAK,CAACC,KAAK,EAAEC,OAAO;MAE3B,MAAME,eAAe,GAAGC,IAAI,CAACC,SAAS,CAACN,KAAK,CAAC;MAE7C,MAAMO,GAAG,GAA2B;QAClCC,oBAAoB,EAAEJ,eAAe;QACrCK,sBAAsB,EAAEP,OAAO,CAACQ,QAAQ;OACzC;MAED,IAAIP,UAAU,KAAKQ,SAAS,EAAE;QAC5BJ,GAAG,CAACK,0BAA0B,GAAGT,UAAU;;MAG7C,MAAMU,cAAc,GAAGrB,IAAI,CAACsB,IAAI,CAACC,SAAS,EAAE,YAAY,CAAC;MAEzD,MAAMC,UAAU,GAAG,IAAA1B,eAAA,CAAA2B,KAAK,EAACC,OAAO,CAACC,QAAQ,EAAE,CAACN,cAAc,CAAC,EAAE;QAC3DO,QAAQ,EAAE,IAAI;QACdb,GAAG;QACHc,KAAK,EAAGnB,OAAO,GAAG,SAAS,GAAG;OAC/B,CAAC;MAEFc,UAAU,CAACM,KAAK,EAAE;MAElB,OAAO;QACLC,MAAM,EAAE5B,MAAM,CAAC6B;OAChB;IACH;;EAGF,OAAO3B,mBAAmB;AAC5B;AA3CA4B,OAAA,CAAA/B,sBAAA,GAAAA,sBAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}