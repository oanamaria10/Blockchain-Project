{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TasksDSL = void 0;\nconst errors_1 = require(\"../errors\");\nconst errors_list_1 = require(\"../errors-list\");\nconst task_definitions_1 = require(\"./task-definitions\");\nconst util_1 = require(\"./util\");\n/**\n * This class defines the DSL used in Hardhat config files\n * for creating and overriding tasks.\n */\nclass TasksDSL {\n  constructor() {\n    this.internalTask = this.subtask;\n    this._tasks = {};\n    this._scopes = {};\n  }\n  task(name, descriptionOrAction, action) {\n    // if this function is updated, update the corresponding callback\n    // passed to `new SimpleScopeDefinition`\n    return this._addTask(name, descriptionOrAction, action, false);\n  }\n  subtask(name, descriptionOrAction, action) {\n    // if this function is updated, update the corresponding callback\n    // passed to `new SimpleScopeDefinition`\n    return this._addTask(name, descriptionOrAction, action, true);\n  }\n  scope(name, description) {\n    if (this._tasks[name] !== undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.TASK_DEFINITIONS.TASK_SCOPE_CLASH, {\n        scopeName: name\n      });\n    }\n    const scopeDefinition = this._scopes[name];\n    if (scopeDefinition !== undefined) {\n      // if the scope already exists, the only thing we might\n      // do is to update its description\n      if (description !== undefined) {\n        scopeDefinition.setDescription(description);\n      }\n      return scopeDefinition;\n    }\n    const scope = new task_definitions_1.SimpleScopeDefinition(name, description, (taskName, descriptionOrAction, action) =>\n    // if this function is updated, update the dsl.task function too\n    this._addTask({\n      scope: name,\n      task: taskName\n    }, descriptionOrAction, action, false), (subtaskName, descriptionOrAction, action) =>\n    // if this function is updated, update the dsl.subtask function too\n    this._addTask({\n      scope: name,\n      task: subtaskName\n    }, descriptionOrAction, action, true));\n    this._scopes[name] = scope;\n    return scope;\n  }\n  /**\n   * Retrieves the task definitions.\n   *\n   * @returns The tasks container.\n   */\n  getTaskDefinitions() {\n    return this._tasks;\n  }\n  /**\n   * Retrieves the scoped task definitions.\n   *\n   * @returns The scoped tasks container.\n   */\n  getScopesDefinitions() {\n    return this._scopes;\n  }\n  getTaskDefinition(scope, name) {\n    if (scope === undefined) {\n      return this._tasks[name];\n    } else {\n      return this._scopes[scope]?.tasks?.[name];\n    }\n  }\n  _addTask(taskIdentifier, descriptionOrAction, action, isSubtask) {\n    const {\n      scope,\n      task\n    } = (0, util_1.parseTaskIdentifier)(taskIdentifier);\n    if (scope === undefined && this._scopes[task] !== undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.TASK_DEFINITIONS.SCOPE_TASK_CLASH, {\n        taskName: task\n      });\n    }\n    const parentTaskDefinition = this.getTaskDefinition(scope, task);\n    let taskDefinition;\n    if (parentTaskDefinition !== undefined) {\n      taskDefinition = new task_definitions_1.OverriddenTaskDefinition(parentTaskDefinition, isSubtask);\n    } else {\n      taskDefinition = new task_definitions_1.SimpleTaskDefinition(taskIdentifier, isSubtask);\n    }\n    if (descriptionOrAction instanceof Function) {\n      action = descriptionOrAction;\n      descriptionOrAction = undefined;\n    }\n    if (descriptionOrAction !== undefined) {\n      taskDefinition.setDescription(descriptionOrAction);\n    }\n    if (action !== undefined) {\n      taskDefinition.setAction(action);\n    }\n    if (scope === undefined) {\n      this._tasks[task] = taskDefinition;\n    } else {\n      const scopeDefinition = this._scopes[scope];\n      (0, errors_1.assertHardhatInvariant)(scopeDefinition !== undefined, \"It shouldn't be possible to create a task in a scope that doesn't exist\");\n      scopeDefinition.tasks[task] = taskDefinition;\n    }\n    return taskDefinition;\n  }\n}\nexports.TasksDSL = TasksDSL;","map":{"version":3,"names":["errors_1","require","errors_list_1","task_definitions_1","util_1","TasksDSL","constructor","internalTask","subtask","_tasks","_scopes","task","name","descriptionOrAction","action","_addTask","scope","description","undefined","HardhatError","ERRORS","TASK_DEFINITIONS","TASK_SCOPE_CLASH","scopeName","scopeDefinition","setDescription","SimpleScopeDefinition","taskName","subtaskName","getTaskDefinitions","getScopesDefinitions","getTaskDefinition","tasks","taskIdentifier","isSubtask","parseTaskIdentifier","SCOPE_TASK_CLASH","parentTaskDefinition","taskDefinition","OverriddenTaskDefinition","SimpleTaskDefinition","Function","setAction","assertHardhatInvariant","exports"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\internal\\core\\tasks\\dsl.ts"],"sourcesContent":["import {\n  ActionType,\n  ScopeDefinition,\n  ScopesMap,\n  TaskArguments,\n  TaskDefinition,\n  TaskIdentifier,\n  TasksMap,\n} from \"../../../types\";\nimport { HardhatError, assertHardhatInvariant } from \"../errors\";\nimport { ERRORS } from \"../errors-list\";\n\nimport {\n  OverriddenTaskDefinition,\n  SimpleScopeDefinition,\n  SimpleTaskDefinition,\n} from \"./task-definitions\";\nimport { parseTaskIdentifier } from \"./util\";\n\n/**\n * This class defines the DSL used in Hardhat config files\n * for creating and overriding tasks.\n */\nexport class TasksDSL {\n  public readonly internalTask = this.subtask;\n\n  private readonly _tasks: TasksMap = {};\n  private readonly _scopes: ScopesMap = {};\n\n  /**\n   * Creates a task, overriding any previous task with the same name.\n   *\n   * @remarks The action must await every async call made within it.\n   *\n   * @param name The task's name.\n   * @param description The task's description.\n   * @param action The task's action.\n   * @returns A task definition.\n   */\n  public task<TaskArgumentsT extends TaskArguments>(\n    name: string,\n    description?: string,\n    action?: ActionType<TaskArgumentsT>\n  ): TaskDefinition;\n\n  /**\n   * Creates a task without description, overriding any previous task\n   * with the same name.\n   *\n   * @remarks The action must await every async call made within it.\n   *\n   * @param name The task's name.\n   * @param action The task's action.\n   *\n   * @returns A task definition.\n   */\n  public task<TaskArgumentsT extends TaskArguments>(\n    name: string,\n    action: ActionType<TaskArgumentsT>\n  ): TaskDefinition;\n\n  public task<TaskArgumentsT extends TaskArguments>(\n    name: string,\n    descriptionOrAction?: string | ActionType<TaskArgumentsT>,\n    action?: ActionType<TaskArgumentsT>\n  ): TaskDefinition {\n    // if this function is updated, update the corresponding callback\n    // passed to `new SimpleScopeDefinition`\n    return this._addTask(name, descriptionOrAction, action, false);\n  }\n\n  /**\n   * Creates a subtask, overriding any previous task with the same name.\n   *\n   * @remarks The subtasks won't be displayed in the CLI help messages.\n   * @remarks The action must await every async call made within it.\n   *\n   * @param name The task's name.\n   * @param description The task's description.\n   * @param action The task's action.\n   * @returns A task definition.\n   */\n  public subtask<TaskArgumentsT extends TaskArguments>(\n    name: string,\n    description?: string,\n    action?: ActionType<TaskArgumentsT>\n  ): TaskDefinition;\n\n  /**\n   * Creates a subtask without description, overriding any previous\n   * task with the same name.\n   *\n   * @remarks The subtasks won't be displayed in the CLI help messages.\n   * @remarks The action must await every async call made within it.\n   *\n   * @param name The task's name.\n   * @param action The task's action.\n   * @returns A task definition.\n   */\n  public subtask<TaskArgumentsT extends TaskArguments>(\n    name: string,\n    action: ActionType<TaskArgumentsT>\n  ): TaskDefinition;\n  public subtask<TaskArgumentsT extends TaskArguments>(\n    name: string,\n    descriptionOrAction?: string | ActionType<TaskArgumentsT>,\n    action?: ActionType<TaskArgumentsT>\n  ): TaskDefinition {\n    // if this function is updated, update the corresponding callback\n    // passed to `new SimpleScopeDefinition`\n    return this._addTask(name, descriptionOrAction, action, true);\n  }\n\n  public scope(name: string, description?: string): ScopeDefinition {\n    if (this._tasks[name] !== undefined) {\n      throw new HardhatError(ERRORS.TASK_DEFINITIONS.TASK_SCOPE_CLASH, {\n        scopeName: name,\n      });\n    }\n\n    const scopeDefinition = this._scopes[name];\n\n    if (scopeDefinition !== undefined) {\n      // if the scope already exists, the only thing we might\n      // do is to update its description\n      if (description !== undefined) {\n        scopeDefinition.setDescription(description);\n      }\n\n      return scopeDefinition;\n    }\n\n    const scope = new SimpleScopeDefinition(\n      name,\n      description,\n      (taskName, descriptionOrAction, action) =>\n        // if this function is updated, update the dsl.task function too\n        this._addTask(\n          { scope: name, task: taskName },\n          descriptionOrAction,\n          action,\n          false\n        ),\n      (subtaskName, descriptionOrAction, action) =>\n        // if this function is updated, update the dsl.subtask function too\n        this._addTask(\n          { scope: name, task: subtaskName },\n          descriptionOrAction,\n          action,\n          true\n        )\n    );\n\n    this._scopes[name] = scope;\n\n    return scope;\n  }\n\n  /**\n   * Retrieves the task definitions.\n   *\n   * @returns The tasks container.\n   */\n  public getTaskDefinitions(): TasksMap {\n    return this._tasks;\n  }\n\n  /**\n   * Retrieves the scoped task definitions.\n   *\n   * @returns The scoped tasks container.\n   */\n  public getScopesDefinitions(): ScopesMap {\n    return this._scopes;\n  }\n\n  public getTaskDefinition(\n    scope: string | undefined,\n    name: string\n  ): TaskDefinition | undefined {\n    if (scope === undefined) {\n      return this._tasks[name];\n    } else {\n      return this._scopes[scope]?.tasks?.[name];\n    }\n  }\n\n  private _addTask<TaskArgumentsT extends TaskArguments>(\n    taskIdentifier: TaskIdentifier,\n    descriptionOrAction?: string | ActionType<TaskArgumentsT>,\n    action?: ActionType<TaskArgumentsT>,\n    isSubtask?: boolean\n  ) {\n    const { scope, task } = parseTaskIdentifier(taskIdentifier);\n\n    if (scope === undefined && this._scopes[task] !== undefined) {\n      throw new HardhatError(ERRORS.TASK_DEFINITIONS.SCOPE_TASK_CLASH, {\n        taskName: task,\n      });\n    }\n\n    const parentTaskDefinition = this.getTaskDefinition(scope, task);\n\n    let taskDefinition: TaskDefinition;\n\n    if (parentTaskDefinition !== undefined) {\n      taskDefinition = new OverriddenTaskDefinition(\n        parentTaskDefinition,\n        isSubtask\n      );\n    } else {\n      taskDefinition = new SimpleTaskDefinition(taskIdentifier, isSubtask);\n    }\n\n    if (descriptionOrAction instanceof Function) {\n      action = descriptionOrAction;\n      descriptionOrAction = undefined;\n    }\n\n    if (descriptionOrAction !== undefined) {\n      taskDefinition.setDescription(descriptionOrAction);\n    }\n\n    if (action !== undefined) {\n      taskDefinition.setAction(action);\n    }\n\n    if (scope === undefined) {\n      this._tasks[task] = taskDefinition;\n    } else {\n      const scopeDefinition = this._scopes[scope];\n      assertHardhatInvariant(\n        scopeDefinition !== undefined,\n        \"It shouldn't be possible to create a task in a scope that doesn't exist\"\n      );\n      scopeDefinition.tasks[task] = taskDefinition;\n    }\n\n    return taskDefinition;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}