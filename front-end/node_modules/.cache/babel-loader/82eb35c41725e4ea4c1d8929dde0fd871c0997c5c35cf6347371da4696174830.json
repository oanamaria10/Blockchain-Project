{"ast":null,"code":"import * as HAMT from \"./lib.js\";\nimport * as Node from \"./node.js\";\nimport * as Path from \"./path/InfiniteUint8Array.js\";\nexport * from \"./api.js\";\nexport { Path };\nexport const bitWidth = 8;\nexport const config = {\n  bitWidth,\n  Path: Path.configure({\n    bitWidth\n  })\n};\n\n/**\n * @param {HAMT.PersistentHashMap} hamt\n */\nexport const tableSize = hamt => Math.pow(2, hamt.config.bitWidth);\n\n/**\n * @template [T=unknown]\n * @template {string} [K=string]\n * @template {HAMT.Config} [C=HAMT.Config<Uint8Array>]\n * @param {Partial<C>} options\n * @returns {HAMT.PersistentHashMap<T, K, C>}\n */\nexport const empty = (options = ( /** @type {C} */config)) => HAMT.empty(options);\n\n/**\n * @template [T=unknown]\n * @template {string} [K=string]\n * @template {HAMT.Config} [C=HAMT.Config<Uint8Array>]\n * @param {Partial<C>} options\n * @returns {HAMT.HashMapBuilder<T, K, C>}\n */\nexport const builder = (options = ( /** @type {C} */config)) => HAMT.builder(options);\n\n/**\n * @template [V=unknown]\n * @template {string} [K=string]\n * @template {HAMT.Config} [C=HAMT.Config<Uint8Array>]\n * @param {Iterable<[K, V]>} entries\n * @param {Partial<C>} options\n */\nexport const from = (entries, options = ( /** @type {C} */config)) => HAMT.from(entries, options);\n\n/**\n * @template T\n * @template {string} K\n * @template Bits, Bitmap\n * @param {HAMT.BitmapIndexedNode<T, K, HAMT.Config<Bits, Bitmap>>} hamt\n */\nexport const bitField = ({\n  datamap,\n  nodemap,\n  config: {\n    BitField\n  }\n}) => withoutLeadingZeros(BitField.toBytes(BitField.or(datamap, nodemap)));\n\n/**\n * @param {Uint8Array} bytes\n */\nconst withoutLeadingZeros = bytes => {\n  let offset = 0;\n  while (offset < bytes.byteLength) {\n    if (bytes[offset] !== 0) {\n      return bytes.subarray(offset);\n    }\n    offset += 1;\n  }\n  return bytes.subarray(offset);\n};\n\n/**\n * Maps HAMT node into IPFS UnixFS compatible format.\n *\n * @template T\n * @template {string} K\n * @template {HAMT.Config} C\n * @param {HAMT.BitmapIndexedNode<T, K, C>} root\n * @returns {IterableIterator<{prefix:string, key:K, value:T, node?:void}|{prefix:string, node:HAMT.BitmapIndexedNode<T, K, C>}>}\n */\nexport const iterate = function* (root) {\n  const {\n    config,\n    datamap,\n    nodemap\n  } = root;\n  const {\n    BitField: bitfield\n  } = config;\n  const size = bitfield.size(datamap);\n  let bitOffset = 0;\n  let dataCount = 0;\n  while (bitOffset < size) {\n    const prefix = bitOffset.toString(16).toUpperCase().padStart(2, \"0\");\n    if (bitfield.get(datamap, bitOffset)) {\n      const key = Node.keyAt(root, dataCount);\n      yield {\n        prefix,\n        key,\n        value: Node.valueAt(root, dataCount)\n      };\n      dataCount++;\n    } else if (bitfield.get(nodemap, bitOffset)) {\n      yield {\n        prefix,\n        // UnixFS never contains hash collision nodes because it uses\n        // inifinite hashes\n        node: ( /** @type {HAMT.BitmapIndexedNode<T, K, C>} */\n        Node.resolveNode(root, bitOffset))\n      };\n    }\n    bitOffset++;\n  }\n};","map":{"version":3,"names":["HAMT","Node","Path","bitWidth","config","configure","tableSize","hamt","Math","pow","empty","options","builder","from","entries","bitField","datamap","nodemap","BitField","withoutLeadingZeros","toBytes","or","bytes","offset","byteLength","subarray","iterate","root","bitfield","size","bitOffset","dataCount","prefix","toString","toUpperCase","padStart","get","key","keyAt","value","valueAt","node","resolveNode"],"sources":["C:/FACULTATE/Proiect/node_modules/@perma/map/src/unixfs.js"],"sourcesContent":["import * as HAMT from \"./lib.js\"\nimport * as Node from \"./node.js\"\nimport * as Path from \"./path/InfiniteUint8Array.js\"\n\nexport * from \"./api.js\"\n\nexport { Path }\n\nexport const bitWidth = 8\nexport const config = {\n  bitWidth,\n  Path: Path.configure({ bitWidth }),\n}\n\n/**\n * @param {HAMT.PersistentHashMap} hamt\n */\nexport const tableSize = hamt => Math.pow(2, hamt.config.bitWidth)\n\n/**\n * @template [T=unknown]\n * @template {string} [K=string]\n * @template {HAMT.Config} [C=HAMT.Config<Uint8Array>]\n * @param {Partial<C>} options\n * @returns {HAMT.PersistentHashMap<T, K, C>}\n */\nexport const empty = (options = /** @type {C} */ (config)) =>\n  HAMT.empty(options)\n\n/**\n * @template [T=unknown]\n * @template {string} [K=string]\n * @template {HAMT.Config} [C=HAMT.Config<Uint8Array>]\n * @param {Partial<C>} options\n * @returns {HAMT.HashMapBuilder<T, K, C>}\n */\nexport const builder = (options = /** @type {C} */ (config)) =>\n  HAMT.builder(options)\n\n/**\n * @template [V=unknown]\n * @template {string} [K=string]\n * @template {HAMT.Config} [C=HAMT.Config<Uint8Array>]\n * @param {Iterable<[K, V]>} entries\n * @param {Partial<C>} options\n */\nexport const from = (entries, options = /** @type {C} */ (config)) =>\n  HAMT.from(entries, options)\n\n/**\n * @template T\n * @template {string} K\n * @template Bits, Bitmap\n * @param {HAMT.BitmapIndexedNode<T, K, HAMT.Config<Bits, Bitmap>>} hamt\n */\nexport const bitField = ({ datamap, nodemap, config: { BitField } }) =>\n  withoutLeadingZeros(BitField.toBytes(BitField.or(datamap, nodemap)))\n\n/**\n * @param {Uint8Array} bytes\n */\nconst withoutLeadingZeros = bytes => {\n  let offset = 0\n  while (offset < bytes.byteLength) {\n    if (bytes[offset] !== 0) {\n      return bytes.subarray(offset)\n    }\n    offset += 1\n  }\n  return bytes.subarray(offset)\n}\n\n/**\n * Maps HAMT node into IPFS UnixFS compatible format.\n *\n * @template T\n * @template {string} K\n * @template {HAMT.Config} C\n * @param {HAMT.BitmapIndexedNode<T, K, C>} root\n * @returns {IterableIterator<{prefix:string, key:K, value:T, node?:void}|{prefix:string, node:HAMT.BitmapIndexedNode<T, K, C>}>}\n */\nexport const iterate = function* (root) {\n  const { config, datamap, nodemap } = root\n  const { BitField: bitfield } = config\n  const size = bitfield.size(datamap)\n  let bitOffset = 0\n  let dataCount = 0\n  while (bitOffset < size) {\n    const prefix = bitOffset.toString(16).toUpperCase().padStart(2, \"0\")\n    if (bitfield.get(datamap, bitOffset)) {\n      const key = Node.keyAt(root, dataCount)\n      yield {\n        prefix,\n        key,\n        value: Node.valueAt(root, dataCount),\n      }\n      dataCount++\n    } else if (bitfield.get(nodemap, bitOffset)) {\n      yield {\n        prefix,\n        // UnixFS never contains hash collision nodes because it uses\n        // inifinite hashes\n        node: /** @type {HAMT.BitmapIndexedNode<T, K, C>} */ (\n          Node.resolveNode(root, bitOffset)\n        ),\n      }\n    }\n    bitOffset++\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}