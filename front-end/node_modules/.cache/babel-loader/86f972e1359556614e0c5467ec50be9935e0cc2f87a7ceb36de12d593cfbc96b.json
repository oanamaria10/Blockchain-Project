{"ast":null,"code":"import * as UCAN from \"../ucan.js\";\nimport * as UTF8 from \"../utf8.js\";\nimport { parse } from \"../parser.js\";\nimport { code } from \"multiformats/codecs/raw\";\nimport { View } from \"../view.js\";\nexport { code };\nexport const name = \"dag-ucan\";\n\n/**\n * Creates a UCAN view from the underlying data model. Please note that this\n * function does no verification of the model and it is callers responsibility\n * to ensure that:\n *\n * 1. Data model is correct contains all the field etc...\n * 2. Payload of the signature will match paylodad when model is serialized\n *    with DAG-JSON.\n *\n * In other words you should never use this function unless you've parsed or\n * decoded a valid UCAN and want to wrap it into a view.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.FromJWT<C>} model\n * @returns {UCAN.View<C>}\n */\nexport const from = model => new JWTView(model);\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.ByteView<UCAN.FromJWT<C>>} bytes\n * @returns {UCAN.View<C>}\n */\nexport const decode = bytes => {\n  const jwt = /** @type {UCAN.JWT<C>} */UTF8.decode(bytes);\n  return new JWTView({\n    ...parse(jwt),\n    jwt\n  });\n};\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.FromJWT<C>} model\n * @returns {UCAN.ByteView<UCAN.UCAN<C>>}\n */\nexport const encode = ({\n  jwt\n}) => UTF8.encode(jwt);\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.FromJWT<C>} model\n * @returns {UCAN.JWT<C>}\n */\nexport const format = ({\n  jwt\n}) => jwt;\n\n/**\n * @template {UCAN.Capabilities} C\n * @extends {View<C>}\n */\nclass JWTView extends View {\n  /**\n   * @param {UCAN.FromJWT<C>} model\n   */\n  constructor(model) {\n    super(model);\n    this.model = model;\n  }\n  get code() {\n    return code;\n  }\n  format() {\n    return format(this.model);\n  }\n  encode() {\n    return encode(this.model);\n  }\n}","map":{"version":3,"names":["UCAN","UTF8","parse","code","View","name","from","model","JWTView","decode","bytes","jwt","encode","format","constructor"],"sources":["C:/FACULTATE/Proiect/node_modules/@ipld/dag-ucan/src/codec/jwt.js"],"sourcesContent":["import * as UCAN from \"../ucan.js\"\nimport * as UTF8 from \"../utf8.js\"\nimport { parse } from \"../parser.js\"\nimport { code } from \"multiformats/codecs/raw\"\nimport { View } from \"../view.js\"\n\nexport { code }\nexport const name = \"dag-ucan\"\n\n/**\n * Creates a UCAN view from the underlying data model. Please note that this\n * function does no verification of the model and it is callers responsibility\n * to ensure that:\n *\n * 1. Data model is correct contains all the field etc...\n * 2. Payload of the signature will match paylodad when model is serialized\n *    with DAG-JSON.\n *\n * In other words you should never use this function unless you've parsed or\n * decoded a valid UCAN and want to wrap it into a view.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.FromJWT<C>} model\n * @returns {UCAN.View<C>}\n */\nexport const from = model => new JWTView(model)\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.ByteView<UCAN.FromJWT<C>>} bytes\n * @returns {UCAN.View<C>}\n */\nexport const decode = bytes => {\n  const jwt = /** @type {UCAN.JWT<C>} */ (UTF8.decode(bytes))\n\n  return new JWTView({ ...parse(jwt), jwt })\n}\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.FromJWT<C>} model\n * @returns {UCAN.ByteView<UCAN.UCAN<C>>}\n */\nexport const encode = ({ jwt }) => UTF8.encode(jwt)\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.FromJWT<C>} model\n * @returns {UCAN.JWT<C>}\n */\nexport const format = ({ jwt }) => jwt\n\n/**\n * @template {UCAN.Capabilities} C\n * @extends {View<C>}\n */\nclass JWTView extends View {\n  /**\n   * @param {UCAN.FromJWT<C>} model\n   */\n  constructor(model) {\n    super(model)\n    this.model = model\n  }\n  get code() {\n    return code\n  }\n  format() {\n    return format(this.model)\n  }\n  encode() {\n    return encode(this.model)\n  }\n}\n"],"mappings":"AAAA,OAAO,KAAKA,IAAI,MAAM,YAAY;AAClC,OAAO,KAAKC,IAAI,MAAM,YAAY;AAClC,SAASC,KAAK,QAAQ,cAAc;AACpC,SAASC,IAAI,QAAQ,yBAAyB;AAC9C,SAASC,IAAI,QAAQ,YAAY;AAEjC,SAASD,IAAI;AACb,OAAO,MAAME,IAAI,GAAG,UAAU;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,IAAI,GAAGC,KAAK,IAAI,IAAIC,OAAO,CAACD,KAAK,CAAC;;AAE/C;AACA;AACA;AACA;AACA;AACA,OAAO,MAAME,MAAM,GAAGC,KAAK,IAAI;EAC7B,MAAMC,GAAG,GAAG,0BAA4BV,IAAI,CAACQ,MAAM,CAACC,KAAK,CAAE;EAE3D,OAAO,IAAIF,OAAO,CAAC;IAAE,GAAGN,KAAK,CAACS,GAAG,CAAC;IAAEA;EAAI,CAAC,CAAC;AAC5C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,MAAM,GAAGA,CAAC;EAAED;AAAI,CAAC,KAAKV,IAAI,CAACW,MAAM,CAACD,GAAG,CAAC;;AAEnD;AACA;AACA;AACA;AACA;AACA,OAAO,MAAME,MAAM,GAAGA,CAAC;EAAEF;AAAI,CAAC,KAAKA,GAAG;;AAEtC;AACA;AACA;AACA;AACA,MAAMH,OAAO,SAASJ,IAAI,CAAC;EACzB;AACF;AACA;EACEU,WAAWA,CAACP,KAAK,EAAE;IACjB,KAAK,CAACA,KAAK,CAAC;IACZ,IAAI,CAACA,KAAK,GAAGA,KAAK;EACpB;EACA,IAAIJ,IAAIA,CAAA,EAAG;IACT,OAAOA,IAAI;EACb;EACAU,MAAMA,CAAA,EAAG;IACP,OAAOA,MAAM,CAAC,IAAI,CAACN,KAAK,CAAC;EAC3B;EACAK,MAAMA,CAAA,EAAG;IACP,OAAOA,MAAM,CAAC,IAAI,CAACL,KAAK,CAAC;EAC3B;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}