{"ast":null,"code":"import * as API from '@ucanto/interface';\nimport { entries, combine, intersection } from './util.js';\nimport { EscalatedCapability, MalformedCapability, UnknownCapability, DelegationError as MatchError } from './error.js';\nimport { invoke, delegate, Schema } from '@ucanto/core';\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @typedef {{\n * can: A\n * with: API.Reader<R, API.Resource, API.Failure>\n * nb?: Schema.MapRepresentation<C, unknown>\n * derives?: (claim: {can:A, with: R, nb: C}, proof:{can:A, with:R, nb:C}) => API.Result<{}, API.Failure>\n * }} Descriptor\n */\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} [C={}]\n * @param {Descriptor<A, R, C>} descriptor\n \n * @returns {API.TheCapabilityParser<API.CapabilityMatch<A, R, C>>}\n */\nexport const capability = ({\n  derives = defaultDerives,\n  nb = defaultNBSchema,\n  ...etc\n}) => new Capability({\n  derives,\n  nb,\n  ...etc\n});\nconst defaultNBSchema = /** @type {Schema.MapRepresentation<any>} */\nSchema.struct({});\n\n/**\n * @template {API.Match} M\n * @template {API.Match} W\n * @param {API.Matcher<M>} left\n * @param {API.Matcher<W>} right\n * @returns {API.CapabilityParser<M|W>}\n */\nexport const or = (left, right) => new Or(left, right);\n\n/**\n * @template {API.MatchSelector<API.Match>[]} Selectors\n * @param {Selectors} selectors\n * @returns {API.CapabilitiesParser<API.InferMembers<Selectors>>}\n */\nexport const and = (...selectors) => new And(selectors);\n\n/**\n * @template {API.Match} M\n * @template {API.ParsedCapability} T\n * @param {object} source\n * @param {API.MatchSelector<M>} source.from\n * @param {API.TheCapabilityParser<API.DirectMatch<T>>} source.to\n * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} source.derives\n \n * @returns {API.TheCapabilityParser<API.DerivedMatch<T, M>>}\n */\nexport const derive = ({\n  from,\n  to,\n  derives\n}) => new Derive(from, to, derives);\n\n/**\n * @template {API.Match} M\n * @implements {API.View<M>}\n */\nclass View {\n  /**\n   * @param {API.Source} source\n   * @returns {API.MatchResult<M>}\n   */\n  /* c8 ignore next 3 */\n  match(source) {\n    return {\n      error: new UnknownCapability(source.capability)\n    };\n  }\n\n  /**\n   * @param {API.Source[]} capabilities\n   * @returns {API.Select<M>}\n   */\n  select(capabilities) {\n    return select(this, capabilities);\n  }\n\n  /**\n   * @template {API.ParsedCapability} U\n   * @param {object} source\n   * @param {API.TheCapabilityParser<API.DirectMatch<U>>} source.to\n   * @param {API.Derives<U, API.InferDeriveProof<M['value']>>} source.derives\n   * @returns {API.TheCapabilityParser<API.DerivedMatch<U, M>>}\n   */\n  derive({\n    derives,\n    to\n  }) {\n    return derive({\n      derives,\n      to,\n      from: this\n    });\n  }\n}\n\n/**\n * @template {API.Match} M\n * @implements {API.CapabilityParser<M>}\n * @extends {View<M>}\n */\nclass Unit extends View {\n  /**\n   * @template {API.Match} W\n   * @param {API.MatchSelector<W>} other\n   * @returns {API.CapabilityParser<M | W>}\n   */\n  or(other) {\n    return or(this, other);\n  }\n\n  /**\n   * @template {API.Match} W\n   * @param {API.CapabilityParser<W>} other\n   * @returns {API.CapabilitiesParser<[M, W]>}\n   */\n  and(other) {\n    return and( /** @type {API.CapabilityParser<M>} */this, other);\n  }\n}\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @implements {API.TheCapabilityParser<API.DirectMatch<API.ParsedCapability<A, R, C>>>}\n * @extends {Unit<API.DirectMatch<API.ParsedCapability<A, R, C>>>}\n */\nclass Capability extends Unit {\n  /**\n   * @param {Required<Descriptor<A, R, C>>} descriptor\n   */\n  constructor(descriptor) {\n    super();\n    this.descriptor = descriptor;\n    this.schema = Schema.struct({\n      can: Schema.literal(descriptor.can),\n      with: descriptor.with,\n      nb: descriptor.nb\n    });\n  }\n\n  /**\n   * @param {API.InferCreateOptions<R, C>} options\n   */\n  create(options) {\n    const {\n      descriptor,\n      can\n    } = this;\n    const decoders = descriptor.nb;\n    const data = /** @type {C} */options.nb || {};\n    const resource = descriptor.with.read(options.with);\n    if (resource.error) {\n      throw Object.assign(new Error(`Invalid 'with' - ${resource.error.message}`), {\n        cause: resource\n      });\n    }\n    const nb = descriptor.nb.read(data);\n    if (nb.error) {\n      throw Object.assign(new Error(`Invalid 'nb' - ${nb.error.message}`), {\n        cause: nb\n      });\n    }\n    return createCapability({\n      can,\n      with: resource.ok,\n      nb: nb.ok\n    });\n  }\n\n  /**\n   * @param {API.InferInvokeOptions<R, C>} options\n   */\n  invoke({\n    with: with_,\n    nb,\n    ...options\n  }) {\n    return invoke({\n      ...options,\n      capability: this.create( /** @type {API.InferCreateOptions<R, C>} */\n      {\n        with: with_,\n        nb\n      })\n    });\n  }\n\n  /**\n   * @param {API.InferDelegationOptions<R, C>} options\n   * @returns {Promise<API.Delegation<[API.InferDelegatedCapability<API.ParsedCapability<A, R, C>>]>>}\n   */\n  async delegate({\n    nb: input = {},\n    with: with_,\n    ...options\n  }) {\n    const {\n      descriptor,\n      can\n    } = this;\n    const readers = descriptor.nb;\n    const resource = descriptor.with.read(with_);\n    if (resource.error) {\n      throw Object.assign(new Error(`Invalid 'with' - ${resource.error.message}`), {\n        cause: resource\n      });\n    }\n    const nb = descriptor.nb.partial().read(input);\n    if (nb.error) {\n      throw Object.assign(new Error(`Invalid 'nb' - ${nb.error.message}`), {\n        cause: nb\n      });\n    }\n    return delegate({\n      capabilities: [createCapability({\n        can,\n        with: resource.ok,\n        nb: nb.ok\n      })],\n      ...options\n    });\n  }\n  get can() {\n    return this.descriptor.can;\n  }\n\n  /**\n   * @param {API.Source} source\n   * @returns {API.MatchResult<API.DirectMatch<API.ParsedCapability<A, R, C>>>}\n   */\n  match(source) {\n    const result = parseCapability(this.descriptor, source);\n    return result.error ? result : {\n      ok: new Match(source, result.ok, this.descriptor)\n    };\n  }\n  toString() {\n    return JSON.stringify({\n      can: this.descriptor.can\n    });\n  }\n}\n\n/**\n * Normalizes capability by removing empty nb field.\n *\n * @template {API.ParsedCapability} T\n * @param {T} source\n */\n\nconst createCapability = ({\n  can,\n  with: with_,\n  nb\n}) => ( /** @type {API.InferCapability<T>} */{\n  can,\n  with: with_,\n  ...(isEmpty(nb) ? {} : {\n    nb\n  })\n});\n\n/**\n * @param {object} object\n * @returns {object is {}}\n */\nconst isEmpty = object => {\n  for (const _ in object) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * @template {API.Match} M\n * @template {API.Match} W\n * @implements {API.CapabilityParser<M|W>}\n * @extends {Unit<M|W>}\n */\nclass Or extends Unit {\n  /**\n   * @param {API.Matcher<M>} left\n   * @param {API.Matcher<W>} right\n   */\n  constructor(left, right) {\n    super();\n    this.left = left;\n    this.right = right;\n  }\n\n  /**\n   * @param {API.Source} capability\n   * @return {API.MatchResult<M|W>}\n   */\n  match(capability) {\n    const left = this.left.match(capability);\n    if (left.error) {\n      const right = this.right.match(capability);\n      if (right.error) {\n        return right.error.name === 'MalformedCapability' ?\n        //\n        right :\n        //\n        left;\n      } else {\n        return right;\n      }\n    } else {\n      return left;\n    }\n  }\n  toString() {\n    return `${this.left.toString()}|${this.right.toString()}`;\n  }\n}\n\n/**\n * @template {API.MatchSelector<API.Match>[]} Selectors\n * @implements {API.CapabilitiesParser<API.InferMembers<Selectors>>}\n * @extends {View<API.Amplify<API.InferMembers<Selectors>>>}\n */\nclass And extends View {\n  /**\n   * @param {Selectors} selectors\n   */\n  constructor(selectors) {\n    super();\n    this.selectors = selectors;\n  }\n  /**\n   * @param {API.Source} capability\n   * @returns {API.MatchResult<API.Amplify<API.InferMembers<Selectors>>>}\n   */\n  match(capability) {\n    const group = [];\n    for (const selector of this.selectors) {\n      const result = selector.match(capability);\n      if (result.error) {\n        return result;\n      } else {\n        group.push(result.ok);\n      }\n    }\n    return {\n      ok: new AndMatch( /** @type {API.InferMembers<Selectors>} */group)\n    };\n  }\n\n  /**\n   * @param {API.Source[]} capabilities\n   */\n  select(capabilities) {\n    return selectGroup(this, capabilities);\n  }\n  /**\n   * @template E\n   * @template {API.Match} X\n   * @param {API.MatchSelector<API.Match<E, X>>} other\n   * @returns {API.CapabilitiesParser<[...API.InferMembers<Selectors>, API.Match<E, X>]>}\n   */\n  and(other) {\n    return new And([...this.selectors, other]);\n  }\n  toString() {\n    return `[${this.selectors.map(String).join(', ')}]`;\n  }\n}\n\n/**\n * @template {API.ParsedCapability} T\n * @template {API.Match} M\n * @implements {API.TheCapabilityParser<API.DerivedMatch<T, M>>}\n * @extends {Unit<API.DerivedMatch<T, M>>}\n */\n\nclass Derive extends Unit {\n  /**\n   * @param {API.MatchSelector<M>} from\n   * @param {API.TheCapabilityParser<API.DirectMatch<T>>} to\n   * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} derives\n   */\n  constructor(from, to, derives) {\n    super();\n    this.from = from;\n    this.to = to;\n    this.derives = derives;\n  }\n\n  /**\n   * @type {typeof this.to['create']}\n   */\n  create(options) {\n    return this.to.create(options);\n  }\n  /**\n   * @type {typeof this.to['invoke']}\n   */\n  invoke(options) {\n    return this.to.invoke(options);\n  }\n  /**\n   * @type {typeof this.to['delegate']}\n   */\n  delegate(options) {\n    return this.to.delegate(options);\n  }\n  get can() {\n    return this.to.can;\n  }\n  /**\n   * @param {API.Source} capability\n   * @returns {API.MatchResult<API.DerivedMatch<T, M>>}\n   */\n  match(capability) {\n    const match = this.to.match(capability);\n    if (match.error) {\n      return match;\n    } else {\n      return {\n        ok: new DerivedMatch(match.ok, this.from, this.derives)\n      };\n    }\n  }\n  toString() {\n    return this.to.toString();\n  }\n}\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @implements {API.DirectMatch<API.ParsedCapability<A, R, C>>}\n */\nclass Match {\n  /**\n   * @param {API.Source} source\n   * @param {API.ParsedCapability<A, R, C>} value\n   * @param {Required<Descriptor<A, R, C>>} descriptor\n   */\n  constructor(source, value, descriptor) {\n    this.source = [source];\n    this.value = value;\n    this.descriptor = descriptor;\n  }\n  get can() {\n    return this.value.can;\n  }\n  get proofs() {\n    const proofs = [this.source[0].delegation];\n    Object.defineProperties(this, {\n      proofs: {\n        value: proofs\n      }\n    });\n    return proofs;\n  }\n\n  /**\n   * @param {API.CanIssue} context\n   * @returns {API.DirectMatch<API.ParsedCapability<A, R, C>>|null}\n   */\n  prune(context) {\n    if (context.canIssue(this.value, this.source[0].delegation.issuer.did())) {\n      return null;\n    } else {\n      return this;\n    }\n  }\n\n  /**\n   * @param {API.Source[]} capabilities\n   * @returns {API.Select<API.DirectMatch<API.ParsedCapability<A, R, C>>>}\n   */\n  select(capabilities) {\n    const unknown = [];\n    const errors = [];\n    const matches = [];\n    for (const capability of capabilities) {\n      const result = resolveCapability(this.descriptor, this.value, capability);\n      if (result.ok) {\n        const claim = this.descriptor.derives(this.value, result.ok);\n        if (claim.error) {\n          errors.push(new MatchError([new EscalatedCapability(this.value, result.ok, claim.error)], this));\n        } else {\n          matches.push(new Match(capability, result.ok, this.descriptor));\n        }\n      } else {\n        switch (result.error.name) {\n          case 'UnknownCapability':\n            unknown.push(result.error.capability);\n            break;\n          case 'MalformedCapability':\n          default:\n            errors.push(new MatchError([result.error], this));\n        }\n      }\n    }\n    return {\n      matches,\n      unknown,\n      errors\n    };\n  }\n  toString() {\n    const {\n      nb\n    } = this.value;\n    return JSON.stringify({\n      can: this.descriptor.can,\n      with: this.value.with,\n      nb: nb && Object.keys(nb).length > 0 ? nb : undefined\n    });\n  }\n}\n\n/**\n * @template {API.ParsedCapability} T\n * @template {API.Match} M\n * @implements {API.DerivedMatch<T, M>}\n */\n\nclass DerivedMatch {\n  /**\n   * @param {API.DirectMatch<T>} selected\n   * @param {API.MatchSelector<M>} from\n   * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} derives\n   */\n  constructor(selected, from, derives) {\n    this.selected = selected;\n    this.from = from;\n    this.derives = derives;\n  }\n  get can() {\n    return this.value.can;\n  }\n  get source() {\n    return this.selected.source;\n  }\n  get proofs() {\n    const proofs = [];\n    for (const {\n      delegation\n    } of this.selected.source) {\n      proofs.push(delegation);\n    }\n    Object.defineProperties(this, {\n      proofs: {\n        value: proofs\n      }\n    });\n    return proofs;\n  }\n  get value() {\n    return this.selected.value;\n  }\n\n  /**\n   * @param {API.CanIssue} context\n   */\n  prune(context) {\n    const selected = /** @type {API.DirectMatch<T>|null} */\n    this.selected.prune(context);\n    return selected ? new DerivedMatch(selected, this.from, this.derives) : null;\n  }\n\n  /**\n   * @param {API.Source[]} capabilities\n   */\n  select(capabilities) {\n    const {\n      derives,\n      selected,\n      from\n    } = this;\n    const {\n      value\n    } = selected;\n    const direct = selected.select(capabilities);\n    const derived = from.select(capabilities);\n    const matches = [];\n    const errors = [];\n    for (const match of derived.matches) {\n      // If capability can not be derived it escalates\n      const result = derives(value, match.value);\n      if (result.error) {\n        errors.push(new MatchError([new EscalatedCapability(value, match.value, result.error)], this));\n      } else {\n        matches.push(match);\n      }\n    }\n    return {\n      unknown: intersection(direct.unknown, derived.unknown),\n      errors: [...errors, ...direct.errors, ...derived.errors.map(error => new MatchError([error], this))],\n      matches: [...direct.matches.map(match => new DerivedMatch(match, from, derives)), ...matches]\n    };\n  }\n  toString() {\n    return this.selected.toString();\n  }\n}\n\n/**\n * @template {API.MatchSelector<API.Match>[]} Selectors\n * @implements {API.Amplify<API.InferMembers<Selectors>>}\n */\nclass AndMatch {\n  /**\n   * @param {API.Match[]} matches\n   */\n  constructor(matches) {\n    this.matches = matches;\n  }\n  get selectors() {\n    return this.matches;\n  }\n  /**\n   * @returns {API.Source[]}\n   */\n  get source() {\n    const source = [];\n    for (const match of this.matches) {\n      source.push(...match.source);\n    }\n    Object.defineProperties(this, {\n      source: {\n        value: source\n      }\n    });\n    return source;\n  }\n\n  /**\n   * @param {API.CanIssue} context\n   */\n  prune(context) {\n    const matches = [];\n    for (const match of this.matches) {\n      const pruned = match.prune(context);\n      if (pruned) {\n        matches.push(pruned);\n      }\n    }\n    return matches.length === 0 ? null : new AndMatch(matches);\n  }\n  get proofs() {\n    const proofs = [];\n    for (const {\n      delegation\n    } of this.source) {\n      proofs.push(delegation);\n    }\n    Object.defineProperties(this, {\n      proofs: {\n        value: proofs\n      }\n    });\n    return proofs;\n  }\n  /**\n   * @type {API.InferValue<API.InferMembers<Selectors>>}\n   */\n  get value() {\n    const value = [];\n    for (const match of this.matches) {\n      value.push(match.value);\n    }\n    Object.defineProperties(this, {\n      value: {\n        value\n      }\n    });\n    return /** @type {any} */value;\n  }\n  /**\n   * @param {API.Source[]} capabilities\n   */\n  select(capabilities) {\n    return selectGroup(this, capabilities);\n  }\n  toString() {\n    return `[${this.matches.map(match => match.toString()).join(', ')}]`;\n  }\n}\n\n/**\n * Resolves ability `pattern` of the delegated capability from the ability\n * of the claimed capability. If pattern matches returns claimed ability\n * otherwise returns given `fallback`.\n *\n * @example\n * ```js\n * resolveAbility('*', 'store/add', null) // => 'store/add'\n * resolveAbility('store/*', 'store/add', null) // => 'store/add'\n * resolveAbility('store/add', 'store/add', null) // => 'store/add'\n * resolveAbility('store/', 'store/add', null) // => null\n * resolveAbility('store/a*', 'store/add', null) // => null\n * resolveAbility('store/list', 'store/add', null) // => null\n * ```\n *\n * @template {API.Ability} T\n * @template U\n * @param {string} pattern\n * @param {T} can\n * @param {U} fallback\n * @returns {T|U}\n */\nconst resolveAbility = (pattern, can, fallback) => {\n  switch (pattern) {\n    case can:\n    case '*':\n      return can;\n    default:\n      return pattern.endsWith('/*') && can.startsWith(pattern.slice(0, -1)) ? can : fallback;\n  }\n};\n\n/**\n * Resolves `source` resource of the delegated capability from the resource\n * `uri` of the claimed capability. If `source` is `\"ucan:*\"\"` or matches `uri`\n * then it returns `uri` back otherwise it returns `fallback`.\n *\n * @example\n * ```js\n * resolveResource('ucan:*', 'did:key:zAlice', null) // => 'did:key:zAlice'\n * resolveAbility('ucan:*', 'https://example.com', null) // => 'https://example.com'\n * resolveAbility('did:*', 'did:key:zAlice', null) // => null\n * resolveAbility('did:key:zAlice', 'did:key:zAlice', null) // => did:key:zAlice\n * ```\n * @template {string} T\n * @template U\n * @param {T} uri\n * @param {string} source\n * @param {U} fallback\n * @returns {T|U}\n */\nconst resolveResource = (source, uri, fallback) => {\n  switch (source) {\n    case uri:\n    case 'ucan:*':\n      return uri;\n    default:\n      return fallback;\n  }\n};\n\n/**\n * Parses capability from the `source` using a provided `parser`.\n *\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @param {Required<Descriptor<A, R, C>>} descriptor\n * @param {API.Source} source\n * @returns {API.Result<API.ParsedCapability<A, R, C>, API.InvalidCapability>}\n */\nconst parseCapability = (descriptor, source) => {\n  const {\n    delegation\n  } = source;\n  const capability = /** @type {API.Capability<A, R, C>} */source.capability;\n  if (descriptor.can !== capability.can) {\n    return {\n      error: new UnknownCapability(capability)\n    };\n  }\n  const uri = descriptor.with.read(capability.with);\n  if (uri.error) {\n    return {\n      error: new MalformedCapability(capability, uri.error)\n    };\n  }\n  const nb = descriptor.nb.read(capability.nb || {});\n  if (nb.error) {\n    return {\n      error: new MalformedCapability(capability, nb.error)\n    };\n  }\n  return {\n    ok: new CapabilityView(descriptor.can, uri.ok, nb.ok, delegation)\n  };\n};\n\n/**\n * Resolves delegated capability `source` from the `claimed` capability using\n * provided capability `parser`. It is similar to `parseCapability` except\n * `source` here is treated as capability pattern which is matched against the\n * `claimed` capability. This means we resolve `can` and `with` fields from the\n * `claimed` capability and inherit all missing `nb` fields from the claimed\n * capability.\n *\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @param {Required<Descriptor<A, R, C>>} descriptor\n * @param {API.ParsedCapability<A, R, C>} claimed\n * @param {API.Source} source\n * @returns {API.Result<API.ParsedCapability<A, R, C>, API.InvalidCapability>}\n */\n\nconst resolveCapability = (descriptor, claimed, {\n  capability,\n  delegation\n}) => {\n  const can = resolveAbility(capability.can, claimed.can, null);\n  if (can == null) {\n    return {\n      error: new UnknownCapability(capability)\n    };\n  }\n  const resource = resolveResource(capability.with, claimed.with, capability.with);\n  const uri = descriptor.with.read(resource);\n  if (uri.error) {\n    return {\n      error: new MalformedCapability(capability, uri.error)\n    };\n  }\n  const nb = descriptor.nb.read({\n    ...claimed.nb,\n    ...capability.nb\n  });\n  if (nb.error) {\n    return {\n      error: new MalformedCapability(capability, nb.error)\n    };\n  }\n  return {\n    ok: new CapabilityView(can, uri.ok, nb.ok, delegation)\n  };\n};\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template C\n */\nclass CapabilityView {\n  /**\n   * @param {A} can\n   * @param {R} with_\n   * @param {C} nb\n   * @param {API.Delegation} delegation\n   */\n  constructor(can, with_, nb, delegation) {\n    this.can = can;\n    this.with = with_;\n    this.delegation = delegation;\n    this.nb = nb;\n  }\n}\n\n/**\n * @template {API.Match} M\n * @param {API.Matcher<M>} matcher\n * @param {API.Source[]} capabilities\n * @returns {API.Select<M>}\n */\n\nconst select = (matcher, capabilities) => {\n  const unknown = [];\n  const matches = [];\n  const errors = [];\n  for (const capability of capabilities) {\n    const result = matcher.match(capability);\n    if (result.error) {\n      switch (result.error.name) {\n        case 'UnknownCapability':\n          unknown.push(result.error.capability);\n          break;\n        case 'MalformedCapability':\n        default:\n          errors.push(new MatchError([result.error], result.error.capability));\n      }\n    } else {\n      matches.push(result.ok);\n    }\n  }\n  return {\n    matches,\n    errors,\n    unknown\n  };\n};\n\n/**\n * @template {API.Selector<API.Match>[]} S\n * @param {{selectors:S}} self\n * @param {API.Source[]} capabilities\n */\n\nconst selectGroup = (self, capabilities) => {\n  let unknown;\n  const data = [];\n  const errors = [];\n  for (const selector of self.selectors) {\n    const selected = selector.select(capabilities);\n    unknown = unknown ? intersection(unknown, selected.unknown) : selected.unknown;\n    for (const error of selected.errors) {\n      errors.push(new MatchError([error], self));\n    }\n    data.push(selected.matches);\n  }\n  const matches = combine(data).map(group => new AndMatch(group));\n  return {\n    unknown: /* c8 ignore next */\n    unknown || [],\n    errors,\n    matches\n  };\n};\n\n/**\n * @template {API.ParsedCapability} T\n * @template {API.ParsedCapability} U\n * @param {T} claimed\n * @param {U} delegated\n * @return {API.Result<true, API.Failure>}\n */\nconst defaultDerives = (claimed, delegated) => {\n  if (delegated.with.endsWith('*')) {\n    if (!claimed.with.startsWith(delegated.with.slice(0, -1))) {\n      return Schema.error(`Resource ${claimed.with} does not match delegated ${delegated.with} `);\n    }\n  } else if (delegated.with !== claimed.with) {\n    return Schema.error(`Resource ${claimed.with} is not contained by ${delegated.with}`);\n  }\n\n  /* c8 ignore next 2 */\n  const caveats = delegated.nb || {};\n  const nb = claimed.nb || {};\n  const kv = entries(caveats);\n  for (const [name, value] of kv) {\n    if (nb[name] != value) {\n      return Schema.error(`${String(name)}: ${nb[name]} violates ${value}`);\n    }\n  }\n  return {\n    ok: true\n  };\n};","map":{"version":3,"names":["API","entries","combine","intersection","EscalatedCapability","MalformedCapability","UnknownCapability","DelegationError","MatchError","invoke","delegate","Schema","capability","derives","defaultDerives","nb","defaultNBSchema","etc","Capability","struct","or","left","right","Or","and","selectors","And","derive","from","to","Derive","View","match","source","error","select","capabilities","Unit","other","constructor","descriptor","schema","can","literal","with","create","options","decoders","data","resource","read","Object","assign","Error","message","cause","createCapability","ok","with_","input","readers","partial","result","parseCapability","Match","toString","JSON","stringify","isEmpty","object","_","name","group","selector","push","AndMatch","selectGroup","map","String","join","DerivedMatch","value","proofs","delegation","defineProperties","prune","context","canIssue","issuer","did","unknown","errors","matches","resolveCapability","claim","keys","length","undefined","selected","direct","derived","pruned","resolveAbility","pattern","fallback","endsWith","startsWith","slice","resolveResource","uri","CapabilityView","claimed","matcher","self","delegated","caveats","kv"],"sources":["C:/FACULTATE/Proiect/node_modules/@ucanto/validator/src/capability.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport { entries, combine, intersection } from './util.js'\nimport {\n  EscalatedCapability,\n  MalformedCapability,\n  UnknownCapability,\n  DelegationError as MatchError,\n} from './error.js'\nimport { invoke, delegate, Schema } from '@ucanto/core'\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @typedef {{\n * can: A\n * with: API.Reader<R, API.Resource, API.Failure>\n * nb?: Schema.MapRepresentation<C, unknown>\n * derives?: (claim: {can:A, with: R, nb: C}, proof:{can:A, with:R, nb:C}) => API.Result<{}, API.Failure>\n * }} Descriptor\n */\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} [C={}]\n * @param {Descriptor<A, R, C>} descriptor\n \n * @returns {API.TheCapabilityParser<API.CapabilityMatch<A, R, C>>}\n */\nexport const capability = ({\n  derives = defaultDerives,\n  nb = defaultNBSchema,\n  ...etc\n}) => new Capability({ derives, nb, ...etc })\n\nconst defaultNBSchema =\n  /** @type {Schema.MapRepresentation<any>} */\n  (Schema.struct({}))\n\n/**\n * @template {API.Match} M\n * @template {API.Match} W\n * @param {API.Matcher<M>} left\n * @param {API.Matcher<W>} right\n * @returns {API.CapabilityParser<M|W>}\n */\nexport const or = (left, right) => new Or(left, right)\n\n/**\n * @template {API.MatchSelector<API.Match>[]} Selectors\n * @param {Selectors} selectors\n * @returns {API.CapabilitiesParser<API.InferMembers<Selectors>>}\n */\nexport const and = (...selectors) => new And(selectors)\n\n/**\n * @template {API.Match} M\n * @template {API.ParsedCapability} T\n * @param {object} source\n * @param {API.MatchSelector<M>} source.from\n * @param {API.TheCapabilityParser<API.DirectMatch<T>>} source.to\n * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} source.derives\n \n * @returns {API.TheCapabilityParser<API.DerivedMatch<T, M>>}\n */\nexport const derive = ({ from, to, derives }) => new Derive(from, to, derives)\n\n/**\n * @template {API.Match} M\n * @implements {API.View<M>}\n */\nclass View {\n  /**\n   * @param {API.Source} source\n   * @returns {API.MatchResult<M>}\n   */\n  /* c8 ignore next 3 */\n  match(source) {\n    return { error: new UnknownCapability(source.capability) }\n  }\n\n  /**\n   * @param {API.Source[]} capabilities\n   * @returns {API.Select<M>}\n   */\n  select(capabilities) {\n    return select(this, capabilities)\n  }\n\n  /**\n   * @template {API.ParsedCapability} U\n   * @param {object} source\n   * @param {API.TheCapabilityParser<API.DirectMatch<U>>} source.to\n   * @param {API.Derives<U, API.InferDeriveProof<M['value']>>} source.derives\n   * @returns {API.TheCapabilityParser<API.DerivedMatch<U, M>>}\n   */\n  derive({ derives, to }) {\n    return derive({ derives, to, from: this })\n  }\n}\n\n/**\n * @template {API.Match} M\n * @implements {API.CapabilityParser<M>}\n * @extends {View<M>}\n */\nclass Unit extends View {\n  /**\n   * @template {API.Match} W\n   * @param {API.MatchSelector<W>} other\n   * @returns {API.CapabilityParser<M | W>}\n   */\n  or(other) {\n    return or(this, other)\n  }\n\n  /**\n   * @template {API.Match} W\n   * @param {API.CapabilityParser<W>} other\n   * @returns {API.CapabilitiesParser<[M, W]>}\n   */\n  and(other) {\n    return and(/** @type {API.CapabilityParser<M>} */ (this), other)\n  }\n}\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @implements {API.TheCapabilityParser<API.DirectMatch<API.ParsedCapability<A, R, C>>>}\n * @extends {Unit<API.DirectMatch<API.ParsedCapability<A, R, C>>>}\n */\nclass Capability extends Unit {\n  /**\n   * @param {Required<Descriptor<A, R, C>>} descriptor\n   */\n  constructor(descriptor) {\n    super()\n    this.descriptor = descriptor\n    this.schema = Schema.struct({\n      can: Schema.literal(descriptor.can),\n      with: descriptor.with,\n      nb: descriptor.nb,\n    })\n  }\n\n  /**\n   * @param {API.InferCreateOptions<R, C>} options\n   */\n  create(options) {\n    const { descriptor, can } = this\n    const decoders = descriptor.nb\n    const data = /** @type {C} */ (options.nb || {})\n\n    const resource = descriptor.with.read(options.with)\n    if (resource.error) {\n      throw Object.assign(\n        new Error(`Invalid 'with' - ${resource.error.message}`),\n        {\n          cause: resource,\n        }\n      )\n    }\n\n    const nb = descriptor.nb.read(data)\n    if (nb.error) {\n      throw Object.assign(new Error(`Invalid 'nb' - ${nb.error.message}`), {\n        cause: nb,\n      })\n    }\n\n    return createCapability({ can, with: resource.ok, nb: nb.ok })\n  }\n\n  /**\n   * @param {API.InferInvokeOptions<R, C>} options\n   */\n  invoke({ with: with_, nb, ...options }) {\n    return invoke({\n      ...options,\n      capability: this.create(\n        /** @type {API.InferCreateOptions<R, C>} */\n        ({ with: with_, nb })\n      ),\n    })\n  }\n\n  /**\n   * @param {API.InferDelegationOptions<R, C>} options\n   * @returns {Promise<API.Delegation<[API.InferDelegatedCapability<API.ParsedCapability<A, R, C>>]>>}\n   */\n  async delegate({ nb: input = {}, with: with_, ...options }) {\n    const { descriptor, can } = this\n    const readers = descriptor.nb\n\n    const resource = descriptor.with.read(with_)\n    if (resource.error) {\n      throw Object.assign(\n        new Error(`Invalid 'with' - ${resource.error.message}`),\n        {\n          cause: resource,\n        }\n      )\n    }\n\n    const nb = descriptor.nb.partial().read(input)\n    if (nb.error) {\n      throw Object.assign(new Error(`Invalid 'nb' - ${nb.error.message}`), {\n        cause: nb,\n      })\n    }\n\n    return delegate({\n      capabilities: [createCapability({ can, with: resource.ok, nb: nb.ok })],\n      ...options,\n    })\n  }\n\n  get can() {\n    return this.descriptor.can\n  }\n\n  /**\n   * @param {API.Source} source\n   * @returns {API.MatchResult<API.DirectMatch<API.ParsedCapability<A, R, C>>>}\n   */\n  match(source) {\n    const result = parseCapability(this.descriptor, source)\n    return result.error\n      ? result\n      : { ok: new Match(source, result.ok, this.descriptor) }\n  }\n  toString() {\n    return JSON.stringify({ can: this.descriptor.can })\n  }\n}\n\n/**\n * Normalizes capability by removing empty nb field.\n *\n * @template {API.ParsedCapability} T\n * @param {T} source\n */\n\nconst createCapability = ({ can, with: with_, nb }) =>\n  /** @type {API.InferCapability<T>} */ ({\n    can,\n    with: with_,\n    ...(isEmpty(nb) ? {} : { nb }),\n  })\n\n/**\n * @param {object} object\n * @returns {object is {}}\n */\nconst isEmpty = object => {\n  for (const _ in object) {\n    return false\n  }\n  return true\n}\n\n/**\n * @template {API.Match} M\n * @template {API.Match} W\n * @implements {API.CapabilityParser<M|W>}\n * @extends {Unit<M|W>}\n */\nclass Or extends Unit {\n  /**\n   * @param {API.Matcher<M>} left\n   * @param {API.Matcher<W>} right\n   */\n  constructor(left, right) {\n    super()\n    this.left = left\n    this.right = right\n  }\n\n  /**\n   * @param {API.Source} capability\n   * @return {API.MatchResult<M|W>}\n   */\n  match(capability) {\n    const left = this.left.match(capability)\n    if (left.error) {\n      const right = this.right.match(capability)\n      if (right.error) {\n        return right.error.name === 'MalformedCapability'\n          ? //\n            right\n          : //\n            left\n      } else {\n        return right\n      }\n    } else {\n      return left\n    }\n  }\n\n  toString() {\n    return `${this.left.toString()}|${this.right.toString()}`\n  }\n}\n\n/**\n * @template {API.MatchSelector<API.Match>[]} Selectors\n * @implements {API.CapabilitiesParser<API.InferMembers<Selectors>>}\n * @extends {View<API.Amplify<API.InferMembers<Selectors>>>}\n */\nclass And extends View {\n  /**\n   * @param {Selectors} selectors\n   */\n  constructor(selectors) {\n    super()\n    this.selectors = selectors\n  }\n  /**\n   * @param {API.Source} capability\n   * @returns {API.MatchResult<API.Amplify<API.InferMembers<Selectors>>>}\n   */\n  match(capability) {\n    const group = []\n    for (const selector of this.selectors) {\n      const result = selector.match(capability)\n      if (result.error) {\n        return result\n      } else {\n        group.push(result.ok)\n      }\n    }\n\n    return {\n      ok: new AndMatch(/** @type {API.InferMembers<Selectors>} */ (group)),\n    }\n  }\n\n  /**\n   * @param {API.Source[]} capabilities\n   */\n  select(capabilities) {\n    return selectGroup(this, capabilities)\n  }\n  /**\n   * @template E\n   * @template {API.Match} X\n   * @param {API.MatchSelector<API.Match<E, X>>} other\n   * @returns {API.CapabilitiesParser<[...API.InferMembers<Selectors>, API.Match<E, X>]>}\n   */\n  and(other) {\n    return new And([...this.selectors, other])\n  }\n  toString() {\n    return `[${this.selectors.map(String).join(', ')}]`\n  }\n}\n\n/**\n * @template {API.ParsedCapability} T\n * @template {API.Match} M\n * @implements {API.TheCapabilityParser<API.DerivedMatch<T, M>>}\n * @extends {Unit<API.DerivedMatch<T, M>>}\n */\n\nclass Derive extends Unit {\n  /**\n   * @param {API.MatchSelector<M>} from\n   * @param {API.TheCapabilityParser<API.DirectMatch<T>>} to\n   * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} derives\n   */\n  constructor(from, to, derives) {\n    super()\n    this.from = from\n    this.to = to\n    this.derives = derives\n  }\n\n  /**\n   * @type {typeof this.to['create']}\n   */\n  create(options) {\n    return this.to.create(options)\n  }\n  /**\n   * @type {typeof this.to['invoke']}\n   */\n  invoke(options) {\n    return this.to.invoke(options)\n  }\n  /**\n   * @type {typeof this.to['delegate']}\n   */\n  delegate(options) {\n    return this.to.delegate(options)\n  }\n  get can() {\n    return this.to.can\n  }\n  /**\n   * @param {API.Source} capability\n   * @returns {API.MatchResult<API.DerivedMatch<T, M>>}\n   */\n  match(capability) {\n    const match = this.to.match(capability)\n    if (match.error) {\n      return match\n    } else {\n      return { ok: new DerivedMatch(match.ok, this.from, this.derives) }\n    }\n  }\n  toString() {\n    return this.to.toString()\n  }\n}\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @implements {API.DirectMatch<API.ParsedCapability<A, R, C>>}\n */\nclass Match {\n  /**\n   * @param {API.Source} source\n   * @param {API.ParsedCapability<A, R, C>} value\n   * @param {Required<Descriptor<A, R, C>>} descriptor\n   */\n  constructor(source, value, descriptor) {\n    this.source = [source]\n    this.value = value\n    this.descriptor = descriptor\n  }\n  get can() {\n    return this.value.can\n  }\n\n  get proofs() {\n    const proofs = [this.source[0].delegation]\n    Object.defineProperties(this, {\n      proofs: { value: proofs },\n    })\n    return proofs\n  }\n\n  /**\n   * @param {API.CanIssue} context\n   * @returns {API.DirectMatch<API.ParsedCapability<A, R, C>>|null}\n   */\n  prune(context) {\n    if (context.canIssue(this.value, this.source[0].delegation.issuer.did())) {\n      return null\n    } else {\n      return this\n    }\n  }\n\n  /**\n   * @param {API.Source[]} capabilities\n   * @returns {API.Select<API.DirectMatch<API.ParsedCapability<A, R, C>>>}\n   */\n  select(capabilities) {\n    const unknown = []\n    const errors = []\n    const matches = []\n    for (const capability of capabilities) {\n      const result = resolveCapability(this.descriptor, this.value, capability)\n      if (result.ok) {\n        const claim = this.descriptor.derives(this.value, result.ok)\n        if (claim.error) {\n          errors.push(\n            new MatchError(\n              [new EscalatedCapability(this.value, result.ok, claim.error)],\n              this\n            )\n          )\n        } else {\n          matches.push(new Match(capability, result.ok, this.descriptor))\n        }\n      } else {\n        switch (result.error.name) {\n          case 'UnknownCapability':\n            unknown.push(result.error.capability)\n            break\n          case 'MalformedCapability':\n          default:\n            errors.push(new MatchError([result.error], this))\n        }\n      }\n    }\n\n    return { matches, unknown, errors }\n  }\n  toString() {\n    const { nb } = this.value\n    return JSON.stringify({\n      can: this.descriptor.can,\n      with: this.value.with,\n      nb: nb && Object.keys(nb).length > 0 ? nb : undefined,\n    })\n  }\n}\n\n/**\n * @template {API.ParsedCapability} T\n * @template {API.Match} M\n * @implements {API.DerivedMatch<T, M>}\n */\n\nclass DerivedMatch {\n  /**\n   * @param {API.DirectMatch<T>} selected\n   * @param {API.MatchSelector<M>} from\n   * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} derives\n   */\n  constructor(selected, from, derives) {\n    this.selected = selected\n    this.from = from\n    this.derives = derives\n  }\n  get can() {\n    return this.value.can\n  }\n  get source() {\n    return this.selected.source\n  }\n  get proofs() {\n    const proofs = []\n    for (const { delegation } of this.selected.source) {\n      proofs.push(delegation)\n    }\n    Object.defineProperties(this, { proofs: { value: proofs } })\n    return proofs\n  }\n  get value() {\n    return this.selected.value\n  }\n\n  /**\n   * @param {API.CanIssue} context\n   */\n  prune(context) {\n    const selected =\n      /** @type {API.DirectMatch<T>|null} */\n      (this.selected.prune(context))\n    return selected ? new DerivedMatch(selected, this.from, this.derives) : null\n  }\n\n  /**\n   * @param {API.Source[]} capabilities\n   */\n  select(capabilities) {\n    const { derives, selected, from } = this\n    const { value } = selected\n\n    const direct = selected.select(capabilities)\n\n    const derived = from.select(capabilities)\n    const matches = []\n    const errors = []\n    for (const match of derived.matches) {\n      // If capability can not be derived it escalates\n      const result = derives(value, match.value)\n      if (result.error) {\n        errors.push(\n          new MatchError(\n            [new EscalatedCapability(value, match.value, result.error)],\n            this\n          )\n        )\n      } else {\n        matches.push(match)\n      }\n    }\n\n    return {\n      unknown: intersection(direct.unknown, derived.unknown),\n      errors: [\n        ...errors,\n        ...direct.errors,\n        ...derived.errors.map(error => new MatchError([error], this)),\n      ],\n      matches: [\n        ...direct.matches.map(match => new DerivedMatch(match, from, derives)),\n        ...matches,\n      ],\n    }\n  }\n\n  toString() {\n    return this.selected.toString()\n  }\n}\n\n/**\n * @template {API.MatchSelector<API.Match>[]} Selectors\n * @implements {API.Amplify<API.InferMembers<Selectors>>}\n */\nclass AndMatch {\n  /**\n   * @param {API.Match[]} matches\n   */\n  constructor(matches) {\n    this.matches = matches\n  }\n  get selectors() {\n    return this.matches\n  }\n  /**\n   * @returns {API.Source[]}\n   */\n  get source() {\n    const source = []\n\n    for (const match of this.matches) {\n      source.push(...match.source)\n    }\n    Object.defineProperties(this, { source: { value: source } })\n    return source\n  }\n\n  /**\n   * @param {API.CanIssue} context\n   */\n  prune(context) {\n    const matches = []\n    for (const match of this.matches) {\n      const pruned = match.prune(context)\n      if (pruned) {\n        matches.push(pruned)\n      }\n    }\n    return matches.length === 0 ? null : new AndMatch(matches)\n  }\n\n  get proofs() {\n    const proofs = []\n\n    for (const { delegation } of this.source) {\n      proofs.push(delegation)\n    }\n\n    Object.defineProperties(this, { proofs: { value: proofs } })\n    return proofs\n  }\n  /**\n   * @type {API.InferValue<API.InferMembers<Selectors>>}\n   */\n  get value() {\n    const value = []\n\n    for (const match of this.matches) {\n      value.push(match.value)\n    }\n    Object.defineProperties(this, { value: { value } })\n    return /** @type {any} */ (value)\n  }\n  /**\n   * @param {API.Source[]} capabilities\n   */\n  select(capabilities) {\n    return selectGroup(this, capabilities)\n  }\n  toString() {\n    return `[${this.matches.map(match => match.toString()).join(', ')}]`\n  }\n}\n\n/**\n * Resolves ability `pattern` of the delegated capability from the ability\n * of the claimed capability. If pattern matches returns claimed ability\n * otherwise returns given `fallback`.\n *\n * @example\n * ```js\n * resolveAbility('*', 'store/add', null) // => 'store/add'\n * resolveAbility('store/*', 'store/add', null) // => 'store/add'\n * resolveAbility('store/add', 'store/add', null) // => 'store/add'\n * resolveAbility('store/', 'store/add', null) // => null\n * resolveAbility('store/a*', 'store/add', null) // => null\n * resolveAbility('store/list', 'store/add', null) // => null\n * ```\n *\n * @template {API.Ability} T\n * @template U\n * @param {string} pattern\n * @param {T} can\n * @param {U} fallback\n * @returns {T|U}\n */\nconst resolveAbility = (pattern, can, fallback) => {\n  switch (pattern) {\n    case can:\n    case '*':\n      return can\n    default:\n      return pattern.endsWith('/*') && can.startsWith(pattern.slice(0, -1))\n        ? can\n        : fallback\n  }\n}\n\n/**\n * Resolves `source` resource of the delegated capability from the resource\n * `uri` of the claimed capability. If `source` is `\"ucan:*\"\"` or matches `uri`\n * then it returns `uri` back otherwise it returns `fallback`.\n *\n * @example\n * ```js\n * resolveResource('ucan:*', 'did:key:zAlice', null) // => 'did:key:zAlice'\n * resolveAbility('ucan:*', 'https://example.com', null) // => 'https://example.com'\n * resolveAbility('did:*', 'did:key:zAlice', null) // => null\n * resolveAbility('did:key:zAlice', 'did:key:zAlice', null) // => did:key:zAlice\n * ```\n * @template {string} T\n * @template U\n * @param {T} uri\n * @param {string} source\n * @param {U} fallback\n * @returns {T|U}\n */\nconst resolveResource = (source, uri, fallback) => {\n  switch (source) {\n    case uri:\n    case 'ucan:*':\n      return uri\n    default:\n      return fallback\n  }\n}\n\n/**\n * Parses capability from the `source` using a provided `parser`.\n *\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @param {Required<Descriptor<A, R, C>>} descriptor\n * @param {API.Source} source\n * @returns {API.Result<API.ParsedCapability<A, R, C>, API.InvalidCapability>}\n */\nconst parseCapability = (descriptor, source) => {\n  const { delegation } = source\n  const capability = /** @type {API.Capability<A, R, C>} */ (source.capability)\n\n  if (descriptor.can !== capability.can) {\n    return { error: new UnknownCapability(capability) }\n  }\n\n  const uri = descriptor.with.read(capability.with)\n  if (uri.error) {\n    return { error: new MalformedCapability(capability, uri.error) }\n  }\n\n  const nb = descriptor.nb.read(capability.nb || {})\n  if (nb.error) {\n    return { error: new MalformedCapability(capability, nb.error) }\n  }\n\n  return { ok: new CapabilityView(descriptor.can, uri.ok, nb.ok, delegation) }\n}\n\n/**\n * Resolves delegated capability `source` from the `claimed` capability using\n * provided capability `parser`. It is similar to `parseCapability` except\n * `source` here is treated as capability pattern which is matched against the\n * `claimed` capability. This means we resolve `can` and `with` fields from the\n * `claimed` capability and inherit all missing `nb` fields from the claimed\n * capability.\n *\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @param {Required<Descriptor<A, R, C>>} descriptor\n * @param {API.ParsedCapability<A, R, C>} claimed\n * @param {API.Source} source\n * @returns {API.Result<API.ParsedCapability<A, R, C>, API.InvalidCapability>}\n */\n\nconst resolveCapability = (descriptor, claimed, { capability, delegation }) => {\n  const can = resolveAbility(capability.can, claimed.can, null)\n  if (can == null) {\n    return { error: new UnknownCapability(capability) }\n  }\n\n  const resource = resolveResource(\n    capability.with,\n    claimed.with,\n    capability.with\n  )\n  const uri = descriptor.with.read(resource)\n  if (uri.error) {\n    return { error: new MalformedCapability(capability, uri.error) }\n  }\n\n  const nb = descriptor.nb.read({\n    ...claimed.nb,\n    ...capability.nb,\n  })\n\n  if (nb.error) {\n    return { error: new MalformedCapability(capability, nb.error) }\n  }\n\n  return { ok: new CapabilityView(can, uri.ok, nb.ok, delegation) }\n}\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template C\n */\nclass CapabilityView {\n  /**\n   * @param {A} can\n   * @param {R} with_\n   * @param {C} nb\n   * @param {API.Delegation} delegation\n   */\n  constructor(can, with_, nb, delegation) {\n    this.can = can\n    this.with = with_\n    this.delegation = delegation\n    this.nb = nb\n  }\n}\n\n/**\n * @template {API.Match} M\n * @param {API.Matcher<M>} matcher\n * @param {API.Source[]} capabilities\n * @returns {API.Select<M>}\n */\n\nconst select = (matcher, capabilities) => {\n  const unknown = []\n  const matches = []\n  const errors = []\n  for (const capability of capabilities) {\n    const result = matcher.match(capability)\n    if (result.error) {\n      switch (result.error.name) {\n        case 'UnknownCapability':\n          unknown.push(result.error.capability)\n          break\n        case 'MalformedCapability':\n        default:\n          errors.push(new MatchError([result.error], result.error.capability))\n      }\n    } else {\n      matches.push(result.ok)\n    }\n  }\n\n  return { matches, errors, unknown }\n}\n\n/**\n * @template {API.Selector<API.Match>[]} S\n * @param {{selectors:S}} self\n * @param {API.Source[]} capabilities\n */\n\nconst selectGroup = (self, capabilities) => {\n  let unknown\n  const data = []\n  const errors = []\n  for (const selector of self.selectors) {\n    const selected = selector.select(capabilities)\n    unknown = unknown\n      ? intersection(unknown, selected.unknown)\n      : selected.unknown\n\n    for (const error of selected.errors) {\n      errors.push(new MatchError([error], self))\n    }\n\n    data.push(selected.matches)\n  }\n\n  const matches = combine(data).map(group => new AndMatch(group))\n\n  return {\n    unknown:\n      /* c8 ignore next */\n      unknown || [],\n    errors,\n    matches,\n  }\n}\n\n/**\n * @template {API.ParsedCapability} T\n * @template {API.ParsedCapability} U\n * @param {T} claimed\n * @param {U} delegated\n * @return {API.Result<true, API.Failure>}\n */\nconst defaultDerives = (claimed, delegated) => {\n  if (delegated.with.endsWith('*')) {\n    if (!claimed.with.startsWith(delegated.with.slice(0, -1))) {\n      return Schema.error(\n        `Resource ${claimed.with} does not match delegated ${delegated.with} `\n      )\n    }\n  } else if (delegated.with !== claimed.with) {\n    return Schema.error(\n      `Resource ${claimed.with} is not contained by ${delegated.with}`\n    )\n  }\n\n  /* c8 ignore next 2 */\n  const caveats = delegated.nb || {}\n  const nb = claimed.nb || {}\n  const kv = entries(caveats)\n\n  for (const [name, value] of kv) {\n    if (nb[name] != value) {\n      return Schema.error(`${String(name)}: ${nb[name]} violates ${value}`)\n    }\n  }\n\n  return { ok: true }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}