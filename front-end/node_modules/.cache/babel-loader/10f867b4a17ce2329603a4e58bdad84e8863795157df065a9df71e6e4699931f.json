{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nimport { browserPerformanceTimeOrigin, getGlobalObject, logger } from '@sentry/utils';\nimport { msToSec } from '../utils';\nimport { getCLS } from './web-vitals/getCLS';\nimport { getFID } from './web-vitals/getFID';\nimport { getLCP } from './web-vitals/getLCP';\nimport { getTTFB } from './web-vitals/getTTFB';\nimport { getFirstHidden } from './web-vitals/lib/getFirstHidden';\nvar global = getGlobalObject();\n/** Class tracking metrics  */\nvar MetricsInstrumentation = /** @class */function () {\n  function MetricsInstrumentation() {\n    this._measurements = {};\n    this._performanceCursor = 0;\n    if (global && global.performance) {\n      if (global.performance.mark) {\n        global.performance.mark('sentry-tracing-init');\n      }\n      this._trackCLS();\n      this._trackLCP();\n      this._trackFID();\n      this._trackTTFB();\n    }\n  }\n  /** Add performance related spans to a transaction */\n  MetricsInstrumentation.prototype.addPerformanceEntries = function (transaction) {\n    var _this = this;\n    if (!global || !global.performance || !global.performance.getEntries || !browserPerformanceTimeOrigin) {\n      // Gatekeeper if performance API not available\n      return;\n    }\n    logger.log('[Tracing] Adding & adjusting spans using Performance API');\n    var timeOrigin = msToSec(browserPerformanceTimeOrigin);\n    var entryScriptSrc;\n    if (global.document) {\n      // eslint-disable-next-line @typescript-eslint/prefer-for-of\n      for (var i = 0; i < document.scripts.length; i++) {\n        // We go through all scripts on the page and look for 'data-entry'\n        // We remember the name and measure the time between this script finished loading and\n        // our mark 'sentry-tracing-init'\n        if (document.scripts[i].dataset.entry === 'true') {\n          entryScriptSrc = document.scripts[i].src;\n          break;\n        }\n      }\n    }\n    var entryScriptStartTimestamp;\n    var tracingInitMarkStartTime;\n    global.performance.getEntries().slice(this._performanceCursor).forEach(function (entry) {\n      var startTime = msToSec(entry.startTime);\n      var duration = msToSec(entry.duration);\n      if (transaction.op === 'navigation' && timeOrigin + startTime < transaction.startTimestamp) {\n        return;\n      }\n      switch (entry.entryType) {\n        case 'navigation':\n          addNavigationSpans(transaction, entry, timeOrigin);\n          break;\n        case 'mark':\n        case 'paint':\n        case 'measure':\n          {\n            var startTimestamp = addMeasureSpans(transaction, entry, startTime, duration, timeOrigin);\n            if (tracingInitMarkStartTime === undefined && entry.name === 'sentry-tracing-init') {\n              tracingInitMarkStartTime = startTimestamp;\n            }\n            // capture web vitals\n            var firstHidden = getFirstHidden();\n            // Only report if the page wasn't hidden prior to the web vital.\n            var shouldRecord = entry.startTime < firstHidden.timeStamp;\n            if (entry.name === 'first-paint' && shouldRecord) {\n              logger.log('[Measurements] Adding FP');\n              _this._measurements['fp'] = {\n                value: entry.startTime\n              };\n              _this._measurements['mark.fp'] = {\n                value: startTimestamp\n              };\n            }\n            if (entry.name === 'first-contentful-paint' && shouldRecord) {\n              logger.log('[Measurements] Adding FCP');\n              _this._measurements['fcp'] = {\n                value: entry.startTime\n              };\n              _this._measurements['mark.fcp'] = {\n                value: startTimestamp\n              };\n            }\n            break;\n          }\n        case 'resource':\n          {\n            var resourceName = entry.name.replace(window.location.origin, '');\n            var endTimestamp = addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin);\n            // We remember the entry script end time to calculate the difference to the first init mark\n            if (entryScriptStartTimestamp === undefined && (entryScriptSrc || '').indexOf(resourceName) > -1) {\n              entryScriptStartTimestamp = endTimestamp;\n            }\n            break;\n          }\n        default:\n        // Ignore other entry types.\n      }\n    });\n    if (entryScriptStartTimestamp !== undefined && tracingInitMarkStartTime !== undefined) {\n      _startChild(transaction, {\n        description: 'evaluation',\n        endTimestamp: tracingInitMarkStartTime,\n        op: 'script',\n        startTimestamp: entryScriptStartTimestamp\n      });\n    }\n    this._performanceCursor = Math.max(performance.getEntries().length - 1, 0);\n    this._trackNavigator(transaction);\n    // Measurements are only available for pageload transactions\n    if (transaction.op === 'pageload') {\n      // normalize applicable web vital values to be relative to transaction.startTimestamp\n      var timeOrigin_1 = msToSec(browserPerformanceTimeOrigin);\n      ['fcp', 'fp', 'lcp', 'ttfb'].forEach(function (name) {\n        if (!_this._measurements[name] || timeOrigin_1 >= transaction.startTimestamp) {\n          return;\n        }\n        // The web vitals, fcp, fp, lcp, and ttfb, all measure relative to timeOrigin.\n        // Unfortunately, timeOrigin is not captured within the transaction span data, so these web vitals will need\n        // to be adjusted to be relative to transaction.startTimestamp.\n        var oldValue = _this._measurements[name].value;\n        var measurementTimestamp = timeOrigin_1 + msToSec(oldValue);\n        // normalizedValue should be in milliseconds\n        var normalizedValue = Math.abs((measurementTimestamp - transaction.startTimestamp) * 1000);\n        var delta = normalizedValue - oldValue;\n        logger.log(\"[Measurements] Normalized \" + name + \" from \" + oldValue + \" to \" + normalizedValue + \" (\" + delta + \")\");\n        _this._measurements[name].value = normalizedValue;\n      });\n      if (this._measurements['mark.fid'] && this._measurements['fid']) {\n        // create span for FID\n        _startChild(transaction, {\n          description: 'first input delay',\n          endTimestamp: this._measurements['mark.fid'].value + msToSec(this._measurements['fid'].value),\n          op: 'web.vitals',\n          startTimestamp: this._measurements['mark.fid'].value\n        });\n      }\n      transaction.setMeasurements(this._measurements);\n    }\n  };\n  /** Starts tracking the Cumulative Layout Shift on the current page. */\n  MetricsInstrumentation.prototype._trackCLS = function () {\n    var _this = this;\n    getCLS(function (metric) {\n      var entry = metric.entries.pop();\n      if (!entry) {\n        return;\n      }\n      logger.log('[Measurements] Adding CLS');\n      _this._measurements['cls'] = {\n        value: metric.value\n      };\n    });\n  };\n  /**\n   * Capture the information of the user agent.\n   */\n  MetricsInstrumentation.prototype._trackNavigator = function (transaction) {\n    var navigator = global.navigator;\n    if (!navigator) {\n      return;\n    }\n    // track network connectivity\n    var connection = navigator.connection;\n    if (connection) {\n      if (connection.effectiveType) {\n        transaction.setTag('effectiveConnectionType', connection.effectiveType);\n      }\n      if (connection.type) {\n        transaction.setTag('connectionType', connection.type);\n      }\n      if (isMeasurementValue(connection.rtt)) {\n        this._measurements['connection.rtt'] = {\n          value: connection.rtt\n        };\n      }\n      if (isMeasurementValue(connection.downlink)) {\n        this._measurements['connection.downlink'] = {\n          value: connection.downlink\n        };\n      }\n    }\n    if (isMeasurementValue(navigator.deviceMemory)) {\n      transaction.setTag('deviceMemory', String(navigator.deviceMemory));\n    }\n    if (isMeasurementValue(navigator.hardwareConcurrency)) {\n      transaction.setTag('hardwareConcurrency', String(navigator.hardwareConcurrency));\n    }\n  };\n  /** Starts tracking the Largest Contentful Paint on the current page. */\n  MetricsInstrumentation.prototype._trackLCP = function () {\n    var _this = this;\n    getLCP(function (metric) {\n      var entry = metric.entries.pop();\n      if (!entry) {\n        return;\n      }\n      var timeOrigin = msToSec(performance.timeOrigin);\n      var startTime = msToSec(entry.startTime);\n      logger.log('[Measurements] Adding LCP');\n      _this._measurements['lcp'] = {\n        value: metric.value\n      };\n      _this._measurements['mark.lcp'] = {\n        value: timeOrigin + startTime\n      };\n    });\n  };\n  /** Starts tracking the First Input Delay on the current page. */\n  MetricsInstrumentation.prototype._trackFID = function () {\n    var _this = this;\n    getFID(function (metric) {\n      var entry = metric.entries.pop();\n      if (!entry) {\n        return;\n      }\n      var timeOrigin = msToSec(performance.timeOrigin);\n      var startTime = msToSec(entry.startTime);\n      logger.log('[Measurements] Adding FID');\n      _this._measurements['fid'] = {\n        value: metric.value\n      };\n      _this._measurements['mark.fid'] = {\n        value: timeOrigin + startTime\n      };\n    });\n  };\n  /** Starts tracking the Time to First Byte on the current page. */\n  MetricsInstrumentation.prototype._trackTTFB = function () {\n    var _this = this;\n    getTTFB(function (metric) {\n      var _a;\n      var entry = metric.entries.pop();\n      if (!entry) {\n        return;\n      }\n      logger.log('[Measurements] Adding TTFB');\n      _this._measurements['ttfb'] = {\n        value: metric.value\n      };\n      // Capture the time spent making the request and receiving the first byte of the response\n      var requestTime = metric.value - (_a = metric.entries[0], _a !== null && _a !== void 0 ? _a : entry).requestStart;\n      _this._measurements['ttfb.requestTime'] = {\n        value: requestTime\n      };\n    });\n  };\n  return MetricsInstrumentation;\n}();\nexport { MetricsInstrumentation };\n/** Instrument navigation entries */\nfunction addNavigationSpans(transaction, entry, timeOrigin) {\n  addPerformanceNavigationTiming(transaction, entry, 'unloadEvent', timeOrigin);\n  addPerformanceNavigationTiming(transaction, entry, 'redirect', timeOrigin);\n  addPerformanceNavigationTiming(transaction, entry, 'domContentLoadedEvent', timeOrigin);\n  addPerformanceNavigationTiming(transaction, entry, 'loadEvent', timeOrigin);\n  addPerformanceNavigationTiming(transaction, entry, 'connect', timeOrigin);\n  addPerformanceNavigationTiming(transaction, entry, 'secureConnection', timeOrigin, 'connectEnd');\n  addPerformanceNavigationTiming(transaction, entry, 'fetch', timeOrigin, 'domainLookupStart');\n  addPerformanceNavigationTiming(transaction, entry, 'domainLookup', timeOrigin);\n  addRequest(transaction, entry, timeOrigin);\n}\n/** Create measure related spans */\nfunction addMeasureSpans(transaction, entry, startTime, duration, timeOrigin) {\n  var measureStartTimestamp = timeOrigin + startTime;\n  var measureEndTimestamp = measureStartTimestamp + duration;\n  _startChild(transaction, {\n    description: entry.name,\n    endTimestamp: measureEndTimestamp,\n    op: entry.entryType,\n    startTimestamp: measureStartTimestamp\n  });\n  return measureStartTimestamp;\n}\n/** Create resource-related spans */\nexport function addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin) {\n  // we already instrument based on fetch and xhr, so we don't need to\n  // duplicate spans here.\n  if (entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch') {\n    return undefined;\n  }\n  var data = {};\n  if ('transferSize' in entry) {\n    data['Transfer Size'] = entry.transferSize;\n  }\n  if ('encodedBodySize' in entry) {\n    data['Encoded Body Size'] = entry.encodedBodySize;\n  }\n  if ('decodedBodySize' in entry) {\n    data['Decoded Body Size'] = entry.decodedBodySize;\n  }\n  var startTimestamp = timeOrigin + startTime;\n  var endTimestamp = startTimestamp + duration;\n  _startChild(transaction, {\n    description: resourceName,\n    endTimestamp: endTimestamp,\n    op: entry.initiatorType ? \"resource.\" + entry.initiatorType : 'resource',\n    startTimestamp: startTimestamp,\n    data: data\n  });\n  return endTimestamp;\n}\n/** Create performance navigation related spans */\nfunction addPerformanceNavigationTiming(transaction, entry, event, timeOrigin, eventEnd) {\n  var end = eventEnd ? entry[eventEnd] : entry[event + \"End\"];\n  var start = entry[event + \"Start\"];\n  if (!start || !end) {\n    return;\n  }\n  _startChild(transaction, {\n    op: 'browser',\n    description: event,\n    startTimestamp: timeOrigin + msToSec(start),\n    endTimestamp: timeOrigin + msToSec(end)\n  });\n}\n/** Create request and response related spans */\nfunction addRequest(transaction, entry, timeOrigin) {\n  _startChild(transaction, {\n    op: 'browser',\n    description: 'request',\n    startTimestamp: timeOrigin + msToSec(entry.requestStart),\n    endTimestamp: timeOrigin + msToSec(entry.responseEnd)\n  });\n  _startChild(transaction, {\n    op: 'browser',\n    description: 'response',\n    startTimestamp: timeOrigin + msToSec(entry.responseStart),\n    endTimestamp: timeOrigin + msToSec(entry.responseEnd)\n  });\n}\n/**\n * Helper function to start child on transactions. This function will make sure that the transaction will\n * use the start timestamp of the created child span if it is earlier than the transactions actual\n * start timestamp.\n */\nexport function _startChild(transaction, _a) {\n  var startTimestamp = _a.startTimestamp,\n    ctx = __rest(_a, [\"startTimestamp\"]);\n  if (startTimestamp && transaction.startTimestamp > startTimestamp) {\n    transaction.startTimestamp = startTimestamp;\n  }\n  return transaction.startChild(__assign({\n    startTimestamp: startTimestamp\n  }, ctx));\n}\n/**\n * Checks if a given value is a valid measurement value.\n */\nfunction isMeasurementValue(value) {\n  return typeof value === 'number' && isFinite(value);\n}","map":{"version":3,"names":["browserPerformanceTimeOrigin","getGlobalObject","logger","msToSec","getCLS","getFID","getLCP","getTTFB","getFirstHidden","global","MetricsInstrumentation","_measurements","_performanceCursor","performance","mark","_trackCLS","_trackLCP","_trackFID","_trackTTFB","prototype","addPerformanceEntries","transaction","_this","getEntries","log","timeOrigin","entryScriptSrc","document","i","scripts","length","dataset","entry","src","entryScriptStartTimestamp","tracingInitMarkStartTime","slice","forEach","startTime","duration","op","startTimestamp","entryType","addNavigationSpans","addMeasureSpans","undefined","name","firstHidden","shouldRecord","timeStamp","value","resourceName","replace","window","location","origin","endTimestamp","addResourceSpans","indexOf","_startChild","description","Math","max","_trackNavigator","timeOrigin_1","oldValue","measurementTimestamp","normalizedValue","abs","delta","setMeasurements","metric","entries","pop","navigator","connection","effectiveType","setTag","type","isMeasurementValue","rtt","downlink","deviceMemory","String","hardwareConcurrency","requestTime","_a","requestStart","addPerformanceNavigationTiming","addRequest","measureStartTimestamp","measureEndTimestamp","initiatorType","data","transferSize","encodedBodySize","decodedBodySize","event","eventEnd","end","start","responseEnd","responseStart","ctx","__rest","startChild","__assign","isFinite"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\@sentry\\tracing\\src\\browser\\metrics.ts"],"sourcesContent":["/* eslint-disable max-lines */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Measurements, SpanContext } from '@sentry/types';\nimport { browserPerformanceTimeOrigin, getGlobalObject, logger } from '@sentry/utils';\n\nimport { Span } from '../span';\nimport { Transaction } from '../transaction';\nimport { msToSec } from '../utils';\nimport { getCLS } from './web-vitals/getCLS';\nimport { getFID } from './web-vitals/getFID';\nimport { getLCP } from './web-vitals/getLCP';\nimport { getTTFB } from './web-vitals/getTTFB';\nimport { getFirstHidden } from './web-vitals/lib/getFirstHidden';\nimport { NavigatorDeviceMemory, NavigatorNetworkInformation } from './web-vitals/types';\n\nconst global = getGlobalObject<Window>();\n\n/** Class tracking metrics  */\nexport class MetricsInstrumentation {\n  private _measurements: Measurements = {};\n\n  private _performanceCursor: number = 0;\n\n  public constructor() {\n    if (global && global.performance) {\n      if (global.performance.mark) {\n        global.performance.mark('sentry-tracing-init');\n      }\n\n      this._trackCLS();\n      this._trackLCP();\n      this._trackFID();\n      this._trackTTFB();\n    }\n  }\n\n  /** Add performance related spans to a transaction */\n  public addPerformanceEntries(transaction: Transaction): void {\n    if (!global || !global.performance || !global.performance.getEntries || !browserPerformanceTimeOrigin) {\n      // Gatekeeper if performance API not available\n      return;\n    }\n\n    logger.log('[Tracing] Adding & adjusting spans using Performance API');\n\n    const timeOrigin = msToSec(browserPerformanceTimeOrigin);\n    let entryScriptSrc: string | undefined;\n\n    if (global.document) {\n      // eslint-disable-next-line @typescript-eslint/prefer-for-of\n      for (let i = 0; i < document.scripts.length; i++) {\n        // We go through all scripts on the page and look for 'data-entry'\n        // We remember the name and measure the time between this script finished loading and\n        // our mark 'sentry-tracing-init'\n        if (document.scripts[i].dataset.entry === 'true') {\n          entryScriptSrc = document.scripts[i].src;\n          break;\n        }\n      }\n    }\n\n    let entryScriptStartTimestamp: number | undefined;\n    let tracingInitMarkStartTime: number | undefined;\n\n    global.performance\n      .getEntries()\n      .slice(this._performanceCursor)\n      .forEach((entry: Record<string, any>) => {\n        const startTime = msToSec(entry.startTime as number);\n        const duration = msToSec(entry.duration as number);\n\n        if (transaction.op === 'navigation' && timeOrigin + startTime < transaction.startTimestamp) {\n          return;\n        }\n\n        switch (entry.entryType) {\n          case 'navigation':\n            addNavigationSpans(transaction, entry, timeOrigin);\n            break;\n          case 'mark':\n          case 'paint':\n          case 'measure': {\n            const startTimestamp = addMeasureSpans(transaction, entry, startTime, duration, timeOrigin);\n            if (tracingInitMarkStartTime === undefined && entry.name === 'sentry-tracing-init') {\n              tracingInitMarkStartTime = startTimestamp;\n            }\n\n            // capture web vitals\n\n            const firstHidden = getFirstHidden();\n            // Only report if the page wasn't hidden prior to the web vital.\n            const shouldRecord = entry.startTime < firstHidden.timeStamp;\n\n            if (entry.name === 'first-paint' && shouldRecord) {\n              logger.log('[Measurements] Adding FP');\n              this._measurements['fp'] = { value: entry.startTime };\n              this._measurements['mark.fp'] = { value: startTimestamp };\n            }\n\n            if (entry.name === 'first-contentful-paint' && shouldRecord) {\n              logger.log('[Measurements] Adding FCP');\n              this._measurements['fcp'] = { value: entry.startTime };\n              this._measurements['mark.fcp'] = { value: startTimestamp };\n            }\n\n            break;\n          }\n          case 'resource': {\n            const resourceName = (entry.name as string).replace(window.location.origin, '');\n            const endTimestamp = addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin);\n            // We remember the entry script end time to calculate the difference to the first init mark\n            if (entryScriptStartTimestamp === undefined && (entryScriptSrc || '').indexOf(resourceName) > -1) {\n              entryScriptStartTimestamp = endTimestamp;\n            }\n            break;\n          }\n          default:\n          // Ignore other entry types.\n        }\n      });\n\n    if (entryScriptStartTimestamp !== undefined && tracingInitMarkStartTime !== undefined) {\n      _startChild(transaction, {\n        description: 'evaluation',\n        endTimestamp: tracingInitMarkStartTime,\n        op: 'script',\n        startTimestamp: entryScriptStartTimestamp,\n      });\n    }\n\n    this._performanceCursor = Math.max(performance.getEntries().length - 1, 0);\n\n    this._trackNavigator(transaction);\n\n    // Measurements are only available for pageload transactions\n    if (transaction.op === 'pageload') {\n      // normalize applicable web vital values to be relative to transaction.startTimestamp\n\n      const timeOrigin = msToSec(browserPerformanceTimeOrigin);\n\n      ['fcp', 'fp', 'lcp', 'ttfb'].forEach(name => {\n        if (!this._measurements[name] || timeOrigin >= transaction.startTimestamp) {\n          return;\n        }\n\n        // The web vitals, fcp, fp, lcp, and ttfb, all measure relative to timeOrigin.\n        // Unfortunately, timeOrigin is not captured within the transaction span data, so these web vitals will need\n        // to be adjusted to be relative to transaction.startTimestamp.\n\n        const oldValue = this._measurements[name].value;\n        const measurementTimestamp = timeOrigin + msToSec(oldValue);\n        // normalizedValue should be in milliseconds\n        const normalizedValue = Math.abs((measurementTimestamp - transaction.startTimestamp) * 1000);\n\n        const delta = normalizedValue - oldValue;\n        logger.log(`[Measurements] Normalized ${name} from ${oldValue} to ${normalizedValue} (${delta})`);\n\n        this._measurements[name].value = normalizedValue;\n      });\n\n      if (this._measurements['mark.fid'] && this._measurements['fid']) {\n        // create span for FID\n\n        _startChild(transaction, {\n          description: 'first input delay',\n          endTimestamp: this._measurements['mark.fid'].value + msToSec(this._measurements['fid'].value),\n          op: 'web.vitals',\n          startTimestamp: this._measurements['mark.fid'].value,\n        });\n      }\n\n      transaction.setMeasurements(this._measurements);\n    }\n  }\n\n  /** Starts tracking the Cumulative Layout Shift on the current page. */\n  private _trackCLS(): void {\n    getCLS(metric => {\n      const entry = metric.entries.pop();\n\n      if (!entry) {\n        return;\n      }\n\n      logger.log('[Measurements] Adding CLS');\n      this._measurements['cls'] = { value: metric.value };\n    });\n  }\n\n  /**\n   * Capture the information of the user agent.\n   */\n  private _trackNavigator(transaction: Transaction): void {\n    const navigator = global.navigator as null | (Navigator & NavigatorNetworkInformation & NavigatorDeviceMemory);\n\n    if (!navigator) {\n      return;\n    }\n\n    // track network connectivity\n\n    const connection = navigator.connection;\n    if (connection) {\n      if (connection.effectiveType) {\n        transaction.setTag('effectiveConnectionType', connection.effectiveType);\n      }\n\n      if (connection.type) {\n        transaction.setTag('connectionType', connection.type);\n      }\n\n      if (isMeasurementValue(connection.rtt)) {\n        this._measurements['connection.rtt'] = { value: connection.rtt as number };\n      }\n\n      if (isMeasurementValue(connection.downlink)) {\n        this._measurements['connection.downlink'] = { value: connection.downlink as number };\n      }\n    }\n\n    if (isMeasurementValue(navigator.deviceMemory)) {\n      transaction.setTag('deviceMemory', String(navigator.deviceMemory));\n    }\n\n    if (isMeasurementValue(navigator.hardwareConcurrency)) {\n      transaction.setTag('hardwareConcurrency', String(navigator.hardwareConcurrency));\n    }\n  }\n\n  /** Starts tracking the Largest Contentful Paint on the current page. */\n  private _trackLCP(): void {\n    getLCP(metric => {\n      const entry = metric.entries.pop();\n\n      if (!entry) {\n        return;\n      }\n\n      const timeOrigin = msToSec(performance.timeOrigin);\n      const startTime = msToSec(entry.startTime as number);\n      logger.log('[Measurements] Adding LCP');\n      this._measurements['lcp'] = { value: metric.value };\n      this._measurements['mark.lcp'] = { value: timeOrigin + startTime };\n    });\n  }\n\n  /** Starts tracking the First Input Delay on the current page. */\n  private _trackFID(): void {\n    getFID(metric => {\n      const entry = metric.entries.pop();\n\n      if (!entry) {\n        return;\n      }\n\n      const timeOrigin = msToSec(performance.timeOrigin);\n      const startTime = msToSec(entry.startTime as number);\n      logger.log('[Measurements] Adding FID');\n      this._measurements['fid'] = { value: metric.value };\n      this._measurements['mark.fid'] = { value: timeOrigin + startTime };\n    });\n  }\n\n  /** Starts tracking the Time to First Byte on the current page. */\n  private _trackTTFB(): void {\n    getTTFB(metric => {\n      const entry = metric.entries.pop();\n\n      if (!entry) {\n        return;\n      }\n\n      logger.log('[Measurements] Adding TTFB');\n      this._measurements['ttfb'] = { value: metric.value };\n\n      // Capture the time spent making the request and receiving the first byte of the response\n      const requestTime = metric.value - ((metric.entries[0] ?? entry) as PerformanceNavigationTiming).requestStart;\n      this._measurements['ttfb.requestTime'] = { value: requestTime };\n    });\n  }\n}\n\n/** Instrument navigation entries */\nfunction addNavigationSpans(transaction: Transaction, entry: Record<string, any>, timeOrigin: number): void {\n  addPerformanceNavigationTiming(transaction, entry, 'unloadEvent', timeOrigin);\n  addPerformanceNavigationTiming(transaction, entry, 'redirect', timeOrigin);\n  addPerformanceNavigationTiming(transaction, entry, 'domContentLoadedEvent', timeOrigin);\n  addPerformanceNavigationTiming(transaction, entry, 'loadEvent', timeOrigin);\n  addPerformanceNavigationTiming(transaction, entry, 'connect', timeOrigin);\n  addPerformanceNavigationTiming(transaction, entry, 'secureConnection', timeOrigin, 'connectEnd');\n  addPerformanceNavigationTiming(transaction, entry, 'fetch', timeOrigin, 'domainLookupStart');\n  addPerformanceNavigationTiming(transaction, entry, 'domainLookup', timeOrigin);\n  addRequest(transaction, entry, timeOrigin);\n}\n\n/** Create measure related spans */\nfunction addMeasureSpans(\n  transaction: Transaction,\n  entry: Record<string, any>,\n  startTime: number,\n  duration: number,\n  timeOrigin: number,\n): number {\n  const measureStartTimestamp = timeOrigin + startTime;\n  const measureEndTimestamp = measureStartTimestamp + duration;\n\n  _startChild(transaction, {\n    description: entry.name as string,\n    endTimestamp: measureEndTimestamp,\n    op: entry.entryType as string,\n    startTimestamp: measureStartTimestamp,\n  });\n\n  return measureStartTimestamp;\n}\n\nexport interface ResourceEntry extends Record<string, unknown> {\n  initiatorType?: string;\n  transferSize?: number;\n  encodedBodySize?: number;\n  decodedBodySize?: number;\n}\n\n/** Create resource-related spans */\nexport function addResourceSpans(\n  transaction: Transaction,\n  entry: ResourceEntry,\n  resourceName: string,\n  startTime: number,\n  duration: number,\n  timeOrigin: number,\n): number | undefined {\n  // we already instrument based on fetch and xhr, so we don't need to\n  // duplicate spans here.\n  if (entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch') {\n    return undefined;\n  }\n\n  const data: Record<string, any> = {};\n  if ('transferSize' in entry) {\n    data['Transfer Size'] = entry.transferSize;\n  }\n  if ('encodedBodySize' in entry) {\n    data['Encoded Body Size'] = entry.encodedBodySize;\n  }\n  if ('decodedBodySize' in entry) {\n    data['Decoded Body Size'] = entry.decodedBodySize;\n  }\n\n  const startTimestamp = timeOrigin + startTime;\n  const endTimestamp = startTimestamp + duration;\n\n  _startChild(transaction, {\n    description: resourceName,\n    endTimestamp,\n    op: entry.initiatorType ? `resource.${entry.initiatorType}` : 'resource',\n    startTimestamp,\n    data,\n  });\n\n  return endTimestamp;\n}\n\n/** Create performance navigation related spans */\nfunction addPerformanceNavigationTiming(\n  transaction: Transaction,\n  entry: Record<string, any>,\n  event: string,\n  timeOrigin: number,\n  eventEnd?: string,\n): void {\n  const end = eventEnd ? (entry[eventEnd] as number | undefined) : (entry[`${event}End`] as number | undefined);\n  const start = entry[`${event}Start`] as number | undefined;\n  if (!start || !end) {\n    return;\n  }\n  _startChild(transaction, {\n    op: 'browser',\n    description: event,\n    startTimestamp: timeOrigin + msToSec(start),\n    endTimestamp: timeOrigin + msToSec(end),\n  });\n}\n\n/** Create request and response related spans */\nfunction addRequest(transaction: Transaction, entry: Record<string, any>, timeOrigin: number): void {\n  _startChild(transaction, {\n    op: 'browser',\n    description: 'request',\n    startTimestamp: timeOrigin + msToSec(entry.requestStart as number),\n    endTimestamp: timeOrigin + msToSec(entry.responseEnd as number),\n  });\n\n  _startChild(transaction, {\n    op: 'browser',\n    description: 'response',\n    startTimestamp: timeOrigin + msToSec(entry.responseStart as number),\n    endTimestamp: timeOrigin + msToSec(entry.responseEnd as number),\n  });\n}\n\n/**\n * Helper function to start child on transactions. This function will make sure that the transaction will\n * use the start timestamp of the created child span if it is earlier than the transactions actual\n * start timestamp.\n */\nexport function _startChild(transaction: Transaction, { startTimestamp, ...ctx }: SpanContext): Span {\n  if (startTimestamp && transaction.startTimestamp > startTimestamp) {\n    transaction.startTimestamp = startTimestamp;\n  }\n\n  return transaction.startChild({\n    startTimestamp,\n    ...ctx,\n  });\n}\n\n/**\n * Checks if a given value is a valid measurement value.\n */\nfunction isMeasurementValue(value: any): boolean {\n  return typeof value === 'number' && isFinite(value);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}