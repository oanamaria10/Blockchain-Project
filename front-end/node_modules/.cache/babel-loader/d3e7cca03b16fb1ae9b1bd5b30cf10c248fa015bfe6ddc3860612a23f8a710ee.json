{"ast":null,"code":"import * as API from '../../api.js';\nimport { PADDED_BYTES_PER_QUAD, EXPANDED_BYTES_PER_QUAD, LEAFS_PER_QUAD } from '../../constant.js';\nimport { log2Ceil } from '../../uint64.js';\nimport * as Padded from './padded.js';\n\n/**\n * Takes the {@link API.Piece} sizing details (height and padding) and\n * calculates original payload size.\n *\n * @param {object} piece\n * @param {number} piece.height\n * @param {API.uint64} piece.padding\n */\nexport const fromPiece = ({\n  height,\n  padding\n}) => Padded.fromHeight(height) - padding;\n\n/**\n * Takes arbitrary payload size and calculates 0-padding required to\n * produce a {@link API.PaddedSize}.\n *\n * @param {API.uint64} size\n */\nexport const toPadding = size => toPadded(size) - size;\n\n/**\n * Takes arbitrary payload size and calculates size after required 0-padding.\n *\n * @param {API.uint64} size\n * @returns {API.PaddedSize}\n */\nexport const toPadded = size => toQauds(size) * PADDED_BYTES_PER_QUAD;\n\n/**\n * Takes arbitrary payload size and calculates the piece size after required\n * 0-padding and FR32 expansion is applied.\n *\n * @param {API.uint64} size\n * @returns {API.PieceSize}\n */\nexport const toExpanded = size => toQauds(size) * EXPANDED_BYTES_PER_QUAD;\n\n/**\n * Takes arbitrary payload size and calculates width of the piece tree (leaf\n * count) that will be required to represent it.\n *\n * @param {API.uint64} size\n */\nexport const toWidth = size => toQauds(size) * LEAFS_PER_QUAD;\n\n/**\n * Takes arbitrary payload size and calculates height of the piece tree that will be required to represent it.\n *\n * @param {API.uint64} size\n */\nexport const toHeight = size => log2Ceil(toWidth(size));\n\n/**\n * Takes arbitrary payload size and calculates number of quads that will be\n * required to represent it.\n *\n * @param {API.uint64} size\n */\nconst toQauds = size => {\n  // Number of quads required to fit given payload size.\n  // Since bigint division truncates we add another quads shy of 1 number of\n  // bytes to round up.\n  const quadCount = (size + PADDED_BYTES_PER_QUAD - 1n) / PADDED_BYTES_PER_QUAD;\n  // Next we we log2 then pow2 with some rounding to ensure that result\n  // is 2 ^ n.\n  return 2n ** BigInt(log2Ceil(quadCount));\n};","map":{"version":3,"names":["API","PADDED_BYTES_PER_QUAD","EXPANDED_BYTES_PER_QUAD","LEAFS_PER_QUAD","log2Ceil","Padded","fromPiece","height","padding","fromHeight","toPadding","size","toPadded","toQauds","toExpanded","toWidth","toHeight","quadCount","BigInt"],"sources":["C:/FACULTATE/Proiect/node_modules/@web3-storage/data-segment/src/piece/size/unpadded.js"],"sourcesContent":["import * as API from '../../api.js'\nimport {\n  PADDED_BYTES_PER_QUAD,\n  EXPANDED_BYTES_PER_QUAD,\n  LEAFS_PER_QUAD,\n} from '../../constant.js'\nimport { log2Ceil } from '../../uint64.js'\nimport * as Padded from './padded.js'\n\n/**\n * Takes the {@link API.Piece} sizing details (height and padding) and\n * calculates original payload size.\n *\n * @param {object} piece\n * @param {number} piece.height\n * @param {API.uint64} piece.padding\n */\nexport const fromPiece = ({ height, padding }) =>\n  Padded.fromHeight(height) - padding\n\n/**\n * Takes arbitrary payload size and calculates 0-padding required to\n * produce a {@link API.PaddedSize}.\n *\n * @param {API.uint64} size\n */\nexport const toPadding = (size) => toPadded(size) - size\n\n/**\n * Takes arbitrary payload size and calculates size after required 0-padding.\n *\n * @param {API.uint64} size\n * @returns {API.PaddedSize}\n */\nexport const toPadded = (size) => toQauds(size) * PADDED_BYTES_PER_QUAD\n\n/**\n * Takes arbitrary payload size and calculates the piece size after required\n * 0-padding and FR32 expansion is applied.\n *\n * @param {API.uint64} size\n * @returns {API.PieceSize}\n */\nexport const toExpanded = (size) => toQauds(size) * EXPANDED_BYTES_PER_QUAD\n\n/**\n * Takes arbitrary payload size and calculates width of the piece tree (leaf\n * count) that will be required to represent it.\n *\n * @param {API.uint64} size\n */\nexport const toWidth = (size) => toQauds(size) * LEAFS_PER_QUAD\n\n/**\n * Takes arbitrary payload size and calculates height of the piece tree that will be required to represent it.\n *\n * @param {API.uint64} size\n */\nexport const toHeight = (size) => log2Ceil(toWidth(size))\n\n/**\n * Takes arbitrary payload size and calculates number of quads that will be\n * required to represent it.\n *\n * @param {API.uint64} size\n */\nconst toQauds = (size) => {\n  // Number of quads required to fit given payload size.\n  // Since bigint division truncates we add another quads shy of 1 number of\n  // bytes to round up.\n  const quadCount = (size + PADDED_BYTES_PER_QUAD - 1n) / PADDED_BYTES_PER_QUAD\n  // Next we we log2 then pow2 with some rounding to ensure that result\n  // is 2 ^ n.\n  return 2n ** BigInt(log2Ceil(quadCount))\n}\n"],"mappings":"AAAA,OAAO,KAAKA,GAAG,MAAM,cAAc;AACnC,SACEC,qBAAqB,EACrBC,uBAAuB,EACvBC,cAAc,QACT,mBAAmB;AAC1B,SAASC,QAAQ,QAAQ,iBAAiB;AAC1C,OAAO,KAAKC,MAAM,MAAM,aAAa;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,SAAS,GAAGA,CAAC;EAAEC,MAAM;EAAEC;AAAQ,CAAC,KAC3CH,MAAM,CAACI,UAAU,CAACF,MAAM,CAAC,GAAGC,OAAO;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAME,SAAS,GAAIC,IAAI,IAAKC,QAAQ,CAACD,IAAI,CAAC,GAAGA,IAAI;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,QAAQ,GAAID,IAAI,IAAKE,OAAO,CAACF,IAAI,CAAC,GAAGV,qBAAqB;;AAEvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMa,UAAU,GAAIH,IAAI,IAAKE,OAAO,CAACF,IAAI,CAAC,GAAGT,uBAAuB;;AAE3E;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMa,OAAO,GAAIJ,IAAI,IAAKE,OAAO,CAACF,IAAI,CAAC,GAAGR,cAAc;;AAE/D;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMa,QAAQ,GAAIL,IAAI,IAAKP,QAAQ,CAACW,OAAO,CAACJ,IAAI,CAAC,CAAC;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,OAAO,GAAIF,IAAI,IAAK;EACxB;EACA;EACA;EACA,MAAMM,SAAS,GAAG,CAACN,IAAI,GAAGV,qBAAqB,GAAG,EAAE,IAAIA,qBAAqB;EAC7E;EACA;EACA,OAAO,EAAE,IAAIiB,MAAM,CAACd,QAAQ,CAACa,SAAS,CAAC,CAAC;AAC1C,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}