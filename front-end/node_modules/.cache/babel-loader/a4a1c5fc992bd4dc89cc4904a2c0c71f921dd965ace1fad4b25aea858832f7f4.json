{"ast":null,"code":"var util = require('util');\nmodule.exports = function tsort(initial) {\n  var graph = new Graph();\n  if (initial) {\n    initial.forEach(function (entry) {\n      Graph.prototype.add.apply(graph, entry);\n    });\n  }\n  return graph;\n};\nfunction Graph() {\n  this.nodes = {};\n}\n\n// Add sorted items to the graph\nGraph.prototype.add = function () {\n  var self = this;\n  var items = [].slice.call(arguments);\n  if (items.length == 1 && util.isArray(items[0])) items = items[0];\n  items.forEach(function (item) {\n    if (!self.nodes[item]) self.nodes[item] = [];\n  });\n  for (var i = 1; i < items.length; i++) {\n    var from = items[i];\n    var to = items[i - 1];\n    self.nodes[from].push(to);\n  }\n  return self;\n};\n\n// Depth first search\n// As given in http://en.wikipedia.org/wiki/Topological_sorting\nGraph.prototype.sort = function () {\n  var self = this;\n  var nodes = Object.keys(this.nodes);\n  var sorted = [];\n  var marks = {};\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    if (!marks[node]) visit(node);\n  }\n  return sorted;\n  function visit(node) {\n    if (marks[node] === 'temp') throw new Error(\"There is a cycle in the graph. It is not possible to derive a topological sort.\");else if (marks[node]) return;\n    marks[node] = 'temp';\n    self.nodes[node].forEach(visit);\n    marks[node] = 'perm';\n    sorted.push(node);\n  }\n};","map":{"version":3,"names":["util","require","module","exports","tsort","initial","graph","Graph","forEach","entry","prototype","add","apply","nodes","self","items","slice","call","arguments","length","isArray","item","i","from","to","push","sort","Object","keys","sorted","marks","node","visit","Error"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/tsort/index.js"],"sourcesContent":["var util = require('util');\n\nmodule.exports = function tsort(initial) {\n  var graph = new Graph();\n\n  if (initial) {\n    initial.forEach(function(entry) {\n      Graph.prototype.add.apply(graph, entry);\n    });\n  }\n\n  return graph;\n}\n\nfunction Graph() {\n  this.nodes = {};\n}\n\n// Add sorted items to the graph\nGraph.prototype.add = function() {\n  var self = this;\n  var items = [].slice.call(arguments);\n\n  if (items.length == 1 && util.isArray(items[0]))\n    items = items[0];\n\n  items.forEach(function(item) {\n    if (!self.nodes[item])\n      self.nodes[item] = [];\n  });\n\n  for (var i = 1; i < items.length; i++) {\n    var from = items[i];\n    var to = items[i - 1];\n\n    self.nodes[from].push(to);\n  }\n\n  return self;\n};\n\n// Depth first search\n// As given in http://en.wikipedia.org/wiki/Topological_sorting\nGraph.prototype.sort = function() {\n  var self = this;\n  var nodes = Object.keys(this.nodes);\n\n  var sorted = [];\n  var marks = {};\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n\n    if (!marks[node])\n      visit(node);\n  }\n\n  return sorted;\n\n  function visit(node) {\n    if (marks[node] === 'temp')\n      throw new Error(\"There is a cycle in the graph. It is not possible to derive a topological sort.\");\n    else if (marks[node])\n      return;\n\n    marks[node] = 'temp';\n    self.nodes[node].forEach(visit);\n    marks[node] = 'perm';\n\n    sorted.push(node);\n  }\n};\n"],"mappings":"AAAA,IAAIA,IAAI,GAAGC,OAAO,CAAC,MAAM,CAAC;AAE1BC,MAAM,CAACC,OAAO,GAAG,SAASC,KAAKA,CAACC,OAAO,EAAE;EACvC,IAAIC,KAAK,GAAG,IAAIC,KAAK,CAAC,CAAC;EAEvB,IAAIF,OAAO,EAAE;IACXA,OAAO,CAACG,OAAO,CAAC,UAASC,KAAK,EAAE;MAC9BF,KAAK,CAACG,SAAS,CAACC,GAAG,CAACC,KAAK,CAACN,KAAK,EAAEG,KAAK,CAAC;IACzC,CAAC,CAAC;EACJ;EAEA,OAAOH,KAAK;AACd,CAAC;AAED,SAASC,KAAKA,CAAA,EAAG;EACf,IAAI,CAACM,KAAK,GAAG,CAAC,CAAC;AACjB;;AAEA;AACAN,KAAK,CAACG,SAAS,CAACC,GAAG,GAAG,YAAW;EAC/B,IAAIG,IAAI,GAAG,IAAI;EACf,IAAIC,KAAK,GAAG,EAAE,CAACC,KAAK,CAACC,IAAI,CAACC,SAAS,CAAC;EAEpC,IAAIH,KAAK,CAACI,MAAM,IAAI,CAAC,IAAInB,IAAI,CAACoB,OAAO,CAACL,KAAK,CAAC,CAAC,CAAC,CAAC,EAC7CA,KAAK,GAAGA,KAAK,CAAC,CAAC,CAAC;EAElBA,KAAK,CAACP,OAAO,CAAC,UAASa,IAAI,EAAE;IAC3B,IAAI,CAACP,IAAI,CAACD,KAAK,CAACQ,IAAI,CAAC,EACnBP,IAAI,CAACD,KAAK,CAACQ,IAAI,CAAC,GAAG,EAAE;EACzB,CAAC,CAAC;EAEF,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,KAAK,CAACI,MAAM,EAAEG,CAAC,EAAE,EAAE;IACrC,IAAIC,IAAI,GAAGR,KAAK,CAACO,CAAC,CAAC;IACnB,IAAIE,EAAE,GAAGT,KAAK,CAACO,CAAC,GAAG,CAAC,CAAC;IAErBR,IAAI,CAACD,KAAK,CAACU,IAAI,CAAC,CAACE,IAAI,CAACD,EAAE,CAAC;EAC3B;EAEA,OAAOV,IAAI;AACb,CAAC;;AAED;AACA;AACAP,KAAK,CAACG,SAAS,CAACgB,IAAI,GAAG,YAAW;EAChC,IAAIZ,IAAI,GAAG,IAAI;EACf,IAAID,KAAK,GAAGc,MAAM,CAACC,IAAI,CAAC,IAAI,CAACf,KAAK,CAAC;EAEnC,IAAIgB,MAAM,GAAG,EAAE;EACf,IAAIC,KAAK,GAAG,CAAC,CAAC;EAEd,KAAK,IAAIR,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,KAAK,CAACM,MAAM,EAAEG,CAAC,EAAE,EAAE;IACrC,IAAIS,IAAI,GAAGlB,KAAK,CAACS,CAAC,CAAC;IAEnB,IAAI,CAACQ,KAAK,CAACC,IAAI,CAAC,EACdC,KAAK,CAACD,IAAI,CAAC;EACf;EAEA,OAAOF,MAAM;EAEb,SAASG,KAAKA,CAACD,IAAI,EAAE;IACnB,IAAID,KAAK,CAACC,IAAI,CAAC,KAAK,MAAM,EACxB,MAAM,IAAIE,KAAK,CAAC,iFAAiF,CAAC,CAAC,KAChG,IAAIH,KAAK,CAACC,IAAI,CAAC,EAClB;IAEFD,KAAK,CAACC,IAAI,CAAC,GAAG,MAAM;IACpBjB,IAAI,CAACD,KAAK,CAACkB,IAAI,CAAC,CAACvB,OAAO,CAACwB,KAAK,CAAC;IAC/BF,KAAK,CAACC,IAAI,CAAC,GAAG,MAAM;IAEpBF,MAAM,CAACJ,IAAI,CAACM,IAAI,CAAC;EACnB;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}