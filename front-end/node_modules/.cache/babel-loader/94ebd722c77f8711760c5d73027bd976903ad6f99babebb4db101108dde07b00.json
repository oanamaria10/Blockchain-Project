{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateResolvedConfig = exports.getValidationErrors = exports.validateConfig = exports.decimalString = exports.address = exports.hexString = exports.DotPathReporter = exports.success = exports.failure = void 0;\nconst t = __importStar(require(\"io-ts\"));\nconst constants_1 = require(\"../../constants\");\nconst io_ts_1 = require(\"../../util/io-ts\");\nconst lang_1 = require(\"../../util/lang\");\nconst errors_1 = require(\"../errors\");\nconst errors_list_1 = require(\"../errors-list\");\nconst hardforks_1 = require(\"../../util/hardforks\");\nconst default_config_1 = require(\"./default-config\");\nfunction stringify(v) {\n  if (typeof v === \"function\") {\n    const {\n      getFunctionName\n    } = require(\"io-ts/lib\");\n    return getFunctionName(v);\n  }\n  if (typeof v === \"number\" && !isFinite(v)) {\n    if (isNaN(v)) {\n      return \"NaN\";\n    }\n    return v > 0 ? \"Infinity\" : \"-Infinity\";\n  }\n  return JSON.stringify(v);\n}\nfunction getContextPath(context) {\n  const keysPath = context.slice(1).map(c => c.key).join(\".\");\n  return `${context[0].type.name}.${keysPath}`;\n}\nfunction getMessage(e) {\n  const lastContext = e.context[e.context.length - 1];\n  return e.message !== undefined ? e.message : getErrorMessage(getContextPath(e.context), e.value, lastContext.type.name);\n}\nfunction getErrorMessage(path, value, expectedType) {\n  return `Invalid value ${stringify(value)} for ${path} - Expected a value of type ${expectedType}.`;\n}\nfunction getPrivateKeyError(index, network, message) {\n  return `Invalid account: #${index} for network: ${network} - ${message}`;\n}\nfunction validatePrivateKey(privateKey, index, network, errors) {\n  if (typeof privateKey !== \"string\") {\n    errors.push(getPrivateKeyError(index, network, `Expected string, received ${typeof privateKey}`));\n  } else {\n    // private key validation\n    const pkWithPrefix = /^0x/.test(privateKey) ? privateKey : `0x${privateKey}`;\n    // 32 bytes = 64 characters + 2 char prefix = 66\n    if (pkWithPrefix.length < 66) {\n      errors.push(getPrivateKeyError(index, network, \"private key too short, expected 32 bytes\"));\n    } else if (pkWithPrefix.length > 66) {\n      errors.push(getPrivateKeyError(index, network, \"private key too long, expected 32 bytes\"));\n    } else if (exports.hexString.decode(pkWithPrefix).isLeft()) {\n      errors.push(getPrivateKeyError(index, network, \"invalid hex character(s) found in string\"));\n    }\n  }\n}\nfunction failure(es) {\n  return es.map(getMessage);\n}\nexports.failure = failure;\nfunction success() {\n  return [];\n}\nexports.success = success;\nexports.DotPathReporter = {\n  report: validation => validation.fold(failure, success)\n};\nconst HEX_STRING_REGEX = /^(0x)?([0-9a-f]{2})+$/gi;\nconst DEC_STRING_REGEX = /^(0|[1-9][0-9]*)$/g;\nfunction isHexString(v) {\n  if (typeof v !== \"string\") {\n    return false;\n  }\n  return v.trim().match(HEX_STRING_REGEX) !== null;\n}\nfunction isDecimalString(v) {\n  if (typeof v !== \"string\") {\n    return false;\n  }\n  return v.match(DEC_STRING_REGEX) !== null;\n}\nexports.hexString = new t.Type(\"hex string\", isHexString, (u, c) => isHexString(u) ? t.success(u) : t.failure(u, c), t.identity);\nfunction isAddress(v) {\n  if (typeof v !== \"string\") {\n    return false;\n  }\n  const trimmed = v.trim();\n  return trimmed.match(HEX_STRING_REGEX) !== null && trimmed.startsWith(\"0x\") && trimmed.length === 42;\n}\nexports.address = new t.Type(\"address\", isAddress, (u, c) => isAddress(u) ? t.success(u) : t.failure(u, c), t.identity);\nexports.decimalString = new t.Type(\"decimal string\", isDecimalString, (u, c) => isDecimalString(u) ? t.success(u) : t.failure(u, c), t.identity);\n// TODO: These types have outdated name. They should match the UserConfig types.\n// IMPORTANT: This t.types MUST be kept in sync with the actual types.\nconst HardhatNetworkAccount = t.type({\n  privateKey: exports.hexString,\n  balance: exports.decimalString\n});\nconst commonHDAccountsFields = {\n  initialIndex: (0, io_ts_1.optional)(t.number),\n  count: (0, io_ts_1.optional)(t.number),\n  path: (0, io_ts_1.optional)(t.string)\n};\nconst HardhatNetworkHDAccountsConfig = t.type({\n  mnemonic: (0, io_ts_1.optional)(t.string),\n  accountsBalance: (0, io_ts_1.optional)(exports.decimalString),\n  passphrase: (0, io_ts_1.optional)(t.string),\n  ...commonHDAccountsFields\n});\nconst Integer = new t.Type(\"Integer\", num => typeof num === \"number\", (u, c) => {\n  try {\n    return typeof u === \"string\" ? t.success(parseInt(u, 10)) : t.failure(u, c);\n  } catch {\n    return t.failure(u, c);\n  }\n}, t.identity);\nconst HardhatNetworkForkingConfig = t.type({\n  enabled: (0, io_ts_1.optional)(t.boolean),\n  url: t.string,\n  blockNumber: (0, io_ts_1.optional)(t.number)\n});\nconst HardhatNetworkMempoolConfig = t.type({\n  order: (0, io_ts_1.optional)(t.keyof((0, lang_1.fromEntries)(constants_1.HARDHAT_MEMPOOL_SUPPORTED_ORDERS.map(order => [order, null]))))\n});\nconst HardhatNetworkMiningConfig = t.type({\n  auto: (0, io_ts_1.optional)(t.boolean),\n  interval: (0, io_ts_1.optional)(t.union([t.number, t.tuple([t.number, t.number])])),\n  mempool: (0, io_ts_1.optional)(HardhatNetworkMempoolConfig)\n});\nfunction isValidHardforkName(name) {\n  return Object.values(hardforks_1.HardforkName).includes(name);\n}\nconst HardforkNameType = new t.Type(Object.values(hardforks_1.HardforkName).map(v => `\"${v}\"`).join(\" | \"), name => typeof name === \"string\" && isValidHardforkName(name), (u, c) => {\n  return typeof u === \"string\" && isValidHardforkName(u) ? t.success(u) : t.failure(u, c);\n}, t.identity);\nconst HardhatNetworkHardforkHistory = t.record(HardforkNameType, t.number, \"HardhatNetworkHardforkHistory\");\nconst HardhatNetworkChainConfig = t.type({\n  hardforkHistory: HardhatNetworkHardforkHistory\n});\nconst HardhatNetworkChainsConfig = t.record(Integer, HardhatNetworkChainConfig);\nconst commonNetworkConfigFields = {\n  chainId: (0, io_ts_1.optional)(t.number),\n  from: (0, io_ts_1.optional)(t.string),\n  gas: (0, io_ts_1.optional)(t.union([t.literal(\"auto\"), t.number])),\n  gasPrice: (0, io_ts_1.optional)(t.union([t.literal(\"auto\"), t.number])),\n  gasMultiplier: (0, io_ts_1.optional)(t.number)\n};\nconst HardhatNetworkConfig = t.type({\n  ...commonNetworkConfigFields,\n  hardfork: (0, io_ts_1.optional)(t.keyof((0, lang_1.fromEntries)(constants_1.HARDHAT_NETWORK_SUPPORTED_HARDFORKS.map(hf => [hf, null])))),\n  accounts: (0, io_ts_1.optional)(t.union([t.array(HardhatNetworkAccount), HardhatNetworkHDAccountsConfig])),\n  blockGasLimit: (0, io_ts_1.optional)(t.number),\n  minGasPrice: (0, io_ts_1.optional)(t.union([t.number, t.string])),\n  throwOnTransactionFailures: (0, io_ts_1.optional)(t.boolean),\n  throwOnCallFailures: (0, io_ts_1.optional)(t.boolean),\n  allowUnlimitedContractSize: (0, io_ts_1.optional)(t.boolean),\n  initialDate: (0, io_ts_1.optional)(t.string),\n  loggingEnabled: (0, io_ts_1.optional)(t.boolean),\n  forking: (0, io_ts_1.optional)(HardhatNetworkForkingConfig),\n  mining: (0, io_ts_1.optional)(HardhatNetworkMiningConfig),\n  coinbase: (0, io_ts_1.optional)(exports.address),\n  chains: (0, io_ts_1.optional)(HardhatNetworkChainsConfig)\n});\nconst HDAccountsConfig = t.type({\n  mnemonic: t.string,\n  passphrase: (0, io_ts_1.optional)(t.string),\n  ...commonHDAccountsFields\n});\nconst NetworkConfigAccounts = t.union([t.literal(\"remote\"), t.array(exports.hexString), HDAccountsConfig]);\nconst HttpHeaders = t.record(t.string, t.string, \"httpHeaders\");\nconst HttpNetworkConfig = t.type({\n  ...commonNetworkConfigFields,\n  url: (0, io_ts_1.optional)(t.string),\n  accounts: (0, io_ts_1.optional)(NetworkConfigAccounts),\n  httpHeaders: (0, io_ts_1.optional)(HttpHeaders),\n  timeout: (0, io_ts_1.optional)(t.number)\n});\nconst NetworkConfig = t.union([HardhatNetworkConfig, HttpNetworkConfig]);\nconst Networks = t.record(t.string, NetworkConfig);\nconst ProjectPaths = t.type({\n  root: (0, io_ts_1.optional)(t.string),\n  cache: (0, io_ts_1.optional)(t.string),\n  artifacts: (0, io_ts_1.optional)(t.string),\n  sources: (0, io_ts_1.optional)(t.string),\n  tests: (0, io_ts_1.optional)(t.string)\n});\nconst SingleSolcConfig = t.type({\n  version: t.string,\n  settings: (0, io_ts_1.optional)(t.any)\n});\nconst MultiSolcConfig = t.type({\n  compilers: t.array(SingleSolcConfig),\n  overrides: (0, io_ts_1.optional)(t.record(t.string, SingleSolcConfig))\n});\nconst SolidityConfig = t.union([t.string, SingleSolcConfig, MultiSolcConfig]);\nconst HardhatConfig = t.type({\n  defaultNetwork: (0, io_ts_1.optional)(t.string),\n  networks: (0, io_ts_1.optional)(Networks),\n  paths: (0, io_ts_1.optional)(ProjectPaths),\n  solidity: (0, io_ts_1.optional)(SolidityConfig)\n}, \"HardhatConfig\");\n/**\n * Validates the config, throwing a HardhatError if invalid.\n * @param config\n */\nfunction validateConfig(config) {\n  const errors = getValidationErrors(config);\n  if (errors.length === 0) {\n    return;\n  }\n  let errorList = errors.join(\"\\n  * \");\n  errorList = `  * ${errorList}`;\n  throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.INVALID_CONFIG, {\n    errors: errorList\n  });\n}\nexports.validateConfig = validateConfig;\nfunction getValidationErrors(config) {\n  const errors = [];\n  // These can't be validated with io-ts\n  if (config !== undefined && typeof config.networks === \"object\") {\n    const hardhatNetwork = config.networks[constants_1.HARDHAT_NETWORK_NAME];\n    if (hardhatNetwork !== undefined && typeof hardhatNetwork === \"object\") {\n      if (\"url\" in hardhatNetwork) {\n        errors.push(`HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME} can't have an url`);\n      }\n      // Validating the accounts with io-ts leads to very confusing errors messages\n      const {\n        accounts,\n        ...configExceptAccounts\n      } = hardhatNetwork;\n      const netConfigResult = HardhatNetworkConfig.decode(configExceptAccounts);\n      if (netConfigResult.isLeft()) {\n        errors.push(getErrorMessage(`HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}`, hardhatNetwork, \"HardhatNetworkConfig\"));\n      }\n      // manual validation of accounts\n      if (Array.isArray(accounts)) {\n        for (const [index, account] of accounts.entries()) {\n          if (typeof account !== \"object\") {\n            errors.push(getPrivateKeyError(index, constants_1.HARDHAT_NETWORK_NAME, `Expected object, received ${typeof account}`));\n            continue;\n          }\n          const {\n            privateKey,\n            balance\n          } = account;\n          validatePrivateKey(privateKey, index, constants_1.HARDHAT_NETWORK_NAME, errors);\n          if (typeof balance !== \"string\") {\n            errors.push(getErrorMessage(`HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}.accounts[].balance`, balance, \"string\"));\n          } else if (exports.decimalString.decode(balance).isLeft()) {\n            errors.push(getErrorMessage(`HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}.accounts[].balance`, balance, \"decimal(wei)\"));\n          }\n        }\n      } else if (typeof hardhatNetwork.accounts === \"object\") {\n        const hdConfigResult = HardhatNetworkHDAccountsConfig.decode(hardhatNetwork.accounts);\n        if (hdConfigResult.isLeft()) {\n          errors.push(getErrorMessage(`HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}.accounts`, hardhatNetwork.accounts, \"[{privateKey: string, balance: string}] | HardhatNetworkHDAccountsConfig | undefined\"));\n        }\n      } else if (hardhatNetwork.accounts !== undefined) {\n        errors.push(getErrorMessage(`HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}.accounts`, hardhatNetwork.accounts, \"[{privateKey: string, balance: string}] | HardhatNetworkHDAccountsConfig | undefined\"));\n      }\n      const hardfork = hardhatNetwork.hardfork ?? default_config_1.defaultHardhatNetworkParams.hardfork;\n      if ((0, hardforks_1.hardforkGte)(hardfork, hardforks_1.HardforkName.LONDON)) {\n        if (hardhatNetwork.minGasPrice !== undefined) {\n          errors.push(`Unexpected config HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}.minGasPrice found - This field is not valid for networks with EIP-1559. Try an older hardfork or remove it.`);\n        }\n      } else {\n        if (hardhatNetwork.initialBaseFeePerGas !== undefined) {\n          errors.push(`Unexpected config HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}.initialBaseFeePerGas found - This field is only valid for networks with EIP-1559. Try a newer hardfork or remove it.`);\n        }\n      }\n      if (hardhatNetwork.chains !== undefined) {\n        Object.entries(hardhatNetwork.chains).forEach(chainEntry => {\n          const [chainId, chainConfig] = chainEntry;\n          const {\n            hardforkHistory\n          } = chainConfig;\n          if (hardforkHistory !== undefined) {\n            Object.keys(hardforkHistory).forEach(hardforkName => {\n              if (!constants_1.HARDHAT_NETWORK_SUPPORTED_HARDFORKS.includes(hardforkName)) {\n                errors.push(getErrorMessage(`HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}.chains[${chainId}].hardforkHistory`, hardforkName, `\"${constants_1.HARDHAT_NETWORK_SUPPORTED_HARDFORKS.join('\" | \"')}\"`));\n              }\n            });\n          }\n        });\n      }\n      if (hardhatNetwork.hardfork !== undefined) {\n        if (!(0, hardforks_1.hardforkGte)(hardhatNetwork.hardfork, hardforks_1.HardforkName.CANCUN) && hardhatNetwork.enableTransientStorage === true) {\n          errors.push(`'enableTransientStorage' cannot be enabled if the hardfork is explicitly set to a pre-cancun value. If you want to use transient storage, use 'cancun' as the hardfork.`);\n        }\n        if ((0, hardforks_1.hardforkGte)(hardhatNetwork.hardfork, hardforks_1.HardforkName.CANCUN) && hardhatNetwork.enableTransientStorage === false) {\n          errors.push(`'enableTransientStorage' cannot be disabled if the hardfork is explicitly set to cancun or later. If you want to disable transient storage, use a hardfork before 'cancun'.`);\n        }\n      }\n    }\n    for (const [networkName, netConfig] of Object.entries(config.networks)) {\n      if (networkName === constants_1.HARDHAT_NETWORK_NAME) {\n        continue;\n      }\n      if (networkName !== \"localhost\" || netConfig.url !== undefined) {\n        if (typeof netConfig.url !== \"string\") {\n          errors.push(getErrorMessage(`HardhatConfig.networks.${networkName}.url`, netConfig.url, \"string\"));\n        }\n      }\n      const {\n        accounts,\n        ...configExceptAccounts\n      } = netConfig;\n      const netConfigResult = HttpNetworkConfig.decode(configExceptAccounts);\n      if (netConfigResult.isLeft()) {\n        errors.push(getErrorMessage(`HardhatConfig.networks.${networkName}`, netConfig, \"HttpNetworkConfig\"));\n      }\n      // manual validation of accounts\n      if (Array.isArray(accounts)) {\n        accounts.forEach((privateKey, index) => validatePrivateKey(privateKey, index, networkName, errors));\n      } else if (typeof accounts === \"object\") {\n        const hdConfigResult = HDAccountsConfig.decode(accounts);\n        if (hdConfigResult.isLeft()) {\n          errors.push(getErrorMessage(`HardhatConfig.networks.${networkName}`, accounts, \"HttpNetworkHDAccountsConfig\"));\n        }\n      } else if (typeof accounts === \"string\") {\n        if (accounts !== \"remote\") {\n          errors.push(`Invalid 'accounts' entry for network '${networkName}': expected an array of accounts or the string 'remote', but got the string '${accounts}'`);\n        }\n      } else if (accounts !== undefined) {\n        errors.push(getErrorMessage(`HardhatConfig.networks.${networkName}.accounts`, accounts, '\"remote\" | string[] | HttpNetworkHDAccountsConfig | undefined'));\n      }\n    }\n  }\n  // io-ts can get confused if there are errors that it can't understand.\n  // Especially around Hardhat Network's config. It will treat it as an HTTPConfig,\n  // and may give a loot of errors.\n  if (errors.length > 0) {\n    return errors;\n  }\n  const result = HardhatConfig.decode(config);\n  if (result.isRight()) {\n    return errors;\n  }\n  const ioTsErrors = exports.DotPathReporter.report(result);\n  return [...errors, ...ioTsErrors];\n}\nexports.getValidationErrors = getValidationErrors;\nfunction validateResolvedConfig(resolvedConfig) {\n  const solcConfigs = [...resolvedConfig.solidity.compilers, ...Object.values(resolvedConfig.solidity.overrides)];\n  const runs = solcConfigs.filter(({\n    settings\n  }) => settings?.optimizer?.runs !== undefined).map(({\n    settings\n  }) => settings?.optimizer?.runs);\n  for (const run of runs) {\n    if (run >= 2 ** 32) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.INVALID_CONFIG, {\n        errors: \"The number of optimizer runs exceeds the maximum of 2**32 - 1\"\n      });\n    }\n  }\n}\nexports.validateResolvedConfig = validateResolvedConfig;","map":{"version":3,"names":["t","__importStar","require","constants_1","io_ts_1","lang_1","errors_1","errors_list_1","hardforks_1","default_config_1","stringify","v","getFunctionName","isFinite","isNaN","JSON","getContextPath","context","keysPath","slice","map","c","key","join","type","name","getMessage","e","lastContext","length","message","undefined","getErrorMessage","value","path","expectedType","getPrivateKeyError","index","network","validatePrivateKey","privateKey","errors","push","pkWithPrefix","test","exports","hexString","decode","isLeft","failure","es","success","DotPathReporter","report","validation","fold","HEX_STRING_REGEX","DEC_STRING_REGEX","isHexString","trim","match","isDecimalString","Type","u","identity","isAddress","trimmed","startsWith","address","decimalString","HardhatNetworkAccount","balance","commonHDAccountsFields","initialIndex","optional","number","count","string","HardhatNetworkHDAccountsConfig","mnemonic","accountsBalance","passphrase","Integer","num","parseInt","HardhatNetworkForkingConfig","enabled","boolean","url","blockNumber","HardhatNetworkMempoolConfig","order","keyof","fromEntries","HARDHAT_MEMPOOL_SUPPORTED_ORDERS","HardhatNetworkMiningConfig","auto","interval","union","tuple","mempool","isValidHardforkName","Object","values","HardforkName","includes","HardforkNameType","HardhatNetworkHardforkHistory","record","HardhatNetworkChainConfig","hardforkHistory","HardhatNetworkChainsConfig","commonNetworkConfigFields","chainId","from","gas","literal","gasPrice","gasMultiplier","HardhatNetworkConfig","hardfork","HARDHAT_NETWORK_SUPPORTED_HARDFORKS","hf","accounts","array","blockGasLimit","minGasPrice","throwOnTransactionFailures","throwOnCallFailures","allowUnlimitedContractSize","initialDate","loggingEnabled","forking","mining","coinbase","chains","HDAccountsConfig","NetworkConfigAccounts","HttpHeaders","HttpNetworkConfig","httpHeaders","timeout","NetworkConfig","Networks","ProjectPaths","root","cache","artifacts","sources","tests","SingleSolcConfig","version","settings","any","MultiSolcConfig","compilers","overrides","SolidityConfig","HardhatConfig","defaultNetwork","networks","paths","solidity","validateConfig","config","getValidationErrors","errorList","HardhatError","ERRORS","GENERAL","INVALID_CONFIG","hardhatNetwork","HARDHAT_NETWORK_NAME","configExceptAccounts","netConfigResult","Array","isArray","account","entries","hdConfigResult","defaultHardhatNetworkParams","hardforkGte","LONDON","initialBaseFeePerGas","forEach","chainEntry","chainConfig","keys","hardforkName","CANCUN","enableTransientStorage","networkName","netConfig","result","isRight","ioTsErrors","validateResolvedConfig","resolvedConfig","solcConfigs","runs","filter","optimizer","run"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\internal\\core\\config\\config-validation.ts"],"sourcesContent":["import type { HardhatConfig as HardhatConfigT } from \"../../../types\";\nimport type {\n  Context,\n  ValidationError,\n  getFunctionName as getFunctionNameT,\n} from \"io-ts/lib\";\nimport type { Reporter } from \"io-ts/lib/Reporter\";\n\nimport * as t from \"io-ts\";\n\nimport {\n  HARDHAT_MEMPOOL_SUPPORTED_ORDERS,\n  HARDHAT_NETWORK_NAME,\n  HARDHAT_NETWORK_SUPPORTED_HARDFORKS,\n} from \"../../constants\";\nimport { optional } from \"../../util/io-ts\";\nimport { fromEntries } from \"../../util/lang\";\nimport { HardhatError } from \"../errors\";\nimport { ERRORS } from \"../errors-list\";\nimport { hardforkGte, HardforkName } from \"../../util/hardforks\";\nimport { HardhatNetworkChainUserConfig } from \"../../../types/config\";\nimport { defaultHardhatNetworkParams } from \"./default-config\";\n\nfunction stringify(v: any): string {\n  if (typeof v === \"function\") {\n    const { getFunctionName } = require(\"io-ts/lib\") as {\n      getFunctionName: typeof getFunctionNameT;\n    };\n    return getFunctionName(v);\n  }\n  if (typeof v === \"number\" && !isFinite(v)) {\n    if (isNaN(v)) {\n      return \"NaN\";\n    }\n    return v > 0 ? \"Infinity\" : \"-Infinity\";\n  }\n  return JSON.stringify(v);\n}\n\nfunction getContextPath(context: Context): string {\n  const keysPath = context\n    .slice(1)\n    .map((c) => c.key)\n    .join(\".\");\n\n  return `${context[0].type.name}.${keysPath}`;\n}\n\nfunction getMessage(e: ValidationError): string {\n  const lastContext = e.context[e.context.length - 1];\n\n  return e.message !== undefined\n    ? e.message\n    : getErrorMessage(\n        getContextPath(e.context),\n        e.value,\n        lastContext.type.name\n      );\n}\n\nfunction getErrorMessage(path: string, value: any, expectedType: string) {\n  return `Invalid value ${stringify(\n    value\n  )} for ${path} - Expected a value of type ${expectedType}.`;\n}\n\nfunction getPrivateKeyError(index: number, network: string, message: string) {\n  return `Invalid account: #${index} for network: ${network} - ${message}`;\n}\n\nfunction validatePrivateKey(\n  privateKey: unknown,\n  index: number,\n  network: string,\n  errors: string[]\n) {\n  if (typeof privateKey !== \"string\") {\n    errors.push(\n      getPrivateKeyError(\n        index,\n        network,\n        `Expected string, received ${typeof privateKey}`\n      )\n    );\n  } else {\n    // private key validation\n    const pkWithPrefix = /^0x/.test(privateKey)\n      ? privateKey\n      : `0x${privateKey}`;\n\n    // 32 bytes = 64 characters + 2 char prefix = 66\n    if (pkWithPrefix.length < 66) {\n      errors.push(\n        getPrivateKeyError(\n          index,\n          network,\n          \"private key too short, expected 32 bytes\"\n        )\n      );\n    } else if (pkWithPrefix.length > 66) {\n      errors.push(\n        getPrivateKeyError(\n          index,\n          network,\n          \"private key too long, expected 32 bytes\"\n        )\n      );\n    } else if (hexString.decode(pkWithPrefix).isLeft()) {\n      errors.push(\n        getPrivateKeyError(\n          index,\n          network,\n          \"invalid hex character(s) found in string\"\n        )\n      );\n    }\n  }\n}\n\nexport function failure(es: ValidationError[]): string[] {\n  return es.map(getMessage);\n}\n\nexport function success(): string[] {\n  return [];\n}\n\nexport const DotPathReporter: Reporter<string[]> = {\n  report: (validation) => validation.fold(failure, success),\n};\n\nconst HEX_STRING_REGEX = /^(0x)?([0-9a-f]{2})+$/gi;\nconst DEC_STRING_REGEX = /^(0|[1-9][0-9]*)$/g;\n\nfunction isHexString(v: unknown): v is string {\n  if (typeof v !== \"string\") {\n    return false;\n  }\n\n  return v.trim().match(HEX_STRING_REGEX) !== null;\n}\n\nfunction isDecimalString(v: unknown): v is string {\n  if (typeof v !== \"string\") {\n    return false;\n  }\n\n  return v.match(DEC_STRING_REGEX) !== null;\n}\n\nexport const hexString = new t.Type<string>(\n  \"hex string\",\n  isHexString,\n  (u, c) => (isHexString(u) ? t.success(u) : t.failure(u, c)),\n  t.identity\n);\n\nfunction isAddress(v: unknown): v is string {\n  if (typeof v !== \"string\") {\n    return false;\n  }\n\n  const trimmed = v.trim();\n\n  return (\n    trimmed.match(HEX_STRING_REGEX) !== null &&\n    trimmed.startsWith(\"0x\") &&\n    trimmed.length === 42\n  );\n}\n\nexport const address = new t.Type<string>(\n  \"address\",\n  isAddress,\n  (u, c) => (isAddress(u) ? t.success(u) : t.failure(u, c)),\n  t.identity\n);\n\nexport const decimalString = new t.Type<string>(\n  \"decimal string\",\n  isDecimalString,\n  (u, c) => (isDecimalString(u) ? t.success(u) : t.failure(u, c)),\n  t.identity\n);\n// TODO: These types have outdated name. They should match the UserConfig types.\n// IMPORTANT: This t.types MUST be kept in sync with the actual types.\n\nconst HardhatNetworkAccount = t.type({\n  privateKey: hexString,\n  balance: decimalString,\n});\n\nconst commonHDAccountsFields = {\n  initialIndex: optional(t.number),\n  count: optional(t.number),\n  path: optional(t.string),\n};\n\nconst HardhatNetworkHDAccountsConfig = t.type({\n  mnemonic: optional(t.string),\n  accountsBalance: optional(decimalString),\n  passphrase: optional(t.string),\n  ...commonHDAccountsFields,\n});\n\nconst Integer = new t.Type<number>(\n  \"Integer\",\n  (num: unknown): num is number => typeof num === \"number\",\n  (u, c) => {\n    try {\n      return typeof u === \"string\"\n        ? t.success(parseInt(u, 10))\n        : t.failure(u, c);\n    } catch {\n      return t.failure(u, c);\n    }\n  },\n  t.identity\n);\n\nconst HardhatNetworkForkingConfig = t.type({\n  enabled: optional(t.boolean),\n  url: t.string,\n  blockNumber: optional(t.number),\n});\n\nconst HardhatNetworkMempoolConfig = t.type({\n  order: optional(\n    t.keyof(\n      fromEntries(\n        HARDHAT_MEMPOOL_SUPPORTED_ORDERS.map((order) => [order, null])\n      )\n    )\n  ),\n});\n\nconst HardhatNetworkMiningConfig = t.type({\n  auto: optional(t.boolean),\n  interval: optional(t.union([t.number, t.tuple([t.number, t.number])])),\n  mempool: optional(HardhatNetworkMempoolConfig),\n});\n\nfunction isValidHardforkName(name: string) {\n  return Object.values(HardforkName).includes(name as HardforkName);\n}\n\nconst HardforkNameType = new t.Type<HardforkName>(\n  Object.values(HardforkName)\n    .map((v) => `\"${v}\"`)\n    .join(\" | \"),\n  (name: unknown): name is HardforkName =>\n    typeof name === \"string\" && isValidHardforkName(name),\n  (u, c) => {\n    return typeof u === \"string\" && isValidHardforkName(u)\n      ? t.success(u as HardforkName)\n      : t.failure(u, c);\n  },\n  t.identity\n);\n\nconst HardhatNetworkHardforkHistory = t.record(\n  HardforkNameType,\n  t.number,\n  \"HardhatNetworkHardforkHistory\"\n);\n\nconst HardhatNetworkChainConfig = t.type({\n  hardforkHistory: HardhatNetworkHardforkHistory,\n});\n\nconst HardhatNetworkChainsConfig = t.record(Integer, HardhatNetworkChainConfig);\n\nconst commonNetworkConfigFields = {\n  chainId: optional(t.number),\n  from: optional(t.string),\n  gas: optional(t.union([t.literal(\"auto\"), t.number])),\n  gasPrice: optional(t.union([t.literal(\"auto\"), t.number])),\n  gasMultiplier: optional(t.number),\n};\n\nconst HardhatNetworkConfig = t.type({\n  ...commonNetworkConfigFields,\n  hardfork: optional(\n    t.keyof(\n      fromEntries(HARDHAT_NETWORK_SUPPORTED_HARDFORKS.map((hf) => [hf, null]))\n    )\n  ),\n  accounts: optional(\n    t.union([t.array(HardhatNetworkAccount), HardhatNetworkHDAccountsConfig])\n  ),\n  blockGasLimit: optional(t.number),\n  minGasPrice: optional(t.union([t.number, t.string])),\n  throwOnTransactionFailures: optional(t.boolean),\n  throwOnCallFailures: optional(t.boolean),\n  allowUnlimitedContractSize: optional(t.boolean),\n  initialDate: optional(t.string),\n  loggingEnabled: optional(t.boolean),\n  forking: optional(HardhatNetworkForkingConfig),\n  mining: optional(HardhatNetworkMiningConfig),\n  coinbase: optional(address),\n  chains: optional(HardhatNetworkChainsConfig),\n});\n\nconst HDAccountsConfig = t.type({\n  mnemonic: t.string,\n  passphrase: optional(t.string),\n  ...commonHDAccountsFields,\n});\n\nconst NetworkConfigAccounts = t.union([\n  t.literal(\"remote\"),\n  t.array(hexString),\n  HDAccountsConfig,\n]);\n\nconst HttpHeaders = t.record(t.string, t.string, \"httpHeaders\");\n\nconst HttpNetworkConfig = t.type({\n  ...commonNetworkConfigFields,\n  url: optional(t.string),\n  accounts: optional(NetworkConfigAccounts),\n  httpHeaders: optional(HttpHeaders),\n  timeout: optional(t.number),\n});\n\nconst NetworkConfig = t.union([HardhatNetworkConfig, HttpNetworkConfig]);\n\nconst Networks = t.record(t.string, NetworkConfig);\n\nconst ProjectPaths = t.type({\n  root: optional(t.string),\n  cache: optional(t.string),\n  artifacts: optional(t.string),\n  sources: optional(t.string),\n  tests: optional(t.string),\n});\n\nconst SingleSolcConfig = t.type({\n  version: t.string,\n  settings: optional(t.any),\n});\n\nconst MultiSolcConfig = t.type({\n  compilers: t.array(SingleSolcConfig),\n  overrides: optional(t.record(t.string, SingleSolcConfig)),\n});\n\nconst SolidityConfig = t.union([t.string, SingleSolcConfig, MultiSolcConfig]);\n\nconst HardhatConfig = t.type(\n  {\n    defaultNetwork: optional(t.string),\n    networks: optional(Networks),\n    paths: optional(ProjectPaths),\n    solidity: optional(SolidityConfig),\n  },\n  \"HardhatConfig\"\n);\n\n/**\n * Validates the config, throwing a HardhatError if invalid.\n * @param config\n */\nexport function validateConfig(config: any) {\n  const errors = getValidationErrors(config);\n\n  if (errors.length === 0) {\n    return;\n  }\n\n  let errorList = errors.join(\"\\n  * \");\n  errorList = `  * ${errorList}`;\n\n  throw new HardhatError(ERRORS.GENERAL.INVALID_CONFIG, { errors: errorList });\n}\n\nexport function getValidationErrors(config: any): string[] {\n  const errors: string[] = [];\n\n  // These can't be validated with io-ts\n  if (config !== undefined && typeof config.networks === \"object\") {\n    const hardhatNetwork = config.networks[HARDHAT_NETWORK_NAME];\n    if (hardhatNetwork !== undefined && typeof hardhatNetwork === \"object\") {\n      if (\"url\" in hardhatNetwork) {\n        errors.push(\n          `HardhatConfig.networks.${HARDHAT_NETWORK_NAME} can't have an url`\n        );\n      }\n\n      // Validating the accounts with io-ts leads to very confusing errors messages\n      const { accounts, ...configExceptAccounts } = hardhatNetwork;\n\n      const netConfigResult = HardhatNetworkConfig.decode(configExceptAccounts);\n      if (netConfigResult.isLeft()) {\n        errors.push(\n          getErrorMessage(\n            `HardhatConfig.networks.${HARDHAT_NETWORK_NAME}`,\n            hardhatNetwork,\n            \"HardhatNetworkConfig\"\n          )\n        );\n      }\n\n      // manual validation of accounts\n      if (Array.isArray(accounts)) {\n        for (const [index, account] of accounts.entries()) {\n          if (typeof account !== \"object\") {\n            errors.push(\n              getPrivateKeyError(\n                index,\n                HARDHAT_NETWORK_NAME,\n                `Expected object, received ${typeof account}`\n              )\n            );\n            continue;\n          }\n\n          const { privateKey, balance } = account;\n\n          validatePrivateKey(privateKey, index, HARDHAT_NETWORK_NAME, errors);\n\n          if (typeof balance !== \"string\") {\n            errors.push(\n              getErrorMessage(\n                `HardhatConfig.networks.${HARDHAT_NETWORK_NAME}.accounts[].balance`,\n                balance,\n                \"string\"\n              )\n            );\n          } else if (decimalString.decode(balance).isLeft()) {\n            errors.push(\n              getErrorMessage(\n                `HardhatConfig.networks.${HARDHAT_NETWORK_NAME}.accounts[].balance`,\n                balance,\n                \"decimal(wei)\"\n              )\n            );\n          }\n        }\n      } else if (typeof hardhatNetwork.accounts === \"object\") {\n        const hdConfigResult = HardhatNetworkHDAccountsConfig.decode(\n          hardhatNetwork.accounts\n        );\n        if (hdConfigResult.isLeft()) {\n          errors.push(\n            getErrorMessage(\n              `HardhatConfig.networks.${HARDHAT_NETWORK_NAME}.accounts`,\n              hardhatNetwork.accounts,\n              \"[{privateKey: string, balance: string}] | HardhatNetworkHDAccountsConfig | undefined\"\n            )\n          );\n        }\n      } else if (hardhatNetwork.accounts !== undefined) {\n        errors.push(\n          getErrorMessage(\n            `HardhatConfig.networks.${HARDHAT_NETWORK_NAME}.accounts`,\n            hardhatNetwork.accounts,\n            \"[{privateKey: string, balance: string}] | HardhatNetworkHDAccountsConfig | undefined\"\n          )\n        );\n      }\n\n      const hardfork =\n        hardhatNetwork.hardfork ?? defaultHardhatNetworkParams.hardfork;\n      if (hardforkGte(hardfork, HardforkName.LONDON)) {\n        if (hardhatNetwork.minGasPrice !== undefined) {\n          errors.push(\n            `Unexpected config HardhatConfig.networks.${HARDHAT_NETWORK_NAME}.minGasPrice found - This field is not valid for networks with EIP-1559. Try an older hardfork or remove it.`\n          );\n        }\n      } else {\n        if (hardhatNetwork.initialBaseFeePerGas !== undefined) {\n          errors.push(\n            `Unexpected config HardhatConfig.networks.${HARDHAT_NETWORK_NAME}.initialBaseFeePerGas found - This field is only valid for networks with EIP-1559. Try a newer hardfork or remove it.`\n          );\n        }\n      }\n\n      if (hardhatNetwork.chains !== undefined) {\n        Object.entries(hardhatNetwork.chains).forEach((chainEntry) => {\n          const [chainId, chainConfig] = chainEntry as [\n            string,\n            HardhatNetworkChainUserConfig\n          ];\n          const { hardforkHistory } = chainConfig;\n          if (hardforkHistory !== undefined) {\n            Object.keys(hardforkHistory).forEach((hardforkName) => {\n              if (!HARDHAT_NETWORK_SUPPORTED_HARDFORKS.includes(hardforkName)) {\n                errors.push(\n                  getErrorMessage(\n                    `HardhatConfig.networks.${HARDHAT_NETWORK_NAME}.chains[${chainId}].hardforkHistory`,\n                    hardforkName,\n                    `\"${HARDHAT_NETWORK_SUPPORTED_HARDFORKS.join('\" | \"')}\"`\n                  )\n                );\n              }\n            });\n          }\n        });\n      }\n\n      if (hardhatNetwork.hardfork !== undefined) {\n        if (\n          !hardforkGte(hardhatNetwork.hardfork, HardforkName.CANCUN) &&\n          hardhatNetwork.enableTransientStorage === true\n        ) {\n          errors.push(\n            `'enableTransientStorage' cannot be enabled if the hardfork is explicitly set to a pre-cancun value. If you want to use transient storage, use 'cancun' as the hardfork.`\n          );\n        }\n        if (\n          hardforkGte(hardhatNetwork.hardfork, HardforkName.CANCUN) &&\n          hardhatNetwork.enableTransientStorage === false\n        ) {\n          errors.push(\n            `'enableTransientStorage' cannot be disabled if the hardfork is explicitly set to cancun or later. If you want to disable transient storage, use a hardfork before 'cancun'.`\n          );\n        }\n      }\n    }\n\n    for (const [networkName, netConfig] of Object.entries<any>(\n      config.networks\n    )) {\n      if (networkName === HARDHAT_NETWORK_NAME) {\n        continue;\n      }\n\n      if (networkName !== \"localhost\" || netConfig.url !== undefined) {\n        if (typeof netConfig.url !== \"string\") {\n          errors.push(\n            getErrorMessage(\n              `HardhatConfig.networks.${networkName}.url`,\n              netConfig.url,\n              \"string\"\n            )\n          );\n        }\n      }\n\n      const { accounts, ...configExceptAccounts } = netConfig;\n\n      const netConfigResult = HttpNetworkConfig.decode(configExceptAccounts);\n      if (netConfigResult.isLeft()) {\n        errors.push(\n          getErrorMessage(\n            `HardhatConfig.networks.${networkName}`,\n            netConfig,\n            \"HttpNetworkConfig\"\n          )\n        );\n      }\n\n      // manual validation of accounts\n      if (Array.isArray(accounts)) {\n        accounts.forEach((privateKey, index) =>\n          validatePrivateKey(privateKey, index, networkName, errors)\n        );\n      } else if (typeof accounts === \"object\") {\n        const hdConfigResult = HDAccountsConfig.decode(accounts);\n        if (hdConfigResult.isLeft()) {\n          errors.push(\n            getErrorMessage(\n              `HardhatConfig.networks.${networkName}`,\n              accounts,\n              \"HttpNetworkHDAccountsConfig\"\n            )\n          );\n        }\n      } else if (typeof accounts === \"string\") {\n        if (accounts !== \"remote\") {\n          errors.push(\n            `Invalid 'accounts' entry for network '${networkName}': expected an array of accounts or the string 'remote', but got the string '${accounts}'`\n          );\n        }\n      } else if (accounts !== undefined) {\n        errors.push(\n          getErrorMessage(\n            `HardhatConfig.networks.${networkName}.accounts`,\n            accounts,\n            '\"remote\" | string[] | HttpNetworkHDAccountsConfig | undefined'\n          )\n        );\n      }\n    }\n  }\n\n  // io-ts can get confused if there are errors that it can't understand.\n  // Especially around Hardhat Network's config. It will treat it as an HTTPConfig,\n  // and may give a loot of errors.\n  if (errors.length > 0) {\n    return errors;\n  }\n\n  const result = HardhatConfig.decode(config);\n\n  if (result.isRight()) {\n    return errors;\n  }\n\n  const ioTsErrors = DotPathReporter.report(result);\n  return [...errors, ...ioTsErrors];\n}\n\nexport function validateResolvedConfig(resolvedConfig: HardhatConfigT) {\n  const solcConfigs = [\n    ...resolvedConfig.solidity.compilers,\n    ...Object.values(resolvedConfig.solidity.overrides),\n  ];\n  const runs = solcConfigs\n    .filter(({ settings }) => settings?.optimizer?.runs !== undefined)\n    .map(({ settings }) => settings?.optimizer?.runs);\n\n  for (const run of runs) {\n    if (run >= 2 ** 32) {\n      throw new HardhatError(ERRORS.GENERAL.INVALID_CONFIG, {\n        errors: \"The number of optimizer runs exceeds the maximum of 2**32 - 1\",\n      });\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}