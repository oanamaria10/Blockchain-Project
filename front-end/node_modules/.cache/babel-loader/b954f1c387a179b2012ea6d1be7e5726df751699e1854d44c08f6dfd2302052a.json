{"ast":null,"code":"/**\n * ASN1 Tags as per https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nconst TAG_SIZE = 1;\nexport const INT_TAG = 0x02;\nexport const BITSTRING_TAG = 0x03;\nexport const OCTET_STRING_TAG = 0x04;\nexport const NULL_TAG = 0x05;\nexport const OBJECT_TAG = 0x06;\nexport const SEQUENCE_TAG = 0x30;\nexport const UNUSED_BIT_PAD = 0x00;\n\n/**\n * @param {number} length\n * @returns {Uint8Array}\n */\nexport const encodeDERLength = length => {\n  if (length <= 127) {\n    return new Uint8Array([length]);\n  }\n\n  /** @type {number[]} */\n  const octets = [];\n  while (length !== 0) {\n    octets.push(length & 0xff);\n    length = length >>> 8;\n  }\n  octets.reverse();\n  return new Uint8Array([0x80 | octets.length & 0xff, ...octets]);\n};\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {{number: number, consumed: number}}\n */\nexport const readDERLength = (bytes, offset = 0) => {\n  if ((bytes[offset] & 0x80) === 0) {\n    return {\n      number: bytes[offset],\n      consumed: 1\n    };\n  }\n  const numberBytes = bytes[offset] & 0x7f;\n  /* c8 ignore next 5 */\n  if (bytes.length < numberBytes + 1) {\n    throw new Error(`ASN parsing error: Too few bytes. Expected encoded length's length to be at least ${numberBytes}`);\n  }\n  let length = 0;\n  for (let i = 0; i < numberBytes; i++) {\n    length = length << 8;\n    length = length | bytes[offset + i + 1];\n  }\n  return {\n    number: length,\n    consumed: numberBytes + 1\n  };\n};\n\n/**\n * @param {Uint8Array} input\n * @param {number} expectedTag\n * @param {number} position\n * @returns {number}\n */\nexport const skip = (input, expectedTag, position) => {\n  const parsed = into(input, expectedTag, position);\n  return parsed.position + parsed.length;\n};\n\n/**\n * @param {Uint8Array} input\n * @param {number} expectedTag\n * @param {number} offset\n * @returns {{ position: number, length: number }}\n */\nexport const into = (input, expectedTag, offset) => {\n  const actualTag = input[offset];\n  /* c8 ignore next 7 */\n  if (actualTag !== expectedTag) {\n    throw new Error(`ASN parsing error: Expected tag 0x${expectedTag.toString(16)} at position ${offset}, but got 0x${actualTag.toString(16)}.`);\n  }\n\n  // length\n  const length = readDERLength(input, offset + TAG_SIZE);\n  const position = offset + TAG_SIZE + length.consumed;\n\n  // content\n  return {\n    position,\n    length: length.number\n  };\n};\n\n/**\n * @param {Uint8Array} input\n */\nexport const encodeBitString = input => {\n  // encode input length + 1 for unused bit pad\n  const length = encodeDERLength(input.byteLength + 1);\n  // allocate a buffer of desired size\n  const bytes = new Uint8Array(TAG_SIZE +\n  // ASN_BITSTRING_TAG\n  length.byteLength + 1 +\n  // amount of unused bits at the end of our bitstring\n  input.byteLength);\n  let byteOffset = 0;\n  // write bytestring tag\n  bytes[byteOffset] = BITSTRING_TAG;\n  byteOffset += TAG_SIZE;\n\n  // write length of the bytestring\n  bytes.set(length, byteOffset);\n  byteOffset += length.byteLength;\n\n  // write unused bits at the end of our bitstring\n  bytes[byteOffset] = UNUSED_BIT_PAD;\n  byteOffset += 1;\n\n  // write actual data into bitstring\n  bytes.set(input, byteOffset);\n  return bytes;\n};\n\n/**\n * @param {Uint8Array} input\n */\nexport const encodeOctetString = input => {\n  // encode input length\n  const length = encodeDERLength(input.byteLength);\n  // allocate a buffer of desired size\n  const bytes = new Uint8Array(TAG_SIZE + length.byteLength + input.byteLength);\n  let byteOffset = 0;\n  // write octet string tag\n  bytes[byteOffset] = OCTET_STRING_TAG;\n  byteOffset += TAG_SIZE;\n\n  // write octet string length\n  bytes.set(length, byteOffset);\n  byteOffset += length.byteLength;\n\n  // write actual data into bitstring\n  bytes.set(input, byteOffset);\n  return bytes;\n};\n\n/**\n * @param {Uint8Array[]} sequence\n */\nexport const encodeSequence = sequence => {\n  // calculate bytelength for all the parts\n  let byteLength = 0;\n  for (const item of sequence) {\n    byteLength += item.byteLength;\n  }\n\n  // encode sequence byte length\n  const length = encodeDERLength(byteLength);\n\n  // allocate the buffer to write sequence into\n  const bytes = new Uint8Array(TAG_SIZE + length.byteLength + byteLength);\n  let byteOffset = 0;\n\n  // write the sequence tag\n  bytes[byteOffset] = SEQUENCE_TAG;\n  byteOffset += TAG_SIZE;\n\n  // write sequence length\n  bytes.set(length, byteOffset);\n  byteOffset += length.byteLength;\n\n  // write each item in the sequence\n  for (const item of sequence) {\n    bytes.set(item, byteOffset);\n    byteOffset += item.byteLength;\n  }\n  return bytes;\n};\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n */\nexport const readSequence = (bytes, offset = 0) => {\n  const {\n    position,\n    length\n  } = into(bytes, SEQUENCE_TAG, offset);\n  return new Uint8Array(bytes.buffer, bytes.byteOffset + position, length);\n};\n\n/**\n * @param {Uint8Array} input\n */\nexport const encodeInt = input => {\n  const extra = input.byteLength === 0 || input[0] & 0x80 ? 1 : 0;\n\n  // encode input length\n  const length = encodeDERLength(input.byteLength + extra);\n  // allocate a buffer of desired size\n  const bytes = new Uint8Array(TAG_SIZE +\n  // INT_TAG\n  length.byteLength + input.byteLength + extra);\n  let byteOffset = 0;\n  // write octet string tag\n  bytes[byteOffset] = INT_TAG;\n  byteOffset += TAG_SIZE;\n\n  // write int length\n  bytes.set(length, byteOffset);\n  byteOffset += length.byteLength;\n\n  // add 0 if the most-significant bit is set\n  if (extra > 0) {\n    bytes[byteOffset] = UNUSED_BIT_PAD;\n    byteOffset += extra;\n  }\n\n  // write actual data into bitstring\n  bytes.set(input, byteOffset);\n  return bytes;\n};\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {number}\n */\n\nexport const enterSequence = (bytes, offset = 0) => into(bytes, SEQUENCE_TAG, offset).position;\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {number}\n */\nexport const skipSequence = (bytes, offset = 0) => skip(bytes, SEQUENCE_TAG, offset);\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {number}\n */\nexport const skipInt = (bytes, offset = 0) => skip(bytes, INT_TAG, offset);\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {Uint8Array}\n */\nexport const readBitString = (bytes, offset = 0) => {\n  const {\n    position,\n    length\n  } = into(bytes, BITSTRING_TAG, offset);\n  const tag = bytes[position];\n  /* c8 ignore next 5 */\n  if (tag !== UNUSED_BIT_PAD) {\n    throw new Error(`Can not read bitstring, expected length to be multiple of 8, but got ${tag} unused bits in last byte.`);\n  }\n  return new Uint8Array(bytes.buffer, bytes.byteOffset + position + 1, length - 1);\n};\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} byteOffset\n * @returns {Uint8Array}\n */\nexport const readInt = (bytes, byteOffset = 0) => {\n  const {\n    position,\n    length\n  } = into(bytes, INT_TAG, byteOffset);\n  let delta = 0;\n\n  // drop leading 0s\n  while (bytes[position + delta] === 0) {\n    delta++;\n  }\n  return new Uint8Array(bytes.buffer, bytes.byteOffset + position + delta, length - delta);\n};\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {Uint8Array}\n */\nexport const readOctetString = (bytes, offset = 0) => {\n  const {\n    position,\n    length\n  } = into(bytes, OCTET_STRING_TAG, offset);\n  return new Uint8Array(bytes.buffer, bytes.byteOffset + position, length);\n};\n\n/**\n * @typedef {(bytes:Uint8Array, offset:number) => Uint8Array} Reader\n * @param {[Reader, ...Reader[]]} readers\n * @param {Uint8Array} source\n * @param {number} byteOffset\n */\nexport const readSequenceWith = (readers, source, byteOffset = 0) => {\n  const results = [];\n  const sequence = readSequence(source, byteOffset);\n  let offset = 0;\n  for (const read of readers) {\n    const chunk = read(sequence, offset);\n    results.push(chunk);\n    offset = chunk.byteOffset + chunk.byteLength - sequence.byteOffset;\n  }\n  return results;\n};","map":{"version":3,"names":["TAG_SIZE","INT_TAG","BITSTRING_TAG","OCTET_STRING_TAG","NULL_TAG","OBJECT_TAG","SEQUENCE_TAG","UNUSED_BIT_PAD","encodeDERLength","length","Uint8Array","octets","push","reverse","readDERLength","bytes","offset","number","consumed","numberBytes","Error","i","skip","input","expectedTag","position","parsed","into","actualTag","toString","encodeBitString","byteLength","byteOffset","set","encodeOctetString","encodeSequence","sequence","item","readSequence","buffer","encodeInt","extra","enterSequence","skipSequence","skipInt","readBitString","tag","readInt","delta","readOctetString","readSequenceWith","readers","source","results","read","chunk"],"sources":["C:/FACULTATE/Proiect/node_modules/@ucanto/principal/src/rsa/asn1.js"],"sourcesContent":["/**\n * ASN1 Tags as per https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nconst TAG_SIZE = 1\nexport const INT_TAG = 0x02\nexport const BITSTRING_TAG = 0x03\nexport const OCTET_STRING_TAG = 0x04\nexport const NULL_TAG = 0x05\nexport const OBJECT_TAG = 0x06\nexport const SEQUENCE_TAG = 0x30\n\nexport const UNUSED_BIT_PAD = 0x00\n\n/**\n * @param {number} length\n * @returns {Uint8Array}\n */\nexport const encodeDERLength = length => {\n  if (length <= 127) {\n    return new Uint8Array([length])\n  }\n\n  /** @type {number[]} */\n  const octets = []\n  while (length !== 0) {\n    octets.push(length & 0xff)\n    length = length >>> 8\n  }\n  octets.reverse()\n  return new Uint8Array([0x80 | (octets.length & 0xff), ...octets])\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {{number: number, consumed: number}}\n */\nexport const readDERLength = (bytes, offset = 0) => {\n  if ((bytes[offset] & 0x80) === 0) {\n    return { number: bytes[offset], consumed: 1 }\n  }\n\n  const numberBytes = bytes[offset] & 0x7f\n  /* c8 ignore next 5 */\n  if (bytes.length < numberBytes + 1) {\n    throw new Error(\n      `ASN parsing error: Too few bytes. Expected encoded length's length to be at least ${numberBytes}`\n    )\n  }\n\n  let length = 0\n  for (let i = 0; i < numberBytes; i++) {\n    length = length << 8\n    length = length | bytes[offset + i + 1]\n  }\n\n  return { number: length, consumed: numberBytes + 1 }\n}\n\n/**\n * @param {Uint8Array} input\n * @param {number} expectedTag\n * @param {number} position\n * @returns {number}\n */\nexport const skip = (input, expectedTag, position) => {\n  const parsed = into(input, expectedTag, position)\n  return parsed.position + parsed.length\n}\n\n/**\n * @param {Uint8Array} input\n * @param {number} expectedTag\n * @param {number} offset\n * @returns {{ position: number, length: number }}\n */\nexport const into = (input, expectedTag, offset) => {\n  const actualTag = input[offset]\n  /* c8 ignore next 7 */\n  if (actualTag !== expectedTag) {\n    throw new Error(\n      `ASN parsing error: Expected tag 0x${expectedTag.toString(\n        16\n      )} at position ${offset}, but got 0x${actualTag.toString(16)}.`\n    )\n  }\n\n  // length\n  const length = readDERLength(input, offset + TAG_SIZE)\n  const position = offset + TAG_SIZE + length.consumed\n\n  // content\n  return { position, length: length.number }\n}\n\n/**\n * @param {Uint8Array} input\n */\nexport const encodeBitString = input => {\n  // encode input length + 1 for unused bit pad\n  const length = encodeDERLength(input.byteLength + 1)\n  // allocate a buffer of desired size\n  const bytes = new Uint8Array(\n    TAG_SIZE + // ASN_BITSTRING_TAG\n      length.byteLength +\n      1 + // amount of unused bits at the end of our bitstring\n      input.byteLength\n  )\n\n  let byteOffset = 0\n  // write bytestring tag\n  bytes[byteOffset] = BITSTRING_TAG\n  byteOffset += TAG_SIZE\n\n  // write length of the bytestring\n  bytes.set(length, byteOffset)\n  byteOffset += length.byteLength\n\n  // write unused bits at the end of our bitstring\n  bytes[byteOffset] = UNUSED_BIT_PAD\n  byteOffset += 1\n\n  // write actual data into bitstring\n  bytes.set(input, byteOffset)\n\n  return bytes\n}\n\n/**\n * @param {Uint8Array} input\n */\nexport const encodeOctetString = input => {\n  // encode input length\n  const length = encodeDERLength(input.byteLength)\n  // allocate a buffer of desired size\n  const bytes = new Uint8Array(TAG_SIZE + length.byteLength + input.byteLength)\n\n  let byteOffset = 0\n  // write octet string tag\n  bytes[byteOffset] = OCTET_STRING_TAG\n  byteOffset += TAG_SIZE\n\n  // write octet string length\n  bytes.set(length, byteOffset)\n  byteOffset += length.byteLength\n\n  // write actual data into bitstring\n  bytes.set(input, byteOffset)\n\n  return bytes\n}\n\n/**\n * @param {Uint8Array[]} sequence\n */\nexport const encodeSequence = sequence => {\n  // calculate bytelength for all the parts\n  let byteLength = 0\n  for (const item of sequence) {\n    byteLength += item.byteLength\n  }\n\n  // encode sequence byte length\n  const length = encodeDERLength(byteLength)\n\n  // allocate the buffer to write sequence into\n  const bytes = new Uint8Array(TAG_SIZE + length.byteLength + byteLength)\n\n  let byteOffset = 0\n\n  // write the sequence tag\n  bytes[byteOffset] = SEQUENCE_TAG\n  byteOffset += TAG_SIZE\n\n  // write sequence length\n  bytes.set(length, byteOffset)\n  byteOffset += length.byteLength\n\n  // write each item in the sequence\n  for (const item of sequence) {\n    bytes.set(item, byteOffset)\n    byteOffset += item.byteLength\n  }\n\n  return bytes\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n */\nexport const readSequence = (bytes, offset = 0) => {\n  const { position, length } = into(bytes, SEQUENCE_TAG, offset)\n\n  return new Uint8Array(bytes.buffer, bytes.byteOffset + position, length)\n}\n\n/**\n * @param {Uint8Array} input\n */\nexport const encodeInt = input => {\n  const extra = input.byteLength === 0 || input[0] & 0x80 ? 1 : 0\n\n  // encode input length\n  const length = encodeDERLength(input.byteLength + extra)\n  // allocate a buffer of desired size\n  const bytes = new Uint8Array(\n    TAG_SIZE + // INT_TAG\n      length.byteLength +\n      input.byteLength +\n      extra\n  )\n\n  let byteOffset = 0\n  // write octet string tag\n  bytes[byteOffset] = INT_TAG\n  byteOffset += TAG_SIZE\n\n  // write int length\n  bytes.set(length, byteOffset)\n  byteOffset += length.byteLength\n\n  // add 0 if the most-significant bit is set\n  if (extra > 0) {\n    bytes[byteOffset] = UNUSED_BIT_PAD\n    byteOffset += extra\n  }\n\n  // write actual data into bitstring\n  bytes.set(input, byteOffset)\n\n  return bytes\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {number}\n */\n\nexport const enterSequence = (bytes, offset = 0) =>\n  into(bytes, SEQUENCE_TAG, offset).position\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {number}\n */\nexport const skipSequence = (bytes, offset = 0) =>\n  skip(bytes, SEQUENCE_TAG, offset)\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {number}\n */\nexport const skipInt = (bytes, offset = 0) => skip(bytes, INT_TAG, offset)\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {Uint8Array}\n */\nexport const readBitString = (bytes, offset = 0) => {\n  const { position, length } = into(bytes, BITSTRING_TAG, offset)\n  const tag = bytes[position]\n  /* c8 ignore next 5 */\n  if (tag !== UNUSED_BIT_PAD) {\n    throw new Error(\n      `Can not read bitstring, expected length to be multiple of 8, but got ${tag} unused bits in last byte.`\n    )\n  }\n\n  return new Uint8Array(\n    bytes.buffer,\n    bytes.byteOffset + position + 1,\n    length - 1\n  )\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} byteOffset\n * @returns {Uint8Array}\n */\nexport const readInt = (bytes, byteOffset = 0) => {\n  const { position, length } = into(bytes, INT_TAG, byteOffset)\n  let delta = 0\n\n  // drop leading 0s\n  while (bytes[position + delta] === 0) {\n    delta++\n  }\n\n  return new Uint8Array(\n    bytes.buffer,\n    bytes.byteOffset + position + delta,\n    length - delta\n  )\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {Uint8Array}\n */\nexport const readOctetString = (bytes, offset = 0) => {\n  const { position, length } = into(bytes, OCTET_STRING_TAG, offset)\n\n  return new Uint8Array(bytes.buffer, bytes.byteOffset + position, length)\n}\n\n/**\n * @typedef {(bytes:Uint8Array, offset:number) => Uint8Array} Reader\n * @param {[Reader, ...Reader[]]} readers\n * @param {Uint8Array} source\n * @param {number} byteOffset\n */\nexport const readSequenceWith = (readers, source, byteOffset = 0) => {\n  const results = []\n  const sequence = readSequence(source, byteOffset)\n  let offset = 0\n  for (const read of readers) {\n    const chunk = read(sequence, offset)\n    results.push(chunk)\n    offset = chunk.byteOffset + chunk.byteLength - sequence.byteOffset\n  }\n  return results\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}