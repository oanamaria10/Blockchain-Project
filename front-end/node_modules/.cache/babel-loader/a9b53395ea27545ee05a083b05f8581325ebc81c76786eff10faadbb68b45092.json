{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Resolver = exports.ResolvedFile = void 0;\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\nconst path_1 = __importDefault(require(\"path\"));\nconst resolve_1 = __importDefault(require(\"resolve\"));\nconst source_names_1 = require(\"../../utils/source-names\");\nconst errors_1 = require(\"../core/errors\");\nconst errors_list_1 = require(\"../core/errors-list\");\nconst hash_1 = require(\"../util/hash\");\nconst fs_utils_1 = require(\"../util/fs-utils\");\nconst remappings_1 = require(\"../../utils/remappings\");\nconst NODE_MODULES = \"node_modules\";\nclass ResolvedFile {\n  constructor(sourceName, absolutePath, content, contentHash, lastModificationDate, libraryName, libraryVersion) {\n    this.sourceName = sourceName;\n    this.absolutePath = absolutePath;\n    this.content = content;\n    this.contentHash = contentHash;\n    this.lastModificationDate = lastModificationDate;\n    (0, errors_1.assertHardhatInvariant)(libraryName === undefined && libraryVersion === undefined || libraryName !== undefined && libraryVersion !== undefined, \"Libraries should have both name and version, or neither one\");\n    if (libraryName !== undefined && libraryVersion !== undefined) {\n      this.library = {\n        name: libraryName,\n        version: libraryVersion\n      };\n    }\n  }\n  getVersionedName() {\n    return this.sourceName + (this.library !== undefined ? `@v${this.library.version}` : \"\");\n  }\n}\nexports.ResolvedFile = ResolvedFile;\nclass Resolver {\n  constructor(_projectRoot, _parser, _remappings, _readFile, _transformImportName) {\n    this._projectRoot = _projectRoot;\n    this._parser = _parser;\n    this._remappings = _remappings;\n    this._readFile = _readFile;\n    this._transformImportName = _transformImportName;\n    this._cache = new Map();\n  }\n  /**\n   * Resolves a source name into a ResolvedFile.\n   *\n   * @param sourceName The source name as it would be provided to solc.\n   */\n  async resolveSourceName(sourceName) {\n    const cached = this._cache.get(sourceName);\n    if (cached !== undefined) {\n      return cached;\n    }\n    const remappedSourceName = (0, remappings_1.applyRemappings)(this._remappings, sourceName);\n    (0, source_names_1.validateSourceNameFormat)(remappedSourceName);\n    let resolvedFile;\n    if (await (0, source_names_1.isLocalSourceName)(this._projectRoot, remappedSourceName)) {\n      resolvedFile = await this._resolveLocalSourceName(sourceName, remappedSourceName);\n    } else {\n      resolvedFile = await this._resolveLibrarySourceName(sourceName, remappedSourceName);\n    }\n    this._cache.set(sourceName, resolvedFile);\n    return resolvedFile;\n  }\n  /**\n   * Resolves an import from an already resolved file.\n   * @param from The file were the import statement is present.\n   * @param importName The path in the import statement.\n   */\n  async resolveImport(from, importName) {\n    // sanity check for deprecated task\n    if (importName !== (await this._transformImportName(importName))) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.TASK_DEFINITIONS.DEPRECATED_TRANSFORM_IMPORT_TASK);\n    }\n    const imported = (0, remappings_1.applyRemappings)(this._remappings, importName);\n    const scheme = this._getUriScheme(imported);\n    if (scheme !== undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_PROTOCOL, {\n        from: from.sourceName,\n        imported,\n        protocol: scheme\n      });\n    }\n    if ((0, source_names_1.replaceBackslashes)(imported) !== imported) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_BACKSLASH, {\n        from: from.sourceName,\n        imported\n      });\n    }\n    if ((0, source_names_1.isAbsolutePathSourceName)(imported)) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_ABSOLUTE_PATH, {\n        from: from.sourceName,\n        imported\n      });\n    }\n    // Edge-case where an import can contain the current package's name in monorepos.\n    // The path can be resolved because there's a symlink in the node modules.\n    if (await (0, source_names_1.includesOwnPackageName)(imported)) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INCLUDES_OWN_PACKAGE_NAME, {\n        from: from.sourceName,\n        imported\n      });\n    }\n    try {\n      let sourceName;\n      const isRelativeImport = this._isRelativeImport(imported);\n      if (isRelativeImport) {\n        sourceName = await this._relativeImportToSourceName(from, imported);\n      } else {\n        sourceName = (0, source_names_1.normalizeSourceName)(importName); // The sourceName of the imported file is not transformed\n      }\n      const cached = this._cache.get(sourceName);\n      if (cached !== undefined) {\n        return cached;\n      }\n      let resolvedFile;\n      // We have this special case here, because otherwise local relative\n      // imports can be treated as library imports. For example if\n      // `contracts/c.sol` imports `../non-existent/a.sol`\n      if (from.library === undefined && isRelativeImport && !this._isRelativeImportToLibrary(from, imported)) {\n        resolvedFile = await this._resolveLocalSourceName(sourceName, (0, remappings_1.applyRemappings)(this._remappings, sourceName));\n      } else {\n        resolvedFile = await this.resolveSourceName(sourceName);\n      }\n      this._cache.set(sourceName, resolvedFile);\n      return resolvedFile;\n    } catch (error) {\n      if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.RESOLVER.FILE_NOT_FOUND) || errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.RESOLVER.LIBRARY_FILE_NOT_FOUND)) {\n        if (imported !== importName) {\n          throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.IMPORTED_MAPPED_FILE_NOT_FOUND, {\n            imported,\n            importName,\n            from: from.sourceName\n          }, error);\n        } else {\n          throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.IMPORTED_FILE_NOT_FOUND, {\n            imported,\n            from: from.sourceName\n          }, error);\n        }\n      }\n      if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.RESOLVER.WRONG_SOURCE_NAME_CASING)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_WRONG_CASING, {\n          imported,\n          from: from.sourceName\n        }, error);\n      }\n      if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.RESOLVER.LIBRARY_NOT_INSTALLED)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.IMPORTED_LIBRARY_NOT_INSTALLED, {\n          library: error.messageArguments.library,\n          from: from.sourceName\n        }, error);\n      }\n      if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.GENERAL.INVALID_READ_OF_DIRECTORY)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_OF_DIRECTORY, {\n          imported,\n          from: from.sourceName\n        }, error);\n      }\n      // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n  }\n  async _resolveLocalSourceName(sourceName, remappedSourceName) {\n    await this._validateSourceNameExistenceAndCasing(this._projectRoot, remappedSourceName, false);\n    const absolutePath = path_1.default.join(this._projectRoot, remappedSourceName);\n    return this._resolveFile(sourceName, absolutePath);\n  }\n  async _resolveLibrarySourceName(sourceName, remappedSourceName) {\n    const normalizedSourceName = remappedSourceName.replace(/^node_modules\\//, \"\");\n    const libraryName = this._getLibraryName(normalizedSourceName);\n    let packageJsonPath;\n    try {\n      packageJsonPath = this._resolveNodeModulesFileFromProjectRoot(path_1.default.join(libraryName, \"package.json\"));\n    } catch (error) {\n      // if the project is using a dependency from hardhat itself but it can't\n      // be found, this means that a global installation is being used, so we\n      // resolve the dependency relative to this file\n      if (libraryName === \"hardhat\") {\n        const hardhatCoreDir = path_1.default.join(__dirname, \"..\", \"..\");\n        packageJsonPath = path_1.default.join(hardhatCoreDir, \"package.json\");\n      } else {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.LIBRARY_NOT_INSTALLED, {\n          library: libraryName\n        }, error);\n      }\n    }\n    let nodeModulesPath = path_1.default.dirname(path_1.default.dirname(packageJsonPath));\n    if (this._isScopedPackage(normalizedSourceName)) {\n      nodeModulesPath = path_1.default.dirname(nodeModulesPath);\n    }\n    let absolutePath;\n    if (path_1.default.basename(nodeModulesPath) !== NODE_MODULES) {\n      // this can happen in monorepos that use PnP, in those\n      // cases we handle resolution differently\n      const packageRoot = path_1.default.dirname(packageJsonPath);\n      const pattern = new RegExp(`^${libraryName}/?`);\n      const fileName = normalizedSourceName.replace(pattern, \"\");\n      await this._validateSourceNameExistenceAndCasing(packageRoot,\n      // TODO: this is _not_ a source name; we should handle this scenario in\n      // a better way\n      fileName, true);\n      absolutePath = path_1.default.join(packageRoot, fileName);\n    } else {\n      await this._validateSourceNameExistenceAndCasing(nodeModulesPath, normalizedSourceName, true);\n      absolutePath = path_1.default.join(nodeModulesPath, normalizedSourceName);\n    }\n    const packageInfo = await fs_extra_1.default.readJson(packageJsonPath);\n    const libraryVersion = packageInfo.version;\n    return this._resolveFile(sourceName,\n    // We resolve to the real path here, as we may be resolving a linked library\n    await (0, fs_utils_1.getRealPath)(absolutePath), libraryName, libraryVersion);\n  }\n  async _relativeImportToSourceName(from, imported) {\n    // This is a special case, were we turn relative imports from local files\n    // into library imports if necessary. The reason for this is that many\n    // users just do `import \"../node_modules/lib/a.sol\";`.\n    if (this._isRelativeImportToLibrary(from, imported)) {\n      return this._relativeImportToLibraryToSourceName(from, imported);\n    }\n    const sourceName = (0, source_names_1.normalizeSourceName)(path_1.default.join(path_1.default.dirname(from.sourceName), imported));\n    // If the file with the import is local, and the normalized version\n    // starts with ../ means that it's trying to get outside of the project.\n    if (from.library === undefined && sourceName.startsWith(\"../\")) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_OUTSIDE_OF_PROJECT, {\n        from: from.sourceName,\n        imported\n      });\n    }\n    if (from.library !== undefined && !this._isInsideSameDir(from.sourceName, sourceName)) {\n      // If the file is being imported from a library, this means that it's\n      // trying to reach another one.\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.ILLEGAL_IMPORT, {\n        from: from.sourceName,\n        imported\n      });\n    }\n    return sourceName;\n  }\n  async _resolveFile(sourceName, absolutePath, libraryName, libraryVersion) {\n    const rawContent = await this._readFile(absolutePath);\n    const stats = await fs_extra_1.default.stat(absolutePath);\n    const lastModificationDate = new Date(stats.ctime);\n    const contentHash = (0, hash_1.createNonCryptographicHashBasedIdentifier)(Buffer.from(rawContent)).toString(\"hex\");\n    const parsedContent = this._parser.parse(rawContent, absolutePath, contentHash);\n    const content = {\n      rawContent,\n      ...parsedContent\n    };\n    return new ResolvedFile(sourceName, absolutePath, content, contentHash, lastModificationDate, libraryName, libraryVersion);\n  }\n  _isRelativeImport(imported) {\n    return imported.startsWith(\"./\") || imported.startsWith(\"../\");\n  }\n  _resolveNodeModulesFileFromProjectRoot(fileName) {\n    return resolve_1.default.sync(fileName, {\n      basedir: this._projectRoot,\n      preserveSymlinks: true\n    });\n  }\n  _getLibraryName(sourceName) {\n    let endIndex;\n    if (this._isScopedPackage(sourceName)) {\n      endIndex = sourceName.indexOf(\"/\", sourceName.indexOf(\"/\") + 1);\n    } else if (sourceName.indexOf(\"/\") === -1) {\n      endIndex = sourceName.length;\n    } else {\n      endIndex = sourceName.indexOf(\"/\");\n    }\n    return sourceName.slice(0, endIndex);\n  }\n  _getUriScheme(s) {\n    const re = /([a-zA-Z]+):\\/\\//;\n    const match = re.exec(s);\n    if (match === null) {\n      return undefined;\n    }\n    return match[1];\n  }\n  _isInsideSameDir(sourceNameInDir, sourceNameToTest) {\n    const firstSlash = sourceNameInDir.indexOf(\"/\");\n    const dir = firstSlash !== -1 ? sourceNameInDir.substring(0, firstSlash) : sourceNameInDir;\n    return sourceNameToTest.startsWith(dir);\n  }\n  _isScopedPackage(packageOrPackageFile) {\n    return packageOrPackageFile.startsWith(\"@\");\n  }\n  _isRelativeImportToLibrary(from, imported) {\n    return this._isRelativeImport(imported) && from.library === undefined && imported.includes(`${NODE_MODULES}/`);\n  }\n  _relativeImportToLibraryToSourceName(from, imported) {\n    const sourceName = (0, source_names_1.normalizeSourceName)(path_1.default.join(path_1.default.dirname(from.sourceName), imported));\n    const nmIndex = sourceName.indexOf(`${NODE_MODULES}/`);\n    return sourceName.substr(nmIndex + NODE_MODULES.length + 1);\n  }\n  async _validateSourceNameExistenceAndCasing(fromDir, sourceName, isLibrary) {\n    try {\n      await (0, source_names_1.validateSourceNameExistenceAndCasing)(fromDir, sourceName);\n    } catch (error) {\n      if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.SOURCE_NAMES.FILE_NOT_FOUND)) {\n        throw new errors_1.HardhatError(isLibrary ? errors_list_1.ERRORS.RESOLVER.LIBRARY_FILE_NOT_FOUND : errors_list_1.ERRORS.RESOLVER.FILE_NOT_FOUND, {\n          file: sourceName\n        }, error);\n      }\n      if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.SOURCE_NAMES.WRONG_CASING)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.WRONG_SOURCE_NAME_CASING, {\n          incorrect: sourceName,\n          correct: error.messageArguments.correct\n        }, error);\n      }\n      // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n  }\n}\nexports.Resolver = Resolver;","map":{"version":3,"names":["fs_extra_1","__importDefault","require","path_1","resolve_1","source_names_1","errors_1","errors_list_1","hash_1","fs_utils_1","remappings_1","NODE_MODULES","ResolvedFile","constructor","sourceName","absolutePath","content","contentHash","lastModificationDate","libraryName","libraryVersion","assertHardhatInvariant","undefined","library","name","version","getVersionedName","exports","Resolver","_projectRoot","_parser","_remappings","_readFile","_transformImportName","_cache","Map","resolveSourceName","cached","get","remappedSourceName","applyRemappings","validateSourceNameFormat","resolvedFile","isLocalSourceName","_resolveLocalSourceName","_resolveLibrarySourceName","set","resolveImport","from","importName","HardhatError","ERRORS","TASK_DEFINITIONS","DEPRECATED_TRANSFORM_IMPORT_TASK","imported","scheme","_getUriScheme","RESOLVER","INVALID_IMPORT_PROTOCOL","protocol","replaceBackslashes","INVALID_IMPORT_BACKSLASH","isAbsolutePathSourceName","INVALID_IMPORT_ABSOLUTE_PATH","includesOwnPackageName","INCLUDES_OWN_PACKAGE_NAME","isRelativeImport","_isRelativeImport","_relativeImportToSourceName","normalizeSourceName","_isRelativeImportToLibrary","error","isHardhatErrorType","FILE_NOT_FOUND","LIBRARY_FILE_NOT_FOUND","IMPORTED_MAPPED_FILE_NOT_FOUND","IMPORTED_FILE_NOT_FOUND","WRONG_SOURCE_NAME_CASING","INVALID_IMPORT_WRONG_CASING","LIBRARY_NOT_INSTALLED","IMPORTED_LIBRARY_NOT_INSTALLED","messageArguments","GENERAL","INVALID_READ_OF_DIRECTORY","INVALID_IMPORT_OF_DIRECTORY","_validateSourceNameExistenceAndCasing","default","join","_resolveFile","normalizedSourceName","replace","_getLibraryName","packageJsonPath","_resolveNodeModulesFileFromProjectRoot","hardhatCoreDir","__dirname","nodeModulesPath","dirname","_isScopedPackage","basename","packageRoot","pattern","RegExp","fileName","packageInfo","readJson","getRealPath","_relativeImportToLibraryToSourceName","startsWith","INVALID_IMPORT_OUTSIDE_OF_PROJECT","_isInsideSameDir","ILLEGAL_IMPORT","rawContent","stats","stat","Date","ctime","createNonCryptographicHashBasedIdentifier","Buffer","toString","parsedContent","parse","sync","basedir","preserveSymlinks","endIndex","indexOf","length","slice","s","re","match","exec","sourceNameInDir","sourceNameToTest","firstSlash","dir","substring","packageOrPackageFile","includes","nmIndex","substr","fromDir","isLibrary","validateSourceNameExistenceAndCasing","SOURCE_NAMES","file","WRONG_CASING","incorrect","correct"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\internal\\solidity\\resolver.ts"],"sourcesContent":["import fsExtra from \"fs-extra\";\nimport path from \"path\";\nimport resolve from \"resolve\";\n\nimport {\n  FileContent,\n  LibraryInfo,\n  ResolvedFile as IResolvedFile,\n} from \"../../types/builtin-tasks\";\nimport {\n  includesOwnPackageName,\n  isAbsolutePathSourceName,\n  isLocalSourceName,\n  normalizeSourceName,\n  replaceBackslashes,\n  validateSourceNameExistenceAndCasing,\n  validateSourceNameFormat,\n} from \"../../utils/source-names\";\nimport { assertHardhatInvariant, HardhatError } from \"../core/errors\";\nimport { ERRORS } from \"../core/errors-list\";\nimport { createNonCryptographicHashBasedIdentifier } from \"../util/hash\";\n\nimport { getRealPath } from \"../util/fs-utils\";\nimport { applyRemappings } from \"../../utils/remappings\";\nimport { Parser } from \"./parse\";\n\nexport interface ResolvedFilesMap {\n  [sourceName: string]: ResolvedFile;\n}\n\nconst NODE_MODULES = \"node_modules\";\n\nexport class ResolvedFile implements IResolvedFile {\n  public readonly library?: LibraryInfo;\n\n  constructor(\n    public readonly sourceName: string,\n    public readonly absolutePath: string,\n    public readonly content: FileContent,\n    public readonly contentHash: string,\n    public readonly lastModificationDate: Date,\n    libraryName?: string,\n    libraryVersion?: string\n  ) {\n    assertHardhatInvariant(\n      (libraryName === undefined && libraryVersion === undefined) ||\n        (libraryName !== undefined && libraryVersion !== undefined),\n      \"Libraries should have both name and version, or neither one\"\n    );\n\n    if (libraryName !== undefined && libraryVersion !== undefined) {\n      this.library = {\n        name: libraryName,\n        version: libraryVersion,\n      };\n    }\n  }\n\n  public getVersionedName() {\n    return (\n      this.sourceName +\n      (this.library !== undefined ? `@v${this.library.version}` : \"\")\n    );\n  }\n}\n\nexport class Resolver {\n  private readonly _cache: Map<string, ResolvedFile> = new Map();\n\n  constructor(\n    private readonly _projectRoot: string,\n    private readonly _parser: Parser,\n    private readonly _remappings: Record<string, string>,\n    private readonly _readFile: (absolutePath: string) => Promise<string>,\n    private readonly _transformImportName: (\n      importName: string\n    ) => Promise<string>\n  ) {}\n\n  /**\n   * Resolves a source name into a ResolvedFile.\n   *\n   * @param sourceName The source name as it would be provided to solc.\n   */\n  public async resolveSourceName(sourceName: string): Promise<ResolvedFile> {\n    const cached = this._cache.get(sourceName);\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    const remappedSourceName = applyRemappings(this._remappings, sourceName);\n\n    validateSourceNameFormat(remappedSourceName);\n\n    let resolvedFile: ResolvedFile;\n\n    if (await isLocalSourceName(this._projectRoot, remappedSourceName)) {\n      resolvedFile = await this._resolveLocalSourceName(\n        sourceName,\n        remappedSourceName\n      );\n    } else {\n      resolvedFile = await this._resolveLibrarySourceName(\n        sourceName,\n        remappedSourceName\n      );\n    }\n\n    this._cache.set(sourceName, resolvedFile);\n    return resolvedFile;\n  }\n\n  /**\n   * Resolves an import from an already resolved file.\n   * @param from The file were the import statement is present.\n   * @param importName The path in the import statement.\n   */\n  public async resolveImport(\n    from: ResolvedFile,\n    importName: string\n  ): Promise<ResolvedFile> {\n    // sanity check for deprecated task\n    if (importName !== (await this._transformImportName(importName))) {\n      throw new HardhatError(\n        ERRORS.TASK_DEFINITIONS.DEPRECATED_TRANSFORM_IMPORT_TASK\n      );\n    }\n\n    const imported = applyRemappings(this._remappings, importName);\n\n    const scheme = this._getUriScheme(imported);\n    if (scheme !== undefined) {\n      throw new HardhatError(ERRORS.RESOLVER.INVALID_IMPORT_PROTOCOL, {\n        from: from.sourceName,\n        imported,\n        protocol: scheme,\n      });\n    }\n\n    if (replaceBackslashes(imported) !== imported) {\n      throw new HardhatError(ERRORS.RESOLVER.INVALID_IMPORT_BACKSLASH, {\n        from: from.sourceName,\n        imported,\n      });\n    }\n\n    if (isAbsolutePathSourceName(imported)) {\n      throw new HardhatError(ERRORS.RESOLVER.INVALID_IMPORT_ABSOLUTE_PATH, {\n        from: from.sourceName,\n        imported,\n      });\n    }\n\n    // Edge-case where an import can contain the current package's name in monorepos.\n    // The path can be resolved because there's a symlink in the node modules.\n    if (await includesOwnPackageName(imported)) {\n      throw new HardhatError(ERRORS.RESOLVER.INCLUDES_OWN_PACKAGE_NAME, {\n        from: from.sourceName,\n        imported,\n      });\n    }\n\n    try {\n      let sourceName: string;\n\n      const isRelativeImport = this._isRelativeImport(imported);\n\n      if (isRelativeImport) {\n        sourceName = await this._relativeImportToSourceName(from, imported);\n      } else {\n        sourceName = normalizeSourceName(importName); // The sourceName of the imported file is not transformed\n      }\n\n      const cached = this._cache.get(sourceName);\n      if (cached !== undefined) {\n        return cached;\n      }\n\n      let resolvedFile: ResolvedFile;\n\n      // We have this special case here, because otherwise local relative\n      // imports can be treated as library imports. For example if\n      // `contracts/c.sol` imports `../non-existent/a.sol`\n      if (\n        from.library === undefined &&\n        isRelativeImport &&\n        !this._isRelativeImportToLibrary(from, imported)\n      ) {\n        resolvedFile = await this._resolveLocalSourceName(\n          sourceName,\n          applyRemappings(this._remappings, sourceName)\n        );\n      } else {\n        resolvedFile = await this.resolveSourceName(sourceName);\n      }\n\n      this._cache.set(sourceName, resolvedFile);\n      return resolvedFile;\n    } catch (error) {\n      if (\n        HardhatError.isHardhatErrorType(\n          error,\n          ERRORS.RESOLVER.FILE_NOT_FOUND\n        ) ||\n        HardhatError.isHardhatErrorType(\n          error,\n          ERRORS.RESOLVER.LIBRARY_FILE_NOT_FOUND\n        )\n      ) {\n        if (imported !== importName) {\n          throw new HardhatError(\n            ERRORS.RESOLVER.IMPORTED_MAPPED_FILE_NOT_FOUND,\n            {\n              imported,\n              importName,\n              from: from.sourceName,\n            },\n            error\n          );\n        } else {\n          throw new HardhatError(\n            ERRORS.RESOLVER.IMPORTED_FILE_NOT_FOUND,\n            {\n              imported,\n              from: from.sourceName,\n            },\n            error\n          );\n        }\n      }\n\n      if (\n        HardhatError.isHardhatErrorType(\n          error,\n          ERRORS.RESOLVER.WRONG_SOURCE_NAME_CASING\n        )\n      ) {\n        throw new HardhatError(\n          ERRORS.RESOLVER.INVALID_IMPORT_WRONG_CASING,\n          {\n            imported,\n            from: from.sourceName,\n          },\n          error\n        );\n      }\n\n      if (\n        HardhatError.isHardhatErrorType(\n          error,\n          ERRORS.RESOLVER.LIBRARY_NOT_INSTALLED\n        )\n      ) {\n        throw new HardhatError(\n          ERRORS.RESOLVER.IMPORTED_LIBRARY_NOT_INSTALLED,\n          {\n            library: error.messageArguments.library,\n            from: from.sourceName,\n          },\n          error\n        );\n      }\n\n      if (\n        HardhatError.isHardhatErrorType(\n          error,\n          ERRORS.GENERAL.INVALID_READ_OF_DIRECTORY\n        )\n      ) {\n        throw new HardhatError(\n          ERRORS.RESOLVER.INVALID_IMPORT_OF_DIRECTORY,\n          {\n            imported,\n            from: from.sourceName,\n          },\n          error\n        );\n      }\n\n      // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n  }\n\n  private async _resolveLocalSourceName(\n    sourceName: string,\n    remappedSourceName: string\n  ): Promise<ResolvedFile> {\n    await this._validateSourceNameExistenceAndCasing(\n      this._projectRoot,\n      remappedSourceName,\n      false\n    );\n\n    const absolutePath = path.join(this._projectRoot, remappedSourceName);\n    return this._resolveFile(sourceName, absolutePath);\n  }\n\n  private async _resolveLibrarySourceName(\n    sourceName: string,\n    remappedSourceName: string\n  ): Promise<ResolvedFile> {\n    const normalizedSourceName = remappedSourceName.replace(\n      /^node_modules\\//,\n      \"\"\n    );\n    const libraryName = this._getLibraryName(normalizedSourceName);\n\n    let packageJsonPath;\n    try {\n      packageJsonPath = this._resolveNodeModulesFileFromProjectRoot(\n        path.join(libraryName, \"package.json\")\n      );\n    } catch (error) {\n      // if the project is using a dependency from hardhat itself but it can't\n      // be found, this means that a global installation is being used, so we\n      // resolve the dependency relative to this file\n      if (libraryName === \"hardhat\") {\n        const hardhatCoreDir = path.join(__dirname, \"..\", \"..\");\n        packageJsonPath = path.join(hardhatCoreDir, \"package.json\");\n      } else {\n        throw new HardhatError(\n          ERRORS.RESOLVER.LIBRARY_NOT_INSTALLED,\n          {\n            library: libraryName,\n          },\n          error as Error\n        );\n      }\n    }\n\n    let nodeModulesPath = path.dirname(path.dirname(packageJsonPath));\n    if (this._isScopedPackage(normalizedSourceName)) {\n      nodeModulesPath = path.dirname(nodeModulesPath);\n    }\n\n    let absolutePath: string;\n    if (path.basename(nodeModulesPath) !== NODE_MODULES) {\n      // this can happen in monorepos that use PnP, in those\n      // cases we handle resolution differently\n      const packageRoot = path.dirname(packageJsonPath);\n      const pattern = new RegExp(`^${libraryName}/?`);\n      const fileName = normalizedSourceName.replace(pattern, \"\");\n\n      await this._validateSourceNameExistenceAndCasing(\n        packageRoot,\n        // TODO: this is _not_ a source name; we should handle this scenario in\n        // a better way\n        fileName,\n        true\n      );\n      absolutePath = path.join(packageRoot, fileName);\n    } else {\n      await this._validateSourceNameExistenceAndCasing(\n        nodeModulesPath,\n        normalizedSourceName,\n        true\n      );\n      absolutePath = path.join(nodeModulesPath, normalizedSourceName);\n    }\n\n    const packageInfo: {\n      name: string;\n      version: string;\n    } = await fsExtra.readJson(packageJsonPath);\n    const libraryVersion = packageInfo.version;\n\n    return this._resolveFile(\n      sourceName,\n      // We resolve to the real path here, as we may be resolving a linked library\n      await getRealPath(absolutePath),\n      libraryName,\n      libraryVersion\n    );\n  }\n\n  private async _relativeImportToSourceName(\n    from: ResolvedFile,\n    imported: string\n  ): Promise<string> {\n    // This is a special case, were we turn relative imports from local files\n    // into library imports if necessary. The reason for this is that many\n    // users just do `import \"../node_modules/lib/a.sol\";`.\n    if (this._isRelativeImportToLibrary(from, imported)) {\n      return this._relativeImportToLibraryToSourceName(from, imported);\n    }\n\n    const sourceName = normalizeSourceName(\n      path.join(path.dirname(from.sourceName), imported)\n    );\n\n    // If the file with the import is local, and the normalized version\n    // starts with ../ means that it's trying to get outside of the project.\n    if (from.library === undefined && sourceName.startsWith(\"../\")) {\n      throw new HardhatError(\n        ERRORS.RESOLVER.INVALID_IMPORT_OUTSIDE_OF_PROJECT,\n        { from: from.sourceName, imported }\n      );\n    }\n\n    if (\n      from.library !== undefined &&\n      !this._isInsideSameDir(from.sourceName, sourceName)\n    ) {\n      // If the file is being imported from a library, this means that it's\n      // trying to reach another one.\n      throw new HardhatError(ERRORS.RESOLVER.ILLEGAL_IMPORT, {\n        from: from.sourceName,\n        imported,\n      });\n    }\n\n    return sourceName;\n  }\n\n  private async _resolveFile(\n    sourceName: string,\n    absolutePath: string,\n    libraryName?: string,\n    libraryVersion?: string\n  ): Promise<ResolvedFile> {\n    const rawContent = await this._readFile(absolutePath);\n    const stats = await fsExtra.stat(absolutePath);\n    const lastModificationDate = new Date(stats.ctime);\n\n    const contentHash = createNonCryptographicHashBasedIdentifier(\n      Buffer.from(rawContent)\n    ).toString(\"hex\");\n\n    const parsedContent = this._parser.parse(\n      rawContent,\n      absolutePath,\n      contentHash\n    );\n\n    const content = {\n      rawContent,\n      ...parsedContent,\n    };\n\n    return new ResolvedFile(\n      sourceName,\n      absolutePath,\n      content,\n      contentHash,\n      lastModificationDate,\n      libraryName,\n      libraryVersion\n    );\n  }\n\n  private _isRelativeImport(imported: string): boolean {\n    return imported.startsWith(\"./\") || imported.startsWith(\"../\");\n  }\n\n  private _resolveNodeModulesFileFromProjectRoot(fileName: string) {\n    return resolve.sync(fileName, {\n      basedir: this._projectRoot,\n      preserveSymlinks: true,\n    });\n  }\n\n  private _getLibraryName(sourceName: string): string {\n    let endIndex: number;\n    if (this._isScopedPackage(sourceName)) {\n      endIndex = sourceName.indexOf(\"/\", sourceName.indexOf(\"/\") + 1);\n    } else if (sourceName.indexOf(\"/\") === -1) {\n      endIndex = sourceName.length;\n    } else {\n      endIndex = sourceName.indexOf(\"/\");\n    }\n\n    return sourceName.slice(0, endIndex);\n  }\n\n  private _getUriScheme(s: string): string | undefined {\n    const re = /([a-zA-Z]+):\\/\\//;\n    const match = re.exec(s);\n    if (match === null) {\n      return undefined;\n    }\n\n    return match[1];\n  }\n\n  private _isInsideSameDir(sourceNameInDir: string, sourceNameToTest: string) {\n    const firstSlash = sourceNameInDir.indexOf(\"/\");\n    const dir =\n      firstSlash !== -1\n        ? sourceNameInDir.substring(0, firstSlash)\n        : sourceNameInDir;\n\n    return sourceNameToTest.startsWith(dir);\n  }\n\n  private _isScopedPackage(packageOrPackageFile: string): boolean {\n    return packageOrPackageFile.startsWith(\"@\");\n  }\n\n  private _isRelativeImportToLibrary(\n    from: ResolvedFile,\n    imported: string\n  ): boolean {\n    return (\n      this._isRelativeImport(imported) &&\n      from.library === undefined &&\n      imported.includes(`${NODE_MODULES}/`)\n    );\n  }\n\n  private _relativeImportToLibraryToSourceName(\n    from: ResolvedFile,\n    imported: string\n  ): string {\n    const sourceName = normalizeSourceName(\n      path.join(path.dirname(from.sourceName), imported)\n    );\n\n    const nmIndex = sourceName.indexOf(`${NODE_MODULES}/`);\n    return sourceName.substr(nmIndex + NODE_MODULES.length + 1);\n  }\n\n  private async _validateSourceNameExistenceAndCasing(\n    fromDir: string,\n    sourceName: string,\n    isLibrary: boolean\n  ) {\n    try {\n      await validateSourceNameExistenceAndCasing(fromDir, sourceName);\n    } catch (error) {\n      if (\n        HardhatError.isHardhatErrorType(\n          error,\n          ERRORS.SOURCE_NAMES.FILE_NOT_FOUND\n        )\n      ) {\n        throw new HardhatError(\n          isLibrary\n            ? ERRORS.RESOLVER.LIBRARY_FILE_NOT_FOUND\n            : ERRORS.RESOLVER.FILE_NOT_FOUND,\n          { file: sourceName },\n          error\n        );\n      }\n\n      if (\n        HardhatError.isHardhatErrorType(error, ERRORS.SOURCE_NAMES.WRONG_CASING)\n      ) {\n        throw new HardhatError(\n          ERRORS.RESOLVER.WRONG_SOURCE_NAME_CASING,\n          {\n            incorrect: sourceName,\n            correct: error.messageArguments.correct,\n          },\n          error\n        );\n      }\n\n      // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}