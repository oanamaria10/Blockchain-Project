{"ast":null,"code":"/**\n * @packageDocumentation\n *\n * A class that lets you do operations over a list of Uint8Arrays without\n * copying them.\n *\n * ```js\n * import { Uint8ArrayList } from 'uint8arraylist'\n *\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray()\n * // -> Uint8Array([0, 1, 2, 3, 4, 5])\n *\n * list.consume(3)\n * list.subarray()\n * // -> Uint8Array([3, 4, 5])\n *\n * // you can also iterate over the list\n * for (const buf of list) {\n *   // ..do something with `buf`\n * }\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ## Converting Uint8ArrayLists to Uint8Arrays\n *\n * There are two ways to turn a `Uint8ArrayList` into a `Uint8Array` - `.slice` and `.subarray` and one way to turn a `Uint8ArrayList` into a `Uint8ArrayList` with different contents - `.sublist`.\n *\n * ### slice\n *\n * Slice follows the same semantics as [Uint8Array.slice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice) in that it creates a new `Uint8Array` and copies bytes into it using an optional offset & length.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.slice(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ### subarray\n *\n * Subarray attempts to follow the same semantics as [Uint8Array.subarray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray) with one important different - this is a no-copy operation, unless the requested bytes span two internal buffers in which case it is a copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0]) - no-copy\n *\n * list.subarray(2, 5)\n * // -> Uint8Array([2, 3, 4]) - copy\n * ```\n *\n * ### sublist\n *\n * Sublist creates and returns a new `Uint8ArrayList` that shares the underlying buffers with the original so is always a no-copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.sublist(0, 1)\n * // -> Uint8ArrayList([0]) - no-copy\n *\n * list.sublist(2, 5)\n * // -> Uint8ArrayList([2], [3, 4]) - no-copy\n * ```\n *\n * ## Inspiration\n *\n * Borrows liberally from [bl](https://www.npmjs.com/package/bl) but only uses native JS types.\n */\nimport { allocUnsafe, alloc } from 'uint8arrays/alloc';\nimport { concat } from 'uint8arrays/concat';\nimport { equals } from 'uint8arrays/equals';\nconst symbol = Symbol.for('@achingbrain/uint8arraylist');\nfunction findBufAndOffset(bufs, index) {\n  if (index == null || index < 0) {\n    throw new RangeError('index is out of bounds');\n  }\n  let offset = 0;\n  for (const buf of bufs) {\n    const bufEnd = offset + buf.byteLength;\n    if (index < bufEnd) {\n      return {\n        buf,\n        index: index - offset\n      };\n    }\n    offset = bufEnd;\n  }\n  throw new RangeError('index is out of bounds');\n}\n/**\n * Check if object is a CID instance\n *\n * @example\n *\n * ```js\n * import { isUint8ArrayList, Uint8ArrayList } from 'uint8arraylist'\n *\n * isUint8ArrayList(true) // false\n * isUint8ArrayList([]) // false\n * isUint8ArrayList(new Uint8ArrayList()) // true\n * ```\n */\nexport function isUint8ArrayList(value) {\n  return Boolean(value?.[symbol]);\n}\nexport class Uint8ArrayList {\n  bufs;\n  length;\n  [symbol] = true;\n  constructor(...data) {\n    this.bufs = [];\n    this.length = 0;\n    if (data.length > 0) {\n      this.appendAll(data);\n    }\n  }\n  *[Symbol.iterator]() {\n    yield* this.bufs;\n  }\n  get byteLength() {\n    return this.length;\n  }\n  /**\n   * Add one or more `bufs` to the end of this Uint8ArrayList\n   */\n  append(...bufs) {\n    this.appendAll(bufs);\n  }\n  /**\n   * Add all `bufs` to the end of this Uint8ArrayList\n   */\n  appendAll(bufs) {\n    let length = 0;\n    for (const buf of bufs) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength;\n        this.bufs.push(buf);\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength;\n        this.bufs.push(...buf.bufs);\n      } else {\n        throw new Error('Could not append value, must be an Uint8Array or a Uint8ArrayList');\n      }\n    }\n    this.length += length;\n  }\n  /**\n   * Add one or more `bufs` to the start of this Uint8ArrayList\n   */\n  prepend(...bufs) {\n    this.prependAll(bufs);\n  }\n  /**\n   * Add all `bufs` to the start of this Uint8ArrayList\n   */\n  prependAll(bufs) {\n    let length = 0;\n    for (const buf of bufs.reverse()) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength;\n        this.bufs.unshift(buf);\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength;\n        this.bufs.unshift(...buf.bufs);\n      } else {\n        throw new Error('Could not prepend value, must be an Uint8Array or a Uint8ArrayList');\n      }\n    }\n    this.length += length;\n  }\n  /**\n   * Read the value at `index`\n   */\n  get(index) {\n    const res = findBufAndOffset(this.bufs, index);\n    return res.buf[res.index];\n  }\n  /**\n   * Set the value at `index` to `value`\n   */\n  set(index, value) {\n    const res = findBufAndOffset(this.bufs, index);\n    res.buf[res.index] = value;\n  }\n  /**\n   * Copy bytes from `buf` to the index specified by `offset`\n   */\n  write(buf, offset = 0) {\n    if (buf instanceof Uint8Array) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf[i]);\n      }\n    } else if (isUint8ArrayList(buf)) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf.get(i));\n      }\n    } else {\n      throw new Error('Could not write value, must be an Uint8Array or a Uint8ArrayList');\n    }\n  }\n  /**\n   * Remove bytes from the front of the pool\n   */\n  consume(bytes) {\n    // first, normalize the argument, in accordance with how Buffer does it\n    bytes = Math.trunc(bytes);\n    // do nothing if not a positive number\n    if (Number.isNaN(bytes) || bytes <= 0) {\n      return;\n    }\n    // if consuming all bytes, skip iterating\n    if (bytes === this.byteLength) {\n      this.bufs = [];\n      this.length = 0;\n      return;\n    }\n    while (this.bufs.length > 0) {\n      if (bytes >= this.bufs[0].byteLength) {\n        bytes -= this.bufs[0].byteLength;\n        this.length -= this.bufs[0].byteLength;\n        this.bufs.shift();\n      } else {\n        this.bufs[0] = this.bufs[0].subarray(bytes);\n        this.length -= bytes;\n        break;\n      }\n    }\n  }\n  /**\n   * Extracts a section of an array and returns a new array.\n   *\n   * This is a copy operation as it is with Uint8Arrays and Arrays\n   * - note this is different to the behaviour of Node Buffers.\n   */\n  slice(beginInclusive, endExclusive) {\n    const {\n      bufs,\n      length\n    } = this._subList(beginInclusive, endExclusive);\n    return concat(bufs, length);\n  }\n  /**\n   * Returns a alloc from the given start and end element index.\n   *\n   * In the best case where the data extracted comes from a single Uint8Array\n   * internally this is a no-copy operation otherwise it is a copy operation.\n   */\n  subarray(beginInclusive, endExclusive) {\n    const {\n      bufs,\n      length\n    } = this._subList(beginInclusive, endExclusive);\n    if (bufs.length === 1) {\n      return bufs[0];\n    }\n    return concat(bufs, length);\n  }\n  /**\n   * Returns a allocList from the given start and end element index.\n   *\n   * This is a no-copy operation.\n   */\n  sublist(beginInclusive, endExclusive) {\n    const {\n      bufs,\n      length\n    } = this._subList(beginInclusive, endExclusive);\n    const list = new Uint8ArrayList();\n    list.length = length;\n    // don't loop, just set the bufs\n    list.bufs = [...bufs];\n    return list;\n  }\n  _subList(beginInclusive, endExclusive) {\n    beginInclusive = beginInclusive ?? 0;\n    endExclusive = endExclusive ?? this.length;\n    if (beginInclusive < 0) {\n      beginInclusive = this.length + beginInclusive;\n    }\n    if (endExclusive < 0) {\n      endExclusive = this.length + endExclusive;\n    }\n    if (beginInclusive < 0 || endExclusive > this.length) {\n      throw new RangeError('index is out of bounds');\n    }\n    if (beginInclusive === endExclusive) {\n      return {\n        bufs: [],\n        length: 0\n      };\n    }\n    if (beginInclusive === 0 && endExclusive === this.length) {\n      return {\n        bufs: this.bufs,\n        length: this.length\n      };\n    }\n    const bufs = [];\n    let offset = 0;\n    for (let i = 0; i < this.bufs.length; i++) {\n      const buf = this.bufs[i];\n      const bufStart = offset;\n      const bufEnd = bufStart + buf.byteLength;\n      // for next loop\n      offset = bufEnd;\n      if (beginInclusive >= bufEnd) {\n        // start after this buf\n        continue;\n      }\n      const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd;\n      const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd;\n      if (sliceStartInBuf && sliceEndsInBuf) {\n        // slice is wholly contained within this buffer\n        if (beginInclusive === bufStart && endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf);\n          break;\n        }\n        // requested part of buffer\n        const start = beginInclusive - bufStart;\n        bufs.push(buf.subarray(start, start + (endExclusive - beginInclusive)));\n        break;\n      }\n      if (sliceStartInBuf) {\n        // slice starts in this buffer\n        if (beginInclusive === 0) {\n          // requested whole buffer\n          bufs.push(buf);\n          continue;\n        }\n        // requested part of buffer\n        bufs.push(buf.subarray(beginInclusive - bufStart));\n        continue;\n      }\n      if (sliceEndsInBuf) {\n        if (endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf);\n          break;\n        }\n        // requested part of buffer\n        bufs.push(buf.subarray(0, endExclusive - bufStart));\n        break;\n      }\n      // slice started before this buffer and ends after it\n      bufs.push(buf);\n    }\n    return {\n      bufs,\n      length: endExclusive - beginInclusive\n    };\n  }\n  indexOf(search, offset = 0) {\n    if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {\n      throw new TypeError('The \"value\" argument must be a Uint8ArrayList or Uint8Array');\n    }\n    const needle = search instanceof Uint8Array ? search : search.subarray();\n    offset = Number(offset ?? 0);\n    if (isNaN(offset)) {\n      offset = 0;\n    }\n    if (offset < 0) {\n      offset = this.length + offset;\n    }\n    if (offset < 0) {\n      offset = 0;\n    }\n    if (search.length === 0) {\n      return offset > this.length ? this.length : offset;\n    }\n    // https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm\n    const M = needle.byteLength;\n    if (M === 0) {\n      throw new TypeError('search must be at least 1 byte long');\n    }\n    // radix\n    const radix = 256;\n    const rightmostPositions = new Int32Array(radix);\n    // position of the rightmost occurrence of the byte c in the pattern\n    for (let c = 0; c < radix; c++) {\n      // -1 for bytes not in pattern\n      rightmostPositions[c] = -1;\n    }\n    for (let j = 0; j < M; j++) {\n      // rightmost position for bytes in pattern\n      rightmostPositions[needle[j]] = j;\n    }\n    // Return offset of first match, -1 if no match\n    const right = rightmostPositions;\n    const lastIndex = this.byteLength - needle.byteLength;\n    const lastPatIndex = needle.byteLength - 1;\n    let skip;\n    for (let i = offset; i <= lastIndex; i += skip) {\n      skip = 0;\n      for (let j = lastPatIndex; j >= 0; j--) {\n        const char = this.get(i + j);\n        if (needle[j] !== char) {\n          skip = Math.max(1, j - right[char]);\n          break;\n        }\n      }\n      if (skip === 0) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  getInt8(byteOffset) {\n    const buf = this.subarray(byteOffset, byteOffset + 1);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    return view.getInt8(0);\n  }\n  setInt8(byteOffset, value) {\n    const buf = allocUnsafe(1);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    view.setInt8(0, value);\n    this.write(buf, byteOffset);\n  }\n  getInt16(byteOffset, littleEndian) {\n    const buf = this.subarray(byteOffset, byteOffset + 2);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    return view.getInt16(0, littleEndian);\n  }\n  setInt16(byteOffset, value, littleEndian) {\n    const buf = alloc(2);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    view.setInt16(0, value, littleEndian);\n    this.write(buf, byteOffset);\n  }\n  getInt32(byteOffset, littleEndian) {\n    const buf = this.subarray(byteOffset, byteOffset + 4);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    return view.getInt32(0, littleEndian);\n  }\n  setInt32(byteOffset, value, littleEndian) {\n    const buf = alloc(4);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    view.setInt32(0, value, littleEndian);\n    this.write(buf, byteOffset);\n  }\n  getBigInt64(byteOffset, littleEndian) {\n    const buf = this.subarray(byteOffset, byteOffset + 8);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    return view.getBigInt64(0, littleEndian);\n  }\n  setBigInt64(byteOffset, value, littleEndian) {\n    const buf = alloc(8);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    view.setBigInt64(0, value, littleEndian);\n    this.write(buf, byteOffset);\n  }\n  getUint8(byteOffset) {\n    const buf = this.subarray(byteOffset, byteOffset + 1);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    return view.getUint8(0);\n  }\n  setUint8(byteOffset, value) {\n    const buf = allocUnsafe(1);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    view.setUint8(0, value);\n    this.write(buf, byteOffset);\n  }\n  getUint16(byteOffset, littleEndian) {\n    const buf = this.subarray(byteOffset, byteOffset + 2);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    return view.getUint16(0, littleEndian);\n  }\n  setUint16(byteOffset, value, littleEndian) {\n    const buf = alloc(2);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    view.setUint16(0, value, littleEndian);\n    this.write(buf, byteOffset);\n  }\n  getUint32(byteOffset, littleEndian) {\n    const buf = this.subarray(byteOffset, byteOffset + 4);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    return view.getUint32(0, littleEndian);\n  }\n  setUint32(byteOffset, value, littleEndian) {\n    const buf = alloc(4);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    view.setUint32(0, value, littleEndian);\n    this.write(buf, byteOffset);\n  }\n  getBigUint64(byteOffset, littleEndian) {\n    const buf = this.subarray(byteOffset, byteOffset + 8);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    return view.getBigUint64(0, littleEndian);\n  }\n  setBigUint64(byteOffset, value, littleEndian) {\n    const buf = alloc(8);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    view.setBigUint64(0, value, littleEndian);\n    this.write(buf, byteOffset);\n  }\n  getFloat32(byteOffset, littleEndian) {\n    const buf = this.subarray(byteOffset, byteOffset + 4);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    return view.getFloat32(0, littleEndian);\n  }\n  setFloat32(byteOffset, value, littleEndian) {\n    const buf = alloc(4);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    view.setFloat32(0, value, littleEndian);\n    this.write(buf, byteOffset);\n  }\n  getFloat64(byteOffset, littleEndian) {\n    const buf = this.subarray(byteOffset, byteOffset + 8);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    return view.getFloat64(0, littleEndian);\n  }\n  setFloat64(byteOffset, value, littleEndian) {\n    const buf = alloc(8);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    view.setFloat64(0, value, littleEndian);\n    this.write(buf, byteOffset);\n  }\n  equals(other) {\n    if (other == null) {\n      return false;\n    }\n    if (!(other instanceof Uint8ArrayList)) {\n      return false;\n    }\n    if (other.bufs.length !== this.bufs.length) {\n      return false;\n    }\n    for (let i = 0; i < this.bufs.length; i++) {\n      if (!equals(this.bufs[i], other.bufs[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this\n   * method if you know the total size of all the Uint8Arrays ahead of time.\n   */\n  static fromUint8Arrays(bufs, length) {\n    const list = new Uint8ArrayList();\n    list.bufs = bufs;\n    if (length == null) {\n      length = bufs.reduce((acc, curr) => acc + curr.byteLength, 0);\n    }\n    list.length = length;\n    return list;\n  }\n}\n/*\nfunction indexOf (needle: Uint8Array, haystack: Uint8Array, offset = 0) {\n  for (let i = offset; i < haystack.byteLength; i++) {\n    for (let j = 0; j < needle.length; j++) {\n      if (haystack[i + j] !== needle[j]) {\n        break\n      }\n\n      if (j === needle.byteLength -1) {\n        return i\n      }\n    }\n\n    if (haystack.byteLength - i < needle.byteLength) {\n      break\n    }\n  }\n\n  return -1\n}\n*/","map":{"version":3,"names":["allocUnsafe","alloc","concat","equals","symbol","Symbol","for","findBufAndOffset","bufs","index","RangeError","offset","buf","bufEnd","byteLength","isUint8ArrayList","value","Boolean","Uint8ArrayList","length","constructor","data","appendAll","iterator","append","Uint8Array","push","Error","prepend","prependAll","reverse","unshift","get","res","set","write","i","consume","bytes","Math","trunc","Number","isNaN","shift","subarray","slice","beginInclusive","endExclusive","_subList","sublist","list","bufStart","sliceStartInBuf","sliceEndsInBuf","start","indexOf","search","TypeError","needle","M","radix","rightmostPositions","Int32Array","c","j","right","lastIndex","lastPatIndex","skip","char","max","getInt8","byteOffset","view","DataView","buffer","setInt8","getInt16","littleEndian","setInt16","getInt32","setInt32","getBigInt64","setBigInt64","getUint8","setUint8","getUint16","setUint16","getUint32","setUint32","getBigUint64","setBigUint64","getFloat32","setFloat32","getFloat64","setFloat64","other","fromUint8Arrays","reduce","acc","curr"],"sources":["C:\\FACULTATE\\Proiect\\node_modules\\uint8arraylist\\src\\index.ts"],"sourcesContent":["/**\n * @packageDocumentation\n *\n * A class that lets you do operations over a list of Uint8Arrays without\n * copying them.\n *\n * ```js\n * import { Uint8ArrayList } from 'uint8arraylist'\n *\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray()\n * // -> Uint8Array([0, 1, 2, 3, 4, 5])\n *\n * list.consume(3)\n * list.subarray()\n * // -> Uint8Array([3, 4, 5])\n *\n * // you can also iterate over the list\n * for (const buf of list) {\n *   // ..do something with `buf`\n * }\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ## Converting Uint8ArrayLists to Uint8Arrays\n *\n * There are two ways to turn a `Uint8ArrayList` into a `Uint8Array` - `.slice` and `.subarray` and one way to turn a `Uint8ArrayList` into a `Uint8ArrayList` with different contents - `.sublist`.\n *\n * ### slice\n *\n * Slice follows the same semantics as [Uint8Array.slice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice) in that it creates a new `Uint8Array` and copies bytes into it using an optional offset & length.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.slice(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ### subarray\n *\n * Subarray attempts to follow the same semantics as [Uint8Array.subarray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray) with one important different - this is a no-copy operation, unless the requested bytes span two internal buffers in which case it is a copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0]) - no-copy\n *\n * list.subarray(2, 5)\n * // -> Uint8Array([2, 3, 4]) - copy\n * ```\n *\n * ### sublist\n *\n * Sublist creates and returns a new `Uint8ArrayList` that shares the underlying buffers with the original so is always a no-copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.sublist(0, 1)\n * // -> Uint8ArrayList([0]) - no-copy\n *\n * list.sublist(2, 5)\n * // -> Uint8ArrayList([2], [3, 4]) - no-copy\n * ```\n *\n * ## Inspiration\n *\n * Borrows liberally from [bl](https://www.npmjs.com/package/bl) but only uses native JS types.\n */\nimport { allocUnsafe, alloc } from 'uint8arrays/alloc'\nimport { concat } from 'uint8arrays/concat'\nimport { equals } from 'uint8arrays/equals'\n\nconst symbol = Symbol.for('@achingbrain/uint8arraylist')\n\nexport type Appendable = Uint8ArrayList | Uint8Array\n\nfunction findBufAndOffset (bufs: Uint8Array[], index: number): { buf: Uint8Array, index: number } {\n  if (index == null || index < 0) {\n    throw new RangeError('index is out of bounds')\n  }\n\n  let offset = 0\n\n  for (const buf of bufs) {\n    const bufEnd = offset + buf.byteLength\n\n    if (index < bufEnd) {\n      return {\n        buf,\n        index: index - offset\n      }\n    }\n\n    offset = bufEnd\n  }\n\n  throw new RangeError('index is out of bounds')\n}\n\n/**\n * Check if object is a CID instance\n *\n * @example\n *\n * ```js\n * import { isUint8ArrayList, Uint8ArrayList } from 'uint8arraylist'\n *\n * isUint8ArrayList(true) // false\n * isUint8ArrayList([]) // false\n * isUint8ArrayList(new Uint8ArrayList()) // true\n * ```\n */\nexport function isUint8ArrayList (value: any): value is Uint8ArrayList {\n  return Boolean(value?.[symbol])\n}\n\nexport class Uint8ArrayList implements Iterable<Uint8Array> {\n  private bufs: Uint8Array[]\n  public length: number\n  public readonly [symbol] = true\n\n  constructor (...data: Appendable[]) {\n    this.bufs = []\n    this.length = 0\n\n    if (data.length > 0) {\n      this.appendAll(data)\n    }\n  }\n\n  * [Symbol.iterator] (): Iterator<Uint8Array> {\n    yield * this.bufs\n  }\n\n  get byteLength (): number {\n    return this.length\n  }\n\n  /**\n   * Add one or more `bufs` to the end of this Uint8ArrayList\n   */\n  append (...bufs: Appendable[]): void {\n    this.appendAll(bufs)\n  }\n\n  /**\n   * Add all `bufs` to the end of this Uint8ArrayList\n   */\n  appendAll (bufs: Appendable[]): void {\n    let length = 0\n\n    for (const buf of bufs) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength\n        this.bufs.push(buf)\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength\n        this.bufs.push(...buf.bufs)\n      } else {\n        throw new Error('Could not append value, must be an Uint8Array or a Uint8ArrayList')\n      }\n    }\n\n    this.length += length\n  }\n\n  /**\n   * Add one or more `bufs` to the start of this Uint8ArrayList\n   */\n  prepend (...bufs: Appendable[]): void {\n    this.prependAll(bufs)\n  }\n\n  /**\n   * Add all `bufs` to the start of this Uint8ArrayList\n   */\n  prependAll (bufs: Appendable[]): void {\n    let length = 0\n\n    for (const buf of bufs.reverse()) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength\n        this.bufs.unshift(buf)\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength\n        this.bufs.unshift(...buf.bufs)\n      } else {\n        throw new Error('Could not prepend value, must be an Uint8Array or a Uint8ArrayList')\n      }\n    }\n\n    this.length += length\n  }\n\n  /**\n   * Read the value at `index`\n   */\n  get (index: number): number {\n    const res = findBufAndOffset(this.bufs, index)\n\n    return res.buf[res.index]\n  }\n\n  /**\n   * Set the value at `index` to `value`\n   */\n  set (index: number, value: number): void {\n    const res = findBufAndOffset(this.bufs, index)\n\n    res.buf[res.index] = value\n  }\n\n  /**\n   * Copy bytes from `buf` to the index specified by `offset`\n   */\n  write (buf: Appendable, offset: number = 0): void {\n    if (buf instanceof Uint8Array) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf[i])\n      }\n    } else if (isUint8ArrayList(buf)) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf.get(i))\n      }\n    } else {\n      throw new Error('Could not write value, must be an Uint8Array or a Uint8ArrayList')\n    }\n  }\n\n  /**\n   * Remove bytes from the front of the pool\n   */\n  consume (bytes: number): void {\n    // first, normalize the argument, in accordance with how Buffer does it\n    bytes = Math.trunc(bytes)\n\n    // do nothing if not a positive number\n    if (Number.isNaN(bytes) || bytes <= 0) {\n      return\n    }\n\n    // if consuming all bytes, skip iterating\n    if (bytes === this.byteLength) {\n      this.bufs = []\n      this.length = 0\n      return\n    }\n\n    while (this.bufs.length > 0) {\n      if (bytes >= this.bufs[0].byteLength) {\n        bytes -= this.bufs[0].byteLength\n        this.length -= this.bufs[0].byteLength\n        this.bufs.shift()\n      } else {\n        this.bufs[0] = this.bufs[0].subarray(bytes)\n        this.length -= bytes\n        break\n      }\n    }\n  }\n\n  /**\n   * Extracts a section of an array and returns a new array.\n   *\n   * This is a copy operation as it is with Uint8Arrays and Arrays\n   * - note this is different to the behaviour of Node Buffers.\n   */\n  slice (beginInclusive?: number, endExclusive?: number): Uint8Array {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    return concat(bufs, length)\n  }\n\n  /**\n   * Returns a alloc from the given start and end element index.\n   *\n   * In the best case where the data extracted comes from a single Uint8Array\n   * internally this is a no-copy operation otherwise it is a copy operation.\n   */\n  subarray (beginInclusive?: number, endExclusive?: number): Uint8Array {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    if (bufs.length === 1) {\n      return bufs[0]\n    }\n\n    return concat(bufs, length)\n  }\n\n  /**\n   * Returns a allocList from the given start and end element index.\n   *\n   * This is a no-copy operation.\n   */\n  sublist (beginInclusive?: number, endExclusive?: number): Uint8ArrayList {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    const list = new Uint8ArrayList()\n    list.length = length\n    // don't loop, just set the bufs\n    list.bufs = [...bufs]\n\n    return list\n  }\n\n  private _subList (beginInclusive?: number, endExclusive?: number): { bufs: Uint8Array[], length: number } {\n    beginInclusive = beginInclusive ?? 0\n    endExclusive = endExclusive ?? this.length\n\n    if (beginInclusive < 0) {\n      beginInclusive = this.length + beginInclusive\n    }\n\n    if (endExclusive < 0) {\n      endExclusive = this.length + endExclusive\n    }\n\n    if (beginInclusive < 0 || endExclusive > this.length) {\n      throw new RangeError('index is out of bounds')\n    }\n\n    if (beginInclusive === endExclusive) {\n      return { bufs: [], length: 0 }\n    }\n\n    if (beginInclusive === 0 && endExclusive === this.length) {\n      return { bufs: this.bufs, length: this.length }\n    }\n\n    const bufs: Uint8Array[] = []\n    let offset = 0\n\n    for (let i = 0; i < this.bufs.length; i++) {\n      const buf = this.bufs[i]\n      const bufStart = offset\n      const bufEnd = bufStart + buf.byteLength\n\n      // for next loop\n      offset = bufEnd\n\n      if (beginInclusive >= bufEnd) {\n        // start after this buf\n        continue\n      }\n\n      const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd\n      const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd\n\n      if (sliceStartInBuf && sliceEndsInBuf) {\n        // slice is wholly contained within this buffer\n        if (beginInclusive === bufStart && endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf)\n          break\n        }\n\n        // requested part of buffer\n        const start = beginInclusive - bufStart\n        bufs.push(buf.subarray(start, start + (endExclusive - beginInclusive)))\n        break\n      }\n\n      if (sliceStartInBuf) {\n        // slice starts in this buffer\n        if (beginInclusive === 0) {\n          // requested whole buffer\n          bufs.push(buf)\n          continue\n        }\n\n        // requested part of buffer\n        bufs.push(buf.subarray(beginInclusive - bufStart))\n        continue\n      }\n\n      if (sliceEndsInBuf) {\n        if (endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf)\n          break\n        }\n\n        // requested part of buffer\n        bufs.push(buf.subarray(0, endExclusive - bufStart))\n        break\n      }\n\n      // slice started before this buffer and ends after it\n      bufs.push(buf)\n    }\n\n    return { bufs, length: endExclusive - beginInclusive }\n  }\n\n  indexOf (search: Uint8ArrayList | Uint8Array, offset: number = 0): number {\n    if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {\n      throw new TypeError('The \"value\" argument must be a Uint8ArrayList or Uint8Array')\n    }\n\n    const needle = search instanceof Uint8Array ? search : search.subarray()\n\n    offset = Number(offset ?? 0)\n\n    if (isNaN(offset)) {\n      offset = 0\n    }\n\n    if (offset < 0) {\n      offset = this.length + offset\n    }\n\n    if (offset < 0) {\n      offset = 0\n    }\n\n    if (search.length === 0) {\n      return offset > this.length ? this.length : offset\n    }\n\n    // https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm\n    const M: number = needle.byteLength\n\n    if (M === 0) {\n      throw new TypeError('search must be at least 1 byte long')\n    }\n\n    // radix\n    const radix: number = 256\n    const rightmostPositions: Int32Array = new Int32Array(radix)\n\n    // position of the rightmost occurrence of the byte c in the pattern\n    for (let c: number = 0; c < radix; c++) {\n      // -1 for bytes not in pattern\n      rightmostPositions[c] = -1\n    }\n\n    for (let j = 0; j < M; j++) {\n      // rightmost position for bytes in pattern\n      rightmostPositions[needle[j]] = j\n    }\n\n    // Return offset of first match, -1 if no match\n    const right = rightmostPositions\n    const lastIndex = this.byteLength - needle.byteLength\n    const lastPatIndex = needle.byteLength - 1\n    let skip: number\n\n    for (let i = offset; i <= lastIndex; i += skip) {\n      skip = 0\n\n      for (let j = lastPatIndex; j >= 0; j--) {\n        const char: number = this.get(i + j)\n\n        if (needle[j] !== char) {\n          skip = Math.max(1, j - right[char])\n          break\n        }\n      }\n\n      if (skip === 0) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  getInt8 (byteOffset: number): number {\n    const buf = this.subarray(byteOffset, byteOffset + 1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt8(0)\n  }\n\n  setInt8 (byteOffset: number, value: number): void {\n    const buf = allocUnsafe(1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt8(0, value)\n\n    this.write(buf, byteOffset)\n  }\n\n  getInt16 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt16(0, littleEndian)\n  }\n\n  setInt16 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt16(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getInt32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt32(0, littleEndian)\n  }\n\n  setInt32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getBigInt64 (byteOffset: number, littleEndian?: boolean): bigint {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getBigInt64(0, littleEndian)\n  }\n\n  setBigInt64 (byteOffset: number, value: bigint, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setBigInt64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint8 (byteOffset: number): number {\n    const buf = this.subarray(byteOffset, byteOffset + 1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint8(0)\n  }\n\n  setUint8 (byteOffset: number, value: number): void {\n    const buf = allocUnsafe(1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint8(0, value)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint16 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint16(0, littleEndian)\n  }\n\n  setUint16 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint16(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint32(0, littleEndian)\n  }\n\n  setUint32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getBigUint64 (byteOffset: number, littleEndian?: boolean): bigint {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getBigUint64(0, littleEndian)\n  }\n\n  setBigUint64 (byteOffset: number, value: bigint, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setBigUint64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getFloat32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getFloat32(0, littleEndian)\n  }\n\n  setFloat32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setFloat32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getFloat64 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getFloat64(0, littleEndian)\n  }\n\n  setFloat64 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setFloat64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  equals (other: any): other is Uint8ArrayList {\n    if (other == null) {\n      return false\n    }\n\n    if (!(other instanceof Uint8ArrayList)) {\n      return false\n    }\n\n    if (other.bufs.length !== this.bufs.length) {\n      return false\n    }\n\n    for (let i = 0; i < this.bufs.length; i++) {\n      if (!equals(this.bufs[i], other.bufs[i])) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this\n   * method if you know the total size of all the Uint8Arrays ahead of time.\n   */\n  static fromUint8Arrays (bufs: Uint8Array[], length?: number): Uint8ArrayList {\n    const list = new Uint8ArrayList()\n    list.bufs = bufs\n\n    if (length == null) {\n      length = bufs.reduce((acc, curr) => acc + curr.byteLength, 0)\n    }\n\n    list.length = length\n\n    return list\n  }\n}\n\n/*\nfunction indexOf (needle: Uint8Array, haystack: Uint8Array, offset = 0) {\n  for (let i = offset; i < haystack.byteLength; i++) {\n    for (let j = 0; j < needle.length; j++) {\n      if (haystack[i + j] !== needle[j]) {\n        break\n      }\n\n      if (j === needle.byteLength -1) {\n        return i\n      }\n    }\n\n    if (haystack.byteLength - i < needle.byteLength) {\n      break\n    }\n  }\n\n  return -1\n}\n*/\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}