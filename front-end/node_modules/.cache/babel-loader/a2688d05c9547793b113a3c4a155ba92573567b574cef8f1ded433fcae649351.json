{"ast":null,"code":"/**\n * Store Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Store from '@web3-storage/capabilities/store'\n * ```\n *\n * @module\n */\nimport { capability, Link, Schema, ok, fail } from '@ucanto/validator';\nimport { equalLink, equalWith, SpaceDID } from './utils.js';\n\n// @see https://github.com/multiformats/multicodec/blob/master/table.csv#L140\nexport const code = 0x0202;\nexport const CARLink = Schema.link({\n  code,\n  version: 1\n});\n\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `store/` prefixed capability for the (memory) space identified\n * by DID in the `with` field.\n */\nexport const store = capability({\n  can: 'store/*',\n  /**\n   * DID of the (memory) space where CAR is intended to\n   * be stored.\n   */\n  with: SpaceDID,\n  derives: equalWith\n});\n\n/**\n * `store/add` capability allows agent to store a CAR file into a (memory) space\n * identified by did:key in the `with` field. Agent must precompute CAR locally\n * and provide it's CID and size using `nb.link` and `nb.size` fields, allowing\n * a service to provision a write location for the agent to PUT or POST desired\n * CAR into.\n */\nexport const add = capability({\n  can: 'store/add',\n  /**\n   * DID of the (memory) space where CAR is intended to\n   * be stored.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * CID of the CAR file to be stored. Service will provision write target\n     * for this exact CAR file for agent to PUT or POST it. Attempt to write\n     * any other content will fail.\n     */\n    link: CARLink,\n    /**\n     * Size of the CAR file to be stored. Service will provision write target\n     * for this exact size. Attempt to write a larger CAR file will fail.\n     */\n    size: Schema.integer(),\n    /**\n     * Agent may optionally provide a link to a related CAR file using `origin`\n     * field. This is useful when storing large DAGs, agent could shard it\n     * across multiple CAR files and then link each shard with a previous one.\n     *\n     * Providing this relation tells service that given CAR is shard of the\n     * larger DAG as opposed to it being intentionally partial DAG. When DAG is\n     * not sharded, there will be only one `store/add` with `origin` left out.\n     */\n    origin: Link.optional()\n  }),\n  derives: (claim, from) => {\n    const result = equalLink(claim, from);\n    if (result.error) {\n      return result;\n    } else if (claim.nb.size !== undefined && from.nb.size !== undefined) {\n      return claim.nb.size > from.nb.size ? fail(`Size constraint violation: ${claim.nb.size} > ${from.nb.size}`) : ok({});\n    } else {\n      return ok({});\n    }\n  }\n});\n\n/**\n * Capability to get store metadata by shard CID.\n * Use to check for inclusion, or get shard size and origin\n *\n * `nb.link` is optional to allow delegation of `store/get`\n * capability for any shard CID. If link is specified, then the\n * capability only allows a get for that specific CID.\n *\n * When used as as an invocation, `nb.link` must be specified.\n */\nexport const get = capability({\n  can: 'store/get',\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * shard CID to fetch info about.\n     */\n    link: CARLink.optional()\n  }),\n  derives: equalLink\n});\n\n/**\n * Capability can be used to remove the stored CAR file from the (memory)\n * space identified by `with` field.\n */\nexport const remove = capability({\n  can: 'store/remove',\n  /**\n   * DID of the (memory) space where CAR is intended to\n   * be stored.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * CID of the CAR file to be removed from the store.\n     */\n    link: CARLink\n  }),\n  derives: equalLink\n});\n\n/**\n * Capability can be invoked to request a list of stored CAR files in the\n * (memory) space identified by `with` field.\n */\nexport const list = capability({\n  can: 'store/list',\n  /**\n   * DID of the (memory) space where CAR is intended to\n   * be stored.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * A pointer that can be moved back and forth on the list.\n     * It can be used to paginate a list for instance.\n     */\n    cursor: Schema.string().optional(),\n    /**\n     * Maximum number of items per page.\n     */\n    size: Schema.integer().optional(),\n    /**\n     * If true, return page of results preceding cursor. Defaults to false.\n     */\n    pre: Schema.boolean().optional()\n  }),\n  derives: (claimed, delegated) => {\n    if (claimed.with !== delegated.with) {\n      return fail(`Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`);\n    }\n    return ok({});\n  }\n});\nexport const all = add.or(remove).or(list);\n\n// ⚠️ We export imports here so they are not omitted in generated typedes\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Schema, Link };","map":{"version":3,"names":["capability","Link","Schema","ok","fail","equalLink","equalWith","SpaceDID","code","CARLink","link","version","store","can","with","derives","add","nb","struct","size","integer","origin","optional","claim","from","result","error","undefined","get","remove","list","cursor","string","pre","boolean","claimed","delegated","all","or"],"sources":["C:/FACULTATE/Proiect/node_modules/@web3-storage/capabilities/src/store.js"],"sourcesContent":["/**\n * Store Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Store from '@web3-storage/capabilities/store'\n * ```\n *\n * @module\n */\nimport { capability, Link, Schema, ok, fail } from '@ucanto/validator'\nimport { equalLink, equalWith, SpaceDID } from './utils.js'\n\n// @see https://github.com/multiformats/multicodec/blob/master/table.csv#L140\nexport const code = 0x0202\n\nexport const CARLink = Schema.link({ code, version: 1 })\n\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `store/` prefixed capability for the (memory) space identified\n * by DID in the `with` field.\n */\nexport const store = capability({\n  can: 'store/*',\n  /**\n   * DID of the (memory) space where CAR is intended to\n   * be stored.\n   */\n  with: SpaceDID,\n  derives: equalWith,\n})\n\n/**\n * `store/add` capability allows agent to store a CAR file into a (memory) space\n * identified by did:key in the `with` field. Agent must precompute CAR locally\n * and provide it's CID and size using `nb.link` and `nb.size` fields, allowing\n * a service to provision a write location for the agent to PUT or POST desired\n * CAR into.\n */\nexport const add = capability({\n  can: 'store/add',\n  /**\n   * DID of the (memory) space where CAR is intended to\n   * be stored.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * CID of the CAR file to be stored. Service will provision write target\n     * for this exact CAR file for agent to PUT or POST it. Attempt to write\n     * any other content will fail.\n     */\n    link: CARLink,\n    /**\n     * Size of the CAR file to be stored. Service will provision write target\n     * for this exact size. Attempt to write a larger CAR file will fail.\n     */\n    size: Schema.integer(),\n    /**\n     * Agent may optionally provide a link to a related CAR file using `origin`\n     * field. This is useful when storing large DAGs, agent could shard it\n     * across multiple CAR files and then link each shard with a previous one.\n     *\n     * Providing this relation tells service that given CAR is shard of the\n     * larger DAG as opposed to it being intentionally partial DAG. When DAG is\n     * not sharded, there will be only one `store/add` with `origin` left out.\n     */\n    origin: Link.optional(),\n  }),\n  derives: (claim, from) => {\n    const result = equalLink(claim, from)\n    if (result.error) {\n      return result\n    } else if (claim.nb.size !== undefined && from.nb.size !== undefined) {\n      return claim.nb.size > from.nb.size\n        ? fail(`Size constraint violation: ${claim.nb.size} > ${from.nb.size}`)\n        : ok({})\n    } else {\n      return ok({})\n    }\n  },\n})\n\n/**\n * Capability to get store metadata by shard CID.\n * Use to check for inclusion, or get shard size and origin\n *\n * `nb.link` is optional to allow delegation of `store/get`\n * capability for any shard CID. If link is specified, then the\n * capability only allows a get for that specific CID.\n *\n * When used as as an invocation, `nb.link` must be specified.\n */\nexport const get = capability({\n  can: 'store/get',\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * shard CID to fetch info about.\n     */\n    link: CARLink.optional(),\n  }),\n  derives: equalLink,\n})\n\n/**\n * Capability can be used to remove the stored CAR file from the (memory)\n * space identified by `with` field.\n */\nexport const remove = capability({\n  can: 'store/remove',\n  /**\n   * DID of the (memory) space where CAR is intended to\n   * be stored.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * CID of the CAR file to be removed from the store.\n     */\n    link: CARLink,\n  }),\n  derives: equalLink,\n})\n\n/**\n * Capability can be invoked to request a list of stored CAR files in the\n * (memory) space identified by `with` field.\n */\nexport const list = capability({\n  can: 'store/list',\n  /**\n   * DID of the (memory) space where CAR is intended to\n   * be stored.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * A pointer that can be moved back and forth on the list.\n     * It can be used to paginate a list for instance.\n     */\n    cursor: Schema.string().optional(),\n    /**\n     * Maximum number of items per page.\n     */\n    size: Schema.integer().optional(),\n    /**\n     * If true, return page of results preceding cursor. Defaults to false.\n     */\n    pre: Schema.boolean().optional(),\n  }),\n  derives: (claimed, delegated) => {\n    if (claimed.with !== delegated.with) {\n      return fail(\n        `Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`\n      )\n    }\n    return ok({})\n  },\n})\n\nexport const all = add.or(remove).or(list)\n\n// ⚠️ We export imports here so they are not omitted in generated typedes\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Schema, Link }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}