{"ast":null,"code":"import { decode as decodeDagCbor } from '@ipld/dag-cbor';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { CIDV0_BYTES, decodeV2Header, decodeVarint, getMultihashLength, V2_HEADER_LENGTH } from './decoder-common.js';\nimport { CarV1HeaderOrV2Pragma } from './header-validator.js';\n\n/**\n * @typedef {import('./api').Block} Block\n * @typedef {import('./api').BlockHeader} BlockHeader\n * @typedef {import('./api').BlockIndex} BlockIndex\n * @typedef {import('./coding').BytesBufferReader} BytesBufferReader\n * @typedef {import('./coding').CarHeader} CarHeader\n * @typedef {import('./coding').CarV2Header} CarV2Header\n * @typedef {import('./coding').CarV2FixedHeader} CarV2FixedHeader\n */\n\n/**\n * Reads header data from a `BytesReader`. The header may either be in the form\n * of a `CarHeader` or `CarV2Header` depending on the CAR being read.\n *\n * @name decoder.readHeader(reader)\n * @param {BytesBufferReader} reader\n * @param {number} [strictVersion]\n * @returns {CarHeader | CarV2Header}\n */\nexport function readHeader(reader, strictVersion) {\n  const length = decodeVarint(reader.upTo(8), reader);\n  if (length === 0) {\n    throw new Error('Invalid CAR header (zero length)');\n  }\n  const header = reader.exactly(length, true);\n  const block = decodeDagCbor(header);\n  if (CarV1HeaderOrV2Pragma.toTyped(block) === undefined) {\n    throw new Error('Invalid CAR header format');\n  }\n  if (block.version !== 1 && block.version !== 2 || strictVersion !== undefined && block.version !== strictVersion) {\n    throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== undefined ? ` (expected ${strictVersion})` : ''}`);\n  }\n  if (block.version === 1) {\n    // CarV1HeaderOrV2Pragma makes roots optional, let's make it mandatory\n    if (!Array.isArray(block.roots)) {\n      throw new Error('Invalid CAR header format');\n    }\n    return block;\n  }\n  // version 2\n  if (block.roots !== undefined) {\n    throw new Error('Invalid CAR header format');\n  }\n  const v2Header = decodeV2Header(reader.exactly(V2_HEADER_LENGTH, true));\n  reader.seek(v2Header.dataOffset - reader.pos);\n  const v1Header = readHeader(reader, 1);\n  return Object.assign(v1Header, v2Header);\n}\n\n/**\n * Reads CID sync\n *\n * @param {BytesBufferReader} reader\n * @returns {CID}\n */\nfunction readCid(reader) {\n  const first = reader.exactly(2, false);\n  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n    // cidv0 32-byte sha2-256\n    const bytes = reader.exactly(34, true);\n    const multihash = Digest.decode(bytes);\n    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash);\n  }\n  const version = decodeVarint(reader.upTo(8), reader);\n  if (version !== 1) {\n    throw new Error(`Unexpected CID version (${version})`);\n  }\n  const codec = decodeVarint(reader.upTo(8), reader);\n  const bytes = reader.exactly(getMultihashLength(reader.upTo(8)), true);\n  const multihash = Digest.decode(bytes);\n  return CID.create(version, codec, multihash);\n}\n\n/**\n * Reads the leading data of an individual block from CAR data from a\n * `BytesBufferReader`. Returns a `BlockHeader` object which contains\n * `{ cid, length, blockLength }` which can be used to either index the block\n * or read the block binary data.\n *\n * @name async decoder.readBlockHead(reader)\n * @param {BytesBufferReader} reader\n * @returns {BlockHeader}\n */\nexport function readBlockHead(reader) {\n  // length includes a CID + Binary, where CID has a variable length\n  // we have to deal with\n  const start = reader.pos;\n  let length = decodeVarint(reader.upTo(8), reader);\n  if (length === 0) {\n    throw new Error('Invalid CAR section (zero length)');\n  }\n  length += reader.pos - start;\n  const cid = readCid(reader);\n  const blockLength = length - Number(reader.pos - start); // subtract CID length\n\n  return {\n    cid,\n    length,\n    blockLength\n  };\n}\n\n/**\n * Returns Car header and blocks from a Uint8Array\n *\n * @param {Uint8Array} bytes\n * @returns {{ header : CarHeader | CarV2Header , blocks: Block[]}}\n */\nexport function fromBytes(bytes) {\n  let reader = bytesReader(bytes);\n  const header = readHeader(reader);\n  if (header.version === 2) {\n    const v1length = reader.pos - header.dataOffset;\n    reader = limitReader(reader, header.dataSize - v1length);\n  }\n  const blocks = [];\n  while (reader.upTo(8).length > 0) {\n    const {\n      cid,\n      blockLength\n    } = readBlockHead(reader);\n    blocks.push({\n      cid,\n      bytes: reader.exactly(blockLength, true)\n    });\n  }\n  return {\n    header,\n    blocks\n  };\n}\n\n/**\n * Creates a `BytesBufferReader` from a `Uint8Array`.\n *\n * @name decoder.bytesReader(bytes)\n * @param {Uint8Array} bytes\n * @returns {BytesBufferReader}\n */\nexport function bytesReader(bytes) {\n  let pos = 0;\n\n  /** @type {BytesBufferReader} */\n  return {\n    upTo(length) {\n      return bytes.subarray(pos, pos + Math.min(length, bytes.length - pos));\n    },\n    exactly(length, seek = false) {\n      if (length > bytes.length - pos) {\n        throw new Error('Unexpected end of data');\n      }\n      const out = bytes.subarray(pos, pos + length);\n      if (seek) {\n        pos += length;\n      }\n      return out;\n    },\n    seek(length) {\n      pos += length;\n    },\n    get pos() {\n      return pos;\n    }\n  };\n}\n\n/**\n * Wraps a `BytesBufferReader` in a limiting `BytesBufferReader` which limits maximum read\n * to `byteLimit` bytes. It _does not_ update `pos` of the original\n * `BytesBufferReader`.\n *\n * @name decoder.limitReader(reader, byteLimit)\n * @param {BytesBufferReader} reader\n * @param {number} byteLimit\n * @returns {BytesBufferReader}\n */\nexport function limitReader(reader, byteLimit) {\n  let bytesRead = 0;\n\n  /** @type {BytesBufferReader} */\n  return {\n    upTo(length) {\n      let bytes = reader.upTo(length);\n      if (bytes.length + bytesRead > byteLimit) {\n        bytes = bytes.subarray(0, byteLimit - bytesRead);\n      }\n      return bytes;\n    },\n    exactly(length, seek = false) {\n      const bytes = reader.exactly(length, seek);\n      if (bytes.length + bytesRead > byteLimit) {\n        throw new Error('Unexpected end of data');\n      }\n      if (seek) {\n        bytesRead += length;\n      }\n      return bytes;\n    },\n    seek(length) {\n      bytesRead += length;\n      reader.seek(length);\n    },\n    get pos() {\n      return reader.pos;\n    }\n  };\n}","map":{"version":3,"names":["decode","decodeDagCbor","CID","Digest","CIDV0_BYTES","decodeV2Header","decodeVarint","getMultihashLength","V2_HEADER_LENGTH","CarV1HeaderOrV2Pragma","readHeader","reader","strictVersion","length","upTo","Error","header","exactly","block","toTyped","undefined","version","Array","isArray","roots","v2Header","seek","dataOffset","pos","v1Header","Object","assign","readCid","first","SHA2_256","LENGTH","bytes","multihash","create","DAG_PB","codec","readBlockHead","start","cid","blockLength","Number","fromBytes","bytesReader","v1length","limitReader","dataSize","blocks","push","subarray","Math","min","out","byteLimit","bytesRead"],"sources":["C:/FACULTATE/Proiect/node_modules/@web3-storage/upload-client/node_modules/@ipld/car/src/buffer-decoder.js"],"sourcesContent":["import { decode as decodeDagCbor } from '@ipld/dag-cbor'\nimport { CID } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { CIDV0_BYTES, decodeV2Header, decodeVarint, getMultihashLength, V2_HEADER_LENGTH } from './decoder-common.js'\nimport { CarV1HeaderOrV2Pragma } from './header-validator.js'\n\n/**\n * @typedef {import('./api').Block} Block\n * @typedef {import('./api').BlockHeader} BlockHeader\n * @typedef {import('./api').BlockIndex} BlockIndex\n * @typedef {import('./coding').BytesBufferReader} BytesBufferReader\n * @typedef {import('./coding').CarHeader} CarHeader\n * @typedef {import('./coding').CarV2Header} CarV2Header\n * @typedef {import('./coding').CarV2FixedHeader} CarV2FixedHeader\n */\n\n/**\n * Reads header data from a `BytesReader`. The header may either be in the form\n * of a `CarHeader` or `CarV2Header` depending on the CAR being read.\n *\n * @name decoder.readHeader(reader)\n * @param {BytesBufferReader} reader\n * @param {number} [strictVersion]\n * @returns {CarHeader | CarV2Header}\n */\nexport function readHeader (reader, strictVersion) {\n  const length = decodeVarint(reader.upTo(8), reader)\n  if (length === 0) {\n    throw new Error('Invalid CAR header (zero length)')\n  }\n  const header = reader.exactly(length, true)\n  const block = decodeDagCbor(header)\n  if (CarV1HeaderOrV2Pragma.toTyped(block) === undefined) {\n    throw new Error('Invalid CAR header format')\n  }\n  if ((block.version !== 1 && block.version !== 2) || (strictVersion !== undefined && block.version !== strictVersion)) {\n    throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== undefined ? ` (expected ${strictVersion})` : ''}`)\n  }\n  if (block.version === 1) {\n    // CarV1HeaderOrV2Pragma makes roots optional, let's make it mandatory\n    if (!Array.isArray(block.roots)) {\n      throw new Error('Invalid CAR header format')\n    }\n    return block\n  }\n  // version 2\n  if (block.roots !== undefined) {\n    throw new Error('Invalid CAR header format')\n  }\n  const v2Header = decodeV2Header(reader.exactly(V2_HEADER_LENGTH, true))\n  reader.seek(v2Header.dataOffset - reader.pos)\n  const v1Header = readHeader(reader, 1)\n  return Object.assign(v1Header, v2Header)\n}\n\n/**\n * Reads CID sync\n *\n * @param {BytesBufferReader} reader\n * @returns {CID}\n */\nfunction readCid (reader) {\n  const first = reader.exactly(2, false)\n  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n    // cidv0 32-byte sha2-256\n    const bytes = reader.exactly(34, true)\n    const multihash = Digest.decode(bytes)\n    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash)\n  }\n\n  const version = decodeVarint(reader.upTo(8), reader)\n  if (version !== 1) {\n    throw new Error(`Unexpected CID version (${version})`)\n  }\n  const codec = decodeVarint(reader.upTo(8), reader)\n  const bytes = reader.exactly(getMultihashLength(reader.upTo(8)), true)\n  const multihash = Digest.decode(bytes)\n  return CID.create(version, codec, multihash)\n}\n\n/**\n * Reads the leading data of an individual block from CAR data from a\n * `BytesBufferReader`. Returns a `BlockHeader` object which contains\n * `{ cid, length, blockLength }` which can be used to either index the block\n * or read the block binary data.\n *\n * @name async decoder.readBlockHead(reader)\n * @param {BytesBufferReader} reader\n * @returns {BlockHeader}\n */\nexport function readBlockHead (reader) {\n  // length includes a CID + Binary, where CID has a variable length\n  // we have to deal with\n  const start = reader.pos\n  let length = decodeVarint(reader.upTo(8), reader)\n  if (length === 0) {\n    throw new Error('Invalid CAR section (zero length)')\n  }\n  length += (reader.pos - start)\n  const cid = readCid(reader)\n  const blockLength = length - Number(reader.pos - start) // subtract CID length\n\n  return { cid, length, blockLength }\n}\n\n/**\n * Returns Car header and blocks from a Uint8Array\n *\n * @param {Uint8Array} bytes\n * @returns {{ header : CarHeader | CarV2Header , blocks: Block[]}}\n */\nexport function fromBytes (bytes) {\n  let reader = bytesReader(bytes)\n  const header = readHeader(reader)\n  if (header.version === 2) {\n    const v1length = reader.pos - header.dataOffset\n    reader = limitReader(reader, header.dataSize - v1length)\n  }\n\n  const blocks = []\n  while (reader.upTo(8).length > 0) {\n    const { cid, blockLength } = readBlockHead(reader)\n\n    blocks.push({ cid, bytes: reader.exactly(blockLength, true) })\n  }\n\n  return {\n    header, blocks\n  }\n}\n\n/**\n * Creates a `BytesBufferReader` from a `Uint8Array`.\n *\n * @name decoder.bytesReader(bytes)\n * @param {Uint8Array} bytes\n * @returns {BytesBufferReader}\n */\nexport function bytesReader (bytes) {\n  let pos = 0\n\n  /** @type {BytesBufferReader} */\n  return {\n    upTo (length) {\n      return bytes.subarray(pos, pos + Math.min(length, bytes.length - pos))\n    },\n\n    exactly (length, seek = false) {\n      if (length > bytes.length - pos) {\n        throw new Error('Unexpected end of data')\n      }\n\n      const out = bytes.subarray(pos, pos + length)\n      if (seek) {\n        pos += length\n      }\n      return out\n    },\n\n    seek (length) {\n      pos += length\n    },\n\n    get pos () {\n      return pos\n    }\n  }\n}\n\n/**\n * Wraps a `BytesBufferReader` in a limiting `BytesBufferReader` which limits maximum read\n * to `byteLimit` bytes. It _does not_ update `pos` of the original\n * `BytesBufferReader`.\n *\n * @name decoder.limitReader(reader, byteLimit)\n * @param {BytesBufferReader} reader\n * @param {number} byteLimit\n * @returns {BytesBufferReader}\n */\nexport function limitReader (reader, byteLimit) {\n  let bytesRead = 0\n\n  /** @type {BytesBufferReader} */\n  return {\n    upTo (length) {\n      let bytes = reader.upTo(length)\n      if (bytes.length + bytesRead > byteLimit) {\n        bytes = bytes.subarray(0, byteLimit - bytesRead)\n      }\n      return bytes\n    },\n\n    exactly (length, seek = false) {\n      const bytes = reader.exactly(length, seek)\n      if (bytes.length + bytesRead > byteLimit) {\n        throw new Error('Unexpected end of data')\n      }\n      if (seek) {\n        bytesRead += length\n      }\n      return bytes\n    },\n\n    seek (length) {\n      bytesRead += length\n      reader.seek(length)\n    },\n\n    get pos () {\n      return reader.pos\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}