{"ast":null,"code":"import * as API from \"./api.js\";\nexport { API };\n\n/**\n * @param {API.Uint32} size\n */\nexport const empty = (size = 32) => {\n  // We could support < 32, but it seems impractical and would negatively affect\n  // performance as we would have to do extra bound checks.\n  if (size !== 32) {\n    throw new Error(`Uint32 BitField does not support size: ${size}`);\n  }\n  return 0;\n};\n\n/**\n * @param  {API.Uint32[]} bits\n * @param {API.Uint32} [size]\n */\nexport const from = (bits, size) => {\n  let bitfield = empty(size);\n  for (const bit of bits) {\n    bitfield = set(bitfield, bit);\n  }\n  return bitfield;\n};\n\n/**\n * @param {API.Uint32} _bitField\n */\nexport const size = _bitField => 32;\n\n/**\n * Reads out 5 bits at the given bit offset.\n *\n * @param {API.Uint32} bitField - Bitfield in Uint32 representation.\n * @param {API.Uint32} index - Index with-in `bitField` to read bits from.\n * @returns {API.Uint32}\n */\nconst mask = (bitField, index) => bitField >>> index & 0b11111;\n\n/**\n * Creates mask that can be used to check a bit in nodes bitmap for the give\n * key (hash) at given depth.\n *\n * @param {API.Uint32} bitField - Key hash as 32 bit integer.\n * @param {API.Uint32} index - Index with-in the 32bit bitfield\n */\nconst offset = (bitField, index) => 1 << mask(bitField, index);\n\n/**\n * Maps numbers [0, 31] to powers of two. Creates mask that can be used\n * to check a bit in nodes bitmap for the give key (hash) at given depth.\n *\n * @param {API.Uint32} bitField - Key hash as 32 bit integer.\n * @param {API.Uint32} index - Index with-in the 32bit bitfield\n */\nexport const popcount = (bitField, index = 31) => bitCount(bitField & offset(index, 0) - 1);\n\n/**\n * @param {API.Uint32} bitField\n * @param {API.Uint32} index\n */\nexport const set = (bitField, index) => bitField | 1 << index;\n\n/**\n * @param {API.Uint32} bitField\n * @param {API.Uint32} index\n */\nexport const unset = (bitField, index) => bitField & (0xff ^ 1 << index);\n\n/**\n * @param {API.Uint32} bitField\n * @param {API.Uint32} index\n */\nexport const get = (bitField, index) => (bitField >> index & 0x1) !== 0;\n\n/**\n * Counts the number of bits set in n\n * @param {API.Uint32} bitField\n */\nexport const bitCount = bitField => {\n  const n1 = bitField - (bitField >> 1 & 0x55555555);\n  const n2 = (n1 & 0x33333333) + (n1 >> 2 & 0x33333333);\n  const n3 = (n2 + (n2 >> 4) & 0xf0f0f0f) * 0x1010101;\n  return n3 >> 24;\n};\n\n/**\n * @param {API.Uint32} left\n * @param {API.Uint32} right\n * @returns {API.Uint32}\n */\nexport const and = (left, right) => left & right;\n\n/**\n * @param {API.Uint32} left\n * @param {API.Uint32} right\n * @returns {API.Uint32}\n */\nexport const or = (left, right) => left | right;\n\n/**\n * Counts the number of bits set in n\n * @param {API.Uint32} bitField\n * @returns {Uint8Array}\n */\nexport const toBytes = bitField => Uint8Array.of(bitField >> 24 & 0b1111_1111, bitField >> 16 & 0b1111_1111, bitField >> 8 & 0b1111_1111, bitField & 0b1111_1111);\n\n/**\n *\n * @param {Uint8Array} bytes\n * @returns {API.Uint32}\n */\nexport const fromBytes = bytes => {\n  if (bytes.length !== 4) {\n    throw new Error(`Expected 4 bytes instead got ${bytes.length}`);\n  }\n  return (bytes[0] << 24) + (bytes[1] << 16) + (bytes[2] << 8) + bytes[3];\n};","map":{"version":3,"names":["API","empty","size","Error","from","bits","bitfield","bit","set","_bitField","mask","bitField","index","offset","popcount","bitCount","unset","get","n1","n2","n3","and","left","right","or","toBytes","Uint8Array","of","fromBytes","bytes","length"],"sources":["C:/FACULTATE/Proiect/node_modules/@perma/map/src/bitfield/Uint32.js"],"sourcesContent":["import * as API from \"./api.js\"\n\nexport { API }\n\n/**\n * @param {API.Uint32} size\n */\nexport const empty = (size = 32) => {\n  // We could support < 32, but it seems impractical and would negatively affect\n  // performance as we would have to do extra bound checks.\n  if (size !== 32) {\n    throw new Error(`Uint32 BitField does not support size: ${size}`)\n  }\n\n  return 0\n}\n\n/**\n * @param  {API.Uint32[]} bits\n * @param {API.Uint32} [size]\n */\nexport const from = (bits, size) => {\n  let bitfield = empty(size)\n  for (const bit of bits) {\n    bitfield = set(bitfield, bit)\n  }\n  return bitfield\n}\n\n/**\n * @param {API.Uint32} _bitField\n */\nexport const size = _bitField => 32\n\n/**\n * Reads out 5 bits at the given bit offset.\n *\n * @param {API.Uint32} bitField - Bitfield in Uint32 representation.\n * @param {API.Uint32} index - Index with-in `bitField` to read bits from.\n * @returns {API.Uint32}\n */\nconst mask = (bitField, index) => (bitField >>> index) & 0b11111\n\n/**\n * Creates mask that can be used to check a bit in nodes bitmap for the give\n * key (hash) at given depth.\n *\n * @param {API.Uint32} bitField - Key hash as 32 bit integer.\n * @param {API.Uint32} index - Index with-in the 32bit bitfield\n */\nconst offset = (bitField, index) => 1 << mask(bitField, index)\n\n/**\n * Maps numbers [0, 31] to powers of two. Creates mask that can be used\n * to check a bit in nodes bitmap for the give key (hash) at given depth.\n *\n * @param {API.Uint32} bitField - Key hash as 32 bit integer.\n * @param {API.Uint32} index - Index with-in the 32bit bitfield\n */\nexport const popcount = (bitField, index = 31) =>\n  bitCount(bitField & (offset(index, 0) - 1))\n\n/**\n * @param {API.Uint32} bitField\n * @param {API.Uint32} index\n */\nexport const set = (bitField, index) => bitField | (1 << index)\n\n/**\n * @param {API.Uint32} bitField\n * @param {API.Uint32} index\n */\nexport const unset = (bitField, index) => bitField & (0xff ^ (1 << index))\n\n/**\n * @param {API.Uint32} bitField\n * @param {API.Uint32} index\n */\nexport const get = (bitField, index) => ((bitField >> index) & 0x1) !== 0\n\n/**\n * Counts the number of bits set in n\n * @param {API.Uint32} bitField\n */\nexport const bitCount = bitField => {\n  const n1 = bitField - ((bitField >> 1) & 0x55555555)\n  const n2 = (n1 & 0x33333333) + ((n1 >> 2) & 0x33333333)\n  const n3 = ((n2 + (n2 >> 4)) & 0xf0f0f0f) * 0x1010101\n  return n3 >> 24\n}\n\n/**\n * @param {API.Uint32} left\n * @param {API.Uint32} right\n * @returns {API.Uint32}\n */\nexport const and = (left, right) => left & right\n\n/**\n * @param {API.Uint32} left\n * @param {API.Uint32} right\n * @returns {API.Uint32}\n */\nexport const or = (left, right) => left | right\n\n/**\n * Counts the number of bits set in n\n * @param {API.Uint32} bitField\n * @returns {Uint8Array}\n */\nexport const toBytes = bitField =>\n  Uint8Array.of(\n    (bitField >> 24) & 0b1111_1111,\n    (bitField >> 16) & 0b1111_1111,\n    (bitField >> 8) & 0b1111_1111,\n    bitField & 0b1111_1111\n  )\n\n/**\n *\n * @param {Uint8Array} bytes\n * @returns {API.Uint32}\n */\nexport const fromBytes = bytes => {\n  if (bytes.length !== 4) {\n    throw new Error(`Expected 4 bytes instead got ${bytes.length}`)\n  }\n  return (bytes[0] << 24) + (bytes[1] << 16) + (bytes[2] << 8) + bytes[3]\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}