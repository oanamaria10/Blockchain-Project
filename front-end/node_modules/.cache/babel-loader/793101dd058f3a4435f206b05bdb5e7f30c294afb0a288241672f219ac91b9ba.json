{"ast":null,"code":"import * as PieceHasher from '@web3-storage/data-segment/multihash';\nimport { Storefront } from '@web3-storage/filecoin-client';\nimport * as Link from 'multiformats/link';\nimport * as raw from 'multiformats/codecs/raw';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport * as Store from './store.js';\nimport * as Blob from './blob/index.js';\nimport * as BlobAdd from './blob/add.js';\nimport * as Index from './index/index.js';\nimport * as IndexAdd from './index/add.js';\nimport * as Upload from './upload/index.js';\nimport * as UploadAdd from './upload/add.js';\nimport * as UnixFS from './unixfs.js';\nimport * as CAR from './car.js';\nimport { ShardingStream, defaultFileComparator } from './sharding.js';\nimport { indexShardedDAG } from '@web3-storage/blob-index';\nexport { Blob, Index, Store, Upload, UnixFS, CAR };\nexport * from './sharding.js';\nexport { receiptsEndpoint } from './service.js';\nimport * as _Receipt from './receipts.js';\nexport { _Receipt as Receipt };\n/**\n * Uploads a file to the service and returns the root data CID for the\n * generated DAG.\n *\n * Required delegated capability proofs: `blob/add`, `index/add`,\n * `filecoin/offer`, `upload/add`\n *\n * @param {import('./types.js').InvocationConfig|import('./types.js').InvocationConfigurator} conf Configuration\n * for the UCAN invocation. An object with `issuer`, `with` and `proofs`, or a\n * function that generates this object.\n *\n * The `issuer` is the signing authority that is issuing the UCAN\n * invocation(s). It is typically the user _agent_.\n *\n * The `with` is the resource the invocation applies to. It is typically the\n * DID of a space.\n *\n * The `proofs` are a set of capability delegations that prove the issuer\n * has the capability to perform the action.\n *\n * The issuer needs the `blob/add`, `index/add`, `filecoin/offer` and\n * `upload/add` delegated capability.\n * @param {import('./types.js').BlobLike} file File data.\n * @param {import('./types.js').UploadFileOptions} [options]\n */\nexport async function uploadFile(conf, file, options = {}) {\n  return await uploadBlockStream(conf, UnixFS.createFileEncoderStream(file, options), options);\n}\n/**\n * Uploads a directory of files to the service and returns the root data CID\n * for the generated DAG. All files are added to a container directory, with\n * paths in file names preserved.\n *\n * Required delegated capability proofs: `blob/add`, `index/add`,\n * `filecoin/offer`, `upload/add`\n *\n * @param {import('./types.js').InvocationConfig|import('./types.js').InvocationConfigurator} conf Configuration\n * for the UCAN invocation. An object with `issuer`, `with` and `proofs`, or a\n * function that generates this object\n *\n * The `issuer` is the signing authority that is issuing the UCAN\n * invocation(s). It is typically the user _agent_.\n *\n * The `with` is the resource the invocation applies to. It is typically the\n * DID of a space.\n *\n * The `proofs` are a set of capability delegations that prove the issuer\n * has the capability to perform the action.\n *\n * The issuer needs the `blob/add`, `index/add`, `filecoin/offer` and\n * `upload/add` delegated capability.\n * @param {import('./types.js').FileLike[]} files  Files that should be in the directory.\n * To ensure determinism in the IPLD encoding, files are automatically sorted by `file.name`.\n * To retain the order of the files as passed in the array, set `customOrder` option to `true`.\n * @param {import('./types.js').UploadDirectoryOptions} [options]\n */\nexport async function uploadDirectory(conf, files, options = {}) {\n  const {\n    customOrder = false\n  } = options;\n  const entries = customOrder ? files : [...files].sort(defaultFileComparator);\n  return await uploadBlockStream(conf, UnixFS.createDirectoryEncoderStream(entries, options), options);\n}\n/**\n * Uploads a CAR file to the service.\n *\n * The difference between this function and `Store.add` is that the CAR file is\n * automatically sharded and an \"upload\" is registered, linking the individual\n * shards (see `Upload.add`).\n *\n * Use the `onShardStored` callback to obtain the CIDs of the CAR file shards.\n *\n * Required delegated capability proofs: `blob/add`, `index/add`,\n * `filecoin/offer`, `upload/add`\n *\n * @param {import('./types.js').InvocationConfig|import('./types.js').InvocationConfigurator} conf Configuration\n * for the UCAN invocation. An object with `issuer`, `with` and `proofs`, or a\n * function that generates this object\n *\n * The `issuer` is the signing authority that is issuing the UCAN\n * invocation(s). It is typically the user _agent_.\n *\n * The `with` is the resource the invocation applies to. It is typically the\n * DID of a space.\n *\n * The `proofs` are a set of capability delegations that prove the issuer\n * has the capability to perform the action.\n *\n * The issuer needs the `blob/add`, `index/add`, `filecoin/offer` and `upload/add` delegated capability.\n * @param {import('./types.js').BlobLike} car CAR file.\n * @param {import('./types.js').UploadOptions} [options]\n */\nexport async function uploadCAR(conf, car, options = {}) {\n  const blocks = new CAR.BlockStream(car);\n  options.rootCID = options.rootCID ?? (await blocks.getRoots())[0];\n  return await uploadBlockStream(conf, blocks, options);\n}\n/**\n * @param {import('./types.js').InvocationConfig|import('./types.js').InvocationConfigurator} conf\n * @param {ReadableStream<import('@ipld/unixfs').Block>} blocks\n * @param {import('./types.js').UploadOptions} [options]\n * @returns {Promise<import('./types.js').AnyLink>}\n */\nasync function uploadBlockStream(conf, blocks, {\n  pieceHasher = PieceHasher,\n  ...options\n} = {}) {\n  /** @type {import('./types.js').InvocationConfigurator} */\n  const configure = typeof conf === 'function' ? conf : () => conf;\n  /** @type {Array<Map<import('./types.js').SliceDigest, import('./types.js').Position>>} */\n  const shardIndexes = [];\n  /** @type {import('./types.js').CARLink[]} */\n  const shards = [];\n  /** @type {import('./types.js').AnyLink?} */\n  let root = null;\n  await blocks.pipeThrough(new ShardingStream(options)).pipeThrough( /** @type {TransformStream<import('./types.js').IndexedCARFile, import('./types.js').CARMetadata>} */\n  new TransformStream({\n    async transform(car, controller) {\n      const bytes = new Uint8Array(await car.arrayBuffer());\n      const digest = await sha256.digest(bytes);\n      const conf = await configure([{\n        can: BlobAdd.ability,\n        nb: BlobAdd.input(digest, bytes.length)\n      }]);\n      // Invoke blob/add and write bytes to write target\n      await Blob.add(conf, digest, bytes, options);\n      const cid = Link.create(CAR.code, digest);\n      let piece;\n      if (pieceHasher) {\n        const multihashDigest = await pieceHasher.digest(bytes);\n        /** @type {import('@web3-storage/capabilities/types').PieceLink} */\n        piece = Link.create(raw.code, multihashDigest);\n        const content = Link.create(raw.code, digest);\n        // Invoke filecoin/offer for data\n        const result = await Storefront.filecoinOffer({\n          issuer: conf.issuer,\n          audience: conf.audience,\n          // Resource of invocation is the issuer did for being self issued\n          with: conf.issuer.did(),\n          proofs: conf.proofs\n        }, content, piece, options);\n        if (result.out.error) {\n          throw new Error('failed to offer piece for aggregation into filecoin deal', {\n            cause: result.out.error\n          });\n        }\n      }\n      const {\n        version,\n        roots,\n        size,\n        slices\n      } = car;\n      controller.enqueue({\n        version,\n        roots,\n        size,\n        cid,\n        piece,\n        slices\n      });\n    }\n  })).pipeTo(new WritableStream({\n    write(meta) {\n      root = root || meta.roots[0];\n      shards.push(meta.cid);\n      // add the CAR shard itself to the slices\n      meta.slices.set(meta.cid.multihash, [0, meta.size]);\n      shardIndexes.push(meta.slices);\n      if (options.onShardStored) options.onShardStored(meta);\n    }\n  }));\n  /* c8 ignore next */\n  if (!root) throw new Error('missing root CID');\n  const indexBytes = await indexShardedDAG(root, shards, shardIndexes);\n  /* c8 ignore next 3 */\n  if (!indexBytes.ok) {\n    throw new Error('failed to archive DAG index', {\n      cause: indexBytes.error\n    });\n  }\n  const indexDigest = await sha256.digest(indexBytes.ok);\n  const indexLink = Link.create(CAR.code, indexDigest);\n  const [blobAddConf, indexAddConf, uploadAddConf] = await Promise.all([configure([{\n    can: BlobAdd.ability,\n    nb: BlobAdd.input(indexDigest, indexBytes.ok.length)\n  }]), configure([{\n    can: IndexAdd.ability,\n    nb: IndexAdd.input(indexLink)\n  }]), configure([{\n    can: UploadAdd.ability,\n    nb: UploadAdd.input(root, shards)\n  }])]);\n  // Store the index in the space\n  await Blob.add(blobAddConf, indexDigest, indexBytes.ok, options);\n  // Register the index with the service\n  await Index.add(indexAddConf, indexLink, options);\n  // Register an upload with the service\n  await Upload.add(uploadAddConf, root, shards, options);\n  return root;\n}","map":{"version":3,"names":["PieceHasher","Storefront","Link","raw","sha256","Store","Blob","BlobAdd","Index","IndexAdd","Upload","UploadAdd","UnixFS","CAR","ShardingStream","defaultFileComparator","indexShardedDAG","receiptsEndpoint","_Receipt","Receipt","uploadFile","conf","file","options","uploadBlockStream","createFileEncoderStream","uploadDirectory","files","customOrder","entries","sort","createDirectoryEncoderStream","uploadCAR","car","blocks","BlockStream","rootCID","getRoots","pieceHasher","configure","shardIndexes","shards","root","pipeThrough","TransformStream","transform","controller","bytes","Uint8Array","arrayBuffer","digest","can","ability","nb","input","length","add","cid","create","code","piece","multihashDigest","content","result","filecoinOffer","issuer","audience","with","did","proofs","out","error","Error","cause","version","roots","size","slices","enqueue","pipeTo","WritableStream","write","meta","push","set","multihash","onShardStored","indexBytes","ok","indexDigest","indexLink","blobAddConf","indexAddConf","uploadAddConf","Promise","all"],"sources":["../../src/index.js"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}