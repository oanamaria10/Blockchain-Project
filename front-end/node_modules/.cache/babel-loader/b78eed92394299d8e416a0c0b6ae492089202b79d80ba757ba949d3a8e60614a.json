{"ast":null,"code":"import { varint } from 'multiformats';\nimport * as API from './api.js';\nimport { IN_BYTES_PER_QUAD, IN_BITS_FR, OUT_BITS_FR, MIN_PAYLOAD_SIZE } from './constant.js';\nimport { SHA256 } from './ipld.js';\nimport { fromHeight as piceSizeFromHeight } from './piece/size/expanded.js';\n\n/**\n * @see https://github.com/multiformats/multicodec/pull/331/files\n */\nexport const name = /** @type {const} */\n'fr32-sha2-256-trunc254-padded-binary-tree';\n\n/**\n * @type {API.MulticodecCode<0x1011, typeof name>}\n * @see https://github.com/multiformats/multicodec/pull/331/files\n */\nexport const code = 0x1011;\n\n/**\n * Varint is used to encode the tree height which is limited to 9 bytes.\n *\n * @see https://github.com/multiformats/unsigned-varint#practical-maximum-of-9-bytes-for-security\n */\nconst MAX_PADDING_SIZE = 9;\n/**\n * One byte is used to store the tree height.\n */\nexport const HEIGHT_SIZE = 1;\n\n/**\n * Amount of bytes used to store the tree root.\n */\nexport const ROOT_SIZE = SHA256.size;\n\n/**\n * Size of the multihash digest in bytes.\n */\nexport const MAX_DIGEST_SIZE = MAX_PADDING_SIZE + HEIGHT_SIZE + SHA256.size;\nexport const TAG_SIZE = varint.encodingLength(code);\n\n/**\n * Max size of the multihash in bytes\n */\nexport const MAX_SIZE = TAG_SIZE + varint.encodingLength(MAX_DIGEST_SIZE) + MAX_DIGEST_SIZE;\n\n/**\n * Since first byte in the digest is the tree height, the maximum height is 255.\n *\n * @type {255}\n */\nexport const MAX_HEIGHT = 255;\n\n/**\n * Max payload is determined by the maximum height of the tree, which is limited\n * by the int we could store in one byte. We calculate the max piece size\n * and derive max payload size that can would produce it after FR32 padding.\n */\nexport const MAX_PAYLOAD_SIZE = piceSizeFromHeight(MAX_HEIGHT) * BigInt(IN_BITS_FR) / BigInt(OUT_BITS_FR);\n\n/**\n * @param {API.Piece} piece\n * @returns {API.PieceDigest}\n */\nexport const fromPiece = ({\n  padding,\n  height,\n  root\n}) => {\n  const paddingLength = varint.encodingLength(Number(padding));\n  const size = paddingLength + HEIGHT_SIZE + ROOT_SIZE;\n  const sizeLength = varint.encodingLength(size);\n  const multihashLength = TAG_SIZE + sizeLength + size;\n  let offset = 0;\n  const bytes = new Uint8Array(multihashLength);\n  varint.encodeTo(code, bytes, offset);\n  offset += TAG_SIZE;\n  varint.encodeTo(size, bytes, offset);\n  offset += sizeLength;\n  varint.encodeTo(Number(padding), bytes, offset);\n  offset += paddingLength;\n  bytes[offset] = height;\n  offset += HEIGHT_SIZE;\n  bytes.set(root, offset);\n  return new Digest(bytes);\n};\n\n/**\n * @param {Uint8Array} bytes\n * @returns {API.PieceDigest}\n */\nexport const fromBytes = bytes => new Digest(bytes);\n\n/**\n * @param {object} input\n * @param {Uint8Array} input.digest\n */\nexport const toBytes = ({\n  digest\n}) => {\n  const SIZE_BYTE_LENGTH = varint.encodingLength(digest.length);\n\n  // number of bytes prefix will take up\n  const prefixByteLength = SIZE_BYTE_LENGTH + TAG_SIZE;\n\n  // if digest is view within a buffer that has enough bytes in front to\n  // fit the prefix it may be already include a prefix in which case we\n  // will simply use a larger slice.\n  if (digest.byteOffset >= prefixByteLength) {\n    const bytes = new Uint8Array(digest.buffer, digest.byteOffset - prefixByteLength, digest.byteOffset + digest.length);\n\n    // if the prefix matches our bytes represent a multihash\n    const [tag, offset] = varint.decode(bytes);\n    if (tag === code && varint.decode(bytes, offset)[0] === digest.length) {\n      return bytes;\n    }\n  }\n  const bytes = new Uint8Array(digest.length + prefixByteLength);\n  varint.encodeTo(code, bytes);\n  varint.encodeTo(digest.length, bytes, TAG_SIZE);\n  bytes.set(digest, prefixByteLength);\n  return bytes;\n};\n\n/**\n * @param {object} input\n * @param {Uint8Array} input.digest\n */\nexport const height = ({\n  digest\n}) => {\n  const [, offset] = varint.decode(digest);\n  return digest[offset];\n};\n\n/**\n * @param {object} input\n * @param {Uint8Array} input.digest\n */\nexport const padding = ({\n  digest\n}) => {\n  const [padding] = varint.decode(digest);\n  return BigInt(padding);\n};\n\n/**\n * @param {object} input\n * @param {Uint8Array} input.digest\n */\nexport const root = ({\n  digest\n}) => {\n  const [, offset] = varint.decode(digest);\n  return digest.subarray(offset + HEIGHT_SIZE, offset + HEIGHT_SIZE + SHA256.size);\n};\n\n/**\n * @implements {API.PieceDigest}\n */\nclass Digest {\n  /**\n   * @param {Uint8Array} bytes\n   */\n  constructor(bytes) {\n    this.bytes = bytes;\n    const [tag] = varint.decode(bytes);\n    if (tag !== code) {\n      throw new RangeError(`Expected multihash with code ${code}`);\n    }\n    let offset = TAG_SIZE;\n    const [size, length] = varint.decode(bytes, offset);\n    offset += length;\n    const digest = bytes.subarray(offset);\n    if (digest.length !== size) {\n      throw new RangeError(`Invalid multihash size expected ${offset + size} bytes, got ${bytes.length} bytes`);\n    }\n    this.digest = digest;\n  }\n  get name() {\n    return name;\n  }\n  get code() {\n    return code;\n  }\n  get size() {\n    return this.digest.length;\n  }\n  get padding() {\n    return padding(this);\n  }\n  get height() {\n    return height(this);\n  }\n  get root() {\n    return root(this);\n  }\n}","map":{"version":3,"names":["varint","API","IN_BYTES_PER_QUAD","IN_BITS_FR","OUT_BITS_FR","MIN_PAYLOAD_SIZE","SHA256","fromHeight","piceSizeFromHeight","name","code","MAX_PADDING_SIZE","HEIGHT_SIZE","ROOT_SIZE","size","MAX_DIGEST_SIZE","TAG_SIZE","encodingLength","MAX_SIZE","MAX_HEIGHT","MAX_PAYLOAD_SIZE","BigInt","fromPiece","padding","height","root","paddingLength","Number","sizeLength","multihashLength","offset","bytes","Uint8Array","encodeTo","set","Digest","fromBytes","toBytes","digest","SIZE_BYTE_LENGTH","length","prefixByteLength","byteOffset","buffer","tag","decode","subarray","constructor","RangeError"],"sources":["C:/FACULTATE/Proiect/node_modules/@web3-storage/data-segment/src/digest.js"],"sourcesContent":["import { varint } from 'multiformats'\nimport * as API from './api.js'\nimport {\n  IN_BYTES_PER_QUAD,\n  IN_BITS_FR,\n  OUT_BITS_FR,\n  MIN_PAYLOAD_SIZE,\n} from './constant.js'\nimport { SHA256 } from './ipld.js'\nimport { fromHeight as piceSizeFromHeight } from './piece/size/expanded.js'\n\n/**\n * @see https://github.com/multiformats/multicodec/pull/331/files\n */\nexport const name = /** @type {const} */ (\n  'fr32-sha2-256-trunc254-padded-binary-tree'\n)\n\n/**\n * @type {API.MulticodecCode<0x1011, typeof name>}\n * @see https://github.com/multiformats/multicodec/pull/331/files\n */\nexport const code = 0x1011\n\n/**\n * Varint is used to encode the tree height which is limited to 9 bytes.\n *\n * @see https://github.com/multiformats/unsigned-varint#practical-maximum-of-9-bytes-for-security\n */\nconst MAX_PADDING_SIZE = 9\n/**\n * One byte is used to store the tree height.\n */\nexport const HEIGHT_SIZE = 1\n\n/**\n * Amount of bytes used to store the tree root.\n */\nexport const ROOT_SIZE = SHA256.size\n\n/**\n * Size of the multihash digest in bytes.\n */\nexport const MAX_DIGEST_SIZE = MAX_PADDING_SIZE + HEIGHT_SIZE + SHA256.size\n\nexport const TAG_SIZE = varint.encodingLength(code)\n\n/**\n * Max size of the multihash in bytes\n */\nexport const MAX_SIZE =\n  TAG_SIZE + varint.encodingLength(MAX_DIGEST_SIZE) + MAX_DIGEST_SIZE\n\n/**\n * Since first byte in the digest is the tree height, the maximum height is 255.\n *\n * @type {255}\n */\nexport const MAX_HEIGHT = 255\n\n/**\n * Max payload is determined by the maximum height of the tree, which is limited\n * by the int we could store in one byte. We calculate the max piece size\n * and derive max payload size that can would produce it after FR32 padding.\n */\nexport const MAX_PAYLOAD_SIZE =\n  (piceSizeFromHeight(MAX_HEIGHT) * BigInt(IN_BITS_FR)) / BigInt(OUT_BITS_FR)\n\n/**\n * @param {API.Piece} piece\n * @returns {API.PieceDigest}\n */\nexport const fromPiece = ({ padding, height, root }) => {\n  const paddingLength = varint.encodingLength(Number(padding))\n  const size = paddingLength + HEIGHT_SIZE + ROOT_SIZE\n  const sizeLength = varint.encodingLength(size)\n\n  const multihashLength = TAG_SIZE + sizeLength + size\n\n  let offset = 0\n  const bytes = new Uint8Array(multihashLength)\n  varint.encodeTo(code, bytes, offset)\n  offset += TAG_SIZE\n\n  varint.encodeTo(size, bytes, offset)\n  offset += sizeLength\n\n  varint.encodeTo(Number(padding), bytes, offset)\n  offset += paddingLength\n\n  bytes[offset] = height\n  offset += HEIGHT_SIZE\n\n  bytes.set(root, offset)\n\n  return new Digest(bytes)\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {API.PieceDigest}\n */\nexport const fromBytes = (bytes) => new Digest(bytes)\n\n/**\n * @param {object} input\n * @param {Uint8Array} input.digest\n */\nexport const toBytes = ({ digest }) => {\n  const SIZE_BYTE_LENGTH = varint.encodingLength(digest.length)\n\n  // number of bytes prefix will take up\n  const prefixByteLength = SIZE_BYTE_LENGTH + TAG_SIZE\n\n  // if digest is view within a buffer that has enough bytes in front to\n  // fit the prefix it may be already include a prefix in which case we\n  // will simply use a larger slice.\n  if (digest.byteOffset >= prefixByteLength) {\n    const bytes = new Uint8Array(\n      digest.buffer,\n      digest.byteOffset - prefixByteLength,\n      digest.byteOffset + digest.length\n    )\n\n    // if the prefix matches our bytes represent a multihash\n    const [tag, offset] = varint.decode(bytes)\n    if (tag === code && varint.decode(bytes, offset)[0] === digest.length) {\n      return bytes\n    }\n  }\n\n  const bytes = new Uint8Array(digest.length + prefixByteLength)\n  varint.encodeTo(code, bytes)\n  varint.encodeTo(digest.length, bytes, TAG_SIZE)\n  bytes.set(digest, prefixByteLength)\n\n  return bytes\n}\n\n/**\n * @param {object} input\n * @param {Uint8Array} input.digest\n */\nexport const height = ({ digest }) => {\n  const [, offset] = varint.decode(digest)\n  return digest[offset]\n}\n\n/**\n * @param {object} input\n * @param {Uint8Array} input.digest\n */\nexport const padding = ({ digest }) => {\n  const [padding] = varint.decode(digest)\n  return BigInt(padding)\n}\n\n/**\n * @param {object} input\n * @param {Uint8Array} input.digest\n */\nexport const root = ({ digest }) => {\n  const [, offset] = varint.decode(digest)\n  return digest.subarray(\n    offset + HEIGHT_SIZE,\n    offset + HEIGHT_SIZE + SHA256.size\n  )\n}\n\n/**\n * @implements {API.PieceDigest}\n */\nclass Digest {\n  /**\n   * @param {Uint8Array} bytes\n   */\n  constructor(bytes) {\n    this.bytes = bytes\n    const [tag] = varint.decode(bytes)\n    if (tag !== code) {\n      throw new RangeError(`Expected multihash with code ${code}`)\n    }\n\n    let offset = TAG_SIZE\n    const [size, length] = varint.decode(bytes, offset)\n    offset += length\n    const digest = bytes.subarray(offset)\n\n    if (digest.length !== size) {\n      throw new RangeError(\n        `Invalid multihash size expected ${offset + size} bytes, got ${\n          bytes.length\n        } bytes`\n      )\n    }\n\n    this.digest = digest\n  }\n  get name() {\n    return name\n  }\n  get code() {\n    return code\n  }\n  get size() {\n    return this.digest.length\n  }\n  get padding() {\n    return padding(this)\n  }\n  get height() {\n    return height(this)\n  }\n  get root() {\n    return root(this)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}