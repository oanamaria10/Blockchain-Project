{"ast":null,"code":"import * as API from \"./api.js\";\nimport { toInt } from \"./Uint8Array.js\";\nimport { murmur364 } from \"@multiformats/murmur3\";\nconst utf8 = new TextEncoder();\n\n/**\n * @param {Uint8Array} bytes\n */\nexport const hash64 = bytes => ( /** @type {Uint8Array} */murmur364.encode(bytes));\n\n/**\n * @param {Partial<API.Options<Uint8Array>>} options\n * @returns {API.Path<Uint8Array>}\n */\nexport const configure = ({\n  bitWidth = 8,\n  hash = hash64\n}) => {\n  const hashSize = hash(new Uint8Array()).byteLength;\n  const options = {\n    bitWidth,\n    hash,\n    hashSize\n  };\n\n  /**\n   * @param {Uint8Array} path\n   * @param {number} depth\n   * @returns {API.Uint32}\n   */\n  const at = (path, depth) => read(path, depth, options);\n\n  /**\n   * @param {string} key\n   */\n  const from = key => utf8.encode(key);\n  return {\n    at,\n    from,\n    size: Infinity\n  };\n};\n\n/**\n * @param {Uint8Array} key\n * @param {number} depth\n * @param {object} options\n * @param {number} [options.bitWidth]\n * @param {number} options.hashSize\n * @param {(input:Uint8Array) => Uint8Array} options.hash\n */\nexport const read = (key, depth = 0, {\n  bitWidth = 8,\n  hash,\n  hashSize\n}) => {\n  // key digest consists of infinite number of hash frames that are computed\n  // from key + frame n which looks like\n  // [hash(key), hash([key, 1]), hash([key, n])]\n  // You can think of the hash as concatination of all frames. Here we calculate\n  // frame bit size from hash size as we going to use that several times.\n  const frameBitSize = hashSize * 8;\n\n  // We start with 0 digest and required `bitCount` corresponding to `bitWith`.\n  // In the loop we'll going to consume `bitCount` hash bits.\n  let digest = 0;\n  let bitCount = bitWidth;\n  // Calculate absolute bit offset within the key digest.\n  let bitOffset = bitWidth * depth;\n  while (bitCount > 0) {\n    // We derive frame number based on current bit offset.\n    const frameOffset = bitOffset / frameBitSize >> 0;\n    // Then we compute that hash frame\n    const frame = frameOffset === 0 ? hash(key) : hash(appendByte(key, frameOffset));\n\n    // compute bit offset within the current frame\n    const offset = frameBitSize <= bitOffset ? bitOffset % frameBitSize : bitOffset;\n    // calculate number of bits remaining in this frame\n    const maxBits = frameBitSize - offset;\n    // we will consume all required bits from frame if enough are available\n    // otherwise we consume whatever's available and continue rest in the next\n    // cycle(s).\n    const count = maxBits < bitCount ? maxBits : bitCount;\n    digest = (digest << count) + toInt(frame, offset, count);\n    bitCount -= count;\n    bitOffset += count;\n  }\n  return digest;\n};\n\n/**\n * @param {Uint8Array} source\n * @param {number} byte\n */\nconst appendByte = (source, byte) => {\n  const bytes = new Uint8Array(source.byteLength + 1).fill(byte, source.byteLength);\n  bytes.set(source);\n  return bytes;\n};","map":{"version":3,"names":["API","toInt","murmur364","utf8","TextEncoder","hash64","bytes","encode","configure","bitWidth","hash","hashSize","Uint8Array","byteLength","options","at","path","depth","read","from","key","size","Infinity","frameBitSize","digest","bitCount","bitOffset","frameOffset","frame","appendByte","offset","maxBits","count","source","byte","fill","set"],"sources":["C:/FACULTATE/Proiect/node_modules/@perma/map/src/path/InfiniteUint8Array.js"],"sourcesContent":["import * as API from \"./api.js\"\nimport { toInt } from \"./Uint8Array.js\"\nimport { murmur364 } from \"@multiformats/murmur3\"\nconst utf8 = new TextEncoder()\n\n/**\n * @param {Uint8Array} bytes\n */\nexport const hash64 = bytes =>\n  /** @type {Uint8Array} */ (murmur364.encode(bytes))\n\n/**\n * @param {Partial<API.Options<Uint8Array>>} options\n * @returns {API.Path<Uint8Array>}\n */\nexport const configure = ({ bitWidth = 8, hash = hash64 }) => {\n  const hashSize = hash(new Uint8Array()).byteLength\n  const options = { bitWidth, hash, hashSize }\n\n  /**\n   * @param {Uint8Array} path\n   * @param {number} depth\n   * @returns {API.Uint32}\n   */\n  const at = (path, depth) => read(path, depth, options)\n\n  /**\n   * @param {string} key\n   */\n  const from = key => utf8.encode(key)\n\n  return { at, from, size: Infinity }\n}\n\n/**\n * @param {Uint8Array} key\n * @param {number} depth\n * @param {object} options\n * @param {number} [options.bitWidth]\n * @param {number} options.hashSize\n * @param {(input:Uint8Array) => Uint8Array} options.hash\n */\nexport const read = (key, depth = 0, { bitWidth = 8, hash, hashSize }) => {\n  // key digest consists of infinite number of hash frames that are computed\n  // from key + frame n which looks like\n  // [hash(key), hash([key, 1]), hash([key, n])]\n  // You can think of the hash as concatination of all frames. Here we calculate\n  // frame bit size from hash size as we going to use that several times.\n  const frameBitSize = hashSize * 8\n\n  // We start with 0 digest and required `bitCount` corresponding to `bitWith`.\n  // In the loop we'll going to consume `bitCount` hash bits.\n  let digest = 0\n  let bitCount = bitWidth\n  // Calculate absolute bit offset within the key digest.\n  let bitOffset = bitWidth * depth\n  while (bitCount > 0) {\n    // We derive frame number based on current bit offset.\n    const frameOffset = (bitOffset / frameBitSize) >> 0\n    // Then we compute that hash frame\n    const frame =\n      frameOffset === 0 ? hash(key) : hash(appendByte(key, frameOffset))\n\n    // compute bit offset within the current frame\n    const offset =\n      frameBitSize <= bitOffset ? bitOffset % frameBitSize : bitOffset\n    // calculate number of bits remaining in this frame\n    const maxBits = frameBitSize - offset\n    // we will consume all required bits from frame if enough are available\n    // otherwise we consume whatever's available and continue rest in the next\n    // cycle(s).\n    const count = maxBits < bitCount ? maxBits : bitCount\n    digest = (digest << count) + toInt(frame, offset, count)\n    bitCount -= count\n    bitOffset += count\n  }\n\n  return digest\n}\n\n/**\n * @param {Uint8Array} source\n * @param {number} byte\n */\nconst appendByte = (source, byte) => {\n  const bytes = new Uint8Array(source.byteLength + 1).fill(\n    byte,\n    source.byteLength\n  )\n  bytes.set(source)\n  return bytes\n}\n"],"mappings":"AAAA,OAAO,KAAKA,GAAG,MAAM,UAAU;AAC/B,SAASC,KAAK,QAAQ,iBAAiB;AACvC,SAASC,SAAS,QAAQ,uBAAuB;AACjD,MAAMC,IAAI,GAAG,IAAIC,WAAW,CAAC,CAAC;;AAE9B;AACA;AACA;AACA,OAAO,MAAMC,MAAM,GAAGC,KAAK,MACzB,yBAA2BJ,SAAS,CAACK,MAAM,CAACD,KAAK,CAAC,CAAC;;AAErD;AACA;AACA;AACA;AACA,OAAO,MAAME,SAAS,GAAGA,CAAC;EAAEC,QAAQ,GAAG,CAAC;EAAEC,IAAI,GAAGL;AAAO,CAAC,KAAK;EAC5D,MAAMM,QAAQ,GAAGD,IAAI,CAAC,IAAIE,UAAU,CAAC,CAAC,CAAC,CAACC,UAAU;EAClD,MAAMC,OAAO,GAAG;IAAEL,QAAQ;IAAEC,IAAI;IAAEC;EAAS,CAAC;;EAE5C;AACF;AACA;AACA;AACA;EACE,MAAMI,EAAE,GAAGA,CAACC,IAAI,EAAEC,KAAK,KAAKC,IAAI,CAACF,IAAI,EAAEC,KAAK,EAAEH,OAAO,CAAC;;EAEtD;AACF;AACA;EACE,MAAMK,IAAI,GAAGC,GAAG,IAAIjB,IAAI,CAACI,MAAM,CAACa,GAAG,CAAC;EAEpC,OAAO;IAAEL,EAAE;IAAEI,IAAI;IAAEE,IAAI,EAAEC;EAAS,CAAC;AACrC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMJ,IAAI,GAAGA,CAACE,GAAG,EAAEH,KAAK,GAAG,CAAC,EAAE;EAAER,QAAQ,GAAG,CAAC;EAAEC,IAAI;EAAEC;AAAS,CAAC,KAAK;EACxE;EACA;EACA;EACA;EACA;EACA,MAAMY,YAAY,GAAGZ,QAAQ,GAAG,CAAC;;EAEjC;EACA;EACA,IAAIa,MAAM,GAAG,CAAC;EACd,IAAIC,QAAQ,GAAGhB,QAAQ;EACvB;EACA,IAAIiB,SAAS,GAAGjB,QAAQ,GAAGQ,KAAK;EAChC,OAAOQ,QAAQ,GAAG,CAAC,EAAE;IACnB;IACA,MAAME,WAAW,GAAID,SAAS,GAAGH,YAAY,IAAK,CAAC;IACnD;IACA,MAAMK,KAAK,GACTD,WAAW,KAAK,CAAC,GAAGjB,IAAI,CAACU,GAAG,CAAC,GAAGV,IAAI,CAACmB,UAAU,CAACT,GAAG,EAAEO,WAAW,CAAC,CAAC;;IAEpE;IACA,MAAMG,MAAM,GACVP,YAAY,IAAIG,SAAS,GAAGA,SAAS,GAAGH,YAAY,GAAGG,SAAS;IAClE;IACA,MAAMK,OAAO,GAAGR,YAAY,GAAGO,MAAM;IACrC;IACA;IACA;IACA,MAAME,KAAK,GAAGD,OAAO,GAAGN,QAAQ,GAAGM,OAAO,GAAGN,QAAQ;IACrDD,MAAM,GAAG,CAACA,MAAM,IAAIQ,KAAK,IAAI/B,KAAK,CAAC2B,KAAK,EAAEE,MAAM,EAAEE,KAAK,CAAC;IACxDP,QAAQ,IAAIO,KAAK;IACjBN,SAAS,IAAIM,KAAK;EACpB;EAEA,OAAOR,MAAM;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMK,UAAU,GAAGA,CAACI,MAAM,EAAEC,IAAI,KAAK;EACnC,MAAM5B,KAAK,GAAG,IAAIM,UAAU,CAACqB,MAAM,CAACpB,UAAU,GAAG,CAAC,CAAC,CAACsB,IAAI,CACtDD,IAAI,EACJD,MAAM,CAACpB,UACT,CAAC;EACDP,KAAK,CAAC8B,GAAG,CAACH,MAAM,CAAC;EACjB,OAAO3B,KAAK;AACd,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}