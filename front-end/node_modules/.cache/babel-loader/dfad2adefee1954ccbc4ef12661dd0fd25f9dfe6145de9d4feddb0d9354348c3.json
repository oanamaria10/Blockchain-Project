{"ast":null,"code":"import { webcrypto } from 'one-webcrypto';\nimport { base58btc } from 'multiformats/bases/base58';\nimport * as API from './rsa/type.js';\nimport * as DID from '@ipld/dag-ucan/did';\nimport { tagWith, untagWith } from './multiformat.js';\nimport * as Signature from '@ipld/dag-ucan/signature';\nimport * as SPKI from './rsa/spki.js';\nimport * as PKCS8 from './rsa/pkcs8.js';\nimport * as PrivateKey from './rsa/private-key.js';\nimport * as PublicKey from './rsa/public-key.js';\nimport * as Verifier from './verifier.js';\nimport * as Signer from './signer.js';\nexport * from './rsa/type.js';\nexport const name = 'RSA';\n\n/** @type {API.RSASigner['code']} */\nexport const code = 0x1305;\n\n/** @type {API.RSAVerifier['code']} */\nconst verifierCode = 0x1205;\n\n/** @type {API.SigAlg} */\nexport const signatureCode = Signature.RS256;\nexport const signatureAlgorithm = 'RS256';\nconst ALG = 'RSASSA-PKCS1-v1_5';\nconst HASH_ALG = 'SHA-256';\nconst KEY_SIZE = 2048;\nconst SALT_LENGTH = 128;\nconst IMPORT_PARAMS = {\n  name: ALG,\n  hash: {\n    name: HASH_ALG\n  }\n};\n\n/**\n * @param {object} options\n * @param {number} [options.size]\n * @param {boolean} [options.extractable]\n * @returns {Promise<API.RSASigner>}\n */\nexport const generate = async ({\n  size = KEY_SIZE,\n  extractable = false\n} = {}) => {\n  // We start by generate an RSA keypair using web crypto API.\n  const {\n    publicKey,\n    privateKey\n  } = await webcrypto.subtle.generateKey({\n    name: ALG,\n    modulusLength: size,\n    publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n    hash: {\n      name: HASH_ALG\n    }\n  }, extractable, ['sign', 'verify']);\n\n  // Next we need to encode public key, because `RSAVerifier` uses it to\n  // for implementing a `did()` method. To do this we first export\n  // Subject Public Key Info (SPKI) using web crypto API.\n  const spki = await webcrypto.subtle.exportKey('spki', publicKey);\n  // Then we extract public key from the SPKI and tag it with RSA public key\n  // multicode\n  const publicBytes = tagWith(verifierCode, SPKI.decode(new Uint8Array(spki)));\n  // Now that we have publicKey and it's multiformat representation we can\n  // create a verifier.\n  const verifier = new RSAVerifier({\n    bytes: publicBytes,\n    publicKey\n  });\n\n  // If we generated non extractable key we just wrap actual keys and verifier\n  // in the RSASigner view.\n  if (!extractable) {\n    return new UnextractableRSASigner({\n      privateKey,\n      verifier\n    });\n  }\n  // Otherwise we export key in Private Key Cryptography Standards (PKCS)\n  // format and extract a bytes corresponding to the private key, which\n  // we tag with RSA private key multiformat code. With both binary and actual\n  // key representation we create a RSASigner view.\n  // Please note that do key export flow during generation so that we can:\n  // 1. Guarantee that it will be exportable.\n  // 2. Make `export` method sync.\n  else {\n    const pkcs8 = await webcrypto.subtle.exportKey('pkcs8', privateKey);\n    const bytes = tagWith(code, PKCS8.decode(new Uint8Array(pkcs8)));\n    return new ExtractableRSASigner({\n      privateKey,\n      bytes,\n      verifier\n    });\n  }\n};\n\n/**\n * @param {API.SignerArchive<API.DID, typeof signatureCode>} archive\n * @returns {API.RSASigner}\n */\nexport const from = ({\n  id,\n  keys\n}) => {\n  if (id.startsWith('did:key:')) {\n    const did = /** @type {API.DIDKey} */id;\n    const key = keys[did];\n    if (key instanceof Uint8Array) {\n      return decode(key);\n    } else {\n      return new UnextractableRSASigner({\n        privateKey: key,\n        verifier: RSAVerifier.parse(did)\n      });\n    }\n  } else {\n    throw new TypeError(`RSA can not import from ${id} archive, try generic Signer instead`);\n  }\n};\n\n/**\n * @template {API.SignerImporter} Other\n * @param {Other} other\n */\nexport const or = other => Signer.or({\n  from\n}, other);\n\n/**\n * @param {EncodedSigner} bytes\n * @returns {API.RSASigner}\n */\nexport const decode = bytes => {\n  // First we decode RSA key data from the private key with multicode tag.\n  const rsa = PrivateKey.decode(untagWith(code, bytes));\n  // Then we encode RSA key data as public key with multicode tag.\n  const publicBytes = tagWith(verifierCode, PublicKey.encode(rsa));\n  return new ExtractableRSASigner({\n    bytes,\n    privateKey: webcrypto.subtle.importKey('pkcs8', PKCS8.encode(untagWith(code, bytes)), IMPORT_PARAMS, true, ['sign']),\n    verifier: RSAVerifier.decode(publicBytes)\n  });\n};\n\n/**\n * @implements {API.RSAVerifier}\n */\nclass RSAVerifier {\n  /**\n   * @param {object} options\n   * @param {API.Await<CryptoKey>} options.publicKey\n   * @param {API.ByteView<API.RSAVerifier>} options.bytes\n   */\n  constructor({\n    publicKey,\n    bytes\n  }) {\n    /** @private */\n    this.publicKey = publicKey;\n    /** @private */\n    this.bytes = bytes;\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   * @returns {API.Verifier<ID, typeof signatureCode>}\n   */\n  withDID(id) {\n    return Verifier.withDID(this, id);\n  }\n  toDIDKey() {\n    return this.did();\n  }\n\n  /**\n   * @param {API.ByteView<API.RSAVerifier>} bytes\n   * @returns {API.RSAVerifier}\n   */\n  static decode(bytes) {\n    return new this({\n      bytes,\n      publicKey: webcrypto.subtle.importKey('spki', SPKI.encode(untagWith(verifierCode, bytes)), IMPORT_PARAMS, true, ['verify'])\n    });\n  }\n  /**\n   * @param {API.DIDKey} did\n   * @returns {API.RSAVerifier}\n   */\n  static parse(did) {\n    return RSAVerifier.decode( /** @type {Uint8Array} */DID.parse(did));\n  }\n\n  /**\n   * @param {API.PrincipalParser} other\n   */\n  static or(other) {\n    return Verifier.or(this, other);\n  }\n\n  /** @type {typeof verifierCode} */\n  get code() {\n    return verifierCode;\n  }\n  /**\n   * @type {typeof signatureCode}\n   */\n  get signatureCode() {\n    return signatureCode;\n  }\n  /**\n   * @type {typeof signatureAlgorithm}\n   */\n  get signatureAlgorithm() {\n    return signatureAlgorithm;\n  }\n  /**\n   * DID of the Principal in `did:key` format.\n   * @returns {API.DID<\"key\">}\n   */\n  did() {\n    return `did:key:${base58btc.encode(this.bytes)}`;\n  }\n\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, typeof this.signatureCode>} signature\n   * @returns {Promise<boolean>}\n   */\n  async verify(payload, signature) {\n    // if signature code does not match RS256 it's not signed by corresponding\n    // signer.\n    if (signature.code !== signatureCode) {\n      return false;\n    }\n    return webcrypto.subtle.verify({\n      name: ALG,\n      hash: {\n        name: HASH_ALG\n      }\n    }, await this.publicKey, signature.raw, payload);\n  }\n}\nconst RSAVerifier$ = /** @type {API.ComposedDIDParser} */RSAVerifier;\nexport { RSAVerifier as Verifier };\n\n/**\n * @typedef {API.ByteView<API.Signer<API.DID<'key'>, typeof signatureCode> & CryptoKey>} EncodedSigner\n */\n\nclass RSASigner {\n  /**\n   * @param {object} options\n   * @param {API.Await<CryptoKey>} options.privateKey\n   * @param {API.RSAVerifier} options.verifier\n   */\n  constructor({\n    privateKey,\n    verifier\n  }) {\n    /** @readonly */\n    this.verifier = verifier;\n    /** @protected */\n    this.privateKey = privateKey;\n  }\n  get signer() {\n    return this;\n  }\n\n  /**\n   * @type {typeof code}\n   */\n  get code() {\n    return code;\n  }\n  /**\n   * @type {typeof signatureCode}\n   */\n  get signatureCode() {\n    return signatureCode;\n  }\n  /**\n   * @type {typeof signatureAlgorithm}\n   */\n  get signatureAlgorithm() {\n    return signatureAlgorithm;\n  }\n  did() {\n    return this.verifier.did();\n  }\n  toDIDKey() {\n    return this.verifier.toDIDKey();\n  }\n\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, typeof this.signatureCode>} signature\n   */\n  verify(payload, signature) {\n    return this.verifier.verify(payload, signature);\n  }\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @returns {Promise<API.SignatureView<T, typeof signatureCode>>}\n   */\n  async sign(payload) {\n    const buffer = await webcrypto.subtle.sign({\n      name: ALG,\n      saltLength: SALT_LENGTH\n    }, await this.privateKey, payload);\n    return Signature.create(signatureCode, new Uint8Array(buffer));\n  }\n}\n\n/**\n * @implements {API.RSASigner}\n */\nclass ExtractableRSASigner extends RSASigner {\n  /**\n   * @param {object} options\n   * @param {API.Await<CryptoKey>} options.privateKey\n   * @param {EncodedSigner} options.bytes\n   * @param {API.RSAVerifier} options.verifier\n   */\n  constructor(options) {\n    super(options);\n    this.bytes = options.bytes;\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   * @returns {API.Signer<ID, typeof signatureCode>}\n   */\n  withDID(id) {\n    return Signer.withDID(this, id);\n  }\n  toArchive() {\n    const id = this.did();\n    return {\n      id,\n      keys: {\n        [id]: this.bytes\n      }\n    };\n  }\n}\n\n/**\n * @implements {API.RSASigner}\n */\nclass UnextractableRSASigner extends RSASigner {\n  /**\n   * @param {object} options\n   * @param {CryptoKey} options.privateKey\n   * @param {API.RSAVerifier} options.verifier\n   */\n  constructor(options) {\n    super(options);\n    this.privateKey = options.privateKey;\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   * @returns {API.Signer<ID, typeof signatureCode>}\n   */\n  withDID(id) {\n    return Signer.withDID(this, id);\n  }\n  toArchive() {\n    const id = this.did();\n    return {\n      id,\n      keys: {\n        [id]: this.privateKey\n      }\n    };\n  }\n}","map":{"version":3,"names":["webcrypto","base58btc","API","DID","tagWith","untagWith","Signature","SPKI","PKCS8","PrivateKey","PublicKey","Verifier","Signer","name","code","verifierCode","signatureCode","RS256","signatureAlgorithm","ALG","HASH_ALG","KEY_SIZE","SALT_LENGTH","IMPORT_PARAMS","hash","generate","size","extractable","publicKey","privateKey","subtle","generateKey","modulusLength","publicExponent","Uint8Array","spki","exportKey","publicBytes","decode","verifier","RSAVerifier","bytes","UnextractableRSASigner","pkcs8","ExtractableRSASigner","from","id","keys","startsWith","did","key","parse","TypeError","or","other","rsa","encode","importKey","constructor","withDID","toDIDKey","verify","payload","signature","raw","RSAVerifier$","RSASigner","signer","sign","buffer","saltLength","create","options","toArchive"],"sources":["C:/FACULTATE/Proiect/node_modules/@ucanto/principal/src/rsa.js"],"sourcesContent":["import { webcrypto } from 'one-webcrypto'\nimport { base58btc } from 'multiformats/bases/base58'\nimport * as API from './rsa/type.js'\nimport * as DID from '@ipld/dag-ucan/did'\nimport { tagWith, untagWith } from './multiformat.js'\nimport * as Signature from '@ipld/dag-ucan/signature'\nimport * as SPKI from './rsa/spki.js'\nimport * as PKCS8 from './rsa/pkcs8.js'\nimport * as PrivateKey from './rsa/private-key.js'\nimport * as PublicKey from './rsa/public-key.js'\nimport * as Verifier from './verifier.js'\nimport * as Signer from './signer.js'\nexport * from './rsa/type.js'\n\nexport const name = 'RSA'\n\n/** @type {API.RSASigner['code']} */\nexport const code = 0x1305\n\n/** @type {API.RSAVerifier['code']} */\nconst verifierCode = 0x1205\n\n/** @type {API.SigAlg} */\nexport const signatureCode = Signature.RS256\nexport const signatureAlgorithm = 'RS256'\n\nconst ALG = 'RSASSA-PKCS1-v1_5'\nconst HASH_ALG = 'SHA-256'\nconst KEY_SIZE = 2048\nconst SALT_LENGTH = 128\nconst IMPORT_PARAMS = {\n  name: ALG,\n  hash: { name: HASH_ALG },\n}\n\n/**\n * @param {object} options\n * @param {number} [options.size]\n * @param {boolean} [options.extractable]\n * @returns {Promise<API.RSASigner>}\n */\nexport const generate = async ({\n  size = KEY_SIZE,\n  extractable = false,\n} = {}) => {\n  // We start by generate an RSA keypair using web crypto API.\n  const { publicKey, privateKey } = await webcrypto.subtle.generateKey(\n    {\n      name: ALG,\n      modulusLength: size,\n      publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n      hash: { name: HASH_ALG },\n    },\n\n    extractable,\n    ['sign', 'verify']\n  )\n\n  // Next we need to encode public key, because `RSAVerifier` uses it to\n  // for implementing a `did()` method. To do this we first export\n  // Subject Public Key Info (SPKI) using web crypto API.\n  const spki = await webcrypto.subtle.exportKey('spki', publicKey)\n  // Then we extract public key from the SPKI and tag it with RSA public key\n  // multicode\n  const publicBytes = tagWith(verifierCode, SPKI.decode(new Uint8Array(spki)))\n  // Now that we have publicKey and it's multiformat representation we can\n  // create a verifier.\n  const verifier = new RSAVerifier({ bytes: publicBytes, publicKey })\n\n  // If we generated non extractable key we just wrap actual keys and verifier\n  // in the RSASigner view.\n  if (!extractable) {\n    return new UnextractableRSASigner({\n      privateKey,\n      verifier,\n    })\n  }\n  // Otherwise we export key in Private Key Cryptography Standards (PKCS)\n  // format and extract a bytes corresponding to the private key, which\n  // we tag with RSA private key multiformat code. With both binary and actual\n  // key representation we create a RSASigner view.\n  // Please note that do key export flow during generation so that we can:\n  // 1. Guarantee that it will be exportable.\n  // 2. Make `export` method sync.\n  else {\n    const pkcs8 = await webcrypto.subtle.exportKey('pkcs8', privateKey)\n    const bytes = tagWith(code, PKCS8.decode(new Uint8Array(pkcs8)))\n    return new ExtractableRSASigner({\n      privateKey,\n      bytes,\n      verifier,\n    })\n  }\n}\n\n/**\n * @param {API.SignerArchive<API.DID, typeof signatureCode>} archive\n * @returns {API.RSASigner}\n */\nexport const from = ({ id, keys }) => {\n  if (id.startsWith('did:key:')) {\n    const did = /** @type {API.DIDKey} */ (id)\n    const key = keys[did]\n    if (key instanceof Uint8Array) {\n      return decode(key)\n    } else {\n      return new UnextractableRSASigner({\n        privateKey: key,\n        verifier: RSAVerifier.parse(did),\n      })\n    }\n  } else {\n    throw new TypeError(\n      `RSA can not import from ${id} archive, try generic Signer instead`\n    )\n  }\n}\n\n/**\n * @template {API.SignerImporter} Other\n * @param {Other} other\n */\nexport const or = other => Signer.or({ from }, other)\n\n/**\n * @param {EncodedSigner} bytes\n * @returns {API.RSASigner}\n */\nexport const decode = bytes => {\n  // First we decode RSA key data from the private key with multicode tag.\n  const rsa = PrivateKey.decode(untagWith(code, bytes))\n  // Then we encode RSA key data as public key with multicode tag.\n  const publicBytes = tagWith(verifierCode, PublicKey.encode(rsa))\n\n  return new ExtractableRSASigner({\n    bytes,\n    privateKey: webcrypto.subtle.importKey(\n      'pkcs8',\n      PKCS8.encode(untagWith(code, bytes)),\n      IMPORT_PARAMS,\n      true,\n      ['sign']\n    ),\n\n    verifier: RSAVerifier.decode(publicBytes),\n  })\n}\n\n/**\n * @implements {API.RSAVerifier}\n */\nclass RSAVerifier {\n  /**\n   * @param {object} options\n   * @param {API.Await<CryptoKey>} options.publicKey\n   * @param {API.ByteView<API.RSAVerifier>} options.bytes\n   */\n  constructor({ publicKey, bytes }) {\n    /** @private */\n    this.publicKey = publicKey\n    /** @private */\n    this.bytes = bytes\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   * @returns {API.Verifier<ID, typeof signatureCode>}\n   */\n  withDID(id) {\n    return Verifier.withDID(this, id)\n  }\n\n  toDIDKey() {\n    return this.did()\n  }\n\n  /**\n   * @param {API.ByteView<API.RSAVerifier>} bytes\n   * @returns {API.RSAVerifier}\n   */\n  static decode(bytes) {\n    return new this({\n      bytes,\n      publicKey: webcrypto.subtle.importKey(\n        'spki',\n        SPKI.encode(untagWith(verifierCode, bytes)),\n        IMPORT_PARAMS,\n        true,\n        ['verify']\n      ),\n    })\n  }\n  /**\n   * @param {API.DIDKey} did\n   * @returns {API.RSAVerifier}\n   */\n  static parse(did) {\n    return RSAVerifier.decode(/** @type {Uint8Array} */ (DID.parse(did)))\n  }\n\n  /**\n   * @param {API.PrincipalParser} other\n   */\n  static or(other) {\n    return Verifier.or(this, other)\n  }\n\n  /** @type {typeof verifierCode} */\n  get code() {\n    return verifierCode\n  }\n  /**\n   * @type {typeof signatureCode}\n   */\n  get signatureCode() {\n    return signatureCode\n  }\n  /**\n   * @type {typeof signatureAlgorithm}\n   */\n  get signatureAlgorithm() {\n    return signatureAlgorithm\n  }\n  /**\n   * DID of the Principal in `did:key` format.\n   * @returns {API.DID<\"key\">}\n   */\n  did() {\n    return `did:key:${base58btc.encode(this.bytes)}`\n  }\n\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, typeof this.signatureCode>} signature\n   * @returns {Promise<boolean>}\n   */\n  async verify(payload, signature) {\n    // if signature code does not match RS256 it's not signed by corresponding\n    // signer.\n    if (signature.code !== signatureCode) {\n      return false\n    }\n\n    return webcrypto.subtle.verify(\n      { name: ALG, hash: { name: HASH_ALG } },\n      await this.publicKey,\n      signature.raw,\n      payload\n    )\n  }\n}\n\nconst RSAVerifier$ = /** @type {API.ComposedDIDParser} */ (RSAVerifier)\nexport { RSAVerifier as Verifier }\n\n/**\n * @typedef {API.ByteView<API.Signer<API.DID<'key'>, typeof signatureCode> & CryptoKey>} EncodedSigner\n */\n\nclass RSASigner {\n  /**\n   * @param {object} options\n   * @param {API.Await<CryptoKey>} options.privateKey\n   * @param {API.RSAVerifier} options.verifier\n   */\n  constructor({ privateKey, verifier }) {\n    /** @readonly */\n    this.verifier = verifier\n    /** @protected */\n    this.privateKey = privateKey\n  }\n  get signer() {\n    return this\n  }\n\n  /**\n   * @type {typeof code}\n   */\n  get code() {\n    return code\n  }\n  /**\n   * @type {typeof signatureCode}\n   */\n  get signatureCode() {\n    return signatureCode\n  }\n  /**\n   * @type {typeof signatureAlgorithm}\n   */\n  get signatureAlgorithm() {\n    return signatureAlgorithm\n  }\n\n  did() {\n    return this.verifier.did()\n  }\n\n  toDIDKey() {\n    return this.verifier.toDIDKey()\n  }\n\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, typeof this.signatureCode>} signature\n   */\n  verify(payload, signature) {\n    return this.verifier.verify(payload, signature)\n  }\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @returns {Promise<API.SignatureView<T, typeof signatureCode>>}\n   */\n  async sign(payload) {\n    const buffer = await webcrypto.subtle.sign(\n      { name: ALG, saltLength: SALT_LENGTH },\n      await this.privateKey,\n      payload\n    )\n\n    return Signature.create(signatureCode, new Uint8Array(buffer))\n  }\n}\n\n/**\n * @implements {API.RSASigner}\n */\nclass ExtractableRSASigner extends RSASigner {\n  /**\n   * @param {object} options\n   * @param {API.Await<CryptoKey>} options.privateKey\n   * @param {EncodedSigner} options.bytes\n   * @param {API.RSAVerifier} options.verifier\n   */\n  constructor(options) {\n    super(options)\n    this.bytes = options.bytes\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   * @returns {API.Signer<ID, typeof signatureCode>}\n   */\n  withDID(id) {\n    return Signer.withDID(this, id)\n  }\n\n  toArchive() {\n    const id = this.did()\n    return {\n      id,\n      keys: { [id]: this.bytes },\n    }\n  }\n}\n\n/**\n * @implements {API.RSASigner}\n */\nclass UnextractableRSASigner extends RSASigner {\n  /**\n   * @param {object} options\n   * @param {CryptoKey} options.privateKey\n   * @param {API.RSAVerifier} options.verifier\n   */\n  constructor(options) {\n    super(options)\n    this.privateKey = options.privateKey\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   * @returns {API.Signer<ID, typeof signatureCode>}\n   */\n  withDID(id) {\n    return Signer.withDID(this, id)\n  }\n\n  toArchive() {\n    const id = this.did()\n    return {\n      id,\n      keys: { [id]: this.privateKey },\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}