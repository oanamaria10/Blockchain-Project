{"ast":null,"code":"import * as API from '@ucanto/interface';\n\n/**\n * Creates the success result containing given `value`. Throws if\n * `null` or `undefined` passed to encourage use of units instead.\n *\n * @template {{}|string|boolean|number} T\n * @param {T} value\n * @returns {{ok: T, error?:undefined}}\n */\nexport const ok = value => {\n  if (value == null) {\n    throw new TypeError(`ok(${value}) is not allowed, consider ok({}) instead`);\n  } else {\n    return {\n      ok: value\n    };\n  }\n};\n\n/**\n * Creates the failing result containing given `cause` of error.\n * Throws if `cause` is `null` or `undefined` to encourage\n * passing descriptive errors instead.\n *\n * @template {{}|string|boolean|number} X\n * @param {X} cause\n * @returns {{ok?:undefined, error:X}}\n */\nexport const error = cause => {\n  if (cause == null) {\n    throw new TypeError(`error(${cause}) is not allowed, consider passing an error instead`);\n  } else {\n    return {\n      error: cause\n    };\n  }\n};\n\n/**\n * Crash the program with a given `message`. This function is\n * intended to be used in places where it is impossible to\n * recover from an error. It is similar to `panic` function in\n * Rust.\n *\n * @param {string} message\n */\nexport const panic = message => {\n  throw new Failure(message);\n};\n/**\n * Creates the failing result containing an error with a given\n * `message`. Unlike `error` function it creates a very generic\n *  error with `message` & `stack` fields. The `error` function\n * is recommended over `fail` for all but the most basic use cases.\n *\n * @param {string} message\n * @returns {{error:API.Failure, ok?:undefined}}\n */\nexport const fail = message => ({\n  error: new Failure(message)\n});\n\n/**\n * @implements {API.Failure}\n */\nexport class Failure extends Error {\n  describe() {\n    return this.toString();\n  }\n  get message() {\n    return this.describe();\n  }\n  toJSON() {\n    const {\n      name,\n      message,\n      stack\n    } = this;\n    return {\n      name,\n      message,\n      stack\n    };\n  }\n}","map":{"version":3,"names":["API","ok","value","TypeError","error","cause","panic","message","Failure","fail","Error","describe","toString","toJSON","name","stack"],"sources":["C:/FACULTATE/Proiect/node_modules/@ucanto/core/src/result.js"],"sourcesContent":["import * as API from '@ucanto/interface'\n\n/**\n * Creates the success result containing given `value`. Throws if\n * `null` or `undefined` passed to encourage use of units instead.\n *\n * @template {{}|string|boolean|number} T\n * @param {T} value\n * @returns {{ok: T, error?:undefined}}\n */\nexport const ok = value => {\n  if (value == null) {\n    throw new TypeError(`ok(${value}) is not allowed, consider ok({}) instead`)\n  } else {\n    return { ok: value }\n  }\n}\n\n/**\n * Creates the failing result containing given `cause` of error.\n * Throws if `cause` is `null` or `undefined` to encourage\n * passing descriptive errors instead.\n *\n * @template {{}|string|boolean|number} X\n * @param {X} cause\n * @returns {{ok?:undefined, error:X}}\n */\nexport const error = cause => {\n  if (cause == null) {\n    throw new TypeError(\n      `error(${cause}) is not allowed, consider passing an error instead`\n    )\n  } else {\n    return { error: cause }\n  }\n}\n\n/**\n * Crash the program with a given `message`. This function is\n * intended to be used in places where it is impossible to\n * recover from an error. It is similar to `panic` function in\n * Rust.\n *\n * @param {string} message\n */\nexport const panic = message => {\n  throw new Failure(message)\n}\n/**\n * Creates the failing result containing an error with a given\n * `message`. Unlike `error` function it creates a very generic\n *  error with `message` & `stack` fields. The `error` function\n * is recommended over `fail` for all but the most basic use cases.\n *\n * @param {string} message\n * @returns {{error:API.Failure, ok?:undefined}}\n */\nexport const fail = message => ({ error: new Failure(message) })\n\n/**\n * @implements {API.Failure}\n */\nexport class Failure extends Error {\n  describe() {\n    return this.toString()\n  }\n  get message() {\n    return this.describe()\n  }\n  toJSON() {\n    const { name, message, stack } = this\n    return { name, message, stack }\n  }\n}\n"],"mappings":"AAAA,OAAO,KAAKA,GAAG,MAAM,mBAAmB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,EAAE,GAAGC,KAAK,IAAI;EACzB,IAAIA,KAAK,IAAI,IAAI,EAAE;IACjB,MAAM,IAAIC,SAAS,CAAE,MAAKD,KAAM,2CAA0C,CAAC;EAC7E,CAAC,MAAM;IACL,OAAO;MAAED,EAAE,EAAEC;IAAM,CAAC;EACtB;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAME,KAAK,GAAGC,KAAK,IAAI;EAC5B,IAAIA,KAAK,IAAI,IAAI,EAAE;IACjB,MAAM,IAAIF,SAAS,CAChB,SAAQE,KAAM,qDACjB,CAAC;EACH,CAAC,MAAM;IACL,OAAO;MAAED,KAAK,EAAEC;IAAM,CAAC;EACzB;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,KAAK,GAAGC,OAAO,IAAI;EAC9B,MAAM,IAAIC,OAAO,CAACD,OAAO,CAAC;AAC5B,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAME,IAAI,GAAGF,OAAO,KAAK;EAAEH,KAAK,EAAE,IAAII,OAAO,CAACD,OAAO;AAAE,CAAC,CAAC;;AAEhE;AACA;AACA;AACA,OAAO,MAAMC,OAAO,SAASE,KAAK,CAAC;EACjCC,QAAQA,CAAA,EAAG;IACT,OAAO,IAAI,CAACC,QAAQ,CAAC,CAAC;EACxB;EACA,IAAIL,OAAOA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACI,QAAQ,CAAC,CAAC;EACxB;EACAE,MAAMA,CAAA,EAAG;IACP,MAAM;MAAEC,IAAI;MAAEP,OAAO;MAAEQ;IAAM,CAAC,GAAG,IAAI;IACrC,OAAO;MAAED,IAAI;MAAEP,OAAO;MAAEQ;IAAM,CAAC;EACjC;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}