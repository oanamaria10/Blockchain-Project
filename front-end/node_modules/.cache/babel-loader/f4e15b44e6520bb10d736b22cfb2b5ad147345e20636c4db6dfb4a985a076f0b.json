{"ast":null,"code":"import * as API from './api.js';\nimport * as Bytes from 'multiformats/bytes';\nimport { Size as NodeSize } from './node.js';\nimport { CBOR, SHA256 } from './ipld.js';\n\n/**\n * @param {API.ProofData} proof\n * @returns {API.MerkleTreePath}\n */\nexport const path = ([, path]) => path;\n\n/**\n * @param {API.ProofData} proof\n * @returns {API.uint64}\n */\nexport const offset = ([offset]) => offset;\n\n/**\n * @param {API.ProofData} proof\n * @returns {number}\n */\nexport const depth = proof => path(proof).length;\n\n/**\n * Verifies that `proof` proves that `claim.node` is contained by\n * the `claim.tree` merkle tree.\n *\n * @param {API.ProofData} proof\n * @param {object} claim\n * @param {API.MerkleTreeNode} claim.tree\n * @param {API.MerkleTreeNode} claim.node\n * @returns {API.Result<{}, Error>}\n */\nexport const verify = (proof, {\n  tree,\n  node\n}) => {\n  const computedRoot = resolveRoot(proof, node);\n  if (computedRoot.error) {\n    return {\n      error: new Error(`computing root: ${computedRoot.error.message}`)\n    };\n  }\n  if (!Bytes.equals(computedRoot.ok, tree)) {\n    return {\n      error: new Error('inclusion proof does not lead to the same root')\n    };\n  }\n  return {\n    ok: {}\n  };\n};\nconst MAX_DEPTH = 63;\n\n/**\n * Resolves the root of the merkle tree from given proof and node that root\n * supposedly includes. It does so by computing parent node from provided node\n * and node in the proof path, then combining that with the next node in the\n * path and so on until the root is reached. Function may return an error if\n * proof path is too long or if proof offset falls out of bounds.\n *\n * @param {API.ProofData} proof\n * @param {API.MerkleTreeNode} node\n * @returns {API.Result<API.MerkleTreeNode, RangeError>}\n */\nexport function resolveRoot(proof, node) {\n  if (depth(proof) > MAX_DEPTH) {\n    return {\n      error: new RangeError('merkle proofs with depths greater than 63 are not supported')\n    };\n  }\n  let position = offset(proof);\n  if (position >> BigInt(depth(proof)) !== 0n) {\n    return {\n      error: new RangeError('offset greater than width of the tree')\n    };\n  }\n  let top = node;\n  let right = 0n;\n  for (const node of path(proof)) {\n    right = position & 1n;\n    position = position >> 1n;\n    top = right === 1n ? computeNode(node, top) : computeNode(top, node);\n  }\n  return {\n    ok: top\n  };\n}\n\n/**\n * @param {Uint8Array} payload\n * @param {object} [options]\n * @param {API.SyncMultihashHasher<API.SHA256_CODE>} [options.hasher]\n * @returns {API.MerkleTreeNode}\n */\nexport function truncatedHash(payload, options = {}) {\n  const hasher = options.hasher || SHA256;\n  const {\n    digest\n  } = hasher.digest(payload);\n  return truncate(digest);\n}\n\n/**\n * @param {API.MerkleTreeNode} left\n * @param {API.MerkleTreeNode} right\n * @param {object} [options]\n * @param {API.SyncMultihashHasher<API.SHA256_CODE>} [options.hasher]\n * @returns {API.MerkleTreeNode}\n */\nexport const computeNode = (left, right, options) => {\n  const payload = new Uint8Array(left.length + right.length);\n  payload.set(left, 0);\n  payload.set(right, left.length);\n  return truncatedHash(payload, options);\n};\n\n/**\n * @param {API.MerkleTreeNode} node\n * @returns {API.MerkleTreeNode}\n */\nexport function truncate(node) {\n  node[NodeSize - 1] &= 0b00111111;\n  return node;\n}\n\n/**\n * Takes data model and returns an IPLD View of it.\n *\n * @param {object} source\n * @param {API.uint64} source.offset\n * @param {API.MerkleTreePath} source.path\n * @returns {API.ProofData}\n */\nexport const create = ({\n  offset,\n  path\n}) => [offset, path];\n\n/**\n * Takes proof in somewhat arbitrary form and returns a proof data.\n *\n * @param {API.IntoProofData} source\n * @returns {API.ProofData}\n */\nexport const from = source => {\n  const [offset, path] = Array.isArray(source) ? source : [source.offset, source.path];\n  return create({\n    offset: BigInt(offset),\n    path\n  });\n};\n\n/**\n * @param {number} height - Height of the merkle tree\n * @param {number} level - Level of the node in the merkle tree\n * @param {API.uint64} index - Index of the node in the level\n */\nexport const validateLevelIndex = (height, level, index) => {\n  if (level < 0) {\n    throw new RangeError('level can not be negative');\n  }\n  if (level > height) {\n    throw new RangeError(`level too high: ${level} >= ${height}`);\n  }\n  if (index > (1 << height - level) - 1) {\n    throw new RangeError(`index too large for level: idx ${index}, level ${level} : ${(1 << height - level) - 1}`);\n  }\n};","map":{"version":3,"names":["API","Bytes","Size","NodeSize","CBOR","SHA256","path","offset","depth","proof","length","verify","tree","node","computedRoot","resolveRoot","error","Error","message","equals","ok","MAX_DEPTH","RangeError","position","BigInt","top","right","computeNode","truncatedHash","payload","options","hasher","digest","truncate","left","Uint8Array","set","create","from","source","Array","isArray","validateLevelIndex","height","level","index"],"sources":["C:/FACULTATE/Proiect/node_modules/@web3-storage/data-segment/src/proof.js"],"sourcesContent":["import * as API from './api.js'\n\nimport * as Bytes from 'multiformats/bytes'\nimport { Size as NodeSize } from './node.js'\nimport { CBOR, SHA256 } from './ipld.js'\n\n/**\n * @param {API.ProofData} proof\n * @returns {API.MerkleTreePath}\n */\nexport const path = ([, path]) => path\n\n/**\n * @param {API.ProofData} proof\n * @returns {API.uint64}\n */\nexport const offset = ([offset]) => offset\n\n/**\n * @param {API.ProofData} proof\n * @returns {number}\n */\nexport const depth = (proof) => path(proof).length\n\n/**\n * Verifies that `proof` proves that `claim.node` is contained by\n * the `claim.tree` merkle tree.\n *\n * @param {API.ProofData} proof\n * @param {object} claim\n * @param {API.MerkleTreeNode} claim.tree\n * @param {API.MerkleTreeNode} claim.node\n * @returns {API.Result<{}, Error>}\n */\nexport const verify = (proof, { tree, node }) => {\n  const computedRoot = resolveRoot(proof, node)\n  if (computedRoot.error) {\n    return { error: new Error(`computing root: ${computedRoot.error.message}`) }\n  }\n\n  if (!Bytes.equals(computedRoot.ok, tree)) {\n    return {\n      error: new Error('inclusion proof does not lead to the same root'),\n    }\n  }\n  return { ok: {} }\n}\n\nconst MAX_DEPTH = 63\n\n/**\n * Resolves the root of the merkle tree from given proof and node that root\n * supposedly includes. It does so by computing parent node from provided node\n * and node in the proof path, then combining that with the next node in the\n * path and so on until the root is reached. Function may return an error if\n * proof path is too long or if proof offset falls out of bounds.\n *\n * @param {API.ProofData} proof\n * @param {API.MerkleTreeNode} node\n * @returns {API.Result<API.MerkleTreeNode, RangeError>}\n */\nexport function resolveRoot(proof, node) {\n  if (depth(proof) > MAX_DEPTH) {\n    return {\n      error: new RangeError(\n        'merkle proofs with depths greater than 63 are not supported'\n      ),\n    }\n  }\n\n  let position = offset(proof)\n  if (position >> BigInt(depth(proof)) !== 0n) {\n    return { error: new RangeError('offset greater than width of the tree') }\n  }\n\n  let top = node\n  let right = 0n\n\n  for (const node of path(proof)) {\n    right =  position & 1n\n    position = position >> 1n\n    top = right === 1n ? computeNode(node, top) : computeNode(top, node)\n  }\n\n  return { ok: top }\n}\n\n/**\n * @param {Uint8Array} payload\n * @param {object} [options]\n * @param {API.SyncMultihashHasher<API.SHA256_CODE>} [options.hasher]\n * @returns {API.MerkleTreeNode}\n */\nexport function truncatedHash(payload, options = {}) {\n  const hasher = options.hasher || SHA256\n  const { digest } = hasher.digest(payload)\n  return truncate(digest)\n}\n\n/**\n * @param {API.MerkleTreeNode} left\n * @param {API.MerkleTreeNode} right\n * @param {object} [options]\n * @param {API.SyncMultihashHasher<API.SHA256_CODE>} [options.hasher]\n * @returns {API.MerkleTreeNode}\n */\nexport const computeNode = (left, right, options) => {\n  const payload = new Uint8Array(left.length + right.length)\n  payload.set(left, 0)\n  payload.set(right, left.length)\n  return truncatedHash(payload, options)\n}\n\n/**\n * @param {API.MerkleTreeNode} node\n * @returns {API.MerkleTreeNode}\n */\nexport function truncate(node) {\n  node[NodeSize - 1] &= 0b00111111\n  return node\n}\n\n/**\n * Takes data model and returns an IPLD View of it.\n *\n * @param {object} source\n * @param {API.uint64} source.offset\n * @param {API.MerkleTreePath} source.path\n * @returns {API.ProofData}\n */\nexport const create = ({ offset, path }) => [offset, path]\n\n/**\n * Takes proof in somewhat arbitrary form and returns a proof data.\n *\n * @param {API.IntoProofData} source\n * @returns {API.ProofData}\n */\nexport const from = (source) => {\n  const [offset, path] = Array.isArray(source)\n    ? source\n    : [source.offset, source.path]\n\n  return create({ offset: BigInt(offset), path })\n}\n\n/**\n * @param {number} height - Height of the merkle tree\n * @param {number} level - Level of the node in the merkle tree\n * @param {API.uint64} index - Index of the node in the level\n */\nexport const validateLevelIndex = (height, level, index) => {\n  if (level < 0) {\n    throw new RangeError('level can not be negative')\n  }\n\n  if (level > height) {\n    throw new RangeError(`level too high: ${level} >= ${height}`)\n  }\n\n  if (index > (1 << (height - level)) - 1) {\n    throw new RangeError(\n      `index too large for level: idx ${index}, level ${level} : ${\n        (1 << (height - level)) - 1\n      }`\n    )\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}