{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Environment = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst artifacts_1 = require(\"../artifacts\");\nconst packageInfo_1 = require(\"../util/packageInfo\");\nconst config_loading_1 = require(\"./config/config-loading\");\nconst errors_1 = require(\"./errors\");\nconst errors_list_1 = require(\"./errors-list\");\nconst construction_1 = require(\"./providers/construction\");\nconst lazy_initialization_1 = require(\"./providers/lazy-initialization\");\nconst task_definitions_1 = require(\"./tasks/task-definitions\");\nconst task_profiling_1 = require(\"./task-profiling\");\nconst util_1 = require(\"./tasks/util\");\nconst log = (0, debug_1.default)(\"hardhat:core:hre\");\nclass Environment {\n  /**\n   * Initializes the Hardhat Runtime Environment and the given\n   * extender functions.\n   *\n   * @remarks The extenders' execution order is given by the order\n   * of the requires in the hardhat's config file and its plugins.\n   *\n   * @param config The hardhat's config object.\n   * @param hardhatArguments The parsed hardhat's arguments.\n   * @param tasks A map of tasks.\n   * @param scopes A map of scopes.\n   * @param environmentExtenders A list of environment extenders.\n   * @param providerExtenders A list of provider extenders.\n   */\n  constructor(config, hardhatArguments, tasks, scopes, environmentExtenders = [], experimentalHardhatNetworkMessageTraceHooks = [], userConfig = {}, providerExtenders = []) {\n    this.config = config;\n    this.hardhatArguments = hardhatArguments;\n    this.tasks = tasks;\n    this.scopes = scopes;\n    this.userConfig = userConfig;\n    this.version = (0, packageInfo_1.getHardhatVersion)();\n    /**\n     * Executes the task with the given name.\n     *\n     * @param taskIdentifier The task or scoped task to be executed.\n     * @param taskArguments A map of task's arguments.\n     * @param subtaskArguments A map of subtasks to their arguments.\n     *\n     * @throws a HH303 if there aren't any defined tasks with the given name.\n     * @returns a promise with the task's execution result.\n     */\n    this.run = async (taskIdentifier, taskArguments = {}, subtaskArguments = {}, callerTaskProfile) => {\n      const {\n        scope,\n        task\n      } = (0, util_1.parseTaskIdentifier)(taskIdentifier);\n      let taskDefinition;\n      if (scope === undefined) {\n        taskDefinition = this.tasks[task];\n        log(\"Running task %s\", task);\n      } else {\n        const scopeDefinition = this.scopes[scope];\n        if (scopeDefinition === undefined) {\n          throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_SCOPE, {\n            scope\n          });\n        }\n        taskDefinition = scopeDefinition.tasks?.[task];\n        log(\"Running scoped task %s %s\", scope, task);\n      }\n      if (taskDefinition === undefined) {\n        if (scope !== undefined) {\n          throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_SCOPED_TASK, {\n            scope,\n            task\n          });\n        }\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_TASK, {\n          task\n        });\n      }\n      const resolvedTaskArguments = this._resolveValidTaskArguments(taskDefinition, taskArguments, subtaskArguments);\n      let taskProfile;\n      if (this.hardhatArguments.flamegraph === true) {\n        taskProfile = (0, task_profiling_1.createTaskProfile)(task);\n        if (callerTaskProfile !== undefined) {\n          callerTaskProfile.children.push(taskProfile);\n        } else {\n          this.entryTaskProfile = taskProfile;\n        }\n      }\n      try {\n        return await this._runTaskDefinition(taskDefinition, resolvedTaskArguments, subtaskArguments, taskProfile);\n      } catch (e) {\n        (0, config_loading_1.analyzeModuleNotFoundError)(e, this.config.paths.configFile);\n        // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n        throw e;\n      } finally {\n        if (taskProfile !== undefined) {\n          (0, task_profiling_1.completeTaskProfile)(taskProfile);\n        }\n      }\n    };\n    log(\"Creating HardhatRuntimeEnvironment\");\n    const networkName = hardhatArguments.network !== undefined ? hardhatArguments.network : config.defaultNetwork;\n    const networkConfig = config.networks[networkName];\n    if (networkConfig === undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.CONFIG_NOT_FOUND, {\n        network: networkName\n      });\n    }\n    this.artifacts = new artifacts_1.Artifacts(config.paths.artifacts);\n    const provider = new lazy_initialization_1.LazyInitializationProviderAdapter(async () => {\n      log(`Creating provider for network ${networkName}`);\n      return (0, construction_1.createProvider)(config, networkName, this.artifacts, experimentalHardhatNetworkMessageTraceHooks.map(hook => (trace, isCallMessageTrace) => hook(this, trace, isCallMessageTrace)), providerExtenders);\n    });\n    this.network = {\n      name: networkName,\n      config: networkConfig,\n      provider\n    };\n    this._environmentExtenders = environmentExtenders;\n    environmentExtenders.forEach(extender => extender(this));\n  }\n  /**\n   * Injects the properties of `this` (the Hardhat Runtime Environment) into the global scope.\n   *\n   * @param blacklist a list of property names that won't be injected.\n   *\n   * @returns a function that restores the previous environment.\n   */\n  injectToGlobal(blacklist = Environment._BLACKLISTED_PROPERTIES) {\n    const globalAsAny = global;\n    const previousValues = {};\n    const previousHre = globalAsAny.hre;\n    globalAsAny.hre = this;\n    for (const [key, value] of Object.entries(this)) {\n      if (blacklist.includes(key)) {\n        continue;\n      }\n      previousValues[key] = globalAsAny[key];\n      globalAsAny[key] = value;\n    }\n    return () => {\n      for (const [key, _] of Object.entries(this)) {\n        if (blacklist.includes(key)) {\n          continue;\n        }\n        globalAsAny.hre = previousHre;\n        globalAsAny[key] = previousValues[key];\n      }\n    };\n  }\n  /**\n   * @param taskProfile Undefined if we aren't computing task profiles\n   * @private\n   */\n  async _runTaskDefinition(taskDefinition, taskArguments, subtaskArguments, taskProfile) {\n    let runSuperFunction;\n    if (taskDefinition instanceof task_definitions_1.OverriddenTaskDefinition) {\n      runSuperFunction = async (_taskArguments = taskArguments, _subtaskArguments = subtaskArguments) => {\n        log(\"Running %s's super\", taskDefinition.name);\n        if (taskProfile === undefined) {\n          return this._runTaskDefinition(taskDefinition.parentTaskDefinition, _taskArguments, _subtaskArguments);\n        }\n        const parentTaskProfile = (0, task_profiling_1.createParentTaskProfile)(taskProfile);\n        taskProfile.children.push(parentTaskProfile);\n        try {\n          return await this._runTaskDefinition(taskDefinition.parentTaskDefinition, _taskArguments, _subtaskArguments, parentTaskProfile);\n        } finally {\n          (0, task_profiling_1.completeTaskProfile)(parentTaskProfile);\n        }\n      };\n      runSuperFunction.isDefined = true;\n    } else {\n      runSuperFunction = async () => {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.TASK_DEFINITIONS.RUNSUPER_NOT_AVAILABLE, {\n          taskName: taskDefinition.name\n        });\n      };\n      runSuperFunction.isDefined = false;\n    }\n    const runSuper = runSuperFunction;\n    const globalAsAny = global;\n    const previousRunSuper = globalAsAny.runSuper;\n    globalAsAny.runSuper = runSuper;\n    // We create a proxied version of `this`, as we want to keep track of the\n    // `subtaskArguments` and `taskProfile` through `run` invocations. This\n    // way we keep track of callers's data, even when tasks are run in parallel.\n    const proxiedHre = new Proxy(this, {\n      get(target, p, receiver) {\n        if (p === \"run\") {\n          return (_name, _taskArguments, _subtaskArguments) => target.run(_name, _taskArguments, {\n            ..._subtaskArguments,\n            ...subtaskArguments\n          },\n          // parent subtask args take precedence\n          taskProfile);\n        }\n        return Reflect.get(target, p, receiver);\n      }\n    });\n    if (this.hardhatArguments.flamegraph === true) {\n      // We modify the `this` again to add  a few utility methods.\n      proxiedHre.adhocProfile = async (_name, f) => {\n        const adhocProfile = (0, task_profiling_1.createTaskProfile)(_name);\n        taskProfile.children.push(adhocProfile);\n        try {\n          return await f();\n        } finally {\n          (0, task_profiling_1.completeTaskProfile)(adhocProfile);\n        }\n      };\n      proxiedHre.adhocProfileSync = (_name, f) => {\n        const adhocProfile = (0, task_profiling_1.createTaskProfile)(_name);\n        taskProfile.children.push(adhocProfile);\n        try {\n          return f();\n        } finally {\n          (0, task_profiling_1.completeTaskProfile)(adhocProfile);\n        }\n      };\n    }\n    const uninjectFromGlobal = proxiedHre.injectToGlobal();\n    try {\n      return await taskDefinition.action(taskArguments, proxiedHre, runSuper);\n    } finally {\n      uninjectFromGlobal();\n      globalAsAny.runSuper = previousRunSuper;\n    }\n  }\n  /**\n   * Check that task arguments are within TaskDefinition defined params constraints.\n   * Also, populate missing, non-mandatory arguments with default param values (if any).\n   *\n   * @private\n   * @throws HardhatError if any of the following are true:\n   *  > a required argument is missing\n   *  > an argument's value's type doesn't match the defined param type\n   *\n   * @param taskDefinition\n   * @param taskArguments\n   * @returns resolvedTaskArguments\n   */\n  _resolveValidTaskArguments(taskDefinition, taskArguments, subtaskArguments) {\n    const {\n      name: taskName,\n      paramDefinitions,\n      positionalParamDefinitions\n    } = taskDefinition;\n    const nonPositionalParamDefinitions = Object.values(paramDefinitions);\n    // gather all task param definitions\n    const allTaskParamDefinitions = [...nonPositionalParamDefinitions, ...positionalParamDefinitions];\n    const resolvedArguments = {};\n    for (const paramDefinition of allTaskParamDefinitions) {\n      const paramName = paramDefinition.name;\n      const argumentValue = subtaskArguments[taskName]?.[paramName] ?? taskArguments[paramName];\n      const resolvedArgumentValue = this._resolveArgument(paramDefinition, argumentValue, taskDefinition.name);\n      if (resolvedArgumentValue !== undefined) {\n        resolvedArguments[paramName] = resolvedArgumentValue;\n      }\n    }\n    // We keep the args in taskArguments that were not resolved\n    return {\n      ...taskArguments,\n      ...resolvedArguments\n    };\n  }\n  /**\n   * Resolves an argument according to a ParamDefinition rules.\n   *\n   * @param paramDefinition\n   * @param argumentValue\n   * @private\n   */\n  _resolveArgument(paramDefinition, argumentValue, taskName) {\n    const {\n      name,\n      isOptional,\n      defaultValue\n    } = paramDefinition;\n    if (argumentValue === undefined) {\n      if (isOptional) {\n        // undefined & optional argument -> return defaultValue\n        return defaultValue;\n      }\n      // undefined & mandatory argument -> error\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n        param: name,\n        task: taskName\n      });\n    }\n    // arg was present -> validate type, if applicable\n    this._checkTypeValidation(paramDefinition, argumentValue);\n    return argumentValue;\n  }\n  /**\n   * Checks if value is valid for the specified param definition.\n   *\n   * @param paramDefinition {ParamDefinition} - the param definition for validation\n   * @param argumentValue - the value to be validated\n   * @private\n   * @throws HH301 if value is not valid for the param type\n   */\n  _checkTypeValidation(paramDefinition, argumentValue) {\n    const {\n      name: paramName,\n      type,\n      isVariadic\n    } = paramDefinition;\n    // in case of variadic param, argValue is an array and the type validation must pass for all values.\n    // otherwise, it's a single value that is to be validated\n    const argumentValueContainer = isVariadic ? argumentValue : [argumentValue];\n    for (const value of argumentValueContainer) {\n      type.validate(paramName, value);\n    }\n  }\n}\nEnvironment._BLACKLISTED_PROPERTIES = [\"injectToGlobal\", \"entryTaskProfile\", \"_runTaskDefinition\", \"_extenders\"];\nexports.Environment = Environment;","map":{"version":3,"names":["debug_1","__importDefault","require","artifacts_1","packageInfo_1","config_loading_1","errors_1","errors_list_1","construction_1","lazy_initialization_1","task_definitions_1","task_profiling_1","util_1","log","default","Environment","constructor","config","hardhatArguments","tasks","scopes","environmentExtenders","experimentalHardhatNetworkMessageTraceHooks","userConfig","providerExtenders","version","getHardhatVersion","run","taskIdentifier","taskArguments","subtaskArguments","callerTaskProfile","scope","task","parseTaskIdentifier","taskDefinition","undefined","scopeDefinition","HardhatError","ERRORS","ARGUMENTS","UNRECOGNIZED_SCOPE","UNRECOGNIZED_SCOPED_TASK","UNRECOGNIZED_TASK","resolvedTaskArguments","_resolveValidTaskArguments","taskProfile","flamegraph","createTaskProfile","children","push","entryTaskProfile","_runTaskDefinition","e","analyzeModuleNotFoundError","paths","configFile","completeTaskProfile","networkName","network","defaultNetwork","networkConfig","networks","NETWORK","CONFIG_NOT_FOUND","artifacts","Artifacts","provider","LazyInitializationProviderAdapter","createProvider","map","hook","trace","isCallMessageTrace","name","_environmentExtenders","forEach","extender","injectToGlobal","blacklist","_BLACKLISTED_PROPERTIES","globalAsAny","global","previousValues","previousHre","hre","key","value","Object","entries","includes","_","runSuperFunction","OverriddenTaskDefinition","_taskArguments","_subtaskArguments","parentTaskDefinition","parentTaskProfile","createParentTaskProfile","isDefined","TASK_DEFINITIONS","RUNSUPER_NOT_AVAILABLE","taskName","runSuper","previousRunSuper","proxiedHre","Proxy","get","target","p","receiver","_name","Reflect","adhocProfile","f","adhocProfileSync","uninjectFromGlobal","action","paramDefinitions","positionalParamDefinitions","nonPositionalParamDefinitions","values","allTaskParamDefinitions","resolvedArguments","paramDefinition","paramName","argumentValue","resolvedArgumentValue","_resolveArgument","isOptional","defaultValue","MISSING_TASK_ARGUMENT","param","_checkTypeValidation","type","isVariadic","argumentValueContainer","validate","exports"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\internal\\core\\runtime-environment.ts"],"sourcesContent":["import type { MessageTrace } from \"../hardhat-network/stack-traces/message-trace\";\n\nimport debug from \"debug\";\n\nimport {\n  Artifacts as IArtifacts,\n  EnvironmentExtender,\n  ExperimentalHardhatNetworkMessageTraceHook,\n  HardhatArguments,\n  HardhatConfig,\n  HardhatRuntimeEnvironment,\n  HardhatUserConfig,\n  Network,\n  ParamDefinition,\n  ProviderExtender,\n  RunSuperFunction,\n  RunTaskFunction,\n  SubtaskArguments,\n  TaskArguments,\n  TaskDefinition,\n  TasksMap,\n  ScopesMap,\n} from \"../../types\";\nimport { Artifacts } from \"../artifacts\";\n\nimport { getHardhatVersion } from \"../util/packageInfo\";\nimport { analyzeModuleNotFoundError } from \"./config/config-loading\";\nimport { HardhatError } from \"./errors\";\nimport { ERRORS } from \"./errors-list\";\nimport { createProvider } from \"./providers/construction\";\nimport { LazyInitializationProviderAdapter } from \"./providers/lazy-initialization\";\nimport { OverriddenTaskDefinition } from \"./tasks/task-definitions\";\nimport {\n  completeTaskProfile,\n  createParentTaskProfile,\n  createTaskProfile,\n  TaskProfile,\n} from \"./task-profiling\";\nimport { parseTaskIdentifier } from \"./tasks/util\";\n\nconst log = debug(\"hardhat:core:hre\");\n\nexport class Environment implements HardhatRuntimeEnvironment {\n  private static readonly _BLACKLISTED_PROPERTIES: string[] = [\n    \"injectToGlobal\",\n    \"entryTaskProfile\",\n    \"_runTaskDefinition\",\n    \"_extenders\",\n  ];\n\n  public network: Network;\n\n  public artifacts: IArtifacts;\n\n  private readonly _environmentExtenders: EnvironmentExtender[];\n\n  public entryTaskProfile?: TaskProfile;\n\n  public version: string = getHardhatVersion();\n\n  /**\n   * Initializes the Hardhat Runtime Environment and the given\n   * extender functions.\n   *\n   * @remarks The extenders' execution order is given by the order\n   * of the requires in the hardhat's config file and its plugins.\n   *\n   * @param config The hardhat's config object.\n   * @param hardhatArguments The parsed hardhat's arguments.\n   * @param tasks A map of tasks.\n   * @param scopes A map of scopes.\n   * @param environmentExtenders A list of environment extenders.\n   * @param providerExtenders A list of provider extenders.\n   */\n  constructor(\n    public readonly config: HardhatConfig,\n    public readonly hardhatArguments: HardhatArguments,\n    public readonly tasks: TasksMap,\n    public readonly scopes: ScopesMap,\n    environmentExtenders: EnvironmentExtender[] = [],\n    experimentalHardhatNetworkMessageTraceHooks: ExperimentalHardhatNetworkMessageTraceHook[] = [],\n    public readonly userConfig: HardhatUserConfig = {},\n    providerExtenders: ProviderExtender[] = []\n  ) {\n    log(\"Creating HardhatRuntimeEnvironment\");\n\n    const networkName =\n      hardhatArguments.network !== undefined\n        ? hardhatArguments.network\n        : config.defaultNetwork;\n\n    const networkConfig = config.networks[networkName];\n\n    if (networkConfig === undefined) {\n      throw new HardhatError(ERRORS.NETWORK.CONFIG_NOT_FOUND, {\n        network: networkName,\n      });\n    }\n\n    this.artifacts = new Artifacts(config.paths.artifacts);\n\n    const provider = new LazyInitializationProviderAdapter(async () => {\n      log(`Creating provider for network ${networkName}`);\n      return createProvider(\n        config,\n        networkName,\n        this.artifacts,\n        experimentalHardhatNetworkMessageTraceHooks.map(\n          (hook) => (trace: MessageTrace, isCallMessageTrace: boolean) =>\n            hook(this, trace, isCallMessageTrace)\n        ),\n        providerExtenders\n      );\n    });\n\n    this.network = {\n      name: networkName,\n      config: networkConfig,\n      provider,\n    };\n\n    this._environmentExtenders = environmentExtenders;\n\n    environmentExtenders.forEach((extender) => extender(this));\n  }\n\n  /**\n   * Executes the task with the given name.\n   *\n   * @param taskIdentifier The task or scoped task to be executed.\n   * @param taskArguments A map of task's arguments.\n   * @param subtaskArguments A map of subtasks to their arguments.\n   *\n   * @throws a HH303 if there aren't any defined tasks with the given name.\n   * @returns a promise with the task's execution result.\n   */\n  public readonly run: RunTaskFunction = async (\n    taskIdentifier,\n    taskArguments = {},\n    subtaskArguments = {},\n    callerTaskProfile?: TaskProfile\n  ) => {\n    const { scope, task } = parseTaskIdentifier(taskIdentifier);\n\n    let taskDefinition;\n    if (scope === undefined) {\n      taskDefinition = this.tasks[task];\n      log(\"Running task %s\", task);\n    } else {\n      const scopeDefinition = this.scopes[scope];\n      if (scopeDefinition === undefined) {\n        throw new HardhatError(ERRORS.ARGUMENTS.UNRECOGNIZED_SCOPE, {\n          scope,\n        });\n      }\n\n      taskDefinition = scopeDefinition.tasks?.[task];\n      log(\"Running scoped task %s %s\", scope, task);\n    }\n\n    if (taskDefinition === undefined) {\n      if (scope !== undefined) {\n        throw new HardhatError(ERRORS.ARGUMENTS.UNRECOGNIZED_SCOPED_TASK, {\n          scope,\n          task,\n        });\n      }\n\n      throw new HardhatError(ERRORS.ARGUMENTS.UNRECOGNIZED_TASK, {\n        task,\n      });\n    }\n\n    const resolvedTaskArguments = this._resolveValidTaskArguments(\n      taskDefinition,\n      taskArguments,\n      subtaskArguments\n    );\n\n    let taskProfile: TaskProfile | undefined;\n    if (this.hardhatArguments.flamegraph === true) {\n      taskProfile = createTaskProfile(task);\n\n      if (callerTaskProfile !== undefined) {\n        callerTaskProfile.children.push(taskProfile);\n      } else {\n        this.entryTaskProfile = taskProfile;\n      }\n    }\n\n    try {\n      return await this._runTaskDefinition(\n        taskDefinition,\n        resolvedTaskArguments,\n        subtaskArguments,\n        taskProfile\n      );\n    } catch (e) {\n      analyzeModuleNotFoundError(e, this.config.paths.configFile);\n\n      // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n      throw e;\n    } finally {\n      if (taskProfile !== undefined) {\n        completeTaskProfile(taskProfile);\n      }\n    }\n  };\n\n  /**\n   * Injects the properties of `this` (the Hardhat Runtime Environment) into the global scope.\n   *\n   * @param blacklist a list of property names that won't be injected.\n   *\n   * @returns a function that restores the previous environment.\n   */\n  public injectToGlobal(\n    blacklist: string[] = Environment._BLACKLISTED_PROPERTIES\n  ): () => void {\n    const globalAsAny = global as any;\n\n    const previousValues: { [name: string]: any } = {};\n    const previousHre = globalAsAny.hre;\n\n    globalAsAny.hre = this;\n\n    for (const [key, value] of Object.entries(this)) {\n      if (blacklist.includes(key)) {\n        continue;\n      }\n\n      previousValues[key] = globalAsAny[key];\n      globalAsAny[key] = value;\n    }\n\n    return () => {\n      for (const [key, _] of Object.entries(this)) {\n        if (blacklist.includes(key)) {\n          continue;\n        }\n\n        globalAsAny.hre = previousHre;\n        globalAsAny[key] = previousValues[key];\n      }\n    };\n  }\n\n  /**\n   * @param taskProfile Undefined if we aren't computing task profiles\n   * @private\n   */\n  private async _runTaskDefinition(\n    taskDefinition: TaskDefinition,\n    taskArguments: TaskArguments,\n    subtaskArguments: SubtaskArguments,\n    taskProfile?: TaskProfile\n  ): Promise<any> {\n    let runSuperFunction: any;\n\n    if (taskDefinition instanceof OverriddenTaskDefinition) {\n      runSuperFunction = async (\n        _taskArguments: TaskArguments = taskArguments,\n        _subtaskArguments: SubtaskArguments = subtaskArguments\n      ) => {\n        log(\"Running %s's super\", taskDefinition.name);\n\n        if (taskProfile === undefined) {\n          return this._runTaskDefinition(\n            taskDefinition.parentTaskDefinition,\n            _taskArguments,\n            _subtaskArguments\n          );\n        }\n\n        const parentTaskProfile = createParentTaskProfile(taskProfile);\n        taskProfile.children.push(parentTaskProfile);\n\n        try {\n          return await this._runTaskDefinition(\n            taskDefinition.parentTaskDefinition,\n            _taskArguments,\n            _subtaskArguments,\n            parentTaskProfile\n          );\n        } finally {\n          completeTaskProfile(parentTaskProfile);\n        }\n      };\n\n      runSuperFunction.isDefined = true;\n    } else {\n      runSuperFunction = async () => {\n        throw new HardhatError(ERRORS.TASK_DEFINITIONS.RUNSUPER_NOT_AVAILABLE, {\n          taskName: taskDefinition.name,\n        });\n      };\n\n      runSuperFunction.isDefined = false;\n    }\n\n    const runSuper: RunSuperFunction<TaskArguments> = runSuperFunction;\n\n    const globalAsAny = global as any;\n    const previousRunSuper: any = globalAsAny.runSuper;\n    globalAsAny.runSuper = runSuper;\n\n    // We create a proxied version of `this`, as we want to keep track of the\n    // `subtaskArguments` and `taskProfile` through `run` invocations. This\n    // way we keep track of callers's data, even when tasks are run in parallel.\n    const proxiedHre = new Proxy<Environment>(this, {\n      get(target: Environment, p: string | symbol, receiver: any): any {\n        if (p === \"run\") {\n          return (\n            _name: string,\n            _taskArguments: TaskArguments,\n            _subtaskArguments: SubtaskArguments\n          ) =>\n            (target as any).run(\n              _name,\n              _taskArguments,\n              { ..._subtaskArguments, ...subtaskArguments }, // parent subtask args take precedence\n              taskProfile\n            );\n        }\n\n        return Reflect.get(target, p, receiver);\n      },\n    });\n\n    if (this.hardhatArguments.flamegraph === true) {\n      // We modify the `this` again to add  a few utility methods.\n      (proxiedHre as any).adhocProfile = async (\n        _name: string,\n        f: () => Promise<any>\n      ) => {\n        const adhocProfile = createTaskProfile(_name);\n        taskProfile!.children.push(adhocProfile);\n        try {\n          return await f();\n        } finally {\n          completeTaskProfile(adhocProfile);\n        }\n      };\n\n      (proxiedHre as any).adhocProfileSync = (_name: string, f: () => any) => {\n        const adhocProfile = createTaskProfile(_name);\n        taskProfile!.children.push(adhocProfile);\n        try {\n          return f();\n        } finally {\n          completeTaskProfile(adhocProfile);\n        }\n      };\n    }\n\n    const uninjectFromGlobal = proxiedHre.injectToGlobal();\n\n    try {\n      return await taskDefinition.action(taskArguments, proxiedHre, runSuper);\n    } finally {\n      uninjectFromGlobal();\n      globalAsAny.runSuper = previousRunSuper;\n    }\n  }\n\n  /**\n   * Check that task arguments are within TaskDefinition defined params constraints.\n   * Also, populate missing, non-mandatory arguments with default param values (if any).\n   *\n   * @private\n   * @throws HardhatError if any of the following are true:\n   *  > a required argument is missing\n   *  > an argument's value's type doesn't match the defined param type\n   *\n   * @param taskDefinition\n   * @param taskArguments\n   * @returns resolvedTaskArguments\n   */\n  private _resolveValidTaskArguments(\n    taskDefinition: TaskDefinition,\n    taskArguments: TaskArguments,\n    subtaskArguments: SubtaskArguments\n  ): TaskArguments {\n    const {\n      name: taskName,\n      paramDefinitions,\n      positionalParamDefinitions,\n    } = taskDefinition;\n\n    const nonPositionalParamDefinitions = Object.values(paramDefinitions);\n\n    // gather all task param definitions\n    const allTaskParamDefinitions = [\n      ...nonPositionalParamDefinitions,\n      ...positionalParamDefinitions,\n    ];\n\n    const resolvedArguments: TaskArguments = {};\n\n    for (const paramDefinition of allTaskParamDefinitions) {\n      const paramName = paramDefinition.name;\n      const argumentValue =\n        subtaskArguments[taskName]?.[paramName] ?? taskArguments[paramName];\n\n      const resolvedArgumentValue = this._resolveArgument(\n        paramDefinition,\n        argumentValue,\n        taskDefinition.name\n      );\n\n      if (resolvedArgumentValue !== undefined) {\n        resolvedArguments[paramName] = resolvedArgumentValue;\n      }\n    }\n\n    // We keep the args in taskArguments that were not resolved\n    return { ...taskArguments, ...resolvedArguments };\n  }\n\n  /**\n   * Resolves an argument according to a ParamDefinition rules.\n   *\n   * @param paramDefinition\n   * @param argumentValue\n   * @private\n   */\n  private _resolveArgument(\n    paramDefinition: ParamDefinition<any>,\n    argumentValue: any,\n    taskName: string\n  ) {\n    const { name, isOptional, defaultValue } = paramDefinition;\n\n    if (argumentValue === undefined) {\n      if (isOptional) {\n        // undefined & optional argument -> return defaultValue\n        return defaultValue;\n      }\n\n      // undefined & mandatory argument -> error\n      throw new HardhatError(ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n        param: name,\n        task: taskName,\n      });\n    }\n\n    // arg was present -> validate type, if applicable\n    this._checkTypeValidation(paramDefinition, argumentValue);\n\n    return argumentValue;\n  }\n\n  /**\n   * Checks if value is valid for the specified param definition.\n   *\n   * @param paramDefinition {ParamDefinition} - the param definition for validation\n   * @param argumentValue - the value to be validated\n   * @private\n   * @throws HH301 if value is not valid for the param type\n   */\n  private _checkTypeValidation(\n    paramDefinition: ParamDefinition<any>,\n    argumentValue: any\n  ) {\n    const { name: paramName, type, isVariadic } = paramDefinition;\n\n    // in case of variadic param, argValue is an array and the type validation must pass for all values.\n    // otherwise, it's a single value that is to be validated\n    const argumentValueContainer = isVariadic ? argumentValue : [argumentValue];\n\n    for (const value of argumentValueContainer) {\n      type.validate(paramName, value);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}