{"ast":null,"code":"'use strict';\n\nconst net = require('net');\nconst assert = require('assert');\nconst util = require('./util');\nconst {\n  InvalidArgumentError,\n  ConnectTimeoutError\n} = require('./errors');\nlet tls; // include tls conditionally since it is not always available\n\n// TODO: session re-use does not wait for the first\n// connection to resolve the session and might therefore\n// resolve the same servername multiple times even when\n// re-use is enabled.\n\nlet SessionCache;\n// FIXME: remove workaround when the Node bug is fixed\n// https://github.com/nodejs/node/issues/49344#issuecomment-1741776308\nif (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) {\n  SessionCache = class WeakSessionCache {\n    constructor(maxCachedSessions) {\n      this._maxCachedSessions = maxCachedSessions;\n      this._sessionCache = new Map();\n      this._sessionRegistry = new global.FinalizationRegistry(key => {\n        if (this._sessionCache.size < this._maxCachedSessions) {\n          return;\n        }\n        const ref = this._sessionCache.get(key);\n        if (ref !== undefined && ref.deref() === undefined) {\n          this._sessionCache.delete(key);\n        }\n      });\n    }\n    get(sessionKey) {\n      const ref = this._sessionCache.get(sessionKey);\n      return ref ? ref.deref() : null;\n    }\n    set(sessionKey, session) {\n      if (this._maxCachedSessions === 0) {\n        return;\n      }\n      this._sessionCache.set(sessionKey, new WeakRef(session));\n      this._sessionRegistry.register(session, sessionKey);\n    }\n  };\n} else {\n  SessionCache = class SimpleSessionCache {\n    constructor(maxCachedSessions) {\n      this._maxCachedSessions = maxCachedSessions;\n      this._sessionCache = new Map();\n    }\n    get(sessionKey) {\n      return this._sessionCache.get(sessionKey);\n    }\n    set(sessionKey, session) {\n      if (this._maxCachedSessions === 0) {\n        return;\n      }\n      if (this._sessionCache.size >= this._maxCachedSessions) {\n        // remove the oldest session\n        const {\n          value: oldestKey\n        } = this._sessionCache.keys().next();\n        this._sessionCache.delete(oldestKey);\n      }\n      this._sessionCache.set(sessionKey, session);\n    }\n  };\n}\nfunction buildConnector({\n  allowH2,\n  maxCachedSessions,\n  socketPath,\n  timeout,\n  ...opts\n}) {\n  if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {\n    throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero');\n  }\n  const options = {\n    path: socketPath,\n    ...opts\n  };\n  const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);\n  timeout = timeout == null ? 10e3 : timeout;\n  allowH2 = allowH2 != null ? allowH2 : false;\n  return function connect({\n    hostname,\n    host,\n    protocol,\n    port,\n    servername,\n    localAddress,\n    httpSocket\n  }, callback) {\n    let socket;\n    if (protocol === 'https:') {\n      if (!tls) {\n        tls = require('tls');\n      }\n      servername = servername || options.servername || util.getServerName(host) || null;\n      const sessionKey = servername || hostname;\n      const session = sessionCache.get(sessionKey) || null;\n      assert(sessionKey);\n      socket = tls.connect({\n        highWaterMark: 16384,\n        // TLS in node can't have bigger HWM anyway...\n        ...options,\n        servername,\n        session,\n        localAddress,\n        // TODO(HTTP/2): Add support for h2c\n        ALPNProtocols: allowH2 ? ['http/1.1', 'h2'] : ['http/1.1'],\n        socket: httpSocket,\n        // upgrade socket connection\n        port: port || 443,\n        host: hostname\n      });\n      socket.on('session', function (session) {\n        // TODO (fix): Can a session become invalid once established? Don't think so?\n        sessionCache.set(sessionKey, session);\n      });\n    } else {\n      assert(!httpSocket, 'httpSocket can only be sent on TLS update');\n      socket = net.connect({\n        highWaterMark: 64 * 1024,\n        // Same as nodejs fs streams.\n        ...options,\n        localAddress,\n        port: port || 80,\n        host: hostname\n      });\n    }\n\n    // Set TCP keep alive options on the socket here instead of in connect() for the case of assigning the socket\n    if (options.keepAlive == null || options.keepAlive) {\n      const keepAliveInitialDelay = options.keepAliveInitialDelay === undefined ? 60e3 : options.keepAliveInitialDelay;\n      socket.setKeepAlive(true, keepAliveInitialDelay);\n    }\n    const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);\n    socket.setNoDelay(true).once(protocol === 'https:' ? 'secureConnect' : 'connect', function () {\n      cancelTimeout();\n      if (callback) {\n        const cb = callback;\n        callback = null;\n        cb(null, this);\n      }\n    }).on('error', function (err) {\n      cancelTimeout();\n      if (callback) {\n        const cb = callback;\n        callback = null;\n        cb(err);\n      }\n    });\n    return socket;\n  };\n}\nfunction setupTimeout(onConnectTimeout, timeout) {\n  if (!timeout) {\n    return () => {};\n  }\n  let s1 = null;\n  let s2 = null;\n  const timeoutId = setTimeout(() => {\n    // setImmediate is added to make sure that we priotorise socket error events over timeouts\n    s1 = setImmediate(() => {\n      if (process.platform === 'win32') {\n        // Windows needs an extra setImmediate probably due to implementation differences in the socket logic\n        s2 = setImmediate(() => onConnectTimeout());\n      } else {\n        onConnectTimeout();\n      }\n    });\n  }, timeout);\n  return () => {\n    clearTimeout(timeoutId);\n    clearImmediate(s1);\n    clearImmediate(s2);\n  };\n}\nfunction onConnectTimeout(socket) {\n  util.destroy(socket, new ConnectTimeoutError());\n}\nmodule.exports = buildConnector;","map":{"version":3,"names":["net","require","assert","util","InvalidArgumentError","ConnectTimeoutError","tls","SessionCache","global","FinalizationRegistry","process","env","NODE_V8_COVERAGE","WeakSessionCache","constructor","maxCachedSessions","_maxCachedSessions","_sessionCache","Map","_sessionRegistry","key","size","ref","get","undefined","deref","delete","sessionKey","set","session","WeakRef","register","SimpleSessionCache","value","oldestKey","keys","next","buildConnector","allowH2","socketPath","timeout","opts","Number","isInteger","options","path","sessionCache","connect","hostname","host","protocol","port","servername","localAddress","httpSocket","callback","socket","getServerName","highWaterMark","ALPNProtocols","on","keepAlive","keepAliveInitialDelay","setKeepAlive","cancelTimeout","setupTimeout","onConnectTimeout","setNoDelay","once","cb","err","s1","s2","timeoutId","setTimeout","setImmediate","platform","clearTimeout","clearImmediate","destroy","module","exports"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/undici/lib/core/connect.js"],"sourcesContent":["'use strict'\n\nconst net = require('net')\nconst assert = require('assert')\nconst util = require('./util')\nconst { InvalidArgumentError, ConnectTimeoutError } = require('./errors')\n\nlet tls // include tls conditionally since it is not always available\n\n// TODO: session re-use does not wait for the first\n// connection to resolve the session and might therefore\n// resolve the same servername multiple times even when\n// re-use is enabled.\n\nlet SessionCache\n// FIXME: remove workaround when the Node bug is fixed\n// https://github.com/nodejs/node/issues/49344#issuecomment-1741776308\nif (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) {\n  SessionCache = class WeakSessionCache {\n    constructor (maxCachedSessions) {\n      this._maxCachedSessions = maxCachedSessions\n      this._sessionCache = new Map()\n      this._sessionRegistry = new global.FinalizationRegistry((key) => {\n        if (this._sessionCache.size < this._maxCachedSessions) {\n          return\n        }\n\n        const ref = this._sessionCache.get(key)\n        if (ref !== undefined && ref.deref() === undefined) {\n          this._sessionCache.delete(key)\n        }\n      })\n    }\n\n    get (sessionKey) {\n      const ref = this._sessionCache.get(sessionKey)\n      return ref ? ref.deref() : null\n    }\n\n    set (sessionKey, session) {\n      if (this._maxCachedSessions === 0) {\n        return\n      }\n\n      this._sessionCache.set(sessionKey, new WeakRef(session))\n      this._sessionRegistry.register(session, sessionKey)\n    }\n  }\n} else {\n  SessionCache = class SimpleSessionCache {\n    constructor (maxCachedSessions) {\n      this._maxCachedSessions = maxCachedSessions\n      this._sessionCache = new Map()\n    }\n\n    get (sessionKey) {\n      return this._sessionCache.get(sessionKey)\n    }\n\n    set (sessionKey, session) {\n      if (this._maxCachedSessions === 0) {\n        return\n      }\n\n      if (this._sessionCache.size >= this._maxCachedSessions) {\n        // remove the oldest session\n        const { value: oldestKey } = this._sessionCache.keys().next()\n        this._sessionCache.delete(oldestKey)\n      }\n\n      this._sessionCache.set(sessionKey, session)\n    }\n  }\n}\n\nfunction buildConnector ({ allowH2, maxCachedSessions, socketPath, timeout, ...opts }) {\n  if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {\n    throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero')\n  }\n\n  const options = { path: socketPath, ...opts }\n  const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions)\n  timeout = timeout == null ? 10e3 : timeout\n  allowH2 = allowH2 != null ? allowH2 : false\n  return function connect ({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {\n    let socket\n    if (protocol === 'https:') {\n      if (!tls) {\n        tls = require('tls')\n      }\n      servername = servername || options.servername || util.getServerName(host) || null\n\n      const sessionKey = servername || hostname\n      const session = sessionCache.get(sessionKey) || null\n\n      assert(sessionKey)\n\n      socket = tls.connect({\n        highWaterMark: 16384, // TLS in node can't have bigger HWM anyway...\n        ...options,\n        servername,\n        session,\n        localAddress,\n        // TODO(HTTP/2): Add support for h2c\n        ALPNProtocols: allowH2 ? ['http/1.1', 'h2'] : ['http/1.1'],\n        socket: httpSocket, // upgrade socket connection\n        port: port || 443,\n        host: hostname\n      })\n\n      socket\n        .on('session', function (session) {\n          // TODO (fix): Can a session become invalid once established? Don't think so?\n          sessionCache.set(sessionKey, session)\n        })\n    } else {\n      assert(!httpSocket, 'httpSocket can only be sent on TLS update')\n      socket = net.connect({\n        highWaterMark: 64 * 1024, // Same as nodejs fs streams.\n        ...options,\n        localAddress,\n        port: port || 80,\n        host: hostname\n      })\n    }\n\n    // Set TCP keep alive options on the socket here instead of in connect() for the case of assigning the socket\n    if (options.keepAlive == null || options.keepAlive) {\n      const keepAliveInitialDelay = options.keepAliveInitialDelay === undefined ? 60e3 : options.keepAliveInitialDelay\n      socket.setKeepAlive(true, keepAliveInitialDelay)\n    }\n\n    const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout)\n\n    socket\n      .setNoDelay(true)\n      .once(protocol === 'https:' ? 'secureConnect' : 'connect', function () {\n        cancelTimeout()\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(null, this)\n        }\n      })\n      .on('error', function (err) {\n        cancelTimeout()\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(err)\n        }\n      })\n\n    return socket\n  }\n}\n\nfunction setupTimeout (onConnectTimeout, timeout) {\n  if (!timeout) {\n    return () => {}\n  }\n\n  let s1 = null\n  let s2 = null\n  const timeoutId = setTimeout(() => {\n    // setImmediate is added to make sure that we priotorise socket error events over timeouts\n    s1 = setImmediate(() => {\n      if (process.platform === 'win32') {\n        // Windows needs an extra setImmediate probably due to implementation differences in the socket logic\n        s2 = setImmediate(() => onConnectTimeout())\n      } else {\n        onConnectTimeout()\n      }\n    })\n  }, timeout)\n  return () => {\n    clearTimeout(timeoutId)\n    clearImmediate(s1)\n    clearImmediate(s2)\n  }\n}\n\nfunction onConnectTimeout (socket) {\n  util.destroy(socket, new ConnectTimeoutError())\n}\n\nmodule.exports = buildConnector\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}