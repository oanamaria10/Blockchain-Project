{"ast":null,"code":"import { defineProperties, concat, getBytesCopy, getNumber, hexlify, toBeArray, toBigInt, toNumber, assert, assertArgument\n/*, isError*/ } from \"../../utils/index.js\";\n/**\n * @_ignore:\n */\nexport const WordSize = 32;\nconst Padding = new Uint8Array(WordSize);\n// Properties used to immediate pass through to the underlying object\n// - `then` is used to detect if an object is a Promise for await\nconst passProperties = [\"then\"];\nconst _guard = {};\nconst resultNames = new WeakMap();\nfunction getNames(result) {\n  return resultNames.get(result);\n}\nfunction setNames(result, names) {\n  resultNames.set(result, names);\n}\nfunction throwError(name, error) {\n  const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);\n  wrapped.error = error;\n  throw wrapped;\n}\nfunction toObject(names, items, deep) {\n  if (names.indexOf(null) >= 0) {\n    return items.map((item, index) => {\n      if (item instanceof Result) {\n        return toObject(getNames(item), item, deep);\n      }\n      return item;\n    });\n  }\n  return names.reduce((accum, name, index) => {\n    let item = items.getValue(name);\n    if (!(name in accum)) {\n      if (deep && item instanceof Result) {\n        item = toObject(getNames(item), item, deep);\n      }\n      accum[name] = item;\n    }\n    return accum;\n  }, {});\n}\n/**\n *  A [[Result]] is a sub-class of Array, which allows accessing any\n *  of its values either positionally by its index or, if keys are\n *  provided by its name.\n *\n *  @_docloc: api/abi\n */\nexport class Result extends Array {\n  // No longer used; but cannot be removed as it will remove the\n  // #private field from the .d.ts which may break backwards\n  // compatibility\n  #names;\n  /**\n   *  @private\n   */\n  constructor(...args) {\n    // To properly sub-class Array so the other built-in\n    // functions work, the constructor has to behave fairly\n    // well. So, in the event we are created via fromItems()\n    // we build the read-only Result object we want, but on\n    // any other input, we use the default constructor\n    // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);\n    const guard = args[0];\n    let items = args[1];\n    let names = (args[2] || []).slice();\n    let wrap = true;\n    if (guard !== _guard) {\n      items = args;\n      names = [];\n      wrap = false;\n    }\n    // Can't just pass in ...items since an array of length 1\n    // is a special case in the super.\n    super(items.length);\n    items.forEach((item, index) => {\n      this[index] = item;\n    });\n    // Find all unique keys\n    const nameCounts = names.reduce((accum, name) => {\n      if (typeof name === \"string\") {\n        accum.set(name, (accum.get(name) || 0) + 1);\n      }\n      return accum;\n    }, new Map());\n    // Remove any key thats not unique\n    setNames(this, Object.freeze(items.map((item, index) => {\n      const name = names[index];\n      if (name != null && nameCounts.get(name) === 1) {\n        return name;\n      }\n      return null;\n    })));\n    // Dummy operations to prevent TypeScript from complaining\n    this.#names = [];\n    if (this.#names == null) {\n      void this.#names;\n    }\n    if (!wrap) {\n      return;\n    }\n    // A wrapped Result is immutable\n    Object.freeze(this);\n    // Proxy indices and names so we can trap deferred errors\n    const proxy = new Proxy(this, {\n      get: (target, prop, receiver) => {\n        if (typeof prop === \"string\") {\n          // Index accessor\n          if (prop.match(/^[0-9]+$/)) {\n            const index = getNumber(prop, \"%index\");\n            if (index < 0 || index >= this.length) {\n              throw new RangeError(\"out of result range\");\n            }\n            const item = target[index];\n            if (item instanceof Error) {\n              throwError(`index ${index}`, item);\n            }\n            return item;\n          }\n          // Pass important checks (like `then` for Promise) through\n          if (passProperties.indexOf(prop) >= 0) {\n            return Reflect.get(target, prop, receiver);\n          }\n          const value = target[prop];\n          if (value instanceof Function) {\n            // Make sure functions work with private variables\n            // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding\n            return function (...args) {\n              return value.apply(this === receiver ? target : this, args);\n            };\n          } else if (!(prop in target)) {\n            // Possible name accessor\n            return target.getValue.apply(this === receiver ? target : this, [prop]);\n          }\n        }\n        return Reflect.get(target, prop, receiver);\n      }\n    });\n    setNames(proxy, getNames(this));\n    return proxy;\n  }\n  /**\n   *  Returns the Result as a normal Array. If %%deep%%, any children\n   *  which are Result objects are also converted to a normal Array.\n   *\n   *  This will throw if there are any outstanding deferred\n   *  errors.\n   */\n  toArray(deep) {\n    const result = [];\n    this.forEach((item, index) => {\n      if (item instanceof Error) {\n        throwError(`index ${index}`, item);\n      }\n      if (deep && item instanceof Result) {\n        item = item.toArray(deep);\n      }\n      result.push(item);\n    });\n    return result;\n  }\n  /**\n   *  Returns the Result as an Object with each name-value pair. If\n   *  %%deep%%, any children which are Result objects are also\n   *  converted to an Object.\n   *\n   *  This will throw if any value is unnamed, or if there are\n   *  any outstanding deferred errors.\n   */\n  toObject(deep) {\n    const names = getNames(this);\n    return names.reduce((accum, name, index) => {\n      assert(name != null, `value at index ${index} unnamed`, \"UNSUPPORTED_OPERATION\", {\n        operation: \"toObject()\"\n      });\n      return toObject(names, this, deep);\n    }, {});\n  }\n  /**\n   *  @_ignore\n   */\n  slice(start, end) {\n    if (start == null) {\n      start = 0;\n    }\n    if (start < 0) {\n      start += this.length;\n      if (start < 0) {\n        start = 0;\n      }\n    }\n    if (end == null) {\n      end = this.length;\n    }\n    if (end < 0) {\n      end += this.length;\n      if (end < 0) {\n        end = 0;\n      }\n    }\n    if (end > this.length) {\n      end = this.length;\n    }\n    const _names = getNames(this);\n    const result = [],\n      names = [];\n    for (let i = start; i < end; i++) {\n      result.push(this[i]);\n      names.push(_names[i]);\n    }\n    return new Result(_guard, result, names);\n  }\n  /**\n   *  @_ignore\n   */\n  filter(callback, thisArg) {\n    const _names = getNames(this);\n    const result = [],\n      names = [];\n    for (let i = 0; i < this.length; i++) {\n      const item = this[i];\n      if (item instanceof Error) {\n        throwError(`index ${i}`, item);\n      }\n      if (callback.call(thisArg, item, i, this)) {\n        result.push(item);\n        names.push(_names[i]);\n      }\n    }\n    return new Result(_guard, result, names);\n  }\n  /**\n   *  @_ignore\n   */\n  map(callback, thisArg) {\n    const result = [];\n    for (let i = 0; i < this.length; i++) {\n      const item = this[i];\n      if (item instanceof Error) {\n        throwError(`index ${i}`, item);\n      }\n      result.push(callback.call(thisArg, item, i, this));\n    }\n    return result;\n  }\n  /**\n   *  Returns the value for %%name%%.\n   *\n   *  Since it is possible to have a key whose name conflicts with\n   *  a method on a [[Result]] or its superclass Array, or any\n   *  JavaScript keyword, this ensures all named values are still\n   *  accessible by name.\n   */\n  getValue(name) {\n    const index = getNames(this).indexOf(name);\n    if (index === -1) {\n      return undefined;\n    }\n    const value = this[index];\n    if (value instanceof Error) {\n      throwError(`property ${JSON.stringify(name)}`, value.error);\n    }\n    return value;\n  }\n  /**\n   *  Creates a new [[Result]] for %%items%% with each entry\n   *  also accessible by its corresponding name in %%keys%%.\n   */\n  static fromItems(items, keys) {\n    return new Result(_guard, items, keys);\n  }\n}\n/**\n *  Returns all errors found in a [[Result]].\n *\n *  Since certain errors encountered when creating a [[Result]] do\n *  not impact the ability to continue parsing data, they are\n *  deferred until they are actually accessed. Hence a faulty string\n *  in an Event that is never used does not impact the program flow.\n *\n *  However, sometimes it may be useful to access, identify or\n *  validate correctness of a [[Result]].\n *\n *  @_docloc api/abi\n */\nexport function checkResultErrors(result) {\n  // Find the first error (if any)\n  const errors = [];\n  const checkErrors = function (path, object) {\n    if (!Array.isArray(object)) {\n      return;\n    }\n    for (let key in object) {\n      const childPath = path.slice();\n      childPath.push(key);\n      try {\n        checkErrors(childPath, object[key]);\n      } catch (error) {\n        errors.push({\n          path: childPath,\n          error: error\n        });\n      }\n    }\n  };\n  checkErrors([], result);\n  return errors;\n}\nfunction getValue(value) {\n  let bytes = toBeArray(value);\n  assert(bytes.length <= WordSize, \"value out-of-bounds\", \"BUFFER_OVERRUN\", {\n    buffer: bytes,\n    length: WordSize,\n    offset: bytes.length\n  });\n  if (bytes.length !== WordSize) {\n    bytes = getBytesCopy(concat([Padding.slice(bytes.length % WordSize), bytes]));\n  }\n  return bytes;\n}\n/**\n *  @_ignore\n */\nexport class Coder {\n  // The coder name:\n  //   - address, uint256, tuple, array, etc.\n  name;\n  // The fully expanded type, including composite types:\n  //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n  type;\n  // The localName bound in the signature, in this example it is \"baz\":\n  //   - tuple(address foo, uint bar) baz\n  localName;\n  // Whether this type is dynamic:\n  //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n  //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n  dynamic;\n  constructor(name, type, localName, dynamic) {\n    defineProperties(this, {\n      name,\n      type,\n      localName,\n      dynamic\n    }, {\n      name: \"string\",\n      type: \"string\",\n      localName: \"string\",\n      dynamic: \"boolean\"\n    });\n  }\n  _throwError(message, value) {\n    assertArgument(false, message, this.localName, value);\n  }\n}\n/**\n *  @_ignore\n */\nexport class Writer {\n  // An array of WordSize lengthed objects to concatenation\n  #data;\n  #dataLength;\n  constructor() {\n    this.#data = [];\n    this.#dataLength = 0;\n  }\n  get data() {\n    return concat(this.#data);\n  }\n  get length() {\n    return this.#dataLength;\n  }\n  #writeData(data) {\n    this.#data.push(data);\n    this.#dataLength += data.length;\n    return data.length;\n  }\n  appendWriter(writer) {\n    return this.#writeData(getBytesCopy(writer.data));\n  }\n  // Arrayish item; pad on the right to *nearest* WordSize\n  writeBytes(value) {\n    let bytes = getBytesCopy(value);\n    const paddingOffset = bytes.length % WordSize;\n    if (paddingOffset) {\n      bytes = getBytesCopy(concat([bytes, Padding.slice(paddingOffset)]));\n    }\n    return this.#writeData(bytes);\n  }\n  // Numeric item; pad on the left *to* WordSize\n  writeValue(value) {\n    return this.#writeData(getValue(value));\n  }\n  // Inserts a numeric place-holder, returning a callback that can\n  // be used to asjust the value later\n  writeUpdatableValue() {\n    const offset = this.#data.length;\n    this.#data.push(Padding);\n    this.#dataLength += WordSize;\n    return value => {\n      this.#data[offset] = getValue(value);\n    };\n  }\n}\n/**\n *  @_ignore\n */\nexport class Reader {\n  // Allows incomplete unpadded data to be read; otherwise an error\n  // is raised if attempting to overrun the buffer. This is required\n  // to deal with an old Solidity bug, in which event data for\n  // external (not public thoguh) was tightly packed.\n  allowLoose;\n  #data;\n  #offset;\n  #bytesRead;\n  #parent;\n  #maxInflation;\n  constructor(data, allowLoose, maxInflation) {\n    defineProperties(this, {\n      allowLoose: !!allowLoose\n    });\n    this.#data = getBytesCopy(data);\n    this.#bytesRead = 0;\n    this.#parent = null;\n    this.#maxInflation = maxInflation != null ? maxInflation : 1024;\n    this.#offset = 0;\n  }\n  get data() {\n    return hexlify(this.#data);\n  }\n  get dataLength() {\n    return this.#data.length;\n  }\n  get consumed() {\n    return this.#offset;\n  }\n  get bytes() {\n    return new Uint8Array(this.#data);\n  }\n  #incrementBytesRead(count) {\n    if (this.#parent) {\n      return this.#parent.#incrementBytesRead(count);\n    }\n    this.#bytesRead += count;\n    // Check for excessive inflation (see: #4537)\n    assert(this.#maxInflation < 1 || this.#bytesRead <= this.#maxInflation * this.dataLength, `compressed ABI data exceeds inflation ratio of ${this.#maxInflation} ( see: https:/\\/github.com/ethers-io/ethers.js/issues/4537 )`, \"BUFFER_OVERRUN\", {\n      buffer: getBytesCopy(this.#data),\n      offset: this.#offset,\n      length: count,\n      info: {\n        bytesRead: this.#bytesRead,\n        dataLength: this.dataLength\n      }\n    });\n  }\n  #peekBytes(offset, length, loose) {\n    let alignedLength = Math.ceil(length / WordSize) * WordSize;\n    if (this.#offset + alignedLength > this.#data.length) {\n      if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {\n        alignedLength = length;\n      } else {\n        assert(false, \"data out-of-bounds\", \"BUFFER_OVERRUN\", {\n          buffer: getBytesCopy(this.#data),\n          length: this.#data.length,\n          offset: this.#offset + alignedLength\n        });\n      }\n    }\n    return this.#data.slice(this.#offset, this.#offset + alignedLength);\n  }\n  // Create a sub-reader with the same underlying data, but offset\n  subReader(offset) {\n    const reader = new Reader(this.#data.slice(this.#offset + offset), this.allowLoose, this.#maxInflation);\n    reader.#parent = this;\n    return reader;\n  }\n  // Read bytes\n  readBytes(length, loose) {\n    let bytes = this.#peekBytes(0, length, !!loose);\n    this.#incrementBytesRead(length);\n    this.#offset += bytes.length;\n    // @TODO: Make sure the length..end bytes are all 0?\n    return bytes.slice(0, length);\n  }\n  // Read a numeric values\n  readValue() {\n    return toBigInt(this.readBytes(WordSize));\n  }\n  readIndex() {\n    return toNumber(this.readBytes(WordSize));\n  }\n}","map":{"version":3,"names":["defineProperties","concat","getBytesCopy","getNumber","hexlify","toBeArray","toBigInt","toNumber","assert","assertArgument","WordSize","Padding","Uint8Array","passProperties","_guard","resultNames","WeakMap","getNames","result","get","setNames","names","set","throwError","name","error","wrapped","Error","toObject","items","deep","indexOf","map","item","index","Result","reduce","accum","getValue","Array","constructor","args","guard","slice","wrap","length","forEach","nameCounts","Map","Object","freeze","proxy","Proxy","target","prop","receiver","match","RangeError","Reflect","value","Function","apply","toArray","push","operation","start","end","_names","i","filter","callback","thisArg","call","undefined","JSON","stringify","fromItems","keys","checkResultErrors","errors","checkErrors","path","object","isArray","key","childPath","bytes","buffer","offset","Coder","type","localName","dynamic","_throwError","message","Writer","data","dataLength","writeData","#writeData","appendWriter","writer","writeBytes","paddingOffset","writeValue","writeUpdatableValue","Reader","allowLoose","bytesRead","parent","maxInflation","consumed","incrementBytesRead","#incrementBytesRead","count","info","peekBytes","#peekBytes","loose","alignedLength","Math","ceil","subReader","reader","readBytes","readValue","readIndex"],"sources":["C:/Users/Oana/Desktop/Blockchain/Blockchain-Project/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js"],"sourcesContent":["import { defineProperties, concat, getBytesCopy, getNumber, hexlify, toBeArray, toBigInt, toNumber, assert, assertArgument\n/*, isError*/\n } from \"../../utils/index.js\";\n/**\n * @_ignore:\n */\nexport const WordSize = 32;\nconst Padding = new Uint8Array(WordSize);\n// Properties used to immediate pass through to the underlying object\n// - `then` is used to detect if an object is a Promise for await\nconst passProperties = [\"then\"];\nconst _guard = {};\nconst resultNames = new WeakMap();\nfunction getNames(result) {\n    return resultNames.get(result);\n}\nfunction setNames(result, names) {\n    resultNames.set(result, names);\n}\nfunction throwError(name, error) {\n    const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);\n    wrapped.error = error;\n    throw wrapped;\n}\nfunction toObject(names, items, deep) {\n    if (names.indexOf(null) >= 0) {\n        return items.map((item, index) => {\n            if (item instanceof Result) {\n                return toObject(getNames(item), item, deep);\n            }\n            return item;\n        });\n    }\n    return names.reduce((accum, name, index) => {\n        let item = items.getValue(name);\n        if (!(name in accum)) {\n            if (deep && item instanceof Result) {\n                item = toObject(getNames(item), item, deep);\n            }\n            accum[name] = item;\n        }\n        return accum;\n    }, {});\n}\n/**\n *  A [[Result]] is a sub-class of Array, which allows accessing any\n *  of its values either positionally by its index or, if keys are\n *  provided by its name.\n *\n *  @_docloc: api/abi\n */\nexport class Result extends Array {\n    // No longer used; but cannot be removed as it will remove the\n    // #private field from the .d.ts which may break backwards\n    // compatibility\n    #names;\n    /**\n     *  @private\n     */\n    constructor(...args) {\n        // To properly sub-class Array so the other built-in\n        // functions work, the constructor has to behave fairly\n        // well. So, in the event we are created via fromItems()\n        // we build the read-only Result object we want, but on\n        // any other input, we use the default constructor\n        // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);\n        const guard = args[0];\n        let items = args[1];\n        let names = (args[2] || []).slice();\n        let wrap = true;\n        if (guard !== _guard) {\n            items = args;\n            names = [];\n            wrap = false;\n        }\n        // Can't just pass in ...items since an array of length 1\n        // is a special case in the super.\n        super(items.length);\n        items.forEach((item, index) => { this[index] = item; });\n        // Find all unique keys\n        const nameCounts = names.reduce((accum, name) => {\n            if (typeof (name) === \"string\") {\n                accum.set(name, (accum.get(name) || 0) + 1);\n            }\n            return accum;\n        }, (new Map()));\n        // Remove any key thats not unique\n        setNames(this, Object.freeze(items.map((item, index) => {\n            const name = names[index];\n            if (name != null && nameCounts.get(name) === 1) {\n                return name;\n            }\n            return null;\n        })));\n        // Dummy operations to prevent TypeScript from complaining\n        this.#names = [];\n        if (this.#names == null) {\n            void (this.#names);\n        }\n        if (!wrap) {\n            return;\n        }\n        // A wrapped Result is immutable\n        Object.freeze(this);\n        // Proxy indices and names so we can trap deferred errors\n        const proxy = new Proxy(this, {\n            get: (target, prop, receiver) => {\n                if (typeof (prop) === \"string\") {\n                    // Index accessor\n                    if (prop.match(/^[0-9]+$/)) {\n                        const index = getNumber(prop, \"%index\");\n                        if (index < 0 || index >= this.length) {\n                            throw new RangeError(\"out of result range\");\n                        }\n                        const item = target[index];\n                        if (item instanceof Error) {\n                            throwError(`index ${index}`, item);\n                        }\n                        return item;\n                    }\n                    // Pass important checks (like `then` for Promise) through\n                    if (passProperties.indexOf(prop) >= 0) {\n                        return Reflect.get(target, prop, receiver);\n                    }\n                    const value = target[prop];\n                    if (value instanceof Function) {\n                        // Make sure functions work with private variables\n                        // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding\n                        return function (...args) {\n                            return value.apply((this === receiver) ? target : this, args);\n                        };\n                    }\n                    else if (!(prop in target)) {\n                        // Possible name accessor\n                        return target.getValue.apply((this === receiver) ? target : this, [prop]);\n                    }\n                }\n                return Reflect.get(target, prop, receiver);\n            }\n        });\n        setNames(proxy, getNames(this));\n        return proxy;\n    }\n    /**\n     *  Returns the Result as a normal Array. If %%deep%%, any children\n     *  which are Result objects are also converted to a normal Array.\n     *\n     *  This will throw if there are any outstanding deferred\n     *  errors.\n     */\n    toArray(deep) {\n        const result = [];\n        this.forEach((item, index) => {\n            if (item instanceof Error) {\n                throwError(`index ${index}`, item);\n            }\n            if (deep && item instanceof Result) {\n                item = item.toArray(deep);\n            }\n            result.push(item);\n        });\n        return result;\n    }\n    /**\n     *  Returns the Result as an Object with each name-value pair. If\n     *  %%deep%%, any children which are Result objects are also\n     *  converted to an Object.\n     *\n     *  This will throw if any value is unnamed, or if there are\n     *  any outstanding deferred errors.\n     */\n    toObject(deep) {\n        const names = getNames(this);\n        return names.reduce((accum, name, index) => {\n            assert(name != null, `value at index ${index} unnamed`, \"UNSUPPORTED_OPERATION\", {\n                operation: \"toObject()\"\n            });\n            return toObject(names, this, deep);\n        }, {});\n    }\n    /**\n     *  @_ignore\n     */\n    slice(start, end) {\n        if (start == null) {\n            start = 0;\n        }\n        if (start < 0) {\n            start += this.length;\n            if (start < 0) {\n                start = 0;\n            }\n        }\n        if (end == null) {\n            end = this.length;\n        }\n        if (end < 0) {\n            end += this.length;\n            if (end < 0) {\n                end = 0;\n            }\n        }\n        if (end > this.length) {\n            end = this.length;\n        }\n        const _names = getNames(this);\n        const result = [], names = [];\n        for (let i = start; i < end; i++) {\n            result.push(this[i]);\n            names.push(_names[i]);\n        }\n        return new Result(_guard, result, names);\n    }\n    /**\n     *  @_ignore\n     */\n    filter(callback, thisArg) {\n        const _names = getNames(this);\n        const result = [], names = [];\n        for (let i = 0; i < this.length; i++) {\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${i}`, item);\n            }\n            if (callback.call(thisArg, item, i, this)) {\n                result.push(item);\n                names.push(_names[i]);\n            }\n        }\n        return new Result(_guard, result, names);\n    }\n    /**\n     *  @_ignore\n     */\n    map(callback, thisArg) {\n        const result = [];\n        for (let i = 0; i < this.length; i++) {\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${i}`, item);\n            }\n            result.push(callback.call(thisArg, item, i, this));\n        }\n        return result;\n    }\n    /**\n     *  Returns the value for %%name%%.\n     *\n     *  Since it is possible to have a key whose name conflicts with\n     *  a method on a [[Result]] or its superclass Array, or any\n     *  JavaScript keyword, this ensures all named values are still\n     *  accessible by name.\n     */\n    getValue(name) {\n        const index = getNames(this).indexOf(name);\n        if (index === -1) {\n            return undefined;\n        }\n        const value = this[index];\n        if (value instanceof Error) {\n            throwError(`property ${JSON.stringify(name)}`, value.error);\n        }\n        return value;\n    }\n    /**\n     *  Creates a new [[Result]] for %%items%% with each entry\n     *  also accessible by its corresponding name in %%keys%%.\n     */\n    static fromItems(items, keys) {\n        return new Result(_guard, items, keys);\n    }\n}\n/**\n *  Returns all errors found in a [[Result]].\n *\n *  Since certain errors encountered when creating a [[Result]] do\n *  not impact the ability to continue parsing data, they are\n *  deferred until they are actually accessed. Hence a faulty string\n *  in an Event that is never used does not impact the program flow.\n *\n *  However, sometimes it may be useful to access, identify or\n *  validate correctness of a [[Result]].\n *\n *  @_docloc api/abi\n */\nexport function checkResultErrors(result) {\n    // Find the first error (if any)\n    const errors = [];\n    const checkErrors = function (path, object) {\n        if (!Array.isArray(object)) {\n            return;\n        }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n            try {\n                checkErrors(childPath, object[key]);\n            }\n            catch (error) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    };\n    checkErrors([], result);\n    return errors;\n}\nfunction getValue(value) {\n    let bytes = toBeArray(value);\n    assert(bytes.length <= WordSize, \"value out-of-bounds\", \"BUFFER_OVERRUN\", { buffer: bytes, length: WordSize, offset: bytes.length });\n    if (bytes.length !== WordSize) {\n        bytes = getBytesCopy(concat([Padding.slice(bytes.length % WordSize), bytes]));\n    }\n    return bytes;\n}\n/**\n *  @_ignore\n */\nexport class Coder {\n    // The coder name:\n    //   - address, uint256, tuple, array, etc.\n    name;\n    // The fully expanded type, including composite types:\n    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n    type;\n    // The localName bound in the signature, in this example it is \"baz\":\n    //   - tuple(address foo, uint bar) baz\n    localName;\n    // Whether this type is dynamic:\n    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n    dynamic;\n    constructor(name, type, localName, dynamic) {\n        defineProperties(this, { name, type, localName, dynamic }, {\n            name: \"string\", type: \"string\", localName: \"string\", dynamic: \"boolean\"\n        });\n    }\n    _throwError(message, value) {\n        assertArgument(false, message, this.localName, value);\n    }\n}\n/**\n *  @_ignore\n */\nexport class Writer {\n    // An array of WordSize lengthed objects to concatenation\n    #data;\n    #dataLength;\n    constructor() {\n        this.#data = [];\n        this.#dataLength = 0;\n    }\n    get data() {\n        return concat(this.#data);\n    }\n    get length() { return this.#dataLength; }\n    #writeData(data) {\n        this.#data.push(data);\n        this.#dataLength += data.length;\n        return data.length;\n    }\n    appendWriter(writer) {\n        return this.#writeData(getBytesCopy(writer.data));\n    }\n    // Arrayish item; pad on the right to *nearest* WordSize\n    writeBytes(value) {\n        let bytes = getBytesCopy(value);\n        const paddingOffset = bytes.length % WordSize;\n        if (paddingOffset) {\n            bytes = getBytesCopy(concat([bytes, Padding.slice(paddingOffset)]));\n        }\n        return this.#writeData(bytes);\n    }\n    // Numeric item; pad on the left *to* WordSize\n    writeValue(value) {\n        return this.#writeData(getValue(value));\n    }\n    // Inserts a numeric place-holder, returning a callback that can\n    // be used to asjust the value later\n    writeUpdatableValue() {\n        const offset = this.#data.length;\n        this.#data.push(Padding);\n        this.#dataLength += WordSize;\n        return (value) => {\n            this.#data[offset] = getValue(value);\n        };\n    }\n}\n/**\n *  @_ignore\n */\nexport class Reader {\n    // Allows incomplete unpadded data to be read; otherwise an error\n    // is raised if attempting to overrun the buffer. This is required\n    // to deal with an old Solidity bug, in which event data for\n    // external (not public thoguh) was tightly packed.\n    allowLoose;\n    #data;\n    #offset;\n    #bytesRead;\n    #parent;\n    #maxInflation;\n    constructor(data, allowLoose, maxInflation) {\n        defineProperties(this, { allowLoose: !!allowLoose });\n        this.#data = getBytesCopy(data);\n        this.#bytesRead = 0;\n        this.#parent = null;\n        this.#maxInflation = (maxInflation != null) ? maxInflation : 1024;\n        this.#offset = 0;\n    }\n    get data() { return hexlify(this.#data); }\n    get dataLength() { return this.#data.length; }\n    get consumed() { return this.#offset; }\n    get bytes() { return new Uint8Array(this.#data); }\n    #incrementBytesRead(count) {\n        if (this.#parent) {\n            return this.#parent.#incrementBytesRead(count);\n        }\n        this.#bytesRead += count;\n        // Check for excessive inflation (see: #4537)\n        assert(this.#maxInflation < 1 || this.#bytesRead <= this.#maxInflation * this.dataLength, `compressed ABI data exceeds inflation ratio of ${this.#maxInflation} ( see: https:/\\/github.com/ethers-io/ethers.js/issues/4537 )`, \"BUFFER_OVERRUN\", {\n            buffer: getBytesCopy(this.#data), offset: this.#offset,\n            length: count, info: {\n                bytesRead: this.#bytesRead,\n                dataLength: this.dataLength\n            }\n        });\n    }\n    #peekBytes(offset, length, loose) {\n        let alignedLength = Math.ceil(length / WordSize) * WordSize;\n        if (this.#offset + alignedLength > this.#data.length) {\n            if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {\n                alignedLength = length;\n            }\n            else {\n                assert(false, \"data out-of-bounds\", \"BUFFER_OVERRUN\", {\n                    buffer: getBytesCopy(this.#data),\n                    length: this.#data.length,\n                    offset: this.#offset + alignedLength\n                });\n            }\n        }\n        return this.#data.slice(this.#offset, this.#offset + alignedLength);\n    }\n    // Create a sub-reader with the same underlying data, but offset\n    subReader(offset) {\n        const reader = new Reader(this.#data.slice(this.#offset + offset), this.allowLoose, this.#maxInflation);\n        reader.#parent = this;\n        return reader;\n    }\n    // Read bytes\n    readBytes(length, loose) {\n        let bytes = this.#peekBytes(0, length, !!loose);\n        this.#incrementBytesRead(length);\n        this.#offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n    // Read a numeric values\n    readValue() {\n        return toBigInt(this.readBytes(WordSize));\n    }\n    readIndex() {\n        return toNumber(this.readBytes(WordSize));\n    }\n}\n//# sourceMappingURL=abstract-coder.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}