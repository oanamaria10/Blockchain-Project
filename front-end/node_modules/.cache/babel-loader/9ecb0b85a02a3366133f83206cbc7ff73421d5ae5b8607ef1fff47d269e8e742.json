{"ast":null,"code":"var Utils = require(\"./util\");\nvar fs = Utils.FileSystem.require(),\n  pth = require(\"path\");\nfs.existsSync = fs.existsSync || pth.existsSync;\nvar ZipEntry = require(\"./zipEntry\"),\n  ZipFile = require(\"./zipFile\");\nvar isWin = /^win/.test(process.platform);\nmodule.exports = function ( /**String*/input) {\n  var _zip = undefined,\n    _filename = \"\";\n  if (input && typeof input === \"string\") {\n    // load zip file\n    if (fs.existsSync(input)) {\n      _filename = input;\n      _zip = new ZipFile(input, Utils.Constants.FILE);\n    } else {\n      throw new Error(Utils.Errors.INVALID_FILENAME);\n    }\n  } else if (input && Buffer.isBuffer(input)) {\n    // load buffer\n    _zip = new ZipFile(input, Utils.Constants.BUFFER);\n  } else {\n    // create new zip file\n    _zip = new ZipFile(null, Utils.Constants.NONE);\n  }\n  function sanitize(prefix, name) {\n    prefix = pth.resolve(pth.normalize(prefix));\n    var parts = name.split('/');\n    for (var i = 0, l = parts.length; i < l; i++) {\n      var path = pth.normalize(pth.join(prefix, parts.slice(i, l).join(pth.sep)));\n      if (path.indexOf(prefix) === 0) {\n        return path;\n      }\n    }\n    return pth.normalize(pth.join(prefix, pth.basename(name)));\n  }\n  function getEntry( /**Object*/entry) {\n    if (entry && _zip) {\n      var item;\n      // If entry was given as a file name\n      if (typeof entry === \"string\") item = _zip.getEntry(entry);\n      // if entry was given as a ZipEntry object\n      if (typeof entry === \"object\" && typeof entry.entryName !== \"undefined\" && typeof entry.header !== \"undefined\") item = _zip.getEntry(entry.entryName);\n      if (item) {\n        return item;\n      }\n    }\n    return null;\n  }\n  return {\n    /**\r\n     * Extracts the given entry from the archive and returns the content as a Buffer object\r\n     * @param entry ZipEntry object or String with the full path of the entry\r\n     *\r\n     * @return Buffer or Null in case of error\r\n     */\n    readFile: function ( /**Object*/entry) {\n      var item = getEntry(entry);\n      return item && item.getData() || null;\n    },\n    /**\r\n     * Asynchronous readFile\r\n     * @param entry ZipEntry object or String with the full path of the entry\r\n     * @param callback\r\n     *\r\n     * @return Buffer or Null in case of error\r\n     */\n    readFileAsync: function ( /**Object*/entry, /**Function*/callback) {\n      var item = getEntry(entry);\n      if (item) {\n        item.getDataAsync(callback);\n      } else {\n        callback(null, \"getEntry failed for:\" + entry);\n      }\n    },\n    /**\r\n     * Extracts the given entry from the archive and returns the content as plain text in the given encoding\r\n     * @param entry ZipEntry object or String with the full path of the entry\r\n     * @param encoding Optional. If no encoding is specified utf8 is used\r\n     *\r\n     * @return String\r\n     */\n    readAsText: function ( /**Object*/entry, /**String=*/encoding) {\n      var item = getEntry(entry);\n      if (item) {\n        var data = item.getData();\n        if (data && data.length) {\n          return data.toString(encoding || \"utf8\");\n        }\n      }\n      return \"\";\n    },\n    /**\r\n     * Asynchronous readAsText\r\n     * @param entry ZipEntry object or String with the full path of the entry\r\n     * @param callback\r\n     * @param encoding Optional. If no encoding is specified utf8 is used\r\n     *\r\n     * @return String\r\n     */\n    readAsTextAsync: function ( /**Object*/entry, /**Function*/callback, /**String=*/encoding) {\n      var item = getEntry(entry);\n      if (item) {\n        item.getDataAsync(function (data, err) {\n          if (err) {\n            callback(data, err);\n            return;\n          }\n          if (data && data.length) {\n            callback(data.toString(encoding || \"utf8\"));\n          } else {\n            callback(\"\");\n          }\n        });\n      } else {\n        callback(\"\");\n      }\n    },\n    /**\r\n     * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory\r\n     *\r\n     * @param entry\r\n     */\n    deleteFile: function ( /**Object*/entry) {\n      // @TODO: test deleteFile\n      var item = getEntry(entry);\n      if (item) {\n        _zip.deleteEntry(item.entryName);\n      }\n    },\n    /**\r\n     * Adds a comment to the zip. The zip must be rewritten after adding the comment.\r\n     *\r\n     * @param comment\r\n     */\n    addZipComment: function ( /**String*/comment) {\n      // @TODO: test addZipComment\n      _zip.comment = comment;\n    },\n    /**\r\n     * Returns the zip comment\r\n     *\r\n     * @return String\r\n     */\n    getZipComment: function () {\n      return _zip.comment || '';\n    },\n    /**\r\n     * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment\r\n     * The comment cannot exceed 65535 characters in length\r\n     *\r\n     * @param entry\r\n     * @param comment\r\n     */\n    addZipEntryComment: function ( /**Object*/entry, /**String*/comment) {\n      var item = getEntry(entry);\n      if (item) {\n        item.comment = comment;\n      }\n    },\n    /**\r\n     * Returns the comment of the specified entry\r\n     *\r\n     * @param entry\r\n     * @return String\r\n     */\n    getZipEntryComment: function ( /**Object*/entry) {\n      var item = getEntry(entry);\n      if (item) {\n        return item.comment || '';\n      }\n      return '';\n    },\n    /**\r\n     * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content\r\n     *\r\n     * @param entry\r\n     * @param content\r\n     */\n    updateFile: function ( /**Object*/entry, /**Buffer*/content) {\n      var item = getEntry(entry);\n      if (item) {\n        item.setData(content);\n      }\n    },\n    /**\r\n     * Adds a file from the disk to the archive\r\n     *\r\n     * @param localPath File to add to zip\r\n     * @param zipPath Optional path inside the zip\r\n     * @param zipName Optional name for the file\r\n     */\n    addLocalFile: function ( /**String*/localPath, /**String=*/zipPath, /**String=*/zipName) {\n      if (fs.existsSync(localPath)) {\n        if (zipPath) {\n          zipPath = zipPath.split(\"\\\\\").join(\"/\");\n          if (zipPath.charAt(zipPath.length - 1) !== \"/\") {\n            zipPath += \"/\";\n          }\n        } else {\n          zipPath = \"\";\n        }\n        var p = localPath.split(\"\\\\\").join(\"/\").split(\"/\").pop();\n        if (zipName) {\n          this.addFile(zipPath + zipName, fs.readFileSync(localPath), \"\", 0);\n        } else {\n          this.addFile(zipPath + p, fs.readFileSync(localPath), \"\", 0);\n        }\n      } else {\n        throw new Error(Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath));\n      }\n    },\n    /**\r\n     * Adds a local directory and all its nested files and directories to the archive\r\n     *\r\n     * @param localPath\r\n     * @param zipPath optional path inside zip\r\n     * @param filter optional RegExp or Function if files match will\r\n     *               be included.\r\n     */\n    addLocalFolder: function ( /**String*/localPath, /**String=*/zipPath, /**=RegExp|Function*/filter) {\n      if (filter === undefined) {\n        filter = function () {\n          return true;\n        };\n      } else if (filter instanceof RegExp) {\n        filter = function (filter) {\n          return function (filename) {\n            return filter.test(filename);\n          };\n        }(filter);\n      }\n      if (zipPath) {\n        zipPath = zipPath.split(\"\\\\\").join(\"/\");\n        if (zipPath.charAt(zipPath.length - 1) !== \"/\") {\n          zipPath += \"/\";\n        }\n      } else {\n        zipPath = \"\";\n      }\n      // normalize the path first\n      localPath = pth.normalize(localPath);\n      localPath = localPath.split(\"\\\\\").join(\"/\"); //windows fix\n      if (localPath.charAt(localPath.length - 1) !== \"/\") localPath += \"/\";\n      if (fs.existsSync(localPath)) {\n        var items = Utils.findFiles(localPath),\n          self = this;\n        if (items.length) {\n          items.forEach(function (path) {\n            var p = path.split(\"\\\\\").join(\"/\").replace(new RegExp(localPath.replace(/(\\(|\\)|\\$)/g, '\\\\$1'), 'i'), \"\"); //windows fix\n            if (filter(p)) {\n              if (p.charAt(p.length - 1) !== \"/\") {\n                self.addFile(zipPath + p, fs.readFileSync(path), \"\", 0);\n              } else {\n                self.addFile(zipPath + p, Buffer.alloc(0), \"\", 0);\n              }\n            }\n          });\n        }\n      } else {\n        throw new Error(Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath));\n      }\n    },\n    /**\r\n     * Asynchronous addLocalFile\r\n     * @param localPath\r\n     * @param callback\r\n     * @param zipPath optional path inside zip\r\n     * @param filter optional RegExp or Function if files match will\r\n     *               be included.\r\n     */\n    addLocalFolderAsync: function ( /*String*/localPath, /*Function*/callback, /*String*/zipPath, /*RegExp|Function*/filter) {\n      if (filter === undefined) {\n        filter = function () {\n          return true;\n        };\n      } else if (filter instanceof RegExp) {\n        filter = function (filter) {\n          return function (filename) {\n            return filter.test(filename);\n          };\n        }(filter);\n      }\n      if (zipPath) {\n        zipPath = zipPath.split(\"\\\\\").join(\"/\");\n        if (zipPath.charAt(zipPath.length - 1) !== \"/\") {\n          zipPath += \"/\";\n        }\n      } else {\n        zipPath = \"\";\n      }\n      // normalize the path first\n      localPath = pth.normalize(localPath);\n      localPath = localPath.split(\"\\\\\").join(\"/\"); //windows fix\n      if (localPath.charAt(localPath.length - 1) !== \"/\") localPath += \"/\";\n      var self = this;\n      fs.open(localPath, 'r', function (err, fd) {\n        if (err && err.code === 'ENOENT') {\n          callback(undefined, Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath));\n        } else if (err) {\n          callback(undefined, err);\n        } else {\n          var items = Utils.findFiles(localPath);\n          var i = -1;\n          var next = function () {\n            i += 1;\n            if (i < items.length) {\n              var p = items[i].split(\"\\\\\").join(\"/\").replace(new RegExp(localPath.replace(/(\\(|\\))/g, '\\\\$1'), 'i'), \"\"); //windows fix\n              p = p.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').replace(/[^\\x20-\\x7E]/g, ''); // accent fix\n              if (filter(p)) {\n                if (p.charAt(p.length - 1) !== \"/\") {\n                  fs.readFile(items[i], function (err, data) {\n                    if (err) {\n                      callback(undefined, err);\n                    } else {\n                      self.addFile(zipPath + p, data, '', 0);\n                      next();\n                    }\n                  });\n                } else {\n                  self.addFile(zipPath + p, Buffer.alloc(0), \"\", 0);\n                  next();\n                }\n              } else {\n                next();\n              }\n            } else {\n              callback(true, undefined);\n            }\n          };\n          next();\n        }\n      });\n    },\n    /**\r\n     * Allows you to create a entry (file or directory) in the zip file.\r\n     * If you want to create a directory the entryName must end in / and a null buffer should be provided.\r\n     * Comment and attributes are optional\r\n     *\r\n     * @param entryName\r\n     * @param content\r\n     * @param comment\r\n     * @param attr\r\n     */\n    addFile: function ( /**String*/entryName, /**Buffer*/content, /**String*/comment, /**Number*/attr) {\n      var entry = new ZipEntry();\n      entry.entryName = entryName;\n      entry.comment = comment || \"\";\n      if (!attr) {\n        if (entry.isDirectory) {\n          attr = 0o40755 << 16 | 0x10; // (permissions drwxr-xr-x) + (MS-DOS directory flag)\n        } else {\n          attr = 0o644 << 16; // permissions -r-wr--r--\n        }\n      }\n      entry.attr = attr;\n      entry.setData(content);\n      _zip.setEntry(entry);\n    },\n    /**\r\n     * Returns an array of ZipEntry objects representing the files and folders inside the archive\r\n     *\r\n     * @return Array\r\n     */\n    getEntries: function () {\n      if (_zip) {\n        return _zip.entries;\n      } else {\n        return [];\n      }\n    },\n    /**\r\n     * Returns a ZipEntry object representing the file or folder specified by ``name``.\r\n     *\r\n     * @param name\r\n     * @return ZipEntry\r\n     */\n    getEntry: function ( /**String*/name) {\n      return getEntry(name);\n    },\n    getEntryCount: function () {\n      return _zip.getEntryCount();\n    },\n    forEach: function (callback) {\n      return _zip.forEach(callback);\n    },\n    /**\r\n     * Extracts the given entry to the given targetPath\r\n     * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted\r\n     *\r\n     * @param entry ZipEntry object or String with the full path of the entry\r\n     * @param targetPath Target folder where to write the file\r\n     * @param maintainEntryPath If maintainEntryPath is true and the entry is inside a folder, the entry folder\r\n     *                          will be created in targetPath as well. Default is TRUE\r\n     * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\r\n     *                  Default is FALSE\r\n     *\r\n     * @return Boolean\r\n     */\n    extractEntryTo: function ( /**Object*/entry, /**String*/targetPath, /**Boolean*/maintainEntryPath, /**Boolean*/overwrite) {\n      overwrite = overwrite || false;\n      maintainEntryPath = typeof maintainEntryPath === \"undefined\" ? true : maintainEntryPath;\n      var item = getEntry(entry);\n      if (!item) {\n        throw new Error(Utils.Errors.NO_ENTRY);\n      }\n      var entryName = item.entryName;\n      var target = sanitize(targetPath, maintainEntryPath ? entryName : pth.basename(entryName));\n      if (item.isDirectory) {\n        target = pth.resolve(target, \"..\");\n        var children = _zip.getEntryChildren(item);\n        children.forEach(function (child) {\n          if (child.isDirectory) return;\n          var content = child.getData();\n          if (!content) {\n            throw new Error(Utils.Errors.CANT_EXTRACT_FILE);\n          }\n          var childName = sanitize(targetPath, maintainEntryPath ? child.entryName : pth.basename(child.entryName));\n          Utils.writeFileTo(childName, content, overwrite);\n        });\n        return true;\n      }\n      var content = item.getData();\n      if (!content) throw new Error(Utils.Errors.CANT_EXTRACT_FILE);\n      if (fs.existsSync(target) && !overwrite) {\n        throw new Error(Utils.Errors.CANT_OVERRIDE);\n      }\n      Utils.writeFileTo(target, content, overwrite);\n      return true;\n    },\n    /**\r\n     * Test the archive\r\n     *\r\n     */\n    test: function () {\n      if (!_zip) {\n        return false;\n      }\n      for (var entry in _zip.entries) {\n        try {\n          if (entry.isDirectory) {\n            continue;\n          }\n          var content = _zip.entries[entry].getData();\n          if (!content) {\n            return false;\n          }\n        } catch (err) {\n          return false;\n        }\n      }\n      return true;\n    },\n    /**\r\n     * Extracts the entire archive to the given location\r\n     *\r\n     * @param targetPath Target location\r\n     * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\r\n     *                  Default is FALSE\r\n     */\n    extractAllTo: function ( /**String*/targetPath, /**Boolean*/overwrite) {\n      overwrite = overwrite || false;\n      if (!_zip) {\n        throw new Error(Utils.Errors.NO_ZIP);\n      }\n      _zip.entries.forEach(function (entry) {\n        var entryName = sanitize(targetPath, entry.entryName.toString());\n        if (entry.isDirectory) {\n          Utils.makeDir(entryName);\n          return;\n        }\n        var content = entry.getData();\n        if (!content) {\n          throw new Error(Utils.Errors.CANT_EXTRACT_FILE);\n        }\n        Utils.writeFileTo(entryName, content, overwrite);\n        try {\n          fs.utimesSync(entryName, entry.header.time, entry.header.time);\n        } catch (err) {\n          throw new Error(Utils.Errors.CANT_EXTRACT_FILE);\n        }\n      });\n    },\n    /**\r\n     * Asynchronous extractAllTo\r\n     *\r\n     * @param targetPath Target location\r\n     * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\r\n     *                  Default is FALSE\r\n     * @param callback\r\n     */\n    extractAllToAsync: function ( /**String*/targetPath, /**Boolean*/overwrite, /**Function*/callback) {\n      if (!callback) {\n        callback = function () {};\n      }\n      overwrite = overwrite || false;\n      if (!_zip) {\n        callback(new Error(Utils.Errors.NO_ZIP));\n        return;\n      }\n      var entries = _zip.entries;\n      var i = entries.length;\n      entries.forEach(function (entry) {\n        if (i <= 0) return; // Had an error already\n\n        var entryName = pth.normalize(entry.entryName.toString());\n        if (entry.isDirectory) {\n          Utils.makeDir(sanitize(targetPath, entryName));\n          if (--i === 0) callback(undefined);\n          return;\n        }\n        entry.getDataAsync(function (content, err) {\n          if (i <= 0) return;\n          if (err) {\n            callback(new Error(err));\n            return;\n          }\n          if (!content) {\n            i = 0;\n            callback(new Error(Utils.Errors.CANT_EXTRACT_FILE));\n            return;\n          }\n          Utils.writeFileToAsync(sanitize(targetPath, entryName), content, overwrite, function (succ) {\n            try {\n              fs.utimesSync(pth.resolve(targetPath, entryName), entry.header.time, entry.header.time);\n            } catch (err) {\n              callback(new Error('Unable to set utimes'));\n            }\n            if (i <= 0) return;\n            if (!succ) {\n              i = 0;\n              callback(new Error('Unable to write'));\n              return;\n            }\n            if (--i === 0) callback(undefined);\n          });\n        });\n      });\n    },\n    /**\r\n     * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip\r\n     *\r\n     * @param targetFileName\r\n     * @param callback\r\n     */\n    writeZip: function ( /**String*/targetFileName, /**Function*/callback) {\n      if (arguments.length === 1) {\n        if (typeof targetFileName === \"function\") {\n          callback = targetFileName;\n          targetFileName = \"\";\n        }\n      }\n      if (!targetFileName && _filename) {\n        targetFileName = _filename;\n      }\n      if (!targetFileName) return;\n      var zipData = _zip.compressToBuffer();\n      if (zipData) {\n        var ok = Utils.writeFileTo(targetFileName, zipData, true);\n        if (typeof callback === 'function') callback(!ok ? new Error(\"failed\") : null, \"\");\n      }\n    },\n    /**\r\n     * Returns the content of the entire zip file as a Buffer object\r\n     *\r\n     * @return Buffer\r\n     */\n    toBuffer: function ( /**Function=*/onSuccess, /**Function=*/onFail, /**Function=*/onItemStart, /**Function=*/onItemEnd) {\n      this.valueOf = 2;\n      if (typeof onSuccess === \"function\") {\n        _zip.toAsyncBuffer(onSuccess, onFail, onItemStart, onItemEnd);\n        return null;\n      }\n      return _zip.compressToBuffer();\n    }\n  };\n};","map":{"version":3,"names":["Utils","require","fs","FileSystem","pth","existsSync","ZipEntry","ZipFile","isWin","test","process","platform","module","exports","input","_zip","undefined","_filename","Constants","FILE","Error","Errors","INVALID_FILENAME","Buffer","isBuffer","BUFFER","NONE","sanitize","prefix","name","resolve","normalize","parts","split","i","l","length","path","join","slice","sep","indexOf","basename","getEntry","entry","item","entryName","header","readFile","getData","readFileAsync","callback","getDataAsync","readAsText","encoding","data","toString","readAsTextAsync","err","deleteFile","deleteEntry","addZipComment","comment","getZipComment","addZipEntryComment","getZipEntryComment","updateFile","content","setData","addLocalFile","localPath","zipPath","zipName","charAt","p","pop","addFile","readFileSync","FILE_NOT_FOUND","replace","addLocalFolder","filter","RegExp","filename","items","findFiles","self","forEach","alloc","addLocalFolderAsync","open","fd","code","next","attr","isDirectory","setEntry","getEntries","entries","getEntryCount","extractEntryTo","targetPath","maintainEntryPath","overwrite","NO_ENTRY","target","children","getEntryChildren","child","CANT_EXTRACT_FILE","childName","writeFileTo","CANT_OVERRIDE","extractAllTo","NO_ZIP","makeDir","utimesSync","time","extractAllToAsync","writeFileToAsync","succ","writeZip","targetFileName","arguments","zipData","compressToBuffer","ok","toBuffer","onSuccess","onFail","onItemStart","onItemEnd","valueOf","toAsyncBuffer"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/adm-zip/adm-zip.js"],"sourcesContent":["var Utils = require(\"./util\");\r\nvar fs = Utils.FileSystem.require(),\r\n\tpth = require(\"path\");\r\n\r\nfs.existsSync = fs.existsSync || pth.existsSync;\r\n\r\nvar ZipEntry = require(\"./zipEntry\"),\r\n\tZipFile = require(\"./zipFile\");\r\n\r\nvar isWin = /^win/.test(process.platform);\r\n\r\n\r\nmodule.exports = function (/**String*/input) {\r\n\tvar _zip = undefined,\r\n\t\t_filename = \"\";\r\n\r\n\tif (input && typeof input === \"string\") { // load zip file\r\n\t\tif (fs.existsSync(input)) {\r\n\t\t\t_filename = input;\r\n\t\t\t_zip = new ZipFile(input, Utils.Constants.FILE);\r\n\t\t} else {\r\n\t\t\tthrow new Error(Utils.Errors.INVALID_FILENAME);\r\n\t\t}\r\n\t} else if (input && Buffer.isBuffer(input)) { // load buffer\r\n\t\t_zip = new ZipFile(input, Utils.Constants.BUFFER);\r\n\t} else { // create new zip file\r\n\t\t_zip = new ZipFile(null, Utils.Constants.NONE);\r\n\t}\r\n\r\n\tfunction sanitize(prefix, name) {\r\n\t\tprefix = pth.resolve(pth.normalize(prefix));\r\n\t\tvar parts = name.split('/');\r\n\t\tfor (var i = 0, l = parts.length; i < l; i++) {\r\n\t\t\tvar path = pth.normalize(pth.join(prefix, parts.slice(i, l).join(pth.sep)));\r\n\t\t\tif (path.indexOf(prefix) === 0) {\r\n\t\t\t\treturn path;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn pth.normalize(pth.join(prefix, pth.basename(name)));\r\n\t}\r\n\r\n\tfunction getEntry(/**Object*/entry) {\r\n\t\tif (entry && _zip) {\r\n\t\t\tvar item;\r\n\t\t\t// If entry was given as a file name\r\n\t\t\tif (typeof entry === \"string\")\r\n\t\t\t\titem = _zip.getEntry(entry);\r\n\t\t\t// if entry was given as a ZipEntry object\r\n\t\t\tif (typeof entry === \"object\" && typeof entry.entryName !== \"undefined\" && typeof entry.header !== \"undefined\")\r\n\t\t\t\titem = _zip.getEntry(entry.entryName);\r\n\r\n\t\t\tif (item) {\r\n\t\t\t\treturn item;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * Extracts the given entry from the archive and returns the content as a Buffer object\r\n\t\t * @param entry ZipEntry object or String with the full path of the entry\r\n\t\t *\r\n\t\t * @return Buffer or Null in case of error\r\n\t\t */\r\n\t\treadFile: function (/**Object*/entry) {\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\treturn item && item.getData() || null;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Asynchronous readFile\r\n\t\t * @param entry ZipEntry object or String with the full path of the entry\r\n\t\t * @param callback\r\n\t\t *\r\n\t\t * @return Buffer or Null in case of error\r\n\t\t */\r\n\t\treadFileAsync: function (/**Object*/entry, /**Function*/callback) {\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (item) {\r\n\t\t\t\titem.getDataAsync(callback);\r\n\t\t\t} else {\r\n\t\t\t\tcallback(null, \"getEntry failed for:\" + entry)\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Extracts the given entry from the archive and returns the content as plain text in the given encoding\r\n\t\t * @param entry ZipEntry object or String with the full path of the entry\r\n\t\t * @param encoding Optional. If no encoding is specified utf8 is used\r\n\t\t *\r\n\t\t * @return String\r\n\t\t */\r\n\t\treadAsText: function (/**Object*/entry, /**String=*/encoding) {\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (item) {\r\n\t\t\t\tvar data = item.getData();\r\n\t\t\t\tif (data && data.length) {\r\n\t\t\t\t\treturn data.toString(encoding || \"utf8\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn \"\";\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Asynchronous readAsText\r\n\t\t * @param entry ZipEntry object or String with the full path of the entry\r\n\t\t * @param callback\r\n\t\t * @param encoding Optional. If no encoding is specified utf8 is used\r\n\t\t *\r\n\t\t * @return String\r\n\t\t */\r\n\t\treadAsTextAsync: function (/**Object*/entry, /**Function*/callback, /**String=*/encoding) {\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (item) {\r\n\t\t\t\titem.getDataAsync(function (data, err) {\r\n\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\tcallback(data, err);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (data && data.length) {\r\n\t\t\t\t\t\tcallback(data.toString(encoding || \"utf8\"));\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcallback(\"\");\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\tcallback(\"\");\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory\r\n\t\t *\r\n\t\t * @param entry\r\n\t\t */\r\n\t\tdeleteFile: function (/**Object*/entry) { // @TODO: test deleteFile\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (item) {\r\n\t\t\t\t_zip.deleteEntry(item.entryName);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds a comment to the zip. The zip must be rewritten after adding the comment.\r\n\t\t *\r\n\t\t * @param comment\r\n\t\t */\r\n\t\taddZipComment: function (/**String*/comment) { // @TODO: test addZipComment\r\n\t\t\t_zip.comment = comment;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the zip comment\r\n\t\t *\r\n\t\t * @return String\r\n\t\t */\r\n\t\tgetZipComment: function () {\r\n\t\t\treturn _zip.comment || '';\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment\r\n\t\t * The comment cannot exceed 65535 characters in length\r\n\t\t *\r\n\t\t * @param entry\r\n\t\t * @param comment\r\n\t\t */\r\n\t\taddZipEntryComment: function (/**Object*/entry, /**String*/comment) {\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (item) {\r\n\t\t\t\titem.comment = comment;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the comment of the specified entry\r\n\t\t *\r\n\t\t * @param entry\r\n\t\t * @return String\r\n\t\t */\r\n\t\tgetZipEntryComment: function (/**Object*/entry) {\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (item) {\r\n\t\t\t\treturn item.comment || '';\r\n\t\t\t}\r\n\t\t\treturn ''\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content\r\n\t\t *\r\n\t\t * @param entry\r\n\t\t * @param content\r\n\t\t */\r\n\t\tupdateFile: function (/**Object*/entry, /**Buffer*/content) {\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (item) {\r\n\t\t\t\titem.setData(content);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds a file from the disk to the archive\r\n\t\t *\r\n\t\t * @param localPath File to add to zip\r\n\t\t * @param zipPath Optional path inside the zip\r\n\t\t * @param zipName Optional name for the file\r\n\t\t */\r\n\t\taddLocalFile: function (/**String*/localPath, /**String=*/zipPath, /**String=*/zipName) {\r\n\t\t\tif (fs.existsSync(localPath)) {\r\n\t\t\t\tif (zipPath) {\r\n\t\t\t\t\tzipPath = zipPath.split(\"\\\\\").join(\"/\");\r\n\t\t\t\t\tif (zipPath.charAt(zipPath.length - 1) !== \"/\") {\r\n\t\t\t\t\t\tzipPath += \"/\";\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tzipPath = \"\";\r\n\t\t\t\t}\r\n\t\t\t\tvar p = localPath.split(\"\\\\\").join(\"/\").split(\"/\").pop();\r\n\r\n\t\t\t\tif (zipName) {\r\n\t\t\t\t\tthis.addFile(zipPath + zipName, fs.readFileSync(localPath), \"\", 0)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.addFile(zipPath + p, fs.readFileSync(localPath), \"\", 0)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error(Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath));\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds a local directory and all its nested files and directories to the archive\r\n\t\t *\r\n\t\t * @param localPath\r\n\t\t * @param zipPath optional path inside zip\r\n\t\t * @param filter optional RegExp or Function if files match will\r\n\t\t *               be included.\r\n\t\t */\r\n\t\taddLocalFolder: function (/**String*/localPath, /**String=*/zipPath, /**=RegExp|Function*/filter) {\r\n\t\t\tif (filter === undefined) {\r\n\t\t\t\tfilter = function () {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t};\r\n\t\t\t} else if (filter instanceof RegExp) {\r\n\t\t\t\tfilter = function (filter) {\r\n\t\t\t\t\treturn function (filename) {\r\n\t\t\t\t\t\treturn filter.test(filename);\r\n\t\t\t\t\t}\r\n\t\t\t\t}(filter);\r\n\t\t\t}\r\n\r\n\t\t\tif (zipPath) {\r\n\t\t\t\tzipPath = zipPath.split(\"\\\\\").join(\"/\");\r\n\t\t\t\tif (zipPath.charAt(zipPath.length - 1) !== \"/\") {\r\n\t\t\t\t\tzipPath += \"/\";\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tzipPath = \"\";\r\n\t\t\t}\r\n\t\t\t// normalize the path first\r\n\t\t\tlocalPath = pth.normalize(localPath);\r\n\t\t\tlocalPath = localPath.split(\"\\\\\").join(\"/\"); //windows fix\r\n\t\t\tif (localPath.charAt(localPath.length - 1) !== \"/\")\r\n\t\t\t\tlocalPath += \"/\";\r\n\r\n\t\t\tif (fs.existsSync(localPath)) {\r\n\r\n\t\t\t\tvar items = Utils.findFiles(localPath),\r\n\t\t\t\t\tself = this;\r\n\r\n\t\t\t\tif (items.length) {\r\n\t\t\t\t\titems.forEach(function (path) {\r\n\t\t\t\t\t\tvar p = path.split(\"\\\\\").join(\"/\").replace(new RegExp(localPath.replace(/(\\(|\\)|\\$)/g, '\\\\$1'), 'i'), \"\"); //windows fix\r\n\t\t\t\t\t\tif (filter(p)) {\r\n\t\t\t\t\t\t\tif (p.charAt(p.length - 1) !== \"/\") {\r\n\t\t\t\t\t\t\t\tself.addFile(zipPath + p, fs.readFileSync(path), \"\", 0)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tself.addFile(zipPath + p, Buffer.alloc(0), \"\", 0)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error(Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath));\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Asynchronous addLocalFile\r\n\t\t * @param localPath\r\n\t\t * @param callback\r\n\t\t * @param zipPath optional path inside zip\r\n\t\t * @param filter optional RegExp or Function if files match will\r\n\t\t *               be included.\r\n\t\t */\r\n\t\taddLocalFolderAsync: function (/*String*/localPath, /*Function*/callback, /*String*/zipPath, /*RegExp|Function*/filter) {\r\n\t\t\tif (filter === undefined) {\r\n\t\t\t\tfilter = function () {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t};\r\n\t\t\t} else if (filter instanceof RegExp) {\r\n\t\t\t\tfilter = function (filter) {\r\n\t\t\t\t\treturn function (filename) {\r\n\t\t\t\t\t\treturn filter.test(filename);\r\n\t\t\t\t\t}\r\n\t\t\t\t}(filter);\r\n\t\t\t}\r\n\r\n\t\t\tif (zipPath) {\r\n\t\t\t\tzipPath = zipPath.split(\"\\\\\").join(\"/\");\r\n\t\t\t\tif (zipPath.charAt(zipPath.length - 1) !== \"/\") {\r\n\t\t\t\t\tzipPath += \"/\";\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tzipPath = \"\";\r\n\t\t\t}\r\n\t\t\t// normalize the path first\r\n\t\t\tlocalPath = pth.normalize(localPath);\r\n\t\t\tlocalPath = localPath.split(\"\\\\\").join(\"/\"); //windows fix\r\n\t\t\tif (localPath.charAt(localPath.length - 1) !== \"/\")\r\n\t\t\t\tlocalPath += \"/\";\r\n\r\n\t\t\tvar self = this;\r\n\t\t\tfs.open(localPath, 'r', function (err, fd) {\r\n\t\t\t\tif (err && err.code === 'ENOENT') {\r\n\t\t\t\t\tcallback(undefined, Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath));\r\n\t\t\t\t} else if (err) {\r\n\t\t\t\t\tcallback(undefined, err);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar items = Utils.findFiles(localPath);\r\n\t\t\t\t\tvar i = -1;\r\n\r\n\t\t\t\t\tvar next = function () {\r\n\t\t\t\t\t\ti += 1;\r\n\t\t\t\t\t\tif (i < items.length) {\r\n\t\t\t\t\t\t\tvar p = items[i].split(\"\\\\\").join(\"/\").replace(new RegExp(localPath.replace(/(\\(|\\))/g, '\\\\$1'), 'i'), \"\"); //windows fix\r\n\t\t\t\t\t\t\tp = p.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').replace(/[^\\x20-\\x7E]/g, '') // accent fix\r\n\t\t\t\t\t\t\tif (filter(p)) {\r\n\t\t\t\t\t\t\t\tif (p.charAt(p.length - 1) !== \"/\") {\r\n\t\t\t\t\t\t\t\t\tfs.readFile(items[i], function (err, data) {\r\n\t\t\t\t\t\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\t\t\t\t\t\tcallback(undefined, err);\r\n\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\tself.addFile(zipPath + p, data, '', 0);\r\n\t\t\t\t\t\t\t\t\t\t\tnext();\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tself.addFile(zipPath + p, Buffer.alloc(0), \"\", 0);\r\n\t\t\t\t\t\t\t\t\tnext();\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tnext();\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tcallback(true, undefined);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tnext();\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Allows you to create a entry (file or directory) in the zip file.\r\n\t\t * If you want to create a directory the entryName must end in / and a null buffer should be provided.\r\n\t\t * Comment and attributes are optional\r\n\t\t *\r\n\t\t * @param entryName\r\n\t\t * @param content\r\n\t\t * @param comment\r\n\t\t * @param attr\r\n\t\t */\r\n\t\taddFile: function (/**String*/entryName, /**Buffer*/content, /**String*/comment, /**Number*/attr) {\r\n\t\t\tvar entry = new ZipEntry();\r\n\t\t\tentry.entryName = entryName;\r\n\t\t\tentry.comment = comment || \"\";\r\n\r\n\t\t\tif (!attr) {\r\n\t\t\t\tif (entry.isDirectory) {\r\n\t\t\t\t\tattr = (0o40755 << 16) | 0x10; // (permissions drwxr-xr-x) + (MS-DOS directory flag)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tattr = 0o644 << 16; // permissions -r-wr--r--\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tentry.attr = attr;\r\n\r\n\t\t\tentry.setData(content);\r\n\t\t\t_zip.setEntry(entry);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns an array of ZipEntry objects representing the files and folders inside the archive\r\n\t\t *\r\n\t\t * @return Array\r\n\t\t */\r\n\t\tgetEntries: function () {\r\n\t\t\tif (_zip) {\r\n\t\t\t\treturn _zip.entries;\r\n\t\t\t} else {\r\n\t\t\t\treturn [];\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns a ZipEntry object representing the file or folder specified by ``name``.\r\n\t\t *\r\n\t\t * @param name\r\n\t\t * @return ZipEntry\r\n\t\t */\r\n\t\tgetEntry: function (/**String*/name) {\r\n\t\t\treturn getEntry(name);\r\n\t\t},\r\n\r\n\t\tgetEntryCount: function() {\r\n\t\t\treturn _zip.getEntryCount();\r\n\t\t},\r\n\r\n\t\tforEach: function(callback) {\r\n\t\t\treturn _zip.forEach(callback);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Extracts the given entry to the given targetPath\r\n\t\t * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted\r\n\t\t *\r\n\t\t * @param entry ZipEntry object or String with the full path of the entry\r\n\t\t * @param targetPath Target folder where to write the file\r\n\t\t * @param maintainEntryPath If maintainEntryPath is true and the entry is inside a folder, the entry folder\r\n\t\t *                          will be created in targetPath as well. Default is TRUE\r\n\t\t * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\r\n\t\t *                  Default is FALSE\r\n\t\t *\r\n\t\t * @return Boolean\r\n\t\t */\r\n\t\textractEntryTo: function (/**Object*/entry, /**String*/targetPath, /**Boolean*/maintainEntryPath, /**Boolean*/overwrite) {\r\n\t\t\toverwrite = overwrite || false;\r\n\t\t\tmaintainEntryPath = typeof maintainEntryPath === \"undefined\" ? true : maintainEntryPath;\r\n\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (!item) {\r\n\t\t\t\tthrow new Error(Utils.Errors.NO_ENTRY);\r\n\t\t\t}\r\n\r\n\t\t\tvar entryName = item.entryName;\r\n\r\n\t\t\tvar target = sanitize(targetPath, maintainEntryPath ? entryName : pth.basename(entryName));\r\n\r\n\t\t\tif (item.isDirectory) {\r\n\t\t\t\ttarget = pth.resolve(target, \"..\");\r\n\t\t\t\tvar children = _zip.getEntryChildren(item);\r\n\t\t\t\tchildren.forEach(function (child) {\r\n\t\t\t\t\tif (child.isDirectory) return;\r\n\t\t\t\t\tvar content = child.getData();\r\n\t\t\t\t\tif (!content) {\r\n\t\t\t\t\t\tthrow new Error(Utils.Errors.CANT_EXTRACT_FILE);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar childName = sanitize(targetPath, maintainEntryPath ? child.entryName : pth.basename(child.entryName));\r\n\r\n\t\t\t\t\tUtils.writeFileTo(childName, content, overwrite);\r\n\t\t\t\t});\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\tvar content = item.getData();\r\n\t\t\tif (!content) throw new Error(Utils.Errors.CANT_EXTRACT_FILE);\r\n\r\n\t\t\tif (fs.existsSync(target) && !overwrite) {\r\n\t\t\t\tthrow new Error(Utils.Errors.CANT_OVERRIDE);\r\n\t\t\t}\r\n\t\t\tUtils.writeFileTo(target, content, overwrite);\r\n\r\n\t\t\treturn true;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Test the archive\r\n\t\t *\r\n\t\t */\r\n\t\ttest: function () {\r\n\t\t\tif (!_zip) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tfor (var entry in _zip.entries) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (entry.isDirectory) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar content = _zip.entries[entry].getData();\r\n\t\t\t\t\tif (!content) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (err) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Extracts the entire archive to the given location\r\n\t\t *\r\n\t\t * @param targetPath Target location\r\n\t\t * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\r\n\t\t *                  Default is FALSE\r\n\t\t */\r\n\t\textractAllTo: function (/**String*/targetPath, /**Boolean*/overwrite) {\r\n\t\t\toverwrite = overwrite || false;\r\n\t\t\tif (!_zip) {\r\n\t\t\t\tthrow new Error(Utils.Errors.NO_ZIP);\r\n\t\t\t}\r\n\t\t\t_zip.entries.forEach(function (entry) {\r\n\t\t\t\tvar entryName = sanitize(targetPath, entry.entryName.toString());\r\n\t\t\t\tif (entry.isDirectory) {\r\n\t\t\t\t\tUtils.makeDir(entryName);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tvar content = entry.getData();\r\n\t\t\t\tif (!content) {\r\n\t\t\t\t\tthrow new Error(Utils.Errors.CANT_EXTRACT_FILE);\r\n\t\t\t\t}\r\n\t\t\t\tUtils.writeFileTo(entryName, content, overwrite);\r\n\t\t\t\ttry {\r\n\t\t\t\t\tfs.utimesSync(entryName, entry.header.time, entry.header.time)\r\n\t\t\t\t} catch (err) {\r\n\t\t\t\t\tthrow new Error(Utils.Errors.CANT_EXTRACT_FILE);\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Asynchronous extractAllTo\r\n\t\t *\r\n\t\t * @param targetPath Target location\r\n\t\t * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\r\n\t\t *                  Default is FALSE\r\n\t\t * @param callback\r\n\t\t */\r\n\t\textractAllToAsync: function (/**String*/targetPath, /**Boolean*/overwrite, /**Function*/callback) {\r\n\t\t\tif (!callback) {\r\n\t\t\t\tcallback = function() {}\r\n\t\t\t}\r\n\t\t\toverwrite = overwrite || false;\r\n\t\t\tif (!_zip) {\r\n\t\t\t\tcallback(new Error(Utils.Errors.NO_ZIP));\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar entries = _zip.entries;\r\n\t\t\tvar i = entries.length;\r\n\t\t\tentries.forEach(function (entry) {\r\n\t\t\t\tif (i <= 0) return; // Had an error already\r\n\r\n\t\t\t\tvar entryName = pth.normalize(entry.entryName.toString());\r\n\r\n\t\t\t\tif (entry.isDirectory) {\r\n\t\t\t\t\tUtils.makeDir(sanitize(targetPath, entryName));\r\n\t\t\t\t\tif (--i === 0)\r\n\t\t\t\t\t\tcallback(undefined);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tentry.getDataAsync(function (content, err) {\r\n\t\t\t\t\tif (i <= 0) return;\r\n\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\tcallback(new Error(err));\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!content) {\r\n\t\t\t\t\t\ti = 0;\r\n\t\t\t\t\t\tcallback(new Error(Utils.Errors.CANT_EXTRACT_FILE));\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tUtils.writeFileToAsync(sanitize(targetPath, entryName), content, overwrite, function (succ) {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tfs.utimesSync(pth.resolve(targetPath, entryName), entry.header.time, entry.header.time);\r\n\t\t\t\t\t\t} catch (err) {\r\n\t\t\t\t\t\t\tcallback(new Error('Unable to set utimes'));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (i <= 0) return;\r\n\t\t\t\t\t\tif (!succ) {\r\n\t\t\t\t\t\t\ti = 0;\r\n\t\t\t\t\t\t\tcallback(new Error('Unable to write'));\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (--i === 0)\r\n\t\t\t\t\t\t\tcallback(undefined);\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t})\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip\r\n\t\t *\r\n\t\t * @param targetFileName\r\n\t\t * @param callback\r\n\t\t */\r\n\t\twriteZip: function (/**String*/targetFileName, /**Function*/callback) {\r\n\t\t\tif (arguments.length === 1) {\r\n\t\t\t\tif (typeof targetFileName === \"function\") {\r\n\t\t\t\t\tcallback = targetFileName;\r\n\t\t\t\t\ttargetFileName = \"\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (!targetFileName && _filename) {\r\n\t\t\t\ttargetFileName = _filename;\r\n\t\t\t}\r\n\t\t\tif (!targetFileName) return;\r\n\r\n\t\t\tvar zipData = _zip.compressToBuffer();\r\n\t\t\tif (zipData) {\r\n\t\t\t\tvar ok = Utils.writeFileTo(targetFileName, zipData, true);\r\n\t\t\t\tif (typeof callback === 'function') callback(!ok ? new Error(\"failed\") : null, \"\");\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the content of the entire zip file as a Buffer object\r\n\t\t *\r\n\t\t * @return Buffer\r\n\t\t */\r\n\t\ttoBuffer: function (/**Function=*/onSuccess, /**Function=*/onFail, /**Function=*/onItemStart, /**Function=*/onItemEnd) {\r\n\t\t\tthis.valueOf = 2;\r\n\t\t\tif (typeof onSuccess === \"function\") {\r\n\t\t\t\t_zip.toAsyncBuffer(onSuccess, onFail, onItemStart, onItemEnd);\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\treturn _zip.compressToBuffer()\r\n\t\t}\r\n\t}\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}