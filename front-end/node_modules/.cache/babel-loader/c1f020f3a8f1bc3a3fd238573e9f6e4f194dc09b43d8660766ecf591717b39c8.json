{"ast":null,"code":"import { getAddress, resolveAddress } from \"../address/index.js\";\nimport { hashMessage, TypedDataEncoder } from \"../hash/index.js\";\nimport { AbstractSigner, copyRequest } from \"../providers/index.js\";\nimport { computeAddress, Transaction } from \"../transaction/index.js\";\nimport { defineProperties, resolveProperties, assert, assertArgument } from \"../utils/index.js\";\n/**\n *  The **BaseWallet** is a stream-lined implementation of a\n *  [[Signer]] that operates with a private key.\n *\n *  It is preferred to use the [[Wallet]] class, as it offers\n *  additional functionality and simplifies loading a variety\n *  of JSON formats, Mnemonic Phrases, etc.\n *\n *  This class may be of use for those attempting to implement\n *  a minimal Signer.\n */\nexport class BaseWallet extends AbstractSigner {\n  /**\n   *  The wallet address.\n   */\n  address;\n  #signingKey;\n  /**\n   *  Creates a new BaseWallet for %%privateKey%%, optionally\n   *  connected to %%provider%%.\n   *\n   *  If %%provider%% is not specified, only offline methods can\n   *  be used.\n   */\n  constructor(privateKey, provider) {\n    super(provider);\n    assertArgument(privateKey && typeof privateKey.sign === \"function\", \"invalid private key\", \"privateKey\", \"[ REDACTED ]\");\n    this.#signingKey = privateKey;\n    const address = computeAddress(this.signingKey.publicKey);\n    defineProperties(this, {\n      address\n    });\n  }\n  // Store private values behind getters to reduce visibility\n  // in console.log\n  /**\n   *  The [[SigningKey]] used for signing payloads.\n   */\n  get signingKey() {\n    return this.#signingKey;\n  }\n  /**\n   *  The private key for this wallet.\n   */\n  get privateKey() {\n    return this.signingKey.privateKey;\n  }\n  async getAddress() {\n    return this.address;\n  }\n  connect(provider) {\n    return new BaseWallet(this.#signingKey, provider);\n  }\n  async signTransaction(tx) {\n    tx = copyRequest(tx);\n    // Replace any Addressable or ENS name with an address\n    const {\n      to,\n      from\n    } = await resolveProperties({\n      to: tx.to ? resolveAddress(tx.to, this.provider) : undefined,\n      from: tx.from ? resolveAddress(tx.from, this.provider) : undefined\n    });\n    if (to != null) {\n      tx.to = to;\n    }\n    if (from != null) {\n      tx.from = from;\n    }\n    if (tx.from != null) {\n      assertArgument(getAddress(tx.from) === this.address, \"transaction from address mismatch\", \"tx.from\", tx.from);\n      delete tx.from;\n    }\n    // Build the transaction\n    const btx = Transaction.from(tx);\n    btx.signature = this.signingKey.sign(btx.unsignedHash);\n    return btx.serialized;\n  }\n  async signMessage(message) {\n    return this.signMessageSync(message);\n  }\n  // @TODO: Add a secialized signTx and signTyped sync that enforces\n  // all parameters are known?\n  /**\n   *  Returns the signature for %%message%% signed with this wallet.\n   */\n  signMessageSync(message) {\n    return this.signingKey.sign(hashMessage(message)).serialized;\n  }\n  async signTypedData(domain, types, value) {\n    // Populate any ENS names\n    const populated = await TypedDataEncoder.resolveNames(domain, types, value, async name => {\n      // @TODO: this should use resolveName; addresses don't\n      //        need a provider\n      assert(this.provider != null, \"cannot resolve ENS names without a provider\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"resolveName\",\n        info: {\n          name\n        }\n      });\n      const address = await this.provider.resolveName(name);\n      assert(address != null, \"unconfigured ENS name\", \"UNCONFIGURED_NAME\", {\n        value: name\n      });\n      return address;\n    });\n    return this.signingKey.sign(TypedDataEncoder.hash(populated.domain, types, populated.value)).serialized;\n  }\n}","map":{"version":3,"names":["getAddress","resolveAddress","hashMessage","TypedDataEncoder","AbstractSigner","copyRequest","computeAddress","Transaction","defineProperties","resolveProperties","assert","assertArgument","BaseWallet","address","signingKey","constructor","privateKey","provider","sign","publicKey","connect","signTransaction","tx","to","from","undefined","btx","signature","unsignedHash","serialized","signMessage","message","signMessageSync","signTypedData","domain","types","value","populated","resolveNames","name","operation","info","resolveName","hash"],"sources":["C:/Users/Oana/Desktop/Blockchain/Blockchain-Project/node_modules/ethers/lib.esm/wallet/base-wallet.js"],"sourcesContent":["import { getAddress, resolveAddress } from \"../address/index.js\";\nimport { hashMessage, TypedDataEncoder } from \"../hash/index.js\";\nimport { AbstractSigner, copyRequest } from \"../providers/index.js\";\nimport { computeAddress, Transaction } from \"../transaction/index.js\";\nimport { defineProperties, resolveProperties, assert, assertArgument } from \"../utils/index.js\";\n/**\n *  The **BaseWallet** is a stream-lined implementation of a\n *  [[Signer]] that operates with a private key.\n *\n *  It is preferred to use the [[Wallet]] class, as it offers\n *  additional functionality and simplifies loading a variety\n *  of JSON formats, Mnemonic Phrases, etc.\n *\n *  This class may be of use for those attempting to implement\n *  a minimal Signer.\n */\nexport class BaseWallet extends AbstractSigner {\n    /**\n     *  The wallet address.\n     */\n    address;\n    #signingKey;\n    /**\n     *  Creates a new BaseWallet for %%privateKey%%, optionally\n     *  connected to %%provider%%.\n     *\n     *  If %%provider%% is not specified, only offline methods can\n     *  be used.\n     */\n    constructor(privateKey, provider) {\n        super(provider);\n        assertArgument(privateKey && typeof (privateKey.sign) === \"function\", \"invalid private key\", \"privateKey\", \"[ REDACTED ]\");\n        this.#signingKey = privateKey;\n        const address = computeAddress(this.signingKey.publicKey);\n        defineProperties(this, { address });\n    }\n    // Store private values behind getters to reduce visibility\n    // in console.log\n    /**\n     *  The [[SigningKey]] used for signing payloads.\n     */\n    get signingKey() { return this.#signingKey; }\n    /**\n     *  The private key for this wallet.\n     */\n    get privateKey() { return this.signingKey.privateKey; }\n    async getAddress() { return this.address; }\n    connect(provider) {\n        return new BaseWallet(this.#signingKey, provider);\n    }\n    async signTransaction(tx) {\n        tx = copyRequest(tx);\n        // Replace any Addressable or ENS name with an address\n        const { to, from } = await resolveProperties({\n            to: (tx.to ? resolveAddress(tx.to, this.provider) : undefined),\n            from: (tx.from ? resolveAddress(tx.from, this.provider) : undefined)\n        });\n        if (to != null) {\n            tx.to = to;\n        }\n        if (from != null) {\n            tx.from = from;\n        }\n        if (tx.from != null) {\n            assertArgument(getAddress((tx.from)) === this.address, \"transaction from address mismatch\", \"tx.from\", tx.from);\n            delete tx.from;\n        }\n        // Build the transaction\n        const btx = Transaction.from(tx);\n        btx.signature = this.signingKey.sign(btx.unsignedHash);\n        return btx.serialized;\n    }\n    async signMessage(message) {\n        return this.signMessageSync(message);\n    }\n    // @TODO: Add a secialized signTx and signTyped sync that enforces\n    // all parameters are known?\n    /**\n     *  Returns the signature for %%message%% signed with this wallet.\n     */\n    signMessageSync(message) {\n        return this.signingKey.sign(hashMessage(message)).serialized;\n    }\n    async signTypedData(domain, types, value) {\n        // Populate any ENS names\n        const populated = await TypedDataEncoder.resolveNames(domain, types, value, async (name) => {\n            // @TODO: this should use resolveName; addresses don't\n            //        need a provider\n            assert(this.provider != null, \"cannot resolve ENS names without a provider\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"resolveName\",\n                info: { name }\n            });\n            const address = await this.provider.resolveName(name);\n            assert(address != null, \"unconfigured ENS name\", \"UNCONFIGURED_NAME\", {\n                value: name\n            });\n            return address;\n        });\n        return this.signingKey.sign(TypedDataEncoder.hash(populated.domain, types, populated.value)).serialized;\n    }\n}\n//# sourceMappingURL=base-wallet.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}