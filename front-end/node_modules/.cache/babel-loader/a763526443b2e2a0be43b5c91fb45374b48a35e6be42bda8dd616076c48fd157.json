{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JsonRpcServer = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst http_1 = __importDefault(require(\"http\"));\nconst http_2 = require(\"../../core/providers/http\");\nconst handler_1 = require(\"./handler\");\nconst log = (0, debug_1.default)(\"hardhat:core:hardhat-network:jsonrpc\");\nclass JsonRpcServer {\n  constructor(config) {\n    this.getProvider = (name = \"json-rpc\") => {\n      const {\n        Client\n      } = require(\"undici\");\n      const {\n        address,\n        port\n      } = this._httpServer.address();\n      const dispatcher = new Client(`http://${address}:${port}/`, {\n        keepAliveTimeout: 10,\n        keepAliveMaxTimeout: 10\n      });\n      return new http_2.HttpProvider(`http://${address}:${port}/`, name, {}, 20000, dispatcher);\n    };\n    this.listen = () => {\n      return new Promise(resolve => {\n        log(`Starting JSON-RPC server on port ${this._config.port}`);\n        this._httpServer.listen(this._config.port, this._config.hostname, () => {\n          // We get the address and port directly from the server in order to handle random port allocation with `0`.\n          const address = this._httpServer.address(); // TCP sockets return AddressInfo\n          resolve(address);\n        });\n      });\n    };\n    this.waitUntilClosed = async () => {\n      const httpServerClosed = new Promise(resolve => {\n        this._httpServer.once(\"close\", resolve);\n      });\n      const wsServerClosed = new Promise(resolve => {\n        this._wsServer.once(\"close\", resolve);\n      });\n      await Promise.all([httpServerClosed, wsServerClosed]);\n    };\n    this.close = async () => {\n      await Promise.all([new Promise((resolve, reject) => {\n        log(\"Closing JSON-RPC server\");\n        this._httpServer.close(err => {\n          if (err !== null && err !== undefined) {\n            log(\"Failed to close JSON-RPC server\");\n            reject(err);\n            return;\n          }\n          log(\"JSON-RPC server closed\");\n          resolve();\n        });\n      }), new Promise((resolve, reject) => {\n        log(\"Closing websocket server\");\n        this._wsServer.close(err => {\n          if (err !== null && err !== undefined) {\n            log(\"Failed to close websocket server\");\n            reject(err);\n            return;\n          }\n          log(\"Websocket server closed\");\n          resolve();\n        });\n      })]);\n    };\n    const {\n      Server: WSServer\n    } = require(\"ws\");\n    this._config = config;\n    const handler = new handler_1.JsonRpcHandler(config.provider);\n    this._httpServer = http_1.default.createServer();\n    this._wsServer = new WSServer({\n      server: this._httpServer\n    });\n    this._httpServer.on(\"request\", handler.handleHttp);\n    this._wsServer.on(\"connection\", handler.handleWs);\n  }\n}\nexports.JsonRpcServer = JsonRpcServer;","map":{"version":3,"names":["debug_1","__importDefault","require","http_1","http_2","handler_1","log","default","JsonRpcServer","constructor","config","getProvider","name","Client","address","port","_httpServer","dispatcher","keepAliveTimeout","keepAliveMaxTimeout","HttpProvider","listen","Promise","resolve","_config","hostname","waitUntilClosed","httpServerClosed","once","wsServerClosed","_wsServer","all","close","reject","err","undefined","Server","WSServer","handler","JsonRpcHandler","provider","createServer","server","on","handleHttp","handleWs","exports"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\internal\\hardhat-network\\jsonrpc\\server.ts"],"sourcesContent":["import type { Client as ClientT } from \"undici\";\nimport type WsT from \"ws\";\n\nimport debug from \"debug\";\nimport http, { Server } from \"http\";\nimport { AddressInfo } from \"net\";\n\nimport {\n  EIP1193Provider,\n  JsonRpcServer as IJsonRpcServer,\n} from \"../../../types\";\nimport { HttpProvider } from \"../../core/providers/http\";\n\nimport { JsonRpcHandler } from \"./handler\";\n\nconst log = debug(\"hardhat:core:hardhat-network:jsonrpc\");\n\nexport interface JsonRpcServerConfig {\n  hostname: string;\n  port: number;\n\n  provider: EIP1193Provider;\n}\n\nexport class JsonRpcServer implements IJsonRpcServer {\n  private _config: JsonRpcServerConfig;\n  private _httpServer: Server;\n  private _wsServer: WsT.Server;\n\n  constructor(config: JsonRpcServerConfig) {\n    const { Server: WSServer } = require(\"ws\") as typeof WsT;\n\n    this._config = config;\n\n    const handler = new JsonRpcHandler(config.provider);\n\n    this._httpServer = http.createServer();\n    this._wsServer = new WSServer({\n      server: this._httpServer,\n    });\n\n    this._httpServer.on(\"request\", handler.handleHttp);\n    this._wsServer.on(\"connection\", handler.handleWs);\n  }\n\n  public getProvider = (name = \"json-rpc\"): EIP1193Provider => {\n    const { Client } = require(\"undici\") as { Client: typeof ClientT };\n    const { address, port } = this._httpServer.address() as AddressInfo;\n\n    const dispatcher = new Client(`http://${address}:${port}/`, {\n      keepAliveTimeout: 10,\n      keepAliveMaxTimeout: 10,\n    });\n\n    return new HttpProvider(\n      `http://${address}:${port}/`,\n      name,\n      {},\n      20000,\n      dispatcher\n    );\n  };\n\n  public listen = (): Promise<{ address: string; port: number }> => {\n    return new Promise((resolve) => {\n      log(`Starting JSON-RPC server on port ${this._config.port}`);\n      this._httpServer.listen(this._config.port, this._config.hostname, () => {\n        // We get the address and port directly from the server in order to handle random port allocation with `0`.\n        const address = this._httpServer.address() as AddressInfo; // TCP sockets return AddressInfo\n        resolve(address);\n      });\n    });\n  };\n\n  public waitUntilClosed = async () => {\n    const httpServerClosed = new Promise((resolve) => {\n      this._httpServer.once(\"close\", resolve);\n    });\n\n    const wsServerClosed = new Promise((resolve) => {\n      this._wsServer.once(\"close\", resolve);\n    });\n\n    await Promise.all([httpServerClosed, wsServerClosed]);\n  };\n\n  public close = async () => {\n    await Promise.all([\n      new Promise<void>((resolve, reject) => {\n        log(\"Closing JSON-RPC server\");\n        this._httpServer.close((err) => {\n          if (err !== null && err !== undefined) {\n            log(\"Failed to close JSON-RPC server\");\n            reject(err);\n            return;\n          }\n\n          log(\"JSON-RPC server closed\");\n          resolve();\n        });\n      }),\n      new Promise<void>((resolve, reject) => {\n        log(\"Closing websocket server\");\n        this._wsServer.close((err) => {\n          if (err !== null && err !== undefined) {\n            log(\"Failed to close websocket server\");\n            reject(err);\n            return;\n          }\n\n          log(\"Websocket server closed\");\n          resolve();\n        });\n      }),\n    ]);\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}