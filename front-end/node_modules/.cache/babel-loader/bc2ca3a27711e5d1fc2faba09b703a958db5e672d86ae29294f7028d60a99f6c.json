{"ast":null,"code":"import * as UCAN from \"./ucan.js\";\nimport { varint } from \"multiformats\";\nimport { base64url, base64 } from \"multiformats/bases/base64\";\nimport * as UTF8 from \"./utf8.js\";\nexport const NON_STANDARD = 0xd000;\nexport const ES256K = 0xd0e7;\nexport const BLS12381G1 = 0xd0ea;\nexport const BLS12381G2 = 0xd0eb;\nexport const EdDSA = 0xd0ed;\nexport const ES256 = 0xd01200;\nexport const ES384 = 0xd01201;\nexport const ES512 = 0xd01202;\nexport const RS256 = 0xd01205;\nexport const EIP191 = 0xd191;\n\n/**\n * @param {number} code\n * @returns {string}\n */\nconst codeName = code => {\n  switch (code) {\n    case ES256K:\n      return \"ES256K\";\n    case BLS12381G1:\n      return \"BLS12381G1\";\n    case BLS12381G2:\n      return \"BLS12381G2\";\n    case EdDSA:\n      return \"EdDSA\";\n    case ES256:\n      return \"ES256\";\n    case ES384:\n      return \"ES384\";\n    case ES512:\n      return \"ES512\";\n    case RS256:\n      return \"RS256\";\n    case EIP191:\n      return \"EIP191\";\n    default:\n      throw new RangeError(`Unknown signature algorithm code 0x${code.toString(16)}`);\n  }\n};\n\n/**\n *\n * @param {string} name\n */\nexport const nameCode = name => {\n  switch (name) {\n    case \"ES256K\":\n      return ES256K;\n    case \"BLS12381G1\":\n      return BLS12381G1;\n    case \"BLS12381G2\":\n      return BLS12381G2;\n    case \"EdDSA\":\n      return EdDSA;\n    case \"ES256\":\n      return ES256;\n    case \"ES384\":\n      return ES384;\n    case \"ES512\":\n      return ES512;\n    case \"RS256\":\n      return RS256;\n    case \"EIP191\":\n      return EIP191;\n    default:\n      return NON_STANDARD;\n  }\n};\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @implements {UCAN.SignatureView<T, A>}\n */\nexport class Signature extends Uint8Array {\n  get code() {\n    const [code] = varint.decode(this);\n    Object.defineProperties(this, {\n      code: {\n        value: code\n      }\n    });\n    return /** @type {A} */code;\n  }\n  get size() {\n    const value = size(this);\n    Object.defineProperties(this, {\n      size: {\n        value\n      }\n    });\n    return value;\n  }\n  get algorithm() {\n    const value = algorithm(this);\n    Object.defineProperties(this, {\n      algorithm: {\n        value\n      }\n    });\n    return value;\n  }\n  get raw() {\n    const {\n      buffer,\n      byteOffset,\n      size,\n      code\n    } = this;\n    const codeSize = varint.encodingLength(code);\n    const rawSize = varint.encodingLength(size);\n    const value = new Uint8Array(buffer, byteOffset + codeSize + rawSize, size);\n    Object.defineProperties(this, {\n      raw: {\n        value\n      }\n    });\n    return value;\n  }\n\n  /**\n   * Verify that this signature was created by the given key.\n   *\n   * @param {UCAN.Crypto.Verifier<A>} signer\n   * @param {UCAN.ByteView<T>} payload\n   */\n  async verify(signer, payload) {\n    try {\n      if ((await signer.verify(payload, this)) === true) {\n        return {\n          ok: {}\n        };\n      } else {\n        throw new Error(\"Invalid signature\");\n      }\n    } catch (cause) {\n      return {\n        error: ( /** @type {Error} */cause)\n      };\n    }\n  }\n  toJSON() {\n    return toJSON(this);\n  }\n}\n\n/**\n * @param {UCAN.Signature} signature\n */\nconst algorithm = signature => {\n  const {\n    code,\n    raw,\n    buffer,\n    byteOffset\n  } = signature;\n  if (code === NON_STANDARD) {\n    const offset = raw.byteLength + varint.encodingLength(code) + varint.encodingLength(raw.byteLength);\n    const bytes = new Uint8Array(buffer, byteOffset + offset);\n    return UTF8.decode(bytes);\n  } else {\n    return codeName(code);\n  }\n};\n\n/**\n * @param {UCAN.Signature} signature\n */\nconst size = signature => {\n  const offset = varint.encodingLength(signature.code);\n  const [size] = varint.decode(new Uint8Array(signature.buffer, signature.byteOffset + offset));\n  return size;\n};\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @param {A} code\n * @param {Uint8Array} raw\n * @returns {UCAN.SignatureView<T, A>}\n */\nexport const create = (code, raw) => {\n  const _ = codeName(code);\n  const codeSize = varint.encodingLength(code);\n  const rawSize = varint.encodingLength(raw.byteLength);\n\n  /** @type {Signature<T, A>} */\n  const signature = new Signature(codeSize + rawSize + raw.byteLength);\n  varint.encodeTo(code, signature);\n  varint.encodeTo(raw.byteLength, signature, codeSize);\n  signature.set(raw, codeSize + rawSize);\n  Object.defineProperties(signature, {\n    code: {\n      value: code\n    },\n    size: {\n      value: raw.byteLength\n    }\n  });\n  return signature;\n};\n\n/**\n * @template {unknown} T\n * @param {string} name\n * @param {Uint8Array} raw\n * @return {UCAN.SignatureView<T>}\n */\nexport const createNamed = (name, raw) => {\n  const code = nameCode(name);\n  return code === NON_STANDARD ? createNonStandard(name, raw) : create(code, raw);\n};\n\n/**\n * @template {unknown} T\n * @param {string} name\n * @param {Uint8Array} raw\n * @return {UCAN.SignatureView<T, typeof NON_STANDARD>}\n */\nexport const createNonStandard = (name, raw) => {\n  const code = NON_STANDARD;\n  const codeSize = varint.encodingLength(code);\n  const rawSize = varint.encodingLength(raw.byteLength);\n  const nameBytes = UTF8.encode(name);\n  /** @type {Signature<T, typeof NON_STANDARD>} */\n  const signature = new Signature(codeSize + rawSize + raw.byteLength + nameBytes.byteLength);\n  varint.encodeTo(code, signature);\n  varint.encodeTo(raw.byteLength, signature, codeSize);\n  signature.set(raw, codeSize + rawSize);\n  signature.set(nameBytes, codeSize + rawSize + raw.byteLength);\n  return signature;\n};\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @param {UCAN.ByteView<UCAN.Signature<T, A>>} bytes\n * @returns {UCAN.SignatureView<T, A>}\n */\nexport const view = bytes => new Signature(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @param {UCAN.ByteView<UCAN.Signature<T, A>>} bytes\n * @returns {UCAN.SignatureView<T, A>}\n */\nexport const decode = bytes => {\n  if (!(bytes instanceof Uint8Array)) {\n    throw new TypeError(`Can only decode Uint8Array into a Signature, instead got ${JSON.stringify(bytes)}`);\n  }\n\n  /** @type {UCAN.SignatureView<T, A>} */\n  const signature = view(bytes);\n  const {\n    code,\n    algorithm,\n    raw\n  } = signature;\n  return signature;\n};\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @param {UCAN.Signature<T, A>} signature\n * @returns {UCAN.ByteView<UCAN.Signature<T, A>>}\n */\nexport const encode = signature => decode(signature);\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @template {string} [Prefix=\"u\"]\n * @param {UCAN.Signature<T, A>} signature\n * @param {UCAN.MultibaseEncoder<Prefix>} [base]\n * @returns {UCAN.ToString<UCAN.Signature<T, A>>}\n */\nexport const format = (signature, base) => (base || base64url).encode(signature);\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @template {string} [Prefix=\"u\"]\n * @param {UCAN.ToString<UCAN.Signature<T, A>>} signature\n * @param {UCAN.MultibaseDecoder<Prefix>} [base]\n * @returns {UCAN.SignatureView<T, A>}\n */\nexport const parse = (signature, base) => ( /** @type {UCAN.SignatureView<T, A>} */\ndecode((base || base64url).decode(signature)));\n\n/**\n * @template {UCAN.Signature} Signature\n * @param {Signature} signature\n * @returns {UCAN.SignatureJSON<Signature>}\n */\nexport const toJSON = signature => ({\n  \"/\": {\n    bytes: base64.baseEncode(signature)\n  }\n});\n\n/**\n * @template {unknown} T\n * @template {UCAN.SigAlg} A\n * @param {UCAN.SignatureJSON<UCAN.Signature<T, A>>} json\n * @returns {UCAN.SignatureView<T, A>}\n */\nexport const fromJSON = json => decode(base64.baseDecode(json[\"/\"].bytes));","map":{"version":3,"names":["UCAN","varint","base64url","base64","UTF8","NON_STANDARD","ES256K","BLS12381G1","BLS12381G2","EdDSA","ES256","ES384","ES512","RS256","EIP191","codeName","code","RangeError","toString","nameCode","name","Signature","Uint8Array","decode","Object","defineProperties","value","size","algorithm","raw","buffer","byteOffset","codeSize","encodingLength","rawSize","verify","signer","payload","ok","Error","cause","error","toJSON","signature","offset","byteLength","bytes","create","_","encodeTo","set","createNamed","createNonStandard","nameBytes","encode","view","TypeError","JSON","stringify","format","base","parse","baseEncode","fromJSON","json","baseDecode"],"sources":["C:/FACULTATE/Proiect/node_modules/@ipld/dag-ucan/src/signature.js"],"sourcesContent":["import * as UCAN from \"./ucan.js\"\nimport { varint } from \"multiformats\"\nimport { base64url, base64 } from \"multiformats/bases/base64\"\nimport * as UTF8 from \"./utf8.js\"\n\nexport const NON_STANDARD = 0xd000\nexport const ES256K = 0xd0e7\nexport const BLS12381G1 = 0xd0ea\nexport const BLS12381G2 = 0xd0eb\nexport const EdDSA = 0xd0ed\nexport const ES256 = 0xd01200\nexport const ES384 = 0xd01201\nexport const ES512 = 0xd01202\nexport const RS256 = 0xd01205\nexport const EIP191 = 0xd191\n\n/**\n * @param {number} code\n * @returns {string}\n */\nconst codeName = code => {\n  switch (code) {\n    case ES256K:\n      return \"ES256K\"\n    case BLS12381G1:\n      return \"BLS12381G1\"\n    case BLS12381G2:\n      return \"BLS12381G2\"\n    case EdDSA:\n      return \"EdDSA\"\n    case ES256:\n      return \"ES256\"\n    case ES384:\n      return \"ES384\"\n    case ES512:\n      return \"ES512\"\n    case RS256:\n      return \"RS256\"\n    case EIP191:\n      return \"EIP191\"\n    default:\n      throw new RangeError(\n        `Unknown signature algorithm code 0x${code.toString(16)}`\n      )\n  }\n}\n\n/**\n *\n * @param {string} name\n */\nexport const nameCode = name => {\n  switch (name) {\n    case \"ES256K\":\n      return ES256K\n    case \"BLS12381G1\":\n      return BLS12381G1\n    case \"BLS12381G2\":\n      return BLS12381G2\n    case \"EdDSA\":\n      return EdDSA\n    case \"ES256\":\n      return ES256\n    case \"ES384\":\n      return ES384\n    case \"ES512\":\n      return ES512\n    case \"RS256\":\n      return RS256\n    case \"EIP191\":\n      return EIP191\n    default:\n      return NON_STANDARD\n  }\n}\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @implements {UCAN.SignatureView<T, A>}\n */\nexport class Signature extends Uint8Array {\n  get code() {\n    const [code] = varint.decode(this)\n    Object.defineProperties(this, { code: { value: code } })\n    return /** @type {A} */ (code)\n  }\n\n  get size() {\n    const value = size(this)\n    Object.defineProperties(this, { size: { value } })\n    return value\n  }\n  get algorithm() {\n    const value = algorithm(this)\n    Object.defineProperties(this, { algorithm: { value } })\n    return value\n  }\n\n  get raw() {\n    const { buffer, byteOffset, size, code } = this\n    const codeSize = varint.encodingLength(code)\n    const rawSize = varint.encodingLength(size)\n    const value = new Uint8Array(buffer, byteOffset + codeSize + rawSize, size)\n    Object.defineProperties(this, { raw: { value } })\n    return value\n  }\n\n  /**\n   * Verify that this signature was created by the given key.\n   *\n   * @param {UCAN.Crypto.Verifier<A>} signer\n   * @param {UCAN.ByteView<T>} payload\n   */\n  async verify(signer, payload) {\n    try {\n      if ((await signer.verify(payload, this)) === true) {\n        return { ok: {} }\n      } else {\n        throw new Error(\"Invalid signature\")\n      }\n    } catch (cause) {\n      return { error: /** @type {Error} */ (cause) }\n    }\n  }\n\n  toJSON() {\n    return toJSON(this)\n  }\n}\n\n/**\n * @param {UCAN.Signature} signature\n */\nconst algorithm = signature => {\n  const { code, raw, buffer, byteOffset } = signature\n  if (code === NON_STANDARD) {\n    const offset =\n      raw.byteLength +\n      varint.encodingLength(code) +\n      varint.encodingLength(raw.byteLength)\n    const bytes = new Uint8Array(buffer, byteOffset + offset)\n    return UTF8.decode(bytes)\n  } else {\n    return codeName(code)\n  }\n}\n\n/**\n * @param {UCAN.Signature} signature\n */\nconst size = signature => {\n  const offset = varint.encodingLength(signature.code)\n  const [size] = varint.decode(\n    new Uint8Array(signature.buffer, signature.byteOffset + offset)\n  )\n  return size\n}\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @param {A} code\n * @param {Uint8Array} raw\n * @returns {UCAN.SignatureView<T, A>}\n */\nexport const create = (code, raw) => {\n  const _ = codeName(code)\n  const codeSize = varint.encodingLength(code)\n  const rawSize = varint.encodingLength(raw.byteLength)\n\n  /** @type {Signature<T, A>} */\n  const signature = new Signature(codeSize + rawSize + raw.byteLength)\n  varint.encodeTo(code, signature)\n  varint.encodeTo(raw.byteLength, signature, codeSize)\n  signature.set(raw, codeSize + rawSize)\n  Object.defineProperties(signature, {\n    code: { value: code },\n    size: { value: raw.byteLength },\n  })\n  return signature\n}\n\n/**\n * @template {unknown} T\n * @param {string} name\n * @param {Uint8Array} raw\n * @return {UCAN.SignatureView<T>}\n */\nexport const createNamed = (name, raw) => {\n  const code = nameCode(name)\n  return code === NON_STANDARD\n    ? createNonStandard(name, raw)\n    : create(code, raw)\n}\n\n/**\n * @template {unknown} T\n * @param {string} name\n * @param {Uint8Array} raw\n * @return {UCAN.SignatureView<T, typeof NON_STANDARD>}\n */\nexport const createNonStandard = (name, raw) => {\n  const code = NON_STANDARD\n  const codeSize = varint.encodingLength(code)\n  const rawSize = varint.encodingLength(raw.byteLength)\n  const nameBytes = UTF8.encode(name)\n  /** @type {Signature<T, typeof NON_STANDARD>} */\n  const signature = new Signature(\n    codeSize + rawSize + raw.byteLength + nameBytes.byteLength\n  )\n  varint.encodeTo(code, signature)\n  varint.encodeTo(raw.byteLength, signature, codeSize)\n  signature.set(raw, codeSize + rawSize)\n  signature.set(nameBytes, codeSize + rawSize + raw.byteLength)\n\n  return signature\n}\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @param {UCAN.ByteView<UCAN.Signature<T, A>>} bytes\n * @returns {UCAN.SignatureView<T, A>}\n */\nexport const view = bytes =>\n  new Signature(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @param {UCAN.ByteView<UCAN.Signature<T, A>>} bytes\n * @returns {UCAN.SignatureView<T, A>}\n */\nexport const decode = bytes => {\n  if (!(bytes instanceof Uint8Array)) {\n    throw new TypeError(\n      `Can only decode Uint8Array into a Signature, instead got ${JSON.stringify(\n        bytes\n      )}`\n    )\n  }\n\n  /** @type {UCAN.SignatureView<T, A>} */\n  const signature = view(bytes)\n  const { code, algorithm, raw } = signature\n  return signature\n}\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @param {UCAN.Signature<T, A>} signature\n * @returns {UCAN.ByteView<UCAN.Signature<T, A>>}\n */\nexport const encode = signature => decode(signature)\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @template {string} [Prefix=\"u\"]\n * @param {UCAN.Signature<T, A>} signature\n * @param {UCAN.MultibaseEncoder<Prefix>} [base]\n * @returns {UCAN.ToString<UCAN.Signature<T, A>>}\n */\nexport const format = (signature, base) => (base || base64url).encode(signature)\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @template {string} [Prefix=\"u\"]\n * @param {UCAN.ToString<UCAN.Signature<T, A>>} signature\n * @param {UCAN.MultibaseDecoder<Prefix>} [base]\n * @returns {UCAN.SignatureView<T, A>}\n */\nexport const parse = (signature, base) =>\n  /** @type {UCAN.SignatureView<T, A>} */ (\n    decode((base || base64url).decode(signature))\n  )\n\n/**\n * @template {UCAN.Signature} Signature\n * @param {Signature} signature\n * @returns {UCAN.SignatureJSON<Signature>}\n */\nexport const toJSON = signature => ({\n  \"/\": { bytes: base64.baseEncode(signature) },\n})\n\n/**\n * @template {unknown} T\n * @template {UCAN.SigAlg} A\n * @param {UCAN.SignatureJSON<UCAN.Signature<T, A>>} json\n * @returns {UCAN.SignatureView<T, A>}\n */\nexport const fromJSON = json => decode(base64.baseDecode(json[\"/\"].bytes))\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}