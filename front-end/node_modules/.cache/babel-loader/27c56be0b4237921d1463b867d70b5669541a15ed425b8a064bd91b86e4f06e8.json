{"ast":null,"code":"export * from './types.js';\n/**\n * create a did:mailto from an email address\n *\n * @param {import(\"./types.js\").EmailAddress} email\n * @returns {import(\"./types.js\").DidMailto}\n */\nexport function fromEmail(email) {\n  const {\n    domain,\n    local\n  } = parseEmail(email);\n  const did = /** @type {const} */`did:mailto:${encodeURIComponent(domain)}:${encodeURIComponent(local)}`;\n  return did;\n}\n/**\n * @param {import(\"./types.js\").DidMailto} did\n * @returns {import(\"./types.js\").EmailAddress}\n */\nexport function toEmail(did) {\n  const parts = did.split(':');\n  if (parts[1] !== 'mailto') {\n    throw new Error(`DID ${did} is not a mailto did.`);\n  }\n  return `${decodeURIComponent(parts[3])}@${decodeURIComponent(parts[2])}`;\n}\n/**\n * given a string, if it is an EmailAddress, return it, otherwise throw an error.\n * Use this to parse string input to `EmailAddress` type to pass to `fromEmail` (when needed).\n * This is not meant to be a general RFC5322 (et al) email address validator, which would be more expensive.\n *\n * @param {string} input\n * @returns {import(\"./types.js\").EmailAddress}\n */\nexport function email(input) {\n  const {\n    domain,\n    local\n  } = parseEmail(input);\n  /** @type {import(\"./types.js\").EmailAddress} */\n  const emailAddress = `${local}@${domain}`;\n  return emailAddress;\n}\n/**\n * parse a did mailto from a string\n *\n * @param {string} input\n * @returns {import(\"./types.js\").DidMailto}\n */\nexport function fromString(input) {\n  const colonParts = input.split(':');\n  if (colonParts.length !== 4) {\n    throw new TypeError(`expected did:mailto to have 4 colon-delimited segments, but got ${colonParts.length}`);\n  }\n  const [domain, local] = [colonParts[2], colonParts[3]];\n  return `did:mailto:${domain}:${local}`;\n}\n/**\n * @param {string} email\n */\nfunction parseEmail(email) {\n  const atParts = email.split('@');\n  if (atParts.length < 2) {\n    throw new TypeError(`expected at least 2 @-delimtied segments, but got ${atParts.length}`);\n  }\n  const domain = atParts.at(-1) ?? '';\n  const local = atParts.slice(0, -1).join('@');\n  return {\n    domain,\n    local\n  };\n}","map":{"version":3,"names":["fromEmail","email","domain","local","parseEmail","did","encodeURIComponent","toEmail","parts","split","Error","decodeURIComponent","input","emailAddress","fromString","colonParts","length","TypeError","atParts","at","slice","join"],"sources":["C:\\FACULTATE\\Proiect\\node_modules\\@web3-storage\\did-mailto\\src\\index.js"],"sourcesContent":["export * from './types.js'\n\n/**\n * create a did:mailto from an email address\n *\n * @param {import(\"./types.js\").EmailAddress} email\n * @returns {import(\"./types.js\").DidMailto}\n */\nexport function fromEmail(email) {\n  const { domain, local } = parseEmail(email)\n  const did = /** @type {const} */ (\n    `did:mailto:${encodeURIComponent(domain)}:${encodeURIComponent(local)}`\n  )\n  return did\n}\n\n/**\n * @param {import(\"./types.js\").DidMailto} did\n * @returns {import(\"./types.js\").EmailAddress}\n */\nexport function toEmail(did) {\n  const parts = did.split(':')\n  if (parts[1] !== 'mailto') {\n    throw new Error(`DID ${did} is not a mailto did.`)\n  }\n  return `${decodeURIComponent(parts[3])}@${decodeURIComponent(parts[2])}`\n}\n\n/**\n * given a string, if it is an EmailAddress, return it, otherwise throw an error.\n * Use this to parse string input to `EmailAddress` type to pass to `fromEmail` (when needed).\n * This is not meant to be a general RFC5322 (et al) email address validator, which would be more expensive.\n *\n * @param {string} input\n * @returns {import(\"./types.js\").EmailAddress}\n */\nexport function email(input) {\n  const { domain, local } = parseEmail(input)\n  /** @type {import(\"./types.js\").EmailAddress} */\n  const emailAddress = `${local}@${domain}`\n  return emailAddress\n}\n\n/**\n * parse a did mailto from a string\n *\n * @param {string} input\n * @returns {import(\"./types.js\").DidMailto}\n */\nexport function fromString(input) {\n  const colonParts = input.split(':')\n  if (colonParts.length !== 4) {\n    throw new TypeError(\n      `expected did:mailto to have 4 colon-delimited segments, but got ${colonParts.length}`\n    )\n  }\n  const [domain, local] = [colonParts[2], colonParts[3]]\n  return `did:mailto:${domain}:${local}`\n}\n\n/**\n * @param {string} email\n */\nfunction parseEmail(email) {\n  const atParts = email.split('@')\n  if (atParts.length < 2) {\n    throw new TypeError(\n      `expected at least 2 @-delimtied segments, but got ${atParts.length}`\n    )\n  }\n  const domain = atParts.at(-1) ?? ''\n  const local = atParts.slice(0, -1).join('@')\n  return { domain, local }\n}\n"],"mappings":"AAAA,cAAc,YAAY;AAE1B;;;;;;AAMA,OAAM,SAAUA,SAASA,CAACC,KAAK;EAC7B,MAAM;IAAEC,MAAM;IAAEC;EAAK,CAAE,GAAGC,UAAU,CAACH,KAAK,CAAC;EAC3C,MAAMI,GAAG,GAAG,oBACV,cAAcC,kBAAkB,CAACJ,MAAM,CAAC,IAAII,kBAAkB,CAACH,KAAK,CAAC,EACtE;EACD,OAAOE,GAAG;AACZ;AAEA;;;;AAIA,OAAM,SAAUE,OAAOA,CAACF,GAAG;EACzB,MAAMG,KAAK,GAAGH,GAAG,CAACI,KAAK,CAAC,GAAG,CAAC;EAC5B,IAAID,KAAK,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;IACzB,MAAM,IAAIE,KAAK,CAAC,OAAOL,GAAG,uBAAuB,CAAC;;EAEpD,OAAO,GAAGM,kBAAkB,CAACH,KAAK,CAAC,CAAC,CAAC,CAAC,IAAIG,kBAAkB,CAACH,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE;AAC1E;AAEA;;;;;;;;AAQA,OAAM,SAAUP,KAAKA,CAACW,KAAK;EACzB,MAAM;IAAEV,MAAM;IAAEC;EAAK,CAAE,GAAGC,UAAU,CAACQ,KAAK,CAAC;EAC3C;EACA,MAAMC,YAAY,GAAG,GAAGV,KAAK,IAAID,MAAM,EAAE;EACzC,OAAOW,YAAY;AACrB;AAEA;;;;;;AAMA,OAAM,SAAUC,UAAUA,CAACF,KAAK;EAC9B,MAAMG,UAAU,GAAGH,KAAK,CAACH,KAAK,CAAC,GAAG,CAAC;EACnC,IAAIM,UAAU,CAACC,MAAM,KAAK,CAAC,EAAE;IAC3B,MAAM,IAAIC,SAAS,CACjB,mEAAmEF,UAAU,CAACC,MAAM,EAAE,CACvF;;EAEH,MAAM,CAACd,MAAM,EAAEC,KAAK,CAAC,GAAG,CAACY,UAAU,CAAC,CAAC,CAAC,EAAEA,UAAU,CAAC,CAAC,CAAC,CAAC;EACtD,OAAO,cAAcb,MAAM,IAAIC,KAAK,EAAE;AACxC;AAEA;;;AAGA,SAASC,UAAUA,CAACH,KAAK;EACvB,MAAMiB,OAAO,GAAGjB,KAAK,CAACQ,KAAK,CAAC,GAAG,CAAC;EAChC,IAAIS,OAAO,CAACF,MAAM,GAAG,CAAC,EAAE;IACtB,MAAM,IAAIC,SAAS,CACjB,qDAAqDC,OAAO,CAACF,MAAM,EAAE,CACtE;;EAEH,MAAMd,MAAM,GAAGgB,OAAO,CAACC,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE;EACnC,MAAMhB,KAAK,GAAGe,OAAO,CAACE,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC;EAC5C,OAAO;IAAEnB,MAAM;IAAEC;EAAK,CAAE;AAC1B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}