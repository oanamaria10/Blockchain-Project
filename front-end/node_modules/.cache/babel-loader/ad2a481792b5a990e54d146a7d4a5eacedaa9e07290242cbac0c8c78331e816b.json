{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ContractsIdentifier = void 0;\nconst ethereumjs_util_1 = require(\"@nomicfoundation/ethereumjs-util\");\nconst library_utils_1 = require(\"./library-utils\");\nconst opcodes_1 = require(\"./opcodes\");\n/**\n * This class represent a somewhat special Trie of bytecodes.\n *\n * What makes it special is that every node has a set of all of its descendants and its depth.\n */\nclass BytecodeTrie {\n  static isBytecodeTrie(o) {\n    if (o === undefined || o === null) {\n      return false;\n    }\n    return \"childNodes\" in o;\n  }\n  constructor(depth) {\n    this.depth = depth;\n    this.childNodes = new Map();\n    this.descendants = [];\n  }\n  add(bytecode) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let trieNode = this;\n    for (let currentCodeByte = 0; currentCodeByte <= bytecode.normalizedCode.length; currentCodeByte += 1) {\n      if (currentCodeByte === bytecode.normalizedCode.length) {\n        // If multiple contracts with the exact same bytecode are added we keep the last of them.\n        // Note that this includes the metadata hash, so the chances of happening are pretty remote,\n        // except in super artificial cases that we have in our test suite.\n        trieNode.match = bytecode;\n        return;\n      }\n      const byte = bytecode.normalizedCode[currentCodeByte];\n      trieNode.descendants.push(bytecode);\n      let childNode = trieNode.childNodes.get(byte);\n      if (childNode === undefined) {\n        childNode = new BytecodeTrie(currentCodeByte);\n        trieNode.childNodes.set(byte, childNode);\n      }\n      trieNode = childNode;\n    }\n  }\n  /**\n   * Searches for a bytecode. If it's an exact match, it is returned. If there's no match, but a\n   * prefix of the code is found in the trie, the node of the longest prefix is returned. If the\n   * entire code is covered by the trie, and there's no match, we return undefined.\n   */\n  search(code, currentCodeByte = 0) {\n    if (currentCodeByte > code.length) {\n      return undefined;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let trieNode = this;\n    for (; currentCodeByte <= code.length; currentCodeByte += 1) {\n      if (currentCodeByte === code.length) {\n        return trieNode.match;\n      }\n      const childNode = trieNode.childNodes.get(code[currentCodeByte]);\n      if (childNode === undefined) {\n        return trieNode;\n      }\n      trieNode = childNode;\n    }\n  }\n}\nclass ContractsIdentifier {\n  constructor(_enableCache = true) {\n    this._enableCache = _enableCache;\n    this._trie = new BytecodeTrie(-1);\n    this._cache = new Map();\n  }\n  addBytecode(bytecode) {\n    this._trie.add(bytecode);\n    this._cache.clear();\n  }\n  getBytecodeForCall(code, isCreate) {\n    const normalizedCode = (0, library_utils_1.normalizeLibraryRuntimeBytecodeIfNecessary)(code);\n    let normalizedCodeHex;\n    if (this._enableCache) {\n      normalizedCodeHex = (0, ethereumjs_util_1.bytesToHex)(normalizedCode);\n      const cached = this._cache.get(normalizedCodeHex);\n      if (cached !== undefined) {\n        return cached;\n      }\n    }\n    const result = this._searchBytecode(isCreate, normalizedCode);\n    if (this._enableCache) {\n      if (result !== undefined) {\n        this._cache.set(normalizedCodeHex, result);\n      }\n    }\n    return result;\n  }\n  _searchBytecode(isCreate, code, normalizeLibraries = true, trie = this._trie, firstByteToSearch = 0) {\n    const searchResult = trie.search(code, firstByteToSearch);\n    if (searchResult === undefined) {\n      return undefined;\n    }\n    if (!BytecodeTrie.isBytecodeTrie(searchResult)) {\n      return searchResult;\n    }\n    // Deployment messages have their abi-encoded arguments at the end of the bytecode.\n    //\n    // We don't know how long those arguments are, as we don't know which contract is being\n    // deployed, hence we don't know the signature of its constructor.\n    //\n    // To make things even harder, we can't trust that the user actually passed the right\n    // amount of arguments.\n    //\n    // Luckily, the chances of a complete deployment bytecode being the prefix of another one are\n    // remote. For example, most of the time it ends with its metadata hash, which will differ.\n    //\n    // We take advantage of this last observation, and just return the bytecode that exactly\n    // matched the searchResult (sub)trie that we got.\n    if (isCreate && searchResult.match !== undefined && searchResult.match.isDeployment) {\n      return searchResult.match;\n    }\n    if (normalizeLibraries) {\n      for (const bytecodeWithLibraries of searchResult.descendants) {\n        if (bytecodeWithLibraries.libraryAddressPositions.length === 0 && bytecodeWithLibraries.immutableReferences.length === 0) {\n          continue;\n        }\n        const normalizedLibrariesCode = (0, library_utils_1.zeroOutAddresses)(code, bytecodeWithLibraries.libraryAddressPositions);\n        const normalizedCode = (0, library_utils_1.zeroOutSlices)(normalizedLibrariesCode, bytecodeWithLibraries.immutableReferences);\n        const normalizedResult = this._searchBytecode(isCreate, normalizedCode, false, searchResult, searchResult.depth + 1);\n        if (normalizedResult !== undefined) {\n          return normalizedResult;\n        }\n      }\n    }\n    // If we got here we may still have the contract, but with a different metadata hash.\n    //\n    // We check if we got to match the entire executable bytecode, and are just stuck because\n    // of the metadata. If that's the case, we can assume that any descendant will be a valid\n    // Bytecode, so we just choose the most recently added one.\n    //\n    // The reason this works is because there's no chance that Solidity includes an entire\n    // bytecode (i.e. with metadata), as a prefix of another one.\n    if (this._isMatchingMetadata(code, searchResult.depth) && searchResult.descendants.length > 0) {\n      return searchResult.descendants[searchResult.descendants.length - 1];\n    }\n    return undefined;\n  }\n  /**\n   * Returns true if the lastByte is placed right when the metadata starts or after it.\n   */\n  _isMatchingMetadata(code, lastByte) {\n    for (let byte = 0; byte < lastByte;) {\n      const opcode = code[byte];\n      // Solidity always emits REVERT INVALID right before the metadata\n      if (opcode === opcodes_1.Opcode.REVERT && code[byte + 1] === opcodes_1.Opcode.INVALID) {\n        return true;\n      }\n      byte += (0, opcodes_1.getOpcodeLength)(opcode);\n    }\n    return false;\n  }\n}\nexports.ContractsIdentifier = ContractsIdentifier;","map":{"version":3,"names":["ethereumjs_util_1","require","library_utils_1","opcodes_1","BytecodeTrie","isBytecodeTrie","o","undefined","constructor","depth","childNodes","Map","descendants","add","bytecode","trieNode","currentCodeByte","normalizedCode","length","match","byte","push","childNode","get","set","search","code","ContractsIdentifier","_enableCache","_trie","_cache","addBytecode","clear","getBytecodeForCall","isCreate","normalizeLibraryRuntimeBytecodeIfNecessary","normalizedCodeHex","bytesToHex","cached","result","_searchBytecode","normalizeLibraries","trie","firstByteToSearch","searchResult","isDeployment","bytecodeWithLibraries","libraryAddressPositions","immutableReferences","normalizedLibrariesCode","zeroOutAddresses","zeroOutSlices","normalizedResult","_isMatchingMetadata","lastByte","opcode","Opcode","REVERT","INVALID","getOpcodeLength","exports"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\internal\\hardhat-network\\stack-traces\\contracts-identifier.ts"],"sourcesContent":["import { bytesToHex } from \"@nomicfoundation/ethereumjs-util\";\n\nimport {\n  normalizeLibraryRuntimeBytecodeIfNecessary,\n  zeroOutAddresses,\n  zeroOutSlices,\n} from \"./library-utils\";\nimport { Bytecode } from \"./model\";\nimport { getOpcodeLength, Opcode } from \"./opcodes\";\n\n/**\n * This class represent a somewhat special Trie of bytecodes.\n *\n * What makes it special is that every node has a set of all of its descendants and its depth.\n */\nclass BytecodeTrie {\n  public static isBytecodeTrie(o: any): o is BytecodeTrie {\n    if (o === undefined || o === null) {\n      return false;\n    }\n\n    return \"childNodes\" in o;\n  }\n\n  public readonly childNodes: Map<number, BytecodeTrie> = new Map();\n  public readonly descendants: Bytecode[] = [];\n  public match?: Bytecode;\n\n  constructor(public readonly depth: number) {}\n\n  public add(bytecode: Bytecode) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let trieNode: BytecodeTrie = this;\n    for (\n      let currentCodeByte = 0;\n      currentCodeByte <= bytecode.normalizedCode.length;\n      currentCodeByte += 1\n    ) {\n      if (currentCodeByte === bytecode.normalizedCode.length) {\n        // If multiple contracts with the exact same bytecode are added we keep the last of them.\n        // Note that this includes the metadata hash, so the chances of happening are pretty remote,\n        // except in super artificial cases that we have in our test suite.\n        trieNode.match = bytecode;\n        return;\n      }\n\n      const byte = bytecode.normalizedCode[currentCodeByte];\n      trieNode.descendants.push(bytecode);\n\n      let childNode = trieNode.childNodes.get(byte);\n      if (childNode === undefined) {\n        childNode = new BytecodeTrie(currentCodeByte);\n        trieNode.childNodes.set(byte, childNode);\n      }\n\n      trieNode = childNode;\n    }\n  }\n\n  /**\n   * Searches for a bytecode. If it's an exact match, it is returned. If there's no match, but a\n   * prefix of the code is found in the trie, the node of the longest prefix is returned. If the\n   * entire code is covered by the trie, and there's no match, we return undefined.\n   */\n  public search(\n    code: Uint8Array,\n    currentCodeByte: number = 0\n  ): Bytecode | BytecodeTrie | undefined {\n    if (currentCodeByte > code.length) {\n      return undefined;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let trieNode: BytecodeTrie = this;\n    for (; currentCodeByte <= code.length; currentCodeByte += 1) {\n      if (currentCodeByte === code.length) {\n        return trieNode.match;\n      }\n\n      const childNode = trieNode.childNodes.get(code[currentCodeByte]);\n\n      if (childNode === undefined) {\n        return trieNode;\n      }\n\n      trieNode = childNode;\n    }\n  }\n}\n\nexport class ContractsIdentifier {\n  private _trie = new BytecodeTrie(-1);\n  private _cache: Map<string, Bytecode> = new Map();\n\n  constructor(private readonly _enableCache = true) {}\n\n  public addBytecode(bytecode: Bytecode) {\n    this._trie.add(bytecode);\n    this._cache.clear();\n  }\n\n  public getBytecodeForCall(\n    code: Uint8Array,\n    isCreate: boolean\n  ): Bytecode | undefined {\n    const normalizedCode = normalizeLibraryRuntimeBytecodeIfNecessary(code);\n\n    let normalizedCodeHex: string | undefined;\n    if (this._enableCache) {\n      normalizedCodeHex = bytesToHex(normalizedCode);\n      const cached = this._cache.get(normalizedCodeHex);\n\n      if (cached !== undefined) {\n        return cached;\n      }\n    }\n\n    const result = this._searchBytecode(isCreate, normalizedCode);\n\n    if (this._enableCache) {\n      if (result !== undefined) {\n        this._cache.set(normalizedCodeHex!, result);\n      }\n    }\n\n    return result;\n  }\n\n  private _searchBytecode(\n    isCreate: boolean,\n    code: Uint8Array,\n    normalizeLibraries = true,\n    trie = this._trie,\n    firstByteToSearch = 0\n  ): Bytecode | undefined {\n    const searchResult = trie.search(code, firstByteToSearch);\n\n    if (searchResult === undefined) {\n      return undefined;\n    }\n\n    if (!BytecodeTrie.isBytecodeTrie(searchResult)) {\n      return searchResult;\n    }\n\n    // Deployment messages have their abi-encoded arguments at the end of the bytecode.\n    //\n    // We don't know how long those arguments are, as we don't know which contract is being\n    // deployed, hence we don't know the signature of its constructor.\n    //\n    // To make things even harder, we can't trust that the user actually passed the right\n    // amount of arguments.\n    //\n    // Luckily, the chances of a complete deployment bytecode being the prefix of another one are\n    // remote. For example, most of the time it ends with its metadata hash, which will differ.\n    //\n    // We take advantage of this last observation, and just return the bytecode that exactly\n    // matched the searchResult (sub)trie that we got.\n    if (\n      isCreate &&\n      searchResult.match !== undefined &&\n      searchResult.match.isDeployment\n    ) {\n      return searchResult.match;\n    }\n\n    if (normalizeLibraries) {\n      for (const bytecodeWithLibraries of searchResult.descendants) {\n        if (\n          bytecodeWithLibraries.libraryAddressPositions.length === 0 &&\n          bytecodeWithLibraries.immutableReferences.length === 0\n        ) {\n          continue;\n        }\n\n        const normalizedLibrariesCode = zeroOutAddresses(\n          code,\n          bytecodeWithLibraries.libraryAddressPositions\n        );\n\n        const normalizedCode = zeroOutSlices(\n          normalizedLibrariesCode,\n          bytecodeWithLibraries.immutableReferences\n        );\n\n        const normalizedResult = this._searchBytecode(\n          isCreate,\n          normalizedCode,\n          false,\n          searchResult,\n          searchResult.depth + 1\n        );\n\n        if (normalizedResult !== undefined) {\n          return normalizedResult;\n        }\n      }\n    }\n\n    // If we got here we may still have the contract, but with a different metadata hash.\n    //\n    // We check if we got to match the entire executable bytecode, and are just stuck because\n    // of the metadata. If that's the case, we can assume that any descendant will be a valid\n    // Bytecode, so we just choose the most recently added one.\n    //\n    // The reason this works is because there's no chance that Solidity includes an entire\n    // bytecode (i.e. with metadata), as a prefix of another one.\n    if (\n      this._isMatchingMetadata(code, searchResult.depth) &&\n      searchResult.descendants.length > 0\n    ) {\n      return searchResult.descendants[searchResult.descendants.length - 1];\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Returns true if the lastByte is placed right when the metadata starts or after it.\n   */\n  private _isMatchingMetadata(code: Uint8Array, lastByte: number): boolean {\n    for (let byte = 0; byte < lastByte; ) {\n      const opcode = code[byte];\n\n      // Solidity always emits REVERT INVALID right before the metadata\n      if (opcode === Opcode.REVERT && code[byte + 1] === Opcode.INVALID) {\n        return true;\n      }\n\n      byte += getOpcodeLength(opcode);\n    }\n\n    return false;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}