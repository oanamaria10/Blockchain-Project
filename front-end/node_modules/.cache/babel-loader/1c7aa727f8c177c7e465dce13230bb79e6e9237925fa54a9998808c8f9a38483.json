{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lazyFunction = exports.lazyObject = void 0;\nconst util_1 = __importDefault(require(\"util\"));\nconst errors_1 = require(\"../core/errors\");\nconst errors_list_1 = require(\"../core/errors-list\");\nconst inspect = Symbol.for(\"nodejs.util.inspect.custom\");\n/**\n * This module provides function to implement proxy-based object, functions, and\n * classes (they are functions). They receive an initializer function that it's\n * not used until someone interacts with the lazy element.\n *\n * This functions can also be used like a lazy `require`, creating a proxy that\n * doesn't require the module until needed.\n *\n * The disadvantage of using this technique is that the type information is\n * lost wrt `import`, as `require` returns an `any. If done with enough care,\n * this can be manually fixed.\n *\n * TypeScript doesn't emit `require` calls for modules that are imported only\n * because of their types. So if one uses lazyObject or lazyFunction along with\n * a normal ESM import you can pass the module's type to this function.\n *\n * An example of this can be:\n *\n *    import findUpT from \"find-up\";\n *    export const findUp = lazyFunction<typeof findUpT>(() => require(\"find-up\"));\n *\n * You can also use it with named exports:\n *\n *    import { EthT } from \"web3x/eth\";\n *    const Eth = lazyFunction<typeof EthT>(() => require(\"web3x/eth\").Eth);\n */\nfunction lazyObject(objectCreator) {\n  return createLazyProxy(objectCreator, getRealTarget => ({\n    [inspect](depth, options, inspectFn = util_1.default.inspect) {\n      const realTarget = getRealTarget();\n      const newOptions = {\n        ...options,\n        depth\n      };\n      return inspectFn(realTarget, newOptions);\n    }\n  }), object => {\n    if (object instanceof Function) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n        operation: \"Creating lazy functions or classes with lazyObject\"\n      });\n    }\n    if (typeof object !== \"object\" || object === null) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n        operation: \"Using lazyObject with anything other than objects\"\n      });\n    }\n  });\n}\nexports.lazyObject = lazyObject;\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction lazyFunction(functionCreator) {\n  return createLazyProxy(functionCreator, getRealTarget => {\n    function dummyTarget() {}\n    dummyTarget[inspect] = function (depth, options, inspectFn = util_1.default.inspect) {\n      const realTarget = getRealTarget();\n      const newOptions = {\n        ...options,\n        depth\n      };\n      return inspectFn(realTarget, newOptions);\n    };\n    return dummyTarget;\n  }, object => {\n    if (!(object instanceof Function)) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n        operation: \"Using lazyFunction with anything other than functions or classes\"\n      });\n    }\n  });\n}\nexports.lazyFunction = lazyFunction;\nfunction createLazyProxy(targetCreator, dummyTargetCreator, validator) {\n  let realTarget;\n  const dummyTarget = dummyTargetCreator(getRealTarget);\n  function getRealTarget() {\n    if (realTarget === undefined) {\n      const target = targetCreator();\n      validator(target);\n      // We copy all properties. We won't use them, but help us avoid Proxy\n      // invariant violations\n      const properties = Object.getOwnPropertyNames(target);\n      for (const property of properties) {\n        const descriptor = Object.getOwnPropertyDescriptor(target, property);\n        Object.defineProperty(dummyTarget, property, descriptor);\n      }\n      Object.setPrototypeOf(dummyTarget, Object.getPrototypeOf(target));\n      // Using a null prototype seems to tirgger a V8 bug, so we forbid it\n      // See: https://github.com/nodejs/node/issues/29730\n      if (Object.getPrototypeOf(target) === null) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n          operation: \"Using lazyFunction or lazyObject to construct objects/functions with prototype null\"\n        });\n      }\n      if (!Object.isExtensible(target)) {\n        Object.preventExtensions(dummyTarget);\n      }\n      realTarget = target;\n    }\n    return realTarget;\n  }\n  const handler = {\n    defineProperty(target, property, descriptor) {\n      Reflect.defineProperty(dummyTarget, property, descriptor);\n      return Reflect.defineProperty(getRealTarget(), property, descriptor);\n    },\n    deleteProperty(target, property) {\n      Reflect.deleteProperty(dummyTarget, property);\n      return Reflect.deleteProperty(getRealTarget(), property);\n    },\n    get(target, property, receiver) {\n      // We have this short-circuit logic here to avoid a cyclic require when\n      // loading Web3.js.\n      //\n      // If a lazy object is somehow accessed while its real target is being\n      // created, it would trigger an endless loop of recreation, which node\n      // detects and resolve to an empty object.\n      //\n      // This happens with Web3.js because we a lazyObject that loads it,\n      // and expose it as `global.web3`. This Web3.js file accesses\n      // `global.web3` when it's being loaded, triggering the loop we mentioned\n      // before: https://github.com/ethereum/web3.js/blob/8574bd3bf11a2e9cf4bcf8850cab13e1db56653f/packages/web3-core-requestmanager/src/givenProvider.js#L41\n      //\n      // We just return `undefined` in that case, to not enter into the loop.\n      //\n      // **SUPER IMPORTANT NOTE:** Removing this is very tempting, I know. This\n      // is a horrible hack. The most obvious approach for doing so is to\n      // remove the `global` elements that trigger this crazy behavior right\n      // before doing our `require(\"web3\")`, and restore them afterwards.\n      // **THIS IS NOT ENOUGH** Users, and libraries (!!!!), will have their own\n      // `require`s that we can't control and will trigger the same bug.\n      const stack = new Error().stack;\n      if (stack !== undefined && stack.includes(\"givenProvider.js\") && realTarget === undefined) {\n        return undefined;\n      }\n      return Reflect.get(getRealTarget(), property, receiver);\n    },\n    getOwnPropertyDescriptor(target, property) {\n      const descriptor = Reflect.getOwnPropertyDescriptor(getRealTarget(), property);\n      if (descriptor !== undefined) {\n        Object.defineProperty(dummyTarget, property, descriptor);\n      }\n      return descriptor;\n    },\n    getPrototypeOf(_target) {\n      return Reflect.getPrototypeOf(getRealTarget());\n    },\n    has(target, property) {\n      return Reflect.has(getRealTarget(), property);\n    },\n    isExtensible(_target) {\n      return Reflect.isExtensible(getRealTarget());\n    },\n    ownKeys(_target) {\n      return Reflect.ownKeys(getRealTarget());\n    },\n    preventExtensions(_target) {\n      Object.preventExtensions(dummyTarget);\n      return Reflect.preventExtensions(getRealTarget());\n    },\n    set(target, property, value, receiver) {\n      Reflect.set(dummyTarget, property, value, receiver);\n      return Reflect.set(getRealTarget(), property, value, receiver);\n    },\n    setPrototypeOf(target, prototype) {\n      Reflect.setPrototypeOf(dummyTarget, prototype);\n      return Reflect.setPrototypeOf(getRealTarget(), prototype);\n    }\n  };\n  if (dummyTarget instanceof Function) {\n    // If dummy target is a function, the actual target must be a function too.\n    handler.apply = (target, thisArg, argArray) => {\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      return Reflect.apply(getRealTarget(), thisArg, argArray);\n    };\n    handler.construct = (target, argArray, _newTarget) => {\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      return Reflect.construct(getRealTarget(), argArray);\n    };\n  }\n  return new Proxy(dummyTarget, handler);\n}","map":{"version":3,"names":["util_1","__importDefault","require","errors_1","errors_list_1","inspect","Symbol","for","lazyObject","objectCreator","createLazyProxy","getRealTarget","depth","options","inspectFn","default","realTarget","newOptions","object","Function","HardhatError","ERRORS","GENERAL","UNSUPPORTED_OPERATION","operation","exports","lazyFunction","functionCreator","dummyTarget","targetCreator","dummyTargetCreator","validator","undefined","target","properties","Object","getOwnPropertyNames","property","descriptor","getOwnPropertyDescriptor","defineProperty","setPrototypeOf","getPrototypeOf","isExtensible","preventExtensions","handler","Reflect","deleteProperty","get","receiver","stack","Error","includes","_target","has","ownKeys","set","value","prototype","apply","thisArg","argArray","construct","_newTarget","Proxy"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\internal\\util\\lazy.ts"],"sourcesContent":["import util, { InspectOptions } from \"util\";\n\nimport { HardhatError } from \"../core/errors\";\nimport { ERRORS } from \"../core/errors-list\";\n\nconst inspect = Symbol.for(\"nodejs.util.inspect.custom\");\n\n/**\n * This module provides function to implement proxy-based object, functions, and\n * classes (they are functions). They receive an initializer function that it's\n * not used until someone interacts with the lazy element.\n *\n * This functions can also be used like a lazy `require`, creating a proxy that\n * doesn't require the module until needed.\n *\n * The disadvantage of using this technique is that the type information is\n * lost wrt `import`, as `require` returns an `any. If done with enough care,\n * this can be manually fixed.\n *\n * TypeScript doesn't emit `require` calls for modules that are imported only\n * because of their types. So if one uses lazyObject or lazyFunction along with\n * a normal ESM import you can pass the module's type to this function.\n *\n * An example of this can be:\n *\n *    import findUpT from \"find-up\";\n *    export const findUp = lazyFunction<typeof findUpT>(() => require(\"find-up\"));\n *\n * You can also use it with named exports:\n *\n *    import { EthT } from \"web3x/eth\";\n *    const Eth = lazyFunction<typeof EthT>(() => require(\"web3x/eth\").Eth);\n */\n\nexport function lazyObject<T extends object>(objectCreator: () => T): T {\n  return createLazyProxy(\n    objectCreator,\n    (getRealTarget) => ({\n      [inspect](\n        depth: number,\n        options: InspectOptions,\n        inspectFn: (\n          object: any,\n          options: InspectOptions\n        ) => string = util.inspect\n      ) {\n        const realTarget = getRealTarget();\n        const newOptions = { ...options, depth };\n        return inspectFn(realTarget, newOptions);\n      },\n    }),\n    (object) => {\n      if (object instanceof Function) {\n        throw new HardhatError(ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n          operation: \"Creating lazy functions or classes with lazyObject\",\n        });\n      }\n\n      if (typeof object !== \"object\" || object === null) {\n        throw new HardhatError(ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n          operation: \"Using lazyObject with anything other than objects\",\n        });\n      }\n    }\n  );\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function lazyFunction<T extends Function>(functionCreator: () => T): T {\n  return createLazyProxy(\n    functionCreator,\n    (getRealTarget) => {\n      function dummyTarget() {}\n\n      (dummyTarget as any)[inspect] = function (\n        depth: number,\n        options: InspectOptions,\n        inspectFn: (\n          object: any,\n          options: InspectOptions\n        ) => string = util.inspect\n      ) {\n        const realTarget = getRealTarget();\n        const newOptions = { ...options, depth };\n        return inspectFn(realTarget, newOptions);\n      };\n\n      return dummyTarget;\n    },\n    (object) => {\n      if (!(object instanceof Function)) {\n        throw new HardhatError(ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n          operation:\n            \"Using lazyFunction with anything other than functions or classes\",\n        });\n      }\n    }\n  );\n}\n\nfunction createLazyProxy<ActualT extends GuardT, GuardT extends object>(\n  targetCreator: () => ActualT,\n  dummyTargetCreator: (getRealTarget: () => ActualT) => GuardT,\n  validator: (target: any) => void\n): ActualT {\n  let realTarget: ActualT | undefined;\n\n  const dummyTarget: ActualT = dummyTargetCreator(getRealTarget) as any;\n\n  function getRealTarget(): ActualT {\n    if (realTarget === undefined) {\n      const target = targetCreator();\n      validator(target);\n\n      // We copy all properties. We won't use them, but help us avoid Proxy\n      // invariant violations\n      const properties = Object.getOwnPropertyNames(target);\n      for (const property of properties) {\n        const descriptor = Object.getOwnPropertyDescriptor(target, property)!;\n        Object.defineProperty(dummyTarget, property, descriptor);\n      }\n\n      Object.setPrototypeOf(dummyTarget, Object.getPrototypeOf(target));\n\n      // Using a null prototype seems to tirgger a V8 bug, so we forbid it\n      // See: https://github.com/nodejs/node/issues/29730\n      if (Object.getPrototypeOf(target) === null) {\n        throw new HardhatError(ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n          operation:\n            \"Using lazyFunction or lazyObject to construct objects/functions with prototype null\",\n        });\n      }\n\n      if (!Object.isExtensible(target)) {\n        Object.preventExtensions(dummyTarget);\n      }\n\n      realTarget = target;\n    }\n\n    return realTarget;\n  }\n\n  const handler: ProxyHandler<ActualT> = {\n    defineProperty(target, property, descriptor) {\n      Reflect.defineProperty(dummyTarget, property, descriptor);\n      return Reflect.defineProperty(getRealTarget(), property, descriptor);\n    },\n\n    deleteProperty(target, property) {\n      Reflect.deleteProperty(dummyTarget, property);\n      return Reflect.deleteProperty(getRealTarget(), property);\n    },\n\n    get(target, property, receiver) {\n      // We have this short-circuit logic here to avoid a cyclic require when\n      // loading Web3.js.\n      //\n      // If a lazy object is somehow accessed while its real target is being\n      // created, it would trigger an endless loop of recreation, which node\n      // detects and resolve to an empty object.\n      //\n      // This happens with Web3.js because we a lazyObject that loads it,\n      // and expose it as `global.web3`. This Web3.js file accesses\n      // `global.web3` when it's being loaded, triggering the loop we mentioned\n      // before: https://github.com/ethereum/web3.js/blob/8574bd3bf11a2e9cf4bcf8850cab13e1db56653f/packages/web3-core-requestmanager/src/givenProvider.js#L41\n      //\n      // We just return `undefined` in that case, to not enter into the loop.\n      //\n      // **SUPER IMPORTANT NOTE:** Removing this is very tempting, I know. This\n      // is a horrible hack. The most obvious approach for doing so is to\n      // remove the `global` elements that trigger this crazy behavior right\n      // before doing our `require(\"web3\")`, and restore them afterwards.\n      // **THIS IS NOT ENOUGH** Users, and libraries (!!!!), will have their own\n      // `require`s that we can't control and will trigger the same bug.\n      const stack = new Error().stack;\n      if (\n        stack !== undefined &&\n        stack.includes(\"givenProvider.js\") &&\n        realTarget === undefined\n      ) {\n        return undefined;\n      }\n\n      return Reflect.get(getRealTarget(), property, receiver);\n    },\n\n    getOwnPropertyDescriptor(target, property) {\n      const descriptor = Reflect.getOwnPropertyDescriptor(\n        getRealTarget(),\n        property\n      );\n\n      if (descriptor !== undefined) {\n        Object.defineProperty(dummyTarget, property, descriptor);\n      }\n\n      return descriptor;\n    },\n\n    getPrototypeOf(_target) {\n      return Reflect.getPrototypeOf(getRealTarget());\n    },\n\n    has(target, property) {\n      return Reflect.has(getRealTarget(), property);\n    },\n\n    isExtensible(_target) {\n      return Reflect.isExtensible(getRealTarget());\n    },\n\n    ownKeys(_target) {\n      return Reflect.ownKeys(getRealTarget());\n    },\n\n    preventExtensions(_target) {\n      Object.preventExtensions(dummyTarget);\n      return Reflect.preventExtensions(getRealTarget());\n    },\n\n    set(target, property, value, receiver) {\n      Reflect.set(dummyTarget, property, value, receiver);\n      return Reflect.set(getRealTarget(), property, value, receiver);\n    },\n\n    setPrototypeOf(target, prototype) {\n      Reflect.setPrototypeOf(dummyTarget, prototype);\n      return Reflect.setPrototypeOf(getRealTarget(), prototype);\n    },\n  };\n\n  if (dummyTarget instanceof Function) {\n    // If dummy target is a function, the actual target must be a function too.\n    handler.apply = (target, thisArg: any, argArray?: any) => {\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      return Reflect.apply(getRealTarget() as Function, thisArg, argArray);\n    };\n\n    handler.construct = (target, argArray: any, _newTarget?: any) => {\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      return Reflect.construct(getRealTarget() as Function, argArray);\n    };\n  }\n\n  return new Proxy(dummyTarget, handler);\n}\n"],"mappings":";;;;;;;;;;;AAAA,MAAAA,MAAA,GAAAC,eAAA,CAAAC,OAAA;AAEA,MAAAC,QAAA,GAAAD,OAAA;AACA,MAAAE,aAAA,GAAAF,OAAA;AAEA,MAAMG,OAAO,GAAGC,MAAM,CAACC,GAAG,CAAC,4BAA4B,CAAC;AAExD;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA,SAAgBC,UAAUA,CAAmBC,aAAsB;EACjE,OAAOC,eAAe,CACpBD,aAAa,EACZE,aAAa,KAAM;IAClB,CAACN,OAAO,EACNO,KAAa,EACbC,OAAuB,EACvBC,SAAA,GAGcd,MAAA,CAAAe,OAAI,CAACV,OAAO;MAE1B,MAAMW,UAAU,GAAGL,aAAa,EAAE;MAClC,MAAMM,UAAU,GAAG;QAAE,GAAGJ,OAAO;QAAED;MAAK,CAAE;MACxC,OAAOE,SAAS,CAACE,UAAU,EAAEC,UAAU,CAAC;IAC1C;GACD,CAAC,EACDC,MAAM,IAAI;IACT,IAAIA,MAAM,YAAYC,QAAQ,EAAE;MAC9B,MAAM,IAAIhB,QAAA,CAAAiB,YAAY,CAAChB,aAAA,CAAAiB,MAAM,CAACC,OAAO,CAACC,qBAAqB,EAAE;QAC3DC,SAAS,EAAE;OACZ,CAAC;;IAGJ,IAAI,OAAON,MAAM,KAAK,QAAQ,IAAIA,MAAM,KAAK,IAAI,EAAE;MACjD,MAAM,IAAIf,QAAA,CAAAiB,YAAY,CAAChB,aAAA,CAAAiB,MAAM,CAACC,OAAO,CAACC,qBAAqB,EAAE;QAC3DC,SAAS,EAAE;OACZ,CAAC;;EAEN,CAAC,CACF;AACH;AA/BAC,OAAA,CAAAjB,UAAA,GAAAA,UAAA;AAiCA;AACA,SAAgBkB,YAAYA,CAAqBC,eAAwB;EACvE,OAAOjB,eAAe,CACpBiB,eAAe,EACdhB,aAAa,IAAI;IAChB,SAASiB,WAAWA,CAAA,GAAI;IAEvBA,WAAmB,CAACvB,OAAO,CAAC,GAAG,UAC9BO,KAAa,EACbC,OAAuB,EACvBC,SAAA,GAGcd,MAAA,CAAAe,OAAI,CAACV,OAAO;MAE1B,MAAMW,UAAU,GAAGL,aAAa,EAAE;MAClC,MAAMM,UAAU,GAAG;QAAE,GAAGJ,OAAO;QAAED;MAAK,CAAE;MACxC,OAAOE,SAAS,CAACE,UAAU,EAAEC,UAAU,CAAC;IAC1C,CAAC;IAED,OAAOW,WAAW;EACpB,CAAC,EACAV,MAAM,IAAI;IACT,IAAI,EAAEA,MAAM,YAAYC,QAAQ,CAAC,EAAE;MACjC,MAAM,IAAIhB,QAAA,CAAAiB,YAAY,CAAChB,aAAA,CAAAiB,MAAM,CAACC,OAAO,CAACC,qBAAqB,EAAE;QAC3DC,SAAS,EACP;OACH,CAAC;;EAEN,CAAC,CACF;AACH;AA9BAC,OAAA,CAAAC,YAAA,GAAAA,YAAA;AAgCA,SAAShB,eAAeA,CACtBmB,aAA4B,EAC5BC,kBAA4D,EAC5DC,SAAgC;EAEhC,IAAIf,UAA+B;EAEnC,MAAMY,WAAW,GAAYE,kBAAkB,CAACnB,aAAa,CAAQ;EAErE,SAASA,aAAaA,CAAA;IACpB,IAAIK,UAAU,KAAKgB,SAAS,EAAE;MAC5B,MAAMC,MAAM,GAAGJ,aAAa,EAAE;MAC9BE,SAAS,CAACE,MAAM,CAAC;MAEjB;MACA;MACA,MAAMC,UAAU,GAAGC,MAAM,CAACC,mBAAmB,CAACH,MAAM,CAAC;MACrD,KAAK,MAAMI,QAAQ,IAAIH,UAAU,EAAE;QACjC,MAAMI,UAAU,GAAGH,MAAM,CAACI,wBAAwB,CAACN,MAAM,EAAEI,QAAQ,CAAE;QACrEF,MAAM,CAACK,cAAc,CAACZ,WAAW,EAAES,QAAQ,EAAEC,UAAU,CAAC;;MAG1DH,MAAM,CAACM,cAAc,CAACb,WAAW,EAAEO,MAAM,CAACO,cAAc,CAACT,MAAM,CAAC,CAAC;MAEjE;MACA;MACA,IAAIE,MAAM,CAACO,cAAc,CAACT,MAAM,CAAC,KAAK,IAAI,EAAE;QAC1C,MAAM,IAAI9B,QAAA,CAAAiB,YAAY,CAAChB,aAAA,CAAAiB,MAAM,CAACC,OAAO,CAACC,qBAAqB,EAAE;UAC3DC,SAAS,EACP;SACH,CAAC;;MAGJ,IAAI,CAACW,MAAM,CAACQ,YAAY,CAACV,MAAM,CAAC,EAAE;QAChCE,MAAM,CAACS,iBAAiB,CAAChB,WAAW,CAAC;;MAGvCZ,UAAU,GAAGiB,MAAM;;IAGrB,OAAOjB,UAAU;EACnB;EAEA,MAAM6B,OAAO,GAA0B;IACrCL,cAAcA,CAACP,MAAM,EAAEI,QAAQ,EAAEC,UAAU;MACzCQ,OAAO,CAACN,cAAc,CAACZ,WAAW,EAAES,QAAQ,EAAEC,UAAU,CAAC;MACzD,OAAOQ,OAAO,CAACN,cAAc,CAAC7B,aAAa,EAAE,EAAE0B,QAAQ,EAAEC,UAAU,CAAC;IACtE,CAAC;IAEDS,cAAcA,CAACd,MAAM,EAAEI,QAAQ;MAC7BS,OAAO,CAACC,cAAc,CAACnB,WAAW,EAAES,QAAQ,CAAC;MAC7C,OAAOS,OAAO,CAACC,cAAc,CAACpC,aAAa,EAAE,EAAE0B,QAAQ,CAAC;IAC1D,CAAC;IAEDW,GAAGA,CAACf,MAAM,EAAEI,QAAQ,EAAEY,QAAQ;MAC5B;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,MAAMC,KAAK,GAAG,IAAIC,KAAK,EAAE,CAACD,KAAK;MAC/B,IACEA,KAAK,KAAKlB,SAAS,IACnBkB,KAAK,CAACE,QAAQ,CAAC,kBAAkB,CAAC,IAClCpC,UAAU,KAAKgB,SAAS,EACxB;QACA,OAAOA,SAAS;;MAGlB,OAAOc,OAAO,CAACE,GAAG,CAACrC,aAAa,EAAE,EAAE0B,QAAQ,EAAEY,QAAQ,CAAC;IACzD,CAAC;IAEDV,wBAAwBA,CAACN,MAAM,EAAEI,QAAQ;MACvC,MAAMC,UAAU,GAAGQ,OAAO,CAACP,wBAAwB,CACjD5B,aAAa,EAAE,EACf0B,QAAQ,CACT;MAED,IAAIC,UAAU,KAAKN,SAAS,EAAE;QAC5BG,MAAM,CAACK,cAAc,CAACZ,WAAW,EAAES,QAAQ,EAAEC,UAAU,CAAC;;MAG1D,OAAOA,UAAU;IACnB,CAAC;IAEDI,cAAcA,CAACW,OAAO;MACpB,OAAOP,OAAO,CAACJ,cAAc,CAAC/B,aAAa,EAAE,CAAC;IAChD,CAAC;IAED2C,GAAGA,CAACrB,MAAM,EAAEI,QAAQ;MAClB,OAAOS,OAAO,CAACQ,GAAG,CAAC3C,aAAa,EAAE,EAAE0B,QAAQ,CAAC;IAC/C,CAAC;IAEDM,YAAYA,CAACU,OAAO;MAClB,OAAOP,OAAO,CAACH,YAAY,CAAChC,aAAa,EAAE,CAAC;IAC9C,CAAC;IAED4C,OAAOA,CAACF,OAAO;MACb,OAAOP,OAAO,CAACS,OAAO,CAAC5C,aAAa,EAAE,CAAC;IACzC,CAAC;IAEDiC,iBAAiBA,CAACS,OAAO;MACvBlB,MAAM,CAACS,iBAAiB,CAAChB,WAAW,CAAC;MACrC,OAAOkB,OAAO,CAACF,iBAAiB,CAACjC,aAAa,EAAE,CAAC;IACnD,CAAC;IAED6C,GAAGA,CAACvB,MAAM,EAAEI,QAAQ,EAAEoB,KAAK,EAAER,QAAQ;MACnCH,OAAO,CAACU,GAAG,CAAC5B,WAAW,EAAES,QAAQ,EAAEoB,KAAK,EAAER,QAAQ,CAAC;MACnD,OAAOH,OAAO,CAACU,GAAG,CAAC7C,aAAa,EAAE,EAAE0B,QAAQ,EAAEoB,KAAK,EAAER,QAAQ,CAAC;IAChE,CAAC;IAEDR,cAAcA,CAACR,MAAM,EAAEyB,SAAS;MAC9BZ,OAAO,CAACL,cAAc,CAACb,WAAW,EAAE8B,SAAS,CAAC;MAC9C,OAAOZ,OAAO,CAACL,cAAc,CAAC9B,aAAa,EAAE,EAAE+C,SAAS,CAAC;IAC3D;GACD;EAED,IAAI9B,WAAW,YAAYT,QAAQ,EAAE;IACnC;IACA0B,OAAO,CAACc,KAAK,GAAG,CAAC1B,MAAM,EAAE2B,OAAY,EAAEC,QAAc,KAAI;MACvD;MACA,OAAOf,OAAO,CAACa,KAAK,CAAChD,aAAa,EAAc,EAAEiD,OAAO,EAAEC,QAAQ,CAAC;IACtE,CAAC;IAEDhB,OAAO,CAACiB,SAAS,GAAG,CAAC7B,MAAM,EAAE4B,QAAa,EAAEE,UAAgB,KAAI;MAC9D;MACA,OAAOjB,OAAO,CAACgB,SAAS,CAACnD,aAAa,EAAc,EAAEkD,QAAQ,CAAC;IACjE,CAAC;;EAGH,OAAO,IAAIG,KAAK,CAACpC,WAAW,EAAEiB,OAAO,CAAC;AACxC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}