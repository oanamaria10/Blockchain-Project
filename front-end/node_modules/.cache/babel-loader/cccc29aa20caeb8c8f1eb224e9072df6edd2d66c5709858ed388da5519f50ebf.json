{"ast":null,"code":"// https://github.com/Ethan-Arrowood/undici-fetch\n\n'use strict';\n\nconst {\n  kHeadersList,\n  kConstruct\n} = require('../core/symbols');\nconst {\n  kGuard\n} = require('./symbols');\nconst {\n  kEnumerableProperty\n} = require('../core/util');\nconst {\n  makeIterator,\n  isValidHeaderName,\n  isValidHeaderValue\n} = require('./util');\nconst {\n  webidl\n} = require('./webidl');\nconst assert = require('assert');\nconst kHeadersMap = Symbol('headers map');\nconst kHeadersSortedMap = Symbol('headers map sorted');\n\n/**\n * @param {number} code\n */\nfunction isHTTPWhiteSpaceCharCode(code) {\n  return code === 0x00a || code === 0x00d || code === 0x009 || code === 0x020;\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-value-normalize\n * @param {string} potentialValue\n */\nfunction headerValueNormalize(potentialValue) {\n  //  To normalize a byte sequence potentialValue, remove\n  //  any leading and trailing HTTP whitespace bytes from\n  //  potentialValue.\n  let i = 0;\n  let j = potentialValue.length;\n  while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j;\n  while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i))) ++i;\n  return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);\n}\nfunction fill(headers, object) {\n  // To fill a Headers object headers with a given object object, run these steps:\n\n  // 1. If object is a sequence, then for each header in object:\n  // Note: webidl conversion to array has already been done.\n  if (Array.isArray(object)) {\n    for (let i = 0; i < object.length; ++i) {\n      const header = object[i];\n      // 1. If header does not contain exactly two items, then throw a TypeError.\n      if (header.length !== 2) {\n        throw webidl.errors.exception({\n          header: 'Headers constructor',\n          message: `expected name/value pair to be length 2, found ${header.length}.`\n        });\n      }\n\n      // 2. Append (header’s first item, header’s second item) to headers.\n      appendHeader(headers, header[0], header[1]);\n    }\n  } else if (typeof object === 'object' && object !== null) {\n    // Note: null should throw\n\n    // 2. Otherwise, object is a record, then for each key → value in object,\n    //    append (key, value) to headers\n    const keys = Object.keys(object);\n    for (let i = 0; i < keys.length; ++i) {\n      appendHeader(headers, keys[i], object[keys[i]]);\n    }\n  } else {\n    throw webidl.errors.conversionFailed({\n      prefix: 'Headers constructor',\n      argument: 'Argument 1',\n      types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']\n    });\n  }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-headers-append\n */\nfunction appendHeader(headers, name, value) {\n  // 1. Normalize value.\n  value = headerValueNormalize(value);\n\n  // 2. If name is not a header name or value is not a\n  //    header value, then throw a TypeError.\n  if (!isValidHeaderName(name)) {\n    throw webidl.errors.invalidArgument({\n      prefix: 'Headers.append',\n      value: name,\n      type: 'header name'\n    });\n  } else if (!isValidHeaderValue(value)) {\n    throw webidl.errors.invalidArgument({\n      prefix: 'Headers.append',\n      value,\n      type: 'header value'\n    });\n  }\n\n  // 3. If headers’s guard is \"immutable\", then throw a TypeError.\n  // 4. Otherwise, if headers’s guard is \"request\" and name is a\n  //    forbidden header name, return.\n  // Note: undici does not implement forbidden header names\n  if (headers[kGuard] === 'immutable') {\n    throw new TypeError('immutable');\n  } else if (headers[kGuard] === 'request-no-cors') {\n    // 5. Otherwise, if headers’s guard is \"request-no-cors\":\n    // TODO\n  }\n\n  // 6. Otherwise, if headers’s guard is \"response\" and name is a\n  //    forbidden response-header name, return.\n\n  // 7. Append (name, value) to headers’s header list.\n  return headers[kHeadersList].append(name, value);\n\n  // 8. If headers’s guard is \"request-no-cors\", then remove\n  //    privileged no-CORS request headers from headers\n}\nclass HeadersList {\n  /** @type {[string, string][]|null} */\n  cookies = null;\n  constructor(init) {\n    if (init instanceof HeadersList) {\n      this[kHeadersMap] = new Map(init[kHeadersMap]);\n      this[kHeadersSortedMap] = init[kHeadersSortedMap];\n      this.cookies = init.cookies === null ? null : [...init.cookies];\n    } else {\n      this[kHeadersMap] = new Map(init);\n      this[kHeadersSortedMap] = null;\n    }\n  }\n\n  // https://fetch.spec.whatwg.org/#header-list-contains\n  contains(name) {\n    // A header list list contains a header name name if list\n    // contains a header whose name is a byte-case-insensitive\n    // match for name.\n    name = name.toLowerCase();\n    return this[kHeadersMap].has(name);\n  }\n  clear() {\n    this[kHeadersMap].clear();\n    this[kHeadersSortedMap] = null;\n    this.cookies = null;\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-append\n  append(name, value) {\n    this[kHeadersSortedMap] = null;\n\n    // 1. If list contains name, then set name to the first such\n    //    header’s name.\n    const lowercaseName = name.toLowerCase();\n    const exists = this[kHeadersMap].get(lowercaseName);\n\n    // 2. Append (name, value) to list.\n    if (exists) {\n      const delimiter = lowercaseName === 'cookie' ? '; ' : ', ';\n      this[kHeadersMap].set(lowercaseName, {\n        name: exists.name,\n        value: `${exists.value}${delimiter}${value}`\n      });\n    } else {\n      this[kHeadersMap].set(lowercaseName, {\n        name,\n        value\n      });\n    }\n    if (lowercaseName === 'set-cookie') {\n      this.cookies ??= [];\n      this.cookies.push(value);\n    }\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-set\n  set(name, value) {\n    this[kHeadersSortedMap] = null;\n    const lowercaseName = name.toLowerCase();\n    if (lowercaseName === 'set-cookie') {\n      this.cookies = [value];\n    }\n\n    // 1. If list contains name, then set the value of\n    //    the first such header to value and remove the\n    //    others.\n    // 2. Otherwise, append header (name, value) to list.\n    this[kHeadersMap].set(lowercaseName, {\n      name,\n      value\n    });\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-delete\n  delete(name) {\n    this[kHeadersSortedMap] = null;\n    name = name.toLowerCase();\n    if (name === 'set-cookie') {\n      this.cookies = null;\n    }\n    this[kHeadersMap].delete(name);\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-get\n  get(name) {\n    const value = this[kHeadersMap].get(name.toLowerCase());\n\n    // 1. If list does not contain name, then return null.\n    // 2. Return the values of all headers in list whose name\n    //    is a byte-case-insensitive match for name,\n    //    separated from each other by 0x2C 0x20, in order.\n    return value === undefined ? null : value.value;\n  }\n  *[Symbol.iterator]() {\n    // use the lowercased name\n    for (const [name, {\n      value\n    }] of this[kHeadersMap]) {\n      yield [name, value];\n    }\n  }\n  get entries() {\n    const headers = {};\n    if (this[kHeadersMap].size) {\n      for (const {\n        name,\n        value\n      } of this[kHeadersMap].values()) {\n        headers[name] = value;\n      }\n    }\n    return headers;\n  }\n}\n\n// https://fetch.spec.whatwg.org/#headers-class\nclass Headers {\n  constructor(init = undefined) {\n    if (init === kConstruct) {\n      return;\n    }\n    this[kHeadersList] = new HeadersList();\n\n    // The new Headers(init) constructor steps are:\n\n    // 1. Set this’s guard to \"none\".\n    this[kGuard] = 'none';\n\n    // 2. If init is given, then fill this with init.\n    if (init !== undefined) {\n      init = webidl.converters.HeadersInit(init);\n      fill(this, init);\n    }\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-append\n  append(name, value) {\n    webidl.brandCheck(this, Headers);\n    webidl.argumentLengthCheck(arguments, 2, {\n      header: 'Headers.append'\n    });\n    name = webidl.converters.ByteString(name);\n    value = webidl.converters.ByteString(value);\n    return appendHeader(this, name, value);\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-delete\n  delete(name) {\n    webidl.brandCheck(this, Headers);\n    webidl.argumentLengthCheck(arguments, 1, {\n      header: 'Headers.delete'\n    });\n    name = webidl.converters.ByteString(name);\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.delete',\n        value: name,\n        type: 'header name'\n      });\n    }\n\n    // 2. If this’s guard is \"immutable\", then throw a TypeError.\n    // 3. Otherwise, if this’s guard is \"request\" and name is a\n    //    forbidden header name, return.\n    // 4. Otherwise, if this’s guard is \"request-no-cors\", name\n    //    is not a no-CORS-safelisted request-header name, and\n    //    name is not a privileged no-CORS request-header name,\n    //    return.\n    // 5. Otherwise, if this’s guard is \"response\" and name is\n    //    a forbidden response-header name, return.\n    // Note: undici does not implement forbidden header names\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable');\n    } else if (this[kGuard] === 'request-no-cors') {\n      // TODO\n    }\n\n    // 6. If this’s header list does not contain name, then\n    //    return.\n    if (!this[kHeadersList].contains(name)) {\n      return;\n    }\n\n    // 7. Delete name from this’s header list.\n    // 8. If this’s guard is \"request-no-cors\", then remove\n    //    privileged no-CORS request headers from this.\n    this[kHeadersList].delete(name);\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-get\n  get(name) {\n    webidl.brandCheck(this, Headers);\n    webidl.argumentLengthCheck(arguments, 1, {\n      header: 'Headers.get'\n    });\n    name = webidl.converters.ByteString(name);\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.get',\n        value: name,\n        type: 'header name'\n      });\n    }\n\n    // 2. Return the result of getting name from this’s header\n    //    list.\n    return this[kHeadersList].get(name);\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-has\n  has(name) {\n    webidl.brandCheck(this, Headers);\n    webidl.argumentLengthCheck(arguments, 1, {\n      header: 'Headers.has'\n    });\n    name = webidl.converters.ByteString(name);\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.has',\n        value: name,\n        type: 'header name'\n      });\n    }\n\n    // 2. Return true if this’s header list contains name;\n    //    otherwise false.\n    return this[kHeadersList].contains(name);\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-set\n  set(name, value) {\n    webidl.brandCheck(this, Headers);\n    webidl.argumentLengthCheck(arguments, 2, {\n      header: 'Headers.set'\n    });\n    name = webidl.converters.ByteString(name);\n    value = webidl.converters.ByteString(value);\n\n    // 1. Normalize value.\n    value = headerValueNormalize(value);\n\n    // 2. If name is not a header name or value is not a\n    //    header value, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.set',\n        value: name,\n        type: 'header name'\n      });\n    } else if (!isValidHeaderValue(value)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.set',\n        value,\n        type: 'header value'\n      });\n    }\n\n    // 3. If this’s guard is \"immutable\", then throw a TypeError.\n    // 4. Otherwise, if this’s guard is \"request\" and name is a\n    //    forbidden header name, return.\n    // 5. Otherwise, if this’s guard is \"request-no-cors\" and\n    //    name/value is not a no-CORS-safelisted request-header,\n    //    return.\n    // 6. Otherwise, if this’s guard is \"response\" and name is a\n    //    forbidden response-header name, return.\n    // Note: undici does not implement forbidden header names\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable');\n    } else if (this[kGuard] === 'request-no-cors') {\n      // TODO\n    }\n\n    // 7. Set (name, value) in this’s header list.\n    // 8. If this’s guard is \"request-no-cors\", then remove\n    //    privileged no-CORS request headers from this\n    this[kHeadersList].set(name, value);\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie\n  getSetCookie() {\n    webidl.brandCheck(this, Headers);\n\n    // 1. If this’s header list does not contain `Set-Cookie`, then return « ».\n    // 2. Return the values of all headers in this’s header list whose name is\n    //    a byte-case-insensitive match for `Set-Cookie`, in order.\n\n    const list = this[kHeadersList].cookies;\n    if (list) {\n      return [...list];\n    }\n    return [];\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n  get [kHeadersSortedMap]() {\n    if (this[kHeadersList][kHeadersSortedMap]) {\n      return this[kHeadersList][kHeadersSortedMap];\n    }\n\n    // 1. Let headers be an empty list of headers with the key being the name\n    //    and value the value.\n    const headers = [];\n\n    // 2. Let names be the result of convert header names to a sorted-lowercase\n    //    set with all the names of the headers in list.\n    const names = [...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1);\n    const cookies = this[kHeadersList].cookies;\n\n    // 3. For each name of names:\n    for (let i = 0; i < names.length; ++i) {\n      const [name, value] = names[i];\n      // 1. If name is `set-cookie`, then:\n      if (name === 'set-cookie') {\n        // 1. Let values be a list of all values of headers in list whose name\n        //    is a byte-case-insensitive match for name, in order.\n\n        // 2. For each value of values:\n        // 1. Append (name, value) to headers.\n        for (let j = 0; j < cookies.length; ++j) {\n          headers.push([name, cookies[j]]);\n        }\n      } else {\n        // 2. Otherwise:\n\n        // 1. Let value be the result of getting name from list.\n\n        // 2. Assert: value is non-null.\n        assert(value !== null);\n\n        // 3. Append (name, value) to headers.\n        headers.push([name, value]);\n      }\n    }\n    this[kHeadersList][kHeadersSortedMap] = headers;\n\n    // 4. Return headers.\n    return headers;\n  }\n  keys() {\n    webidl.brandCheck(this, Headers);\n    if (this[kGuard] === 'immutable') {\n      const value = this[kHeadersSortedMap];\n      return makeIterator(() => value, 'Headers', 'key');\n    }\n    return makeIterator(() => [...this[kHeadersSortedMap].values()], 'Headers', 'key');\n  }\n  values() {\n    webidl.brandCheck(this, Headers);\n    if (this[kGuard] === 'immutable') {\n      const value = this[kHeadersSortedMap];\n      return makeIterator(() => value, 'Headers', 'value');\n    }\n    return makeIterator(() => [...this[kHeadersSortedMap].values()], 'Headers', 'value');\n  }\n  entries() {\n    webidl.brandCheck(this, Headers);\n    if (this[kGuard] === 'immutable') {\n      const value = this[kHeadersSortedMap];\n      return makeIterator(() => value, 'Headers', 'key+value');\n    }\n    return makeIterator(() => [...this[kHeadersSortedMap].values()], 'Headers', 'key+value');\n  }\n\n  /**\n   * @param {(value: string, key: string, self: Headers) => void} callbackFn\n   * @param {unknown} thisArg\n   */\n  forEach(callbackFn, thisArg = globalThis) {\n    webidl.brandCheck(this, Headers);\n    webidl.argumentLengthCheck(arguments, 1, {\n      header: 'Headers.forEach'\n    });\n    if (typeof callbackFn !== 'function') {\n      throw new TypeError(\"Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.\");\n    }\n    for (const [key, value] of this) {\n      callbackFn.apply(thisArg, [value, key, this]);\n    }\n  }\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    webidl.brandCheck(this, Headers);\n    return this[kHeadersList];\n  }\n}\nHeaders.prototype[Symbol.iterator] = Headers.prototype.entries;\nObject.defineProperties(Headers.prototype, {\n  append: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  get: kEnumerableProperty,\n  has: kEnumerableProperty,\n  set: kEnumerableProperty,\n  getSetCookie: kEnumerableProperty,\n  keys: kEnumerableProperty,\n  values: kEnumerableProperty,\n  entries: kEnumerableProperty,\n  forEach: kEnumerableProperty,\n  [Symbol.iterator]: {\n    enumerable: false\n  },\n  [Symbol.toStringTag]: {\n    value: 'Headers',\n    configurable: true\n  }\n});\nwebidl.converters.HeadersInit = function (V) {\n  if (webidl.util.Type(V) === 'Object') {\n    if (V[Symbol.iterator]) {\n      return webidl.converters['sequence<sequence<ByteString>>'](V);\n    }\n    return webidl.converters['record<ByteString, ByteString>'](V);\n  }\n  throw webidl.errors.conversionFailed({\n    prefix: 'Headers constructor',\n    argument: 'Argument 1',\n    types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']\n  });\n};\nmodule.exports = {\n  fill,\n  Headers,\n  HeadersList\n};","map":{"version":3,"names":["kHeadersList","kConstruct","require","kGuard","kEnumerableProperty","makeIterator","isValidHeaderName","isValidHeaderValue","webidl","assert","kHeadersMap","Symbol","kHeadersSortedMap","isHTTPWhiteSpaceCharCode","code","headerValueNormalize","potentialValue","i","j","length","charCodeAt","substring","fill","headers","object","Array","isArray","header","errors","exception","message","appendHeader","keys","Object","conversionFailed","prefix","argument","types","name","value","invalidArgument","type","TypeError","append","HeadersList","cookies","constructor","init","Map","contains","toLowerCase","has","clear","lowercaseName","exists","get","delimiter","set","push","delete","undefined","iterator","entries","size","values","Headers","converters","HeadersInit","brandCheck","argumentLengthCheck","arguments","ByteString","getSetCookie","list","names","sort","a","b","forEach","callbackFn","thisArg","globalThis","key","apply","for","prototype","defineProperties","enumerable","toStringTag","configurable","V","util","Type","module","exports"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/undici/lib/fetch/headers.js"],"sourcesContent":["// https://github.com/Ethan-Arrowood/undici-fetch\n\n'use strict'\n\nconst { kHeadersList, kConstruct } = require('../core/symbols')\nconst { kGuard } = require('./symbols')\nconst { kEnumerableProperty } = require('../core/util')\nconst {\n  makeIterator,\n  isValidHeaderName,\n  isValidHeaderValue\n} = require('./util')\nconst { webidl } = require('./webidl')\nconst assert = require('assert')\n\nconst kHeadersMap = Symbol('headers map')\nconst kHeadersSortedMap = Symbol('headers map sorted')\n\n/**\n * @param {number} code\n */\nfunction isHTTPWhiteSpaceCharCode (code) {\n  return code === 0x00a || code === 0x00d || code === 0x009 || code === 0x020\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-value-normalize\n * @param {string} potentialValue\n */\nfunction headerValueNormalize (potentialValue) {\n  //  To normalize a byte sequence potentialValue, remove\n  //  any leading and trailing HTTP whitespace bytes from\n  //  potentialValue.\n  let i = 0; let j = potentialValue.length\n\n  while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j\n  while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i))) ++i\n\n  return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j)\n}\n\nfunction fill (headers, object) {\n  // To fill a Headers object headers with a given object object, run these steps:\n\n  // 1. If object is a sequence, then for each header in object:\n  // Note: webidl conversion to array has already been done.\n  if (Array.isArray(object)) {\n    for (let i = 0; i < object.length; ++i) {\n      const header = object[i]\n      // 1. If header does not contain exactly two items, then throw a TypeError.\n      if (header.length !== 2) {\n        throw webidl.errors.exception({\n          header: 'Headers constructor',\n          message: `expected name/value pair to be length 2, found ${header.length}.`\n        })\n      }\n\n      // 2. Append (header’s first item, header’s second item) to headers.\n      appendHeader(headers, header[0], header[1])\n    }\n  } else if (typeof object === 'object' && object !== null) {\n    // Note: null should throw\n\n    // 2. Otherwise, object is a record, then for each key → value in object,\n    //    append (key, value) to headers\n    const keys = Object.keys(object)\n    for (let i = 0; i < keys.length; ++i) {\n      appendHeader(headers, keys[i], object[keys[i]])\n    }\n  } else {\n    throw webidl.errors.conversionFailed({\n      prefix: 'Headers constructor',\n      argument: 'Argument 1',\n      types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']\n    })\n  }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-headers-append\n */\nfunction appendHeader (headers, name, value) {\n  // 1. Normalize value.\n  value = headerValueNormalize(value)\n\n  // 2. If name is not a header name or value is not a\n  //    header value, then throw a TypeError.\n  if (!isValidHeaderName(name)) {\n    throw webidl.errors.invalidArgument({\n      prefix: 'Headers.append',\n      value: name,\n      type: 'header name'\n    })\n  } else if (!isValidHeaderValue(value)) {\n    throw webidl.errors.invalidArgument({\n      prefix: 'Headers.append',\n      value,\n      type: 'header value'\n    })\n  }\n\n  // 3. If headers’s guard is \"immutable\", then throw a TypeError.\n  // 4. Otherwise, if headers’s guard is \"request\" and name is a\n  //    forbidden header name, return.\n  // Note: undici does not implement forbidden header names\n  if (headers[kGuard] === 'immutable') {\n    throw new TypeError('immutable')\n  } else if (headers[kGuard] === 'request-no-cors') {\n    // 5. Otherwise, if headers’s guard is \"request-no-cors\":\n    // TODO\n  }\n\n  // 6. Otherwise, if headers’s guard is \"response\" and name is a\n  //    forbidden response-header name, return.\n\n  // 7. Append (name, value) to headers’s header list.\n  return headers[kHeadersList].append(name, value)\n\n  // 8. If headers’s guard is \"request-no-cors\", then remove\n  //    privileged no-CORS request headers from headers\n}\n\nclass HeadersList {\n  /** @type {[string, string][]|null} */\n  cookies = null\n\n  constructor (init) {\n    if (init instanceof HeadersList) {\n      this[kHeadersMap] = new Map(init[kHeadersMap])\n      this[kHeadersSortedMap] = init[kHeadersSortedMap]\n      this.cookies = init.cookies === null ? null : [...init.cookies]\n    } else {\n      this[kHeadersMap] = new Map(init)\n      this[kHeadersSortedMap] = null\n    }\n  }\n\n  // https://fetch.spec.whatwg.org/#header-list-contains\n  contains (name) {\n    // A header list list contains a header name name if list\n    // contains a header whose name is a byte-case-insensitive\n    // match for name.\n    name = name.toLowerCase()\n\n    return this[kHeadersMap].has(name)\n  }\n\n  clear () {\n    this[kHeadersMap].clear()\n    this[kHeadersSortedMap] = null\n    this.cookies = null\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-append\n  append (name, value) {\n    this[kHeadersSortedMap] = null\n\n    // 1. If list contains name, then set name to the first such\n    //    header’s name.\n    const lowercaseName = name.toLowerCase()\n    const exists = this[kHeadersMap].get(lowercaseName)\n\n    // 2. Append (name, value) to list.\n    if (exists) {\n      const delimiter = lowercaseName === 'cookie' ? '; ' : ', '\n      this[kHeadersMap].set(lowercaseName, {\n        name: exists.name,\n        value: `${exists.value}${delimiter}${value}`\n      })\n    } else {\n      this[kHeadersMap].set(lowercaseName, { name, value })\n    }\n\n    if (lowercaseName === 'set-cookie') {\n      this.cookies ??= []\n      this.cookies.push(value)\n    }\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-set\n  set (name, value) {\n    this[kHeadersSortedMap] = null\n    const lowercaseName = name.toLowerCase()\n\n    if (lowercaseName === 'set-cookie') {\n      this.cookies = [value]\n    }\n\n    // 1. If list contains name, then set the value of\n    //    the first such header to value and remove the\n    //    others.\n    // 2. Otherwise, append header (name, value) to list.\n    this[kHeadersMap].set(lowercaseName, { name, value })\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-delete\n  delete (name) {\n    this[kHeadersSortedMap] = null\n\n    name = name.toLowerCase()\n\n    if (name === 'set-cookie') {\n      this.cookies = null\n    }\n\n    this[kHeadersMap].delete(name)\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-get\n  get (name) {\n    const value = this[kHeadersMap].get(name.toLowerCase())\n\n    // 1. If list does not contain name, then return null.\n    // 2. Return the values of all headers in list whose name\n    //    is a byte-case-insensitive match for name,\n    //    separated from each other by 0x2C 0x20, in order.\n    return value === undefined ? null : value.value\n  }\n\n  * [Symbol.iterator] () {\n    // use the lowercased name\n    for (const [name, { value }] of this[kHeadersMap]) {\n      yield [name, value]\n    }\n  }\n\n  get entries () {\n    const headers = {}\n\n    if (this[kHeadersMap].size) {\n      for (const { name, value } of this[kHeadersMap].values()) {\n        headers[name] = value\n      }\n    }\n\n    return headers\n  }\n}\n\n// https://fetch.spec.whatwg.org/#headers-class\nclass Headers {\n  constructor (init = undefined) {\n    if (init === kConstruct) {\n      return\n    }\n    this[kHeadersList] = new HeadersList()\n\n    // The new Headers(init) constructor steps are:\n\n    // 1. Set this’s guard to \"none\".\n    this[kGuard] = 'none'\n\n    // 2. If init is given, then fill this with init.\n    if (init !== undefined) {\n      init = webidl.converters.HeadersInit(init)\n      fill(this, init)\n    }\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-append\n  append (name, value) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 2, { header: 'Headers.append' })\n\n    name = webidl.converters.ByteString(name)\n    value = webidl.converters.ByteString(value)\n\n    return appendHeader(this, name, value)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-delete\n  delete (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.delete' })\n\n    name = webidl.converters.ByteString(name)\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.delete',\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. If this’s guard is \"immutable\", then throw a TypeError.\n    // 3. Otherwise, if this’s guard is \"request\" and name is a\n    //    forbidden header name, return.\n    // 4. Otherwise, if this’s guard is \"request-no-cors\", name\n    //    is not a no-CORS-safelisted request-header name, and\n    //    name is not a privileged no-CORS request-header name,\n    //    return.\n    // 5. Otherwise, if this’s guard is \"response\" and name is\n    //    a forbidden response-header name, return.\n    // Note: undici does not implement forbidden header names\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable')\n    } else if (this[kGuard] === 'request-no-cors') {\n      // TODO\n    }\n\n    // 6. If this’s header list does not contain name, then\n    //    return.\n    if (!this[kHeadersList].contains(name)) {\n      return\n    }\n\n    // 7. Delete name from this’s header list.\n    // 8. If this’s guard is \"request-no-cors\", then remove\n    //    privileged no-CORS request headers from this.\n    this[kHeadersList].delete(name)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-get\n  get (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.get' })\n\n    name = webidl.converters.ByteString(name)\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.get',\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. Return the result of getting name from this’s header\n    //    list.\n    return this[kHeadersList].get(name)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-has\n  has (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.has' })\n\n    name = webidl.converters.ByteString(name)\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.has',\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. Return true if this’s header list contains name;\n    //    otherwise false.\n    return this[kHeadersList].contains(name)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-set\n  set (name, value) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 2, { header: 'Headers.set' })\n\n    name = webidl.converters.ByteString(name)\n    value = webidl.converters.ByteString(value)\n\n    // 1. Normalize value.\n    value = headerValueNormalize(value)\n\n    // 2. If name is not a header name or value is not a\n    //    header value, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.set',\n        value: name,\n        type: 'header name'\n      })\n    } else if (!isValidHeaderValue(value)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.set',\n        value,\n        type: 'header value'\n      })\n    }\n\n    // 3. If this’s guard is \"immutable\", then throw a TypeError.\n    // 4. Otherwise, if this’s guard is \"request\" and name is a\n    //    forbidden header name, return.\n    // 5. Otherwise, if this’s guard is \"request-no-cors\" and\n    //    name/value is not a no-CORS-safelisted request-header,\n    //    return.\n    // 6. Otherwise, if this’s guard is \"response\" and name is a\n    //    forbidden response-header name, return.\n    // Note: undici does not implement forbidden header names\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable')\n    } else if (this[kGuard] === 'request-no-cors') {\n      // TODO\n    }\n\n    // 7. Set (name, value) in this’s header list.\n    // 8. If this’s guard is \"request-no-cors\", then remove\n    //    privileged no-CORS request headers from this\n    this[kHeadersList].set(name, value)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie\n  getSetCookie () {\n    webidl.brandCheck(this, Headers)\n\n    // 1. If this’s header list does not contain `Set-Cookie`, then return « ».\n    // 2. Return the values of all headers in this’s header list whose name is\n    //    a byte-case-insensitive match for `Set-Cookie`, in order.\n\n    const list = this[kHeadersList].cookies\n\n    if (list) {\n      return [...list]\n    }\n\n    return []\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n  get [kHeadersSortedMap] () {\n    if (this[kHeadersList][kHeadersSortedMap]) {\n      return this[kHeadersList][kHeadersSortedMap]\n    }\n\n    // 1. Let headers be an empty list of headers with the key being the name\n    //    and value the value.\n    const headers = []\n\n    // 2. Let names be the result of convert header names to a sorted-lowercase\n    //    set with all the names of the headers in list.\n    const names = [...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1)\n    const cookies = this[kHeadersList].cookies\n\n    // 3. For each name of names:\n    for (let i = 0; i < names.length; ++i) {\n      const [name, value] = names[i]\n      // 1. If name is `set-cookie`, then:\n      if (name === 'set-cookie') {\n        // 1. Let values be a list of all values of headers in list whose name\n        //    is a byte-case-insensitive match for name, in order.\n\n        // 2. For each value of values:\n        // 1. Append (name, value) to headers.\n        for (let j = 0; j < cookies.length; ++j) {\n          headers.push([name, cookies[j]])\n        }\n      } else {\n        // 2. Otherwise:\n\n        // 1. Let value be the result of getting name from list.\n\n        // 2. Assert: value is non-null.\n        assert(value !== null)\n\n        // 3. Append (name, value) to headers.\n        headers.push([name, value])\n      }\n    }\n\n    this[kHeadersList][kHeadersSortedMap] = headers\n\n    // 4. Return headers.\n    return headers\n  }\n\n  keys () {\n    webidl.brandCheck(this, Headers)\n\n    if (this[kGuard] === 'immutable') {\n      const value = this[kHeadersSortedMap]\n      return makeIterator(() => value, 'Headers',\n        'key')\n    }\n\n    return makeIterator(\n      () => [...this[kHeadersSortedMap].values()],\n      'Headers',\n      'key'\n    )\n  }\n\n  values () {\n    webidl.brandCheck(this, Headers)\n\n    if (this[kGuard] === 'immutable') {\n      const value = this[kHeadersSortedMap]\n      return makeIterator(() => value, 'Headers',\n        'value')\n    }\n\n    return makeIterator(\n      () => [...this[kHeadersSortedMap].values()],\n      'Headers',\n      'value'\n    )\n  }\n\n  entries () {\n    webidl.brandCheck(this, Headers)\n\n    if (this[kGuard] === 'immutable') {\n      const value = this[kHeadersSortedMap]\n      return makeIterator(() => value, 'Headers',\n        'key+value')\n    }\n\n    return makeIterator(\n      () => [...this[kHeadersSortedMap].values()],\n      'Headers',\n      'key+value'\n    )\n  }\n\n  /**\n   * @param {(value: string, key: string, self: Headers) => void} callbackFn\n   * @param {unknown} thisArg\n   */\n  forEach (callbackFn, thisArg = globalThis) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.forEach' })\n\n    if (typeof callbackFn !== 'function') {\n      throw new TypeError(\n        \"Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.\"\n      )\n    }\n\n    for (const [key, value] of this) {\n      callbackFn.apply(thisArg, [value, key, this])\n    }\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    webidl.brandCheck(this, Headers)\n\n    return this[kHeadersList]\n  }\n}\n\nHeaders.prototype[Symbol.iterator] = Headers.prototype.entries\n\nObject.defineProperties(Headers.prototype, {\n  append: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  get: kEnumerableProperty,\n  has: kEnumerableProperty,\n  set: kEnumerableProperty,\n  getSetCookie: kEnumerableProperty,\n  keys: kEnumerableProperty,\n  values: kEnumerableProperty,\n  entries: kEnumerableProperty,\n  forEach: kEnumerableProperty,\n  [Symbol.iterator]: { enumerable: false },\n  [Symbol.toStringTag]: {\n    value: 'Headers',\n    configurable: true\n  }\n})\n\nwebidl.converters.HeadersInit = function (V) {\n  if (webidl.util.Type(V) === 'Object') {\n    if (V[Symbol.iterator]) {\n      return webidl.converters['sequence<sequence<ByteString>>'](V)\n    }\n\n    return webidl.converters['record<ByteString, ByteString>'](V)\n  }\n\n  throw webidl.errors.conversionFailed({\n    prefix: 'Headers constructor',\n    argument: 'Argument 1',\n    types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']\n  })\n}\n\nmodule.exports = {\n  fill,\n  Headers,\n  HeadersList\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}