{"ast":null,"code":"import * as API from './api.js';\nimport { CAR, ok, error, Schema, Failure } from '@ucanto/core';\nimport { compare } from 'uint8arrays';\nimport * as dagCBOR from '@ipld/dag-cbor';\nimport * as Digest from 'multiformats/hashes/digest';\nimport * as Link from 'multiformats/link';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { DigestMap } from './digest-map.js';\nexport const version = 'index/sharded/dag@0.1';\nexport const ShardedDAGIndexSchema = Schema.variant({\n  [version]: Schema.struct({\n    /** DAG root. */\n    content: Schema.link(),\n    /** Shards the DAG can be found in. */\n    shards: Schema.array(Schema.link())\n  })\n});\nexport const MultihashSchema = Schema.bytes();\nexport const BlobIndexSchema = Schema.tuple([MultihashSchema, Schema.array( /** multihash bytes, offset, length. */\nSchema.tuple([MultihashSchema, Schema.tuple([Schema.number(), Schema.number()])]))]);\n/**\n * @param {Uint8Array} archive\n * @returns {API.Result<API.ShardedDAGIndexView, API.DecodeFailure|API.UnknownFormat>}\n */\nexport const extract = archive => {\n  const {\n    roots,\n    blocks\n  } = CAR.decode(archive);\n  if (!roots.length) {\n    return error(new UnknownFormat('missing root block'));\n  }\n  const {\n    code\n  } = roots[0].cid;\n  if (code !== dagCBOR.code) {\n    return error(new UnknownFormat(`unexpected root CID codec: 0x${code.toString(16)}`));\n  }\n  return view({\n    root: roots[0],\n    blocks\n  });\n};\n/**\n * @param {object} source\n * @param {API.IPLDBlock} source.root\n * @param {Map<string, API.IPLDBlock>} source.blocks\n * @returns {API.Result<API.ShardedDAGIndexView, API.DecodeFailure|API.UnknownFormat>}\n */\nexport const view = ({\n  root,\n  blocks\n}) => {\n  const [version, dagIndexData] = ShardedDAGIndexSchema.match(dagCBOR.decode(root.bytes));\n  switch (version) {\n    case version:\n      {\n        const dagIndex = create(dagIndexData.content);\n        for (const shardLink of dagIndexData.shards) {\n          const shard = blocks.get(shardLink.toString());\n          if (!shard) {\n            return error(new DecodeFailure(`missing shard block: ${shardLink}`));\n          }\n          const blobIndexData = BlobIndexSchema.from(dagCBOR.decode(shard.bytes));\n          const blobIndex = new DigestMap();\n          for (const [digest, [offset, length]] of blobIndexData[1]) {\n            blobIndex.set(Digest.decode(digest), [offset, length]);\n          }\n          dagIndex.shards.set(Digest.decode(blobIndexData[0]), blobIndex);\n        }\n        return ok(dagIndex);\n      }\n    default:\n      return error(new UnknownFormat(`unknown index version: ${version}`));\n  }\n};\n/** @implements {API.ShardedDAGIndexView} */\nclass ShardedDAGIndex {\n  #content;\n  #shards;\n  /** @param {API.UnknownLink} content */\n  constructor(content) {\n    this.#content = content;\n    /** @type {DigestMap<API.ShardDigest, API.Position>} */\n    this.#shards = new DigestMap();\n  }\n  get content() {\n    return this.#content;\n  }\n  get shards() {\n    return this.#shards;\n  }\n  /**\n   * @param {API.ShardDigest} shard\n   * @param {API.SliceDigest} slice\n   * @param {API.Position} pos\n   */\n  setSlice(shard, slice, pos) {\n    let index = this.#shards.get(shard);\n    if (!index) {\n      index = new DigestMap();\n      this.#shards.set(shard, index);\n    }\n    index.set(slice, pos);\n  }\n  archive() {\n    return archive(this);\n  }\n}\nexport class UnknownFormat extends Failure {\n  #reason;\n  /** @param {string} [reason] */\n  constructor(reason) {\n    super();\n    this.name = /** @type {const} */'UnknownFormat';\n    this.#reason = reason;\n  }\n  describe() {\n    return this.#reason ?? 'unknown format';\n  }\n}\nexport class DecodeFailure extends Failure {\n  #reason;\n  /** @param {string} [reason] */\n  constructor(reason) {\n    super();\n    this.name = /** @type {const} */'DecodeFailure';\n    this.#reason = reason;\n  }\n  describe() {\n    return this.#reason ?? 'failed to decode';\n  }\n}\n/**\n * @param {API.UnknownLink} content\n * @returns {API.ShardedDAGIndexView}\n */\nexport const create = content => new ShardedDAGIndex(content);\n/**\n * @param {API.ShardedDAGIndex} model\n * @returns {Promise<API.Result<Uint8Array>>}\n */\nexport const archive = async model => {\n  const blocks = new Map();\n  const shards = [...model.shards.entries()].sort((a, b) => compare(a[0].digest, b[0].digest));\n  const index = {\n    content: model.content,\n    shards: ( /** @type {API.Link[]} */[])\n  };\n  for (const s of shards) {\n    const slices = [...s[1].entries()].sort((a, b) => compare(a[0].digest, b[0].digest)).map(e => [e[0].bytes, e[1]]);\n    const bytes = dagCBOR.encode([s[0].bytes, slices]);\n    const digest = await sha256.digest(bytes);\n    const cid = Link.create(dagCBOR.code, digest);\n    blocks.set(cid.toString(), {\n      cid,\n      bytes\n    });\n    index.shards.push(cid);\n  }\n  const bytes = dagCBOR.encode({\n    [version]: index\n  });\n  const digest = await sha256.digest(bytes);\n  const cid = Link.create(dagCBOR.code, digest);\n  return ok(CAR.encode({\n    roots: [{\n      cid,\n      bytes\n    }],\n    blocks\n  }));\n};","map":{"version":3,"names":["API","CAR","ok","error","Schema","Failure","compare","dagCBOR","Digest","Link","sha256","DigestMap","version","ShardedDAGIndexSchema","variant","struct","content","link","shards","array","MultihashSchema","bytes","BlobIndexSchema","tuple","number","extract","archive","roots","blocks","decode","length","UnknownFormat","code","cid","toString","view","root","dagIndexData","match","dagIndex","create","shardLink","shard","get","DecodeFailure","blobIndexData","from","blobIndex","digest","offset","set","ShardedDAGIndex","constructor","setSlice","slice","pos","index","reason","name","describe","model","Map","entries","sort","a","b","s","slices","map","e","encode","push"],"sources":["C:\\FACULTATE\\Proiect\\node_modules\\@web3-storage\\blob-index\\src\\sharded-dag-index.js"],"sourcesContent":["import * as API from './api.js'\nimport { CAR, ok, error, Schema, Failure } from '@ucanto/core'\nimport { compare } from 'uint8arrays'\nimport * as dagCBOR from '@ipld/dag-cbor'\nimport * as Digest from 'multiformats/hashes/digest'\nimport * as Link from 'multiformats/link'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { DigestMap } from './digest-map.js'\n\nexport const version = 'index/sharded/dag@0.1'\n\nexport const ShardedDAGIndexSchema = Schema.variant({\n  [version]: Schema.struct({\n    /** DAG root. */\n    content: Schema.link(),\n    /** Shards the DAG can be found in. */\n    shards: Schema.array(Schema.link()),\n  }),\n})\n\nexport const MultihashSchema = Schema.bytes()\n\nexport const BlobIndexSchema = Schema.tuple([\n  MultihashSchema,\n  Schema.array(\n    /** multihash bytes, offset, length. */\n    Schema.tuple([\n      MultihashSchema,\n      Schema.tuple([Schema.number(), Schema.number()]),\n    ])\n  ),\n])\n\n/**\n * @param {Uint8Array} archive\n * @returns {API.Result<API.ShardedDAGIndexView, API.DecodeFailure|API.UnknownFormat>}\n */\nexport const extract = (archive) => {\n  const { roots, blocks } = CAR.decode(archive)\n\n  if (!roots.length) {\n    return error(new UnknownFormat('missing root block'))\n  }\n\n  const { code } = roots[0].cid\n  if (code !== dagCBOR.code) {\n    return error(\n      new UnknownFormat(`unexpected root CID codec: 0x${code.toString(16)}`)\n    )\n  }\n\n  return view({ root: roots[0], blocks })\n}\n\n/**\n * @param {object} source\n * @param {API.IPLDBlock} source.root\n * @param {Map<string, API.IPLDBlock>} source.blocks\n * @returns {API.Result<API.ShardedDAGIndexView, API.DecodeFailure|API.UnknownFormat>}\n */\nexport const view = ({ root, blocks }) => {\n  const [version, dagIndexData] = ShardedDAGIndexSchema.match(\n    dagCBOR.decode(root.bytes)\n  )\n  switch (version) {\n    case version: {\n      const dagIndex = create(dagIndexData.content)\n      for (const shardLink of dagIndexData.shards) {\n        const shard = blocks.get(shardLink.toString())\n        if (!shard) {\n          return error(new DecodeFailure(`missing shard block: ${shardLink}`))\n        }\n\n        const blobIndexData = BlobIndexSchema.from(dagCBOR.decode(shard.bytes))\n        const blobIndex = new DigestMap()\n        for (const [digest, [offset, length]] of blobIndexData[1]) {\n          blobIndex.set(Digest.decode(digest), [offset, length])\n        }\n        dagIndex.shards.set(Digest.decode(blobIndexData[0]), blobIndex)\n      }\n      return ok(dagIndex)\n    }\n    default:\n      return error(new UnknownFormat(`unknown index version: ${version}`))\n  }\n}\n\n/** @implements {API.ShardedDAGIndexView} */\nclass ShardedDAGIndex {\n  #content\n  #shards\n\n  /** @param {API.UnknownLink} content */\n  constructor(content) {\n    this.#content = content\n    /** @type {DigestMap<API.ShardDigest, API.Position>} */\n    this.#shards = new DigestMap()\n  }\n\n  get content() {\n    return this.#content\n  }\n\n  get shards() {\n    return this.#shards\n  }\n\n  /**\n   * @param {API.ShardDigest} shard\n   * @param {API.SliceDigest} slice\n   * @param {API.Position} pos\n   */\n  setSlice(shard, slice, pos) {\n    let index = this.#shards.get(shard)\n    if (!index) {\n      index = new DigestMap()\n      this.#shards.set(shard, index)\n    }\n    index.set(slice, pos)\n  }\n\n  archive() {\n    return archive(this)\n  }\n}\n\nexport class UnknownFormat extends Failure {\n  #reason\n\n  /** @param {string} [reason] */\n  constructor(reason) {\n    super()\n    this.name = /** @type {const} */ ('UnknownFormat')\n    this.#reason = reason\n  }\n\n  describe() {\n    return this.#reason ?? 'unknown format'\n  }\n}\n\nexport class DecodeFailure extends Failure {\n  #reason\n\n  /** @param {string} [reason] */\n  constructor(reason) {\n    super()\n    this.name = /** @type {const} */ ('DecodeFailure')\n    this.#reason = reason\n  }\n\n  describe() {\n    return this.#reason ?? 'failed to decode'\n  }\n}\n\n/**\n * @param {API.UnknownLink} content\n * @returns {API.ShardedDAGIndexView}\n */\nexport const create = (content) => new ShardedDAGIndex(content)\n\n/**\n * @param {API.ShardedDAGIndex} model\n * @returns {Promise<API.Result<Uint8Array>>}\n */\nexport const archive = async (model) => {\n  const blocks = new Map()\n  const shards = [...model.shards.entries()].sort((a, b) =>\n    compare(a[0].digest, b[0].digest)\n  )\n  const index = {\n    content: model.content,\n    shards: /** @type {API.Link[]} */ ([]),\n  }\n  for (const s of shards) {\n    const slices = [...s[1].entries()]\n      .sort((a, b) => compare(a[0].digest, b[0].digest))\n      .map((e) => [e[0].bytes, e[1]])\n    const bytes = dagCBOR.encode([s[0].bytes, slices])\n    const digest = await sha256.digest(bytes)\n    const cid = Link.create(dagCBOR.code, digest)\n    blocks.set(cid.toString(), { cid, bytes })\n    index.shards.push(cid)\n  }\n  const bytes = dagCBOR.encode({ [version]: index })\n  const digest = await sha256.digest(bytes)\n  const cid = Link.create(dagCBOR.code, digest)\n  return ok(CAR.encode({ roots: [{ cid, bytes }], blocks }))\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}