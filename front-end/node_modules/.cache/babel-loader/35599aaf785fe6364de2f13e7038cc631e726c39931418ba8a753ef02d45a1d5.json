{"ast":null,"code":"import * as PB from \"@ipld/dag-pb\";\nimport * as UnixFS from \"./unixfs.js\";\nimport { NodeType } from \"./unixfs.js\";\nimport { Data } from \"../gen/unixfs.js\";\nexport * from \"./unixfs.js\";\n\n/** @type {ReadonlyArray<any>} */\nconst EMPTY = Object.freeze([]);\nconst EMPTY_BUFFER = new Uint8Array(0);\nconst BLANK = Object.freeze({});\nexport const DEFAULT_FILE_MODE = parseInt(\"0644\", 8);\nexport const DEFAULT_DIRECTORY_MODE = parseInt(\"0755\", 8);\nexport const code = PB.code;\nexport const name = \"UnixFS\";\n\n/**\n * @param {UnixFS.IData} data\n * @param {ReadonlyArray<UnixFS.PBLink>} links\n */\nconst encodePB = (data, links) => {\n  Object(globalThis).debug && console.log({\n    data,\n    links\n  });\n  return PB.encode(\n  // We run through prepare as links need to be sorted by name which it will\n  // do.\n  PB.prepare({\n    Data: Data.encode(data).finish(),\n    // We can cast to mutable array as we know no mutation occurs there\n    Links: ( /** @type {PB.PBLink[]} */links)\n  }));\n};\n\n/**\n * @param {Uint8Array} content\n * @returns {UnixFS.Raw}\n */\nexport const createRaw = content => ({\n  type: NodeType.Raw,\n  content\n});\n\n/**\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.SimpleFile}\n */\nexport const createEmptyFile = metadata => createSimpleFile(EMPTY_BUFFER, metadata);\n\n/**\n * @param {Uint8Array} content\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.SimpleFile}\n */\nexport const createSimpleFile = (content, metadata) => ({\n  type: NodeType.File,\n  layout: \"simple\",\n  content,\n  metadata: decodeMetadata(metadata)\n});\n\n/**\n * @param {Uint8Array} content\n * @returns {UnixFS.FileChunk}\n */\nexport const createFileChunk = content => ({\n  type: NodeType.File,\n  layout: \"simple\",\n  content\n});\n\n/**\n * @param {UnixFS.FileLink[]} parts\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.AdvancedFile}\n */\nexport const createAdvancedFile = (parts, metadata) => ({\n  type: NodeType.File,\n  layout: \"advanced\",\n  parts,\n  metadata: decodeMetadata(metadata)\n});\n\n/**\n * @param {UnixFS.FileLink[]} parts\n * @returns {UnixFS.FileShard}\n */\nexport const createFileShard = parts => ({\n  type: NodeType.File,\n  layout: \"advanced\",\n  parts\n});\n\n/**\n * @deprecated\n * @param {Uint8Array} content\n * @param {UnixFS.FileLink[]} parts\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ComplexFile}\n */\nexport const createComplexFile = (content, parts, metadata) => ({\n  type: NodeType.File,\n  layout: \"complex\",\n  content,\n  parts,\n  metadata: decodeMetadata(metadata)\n});\n\n/**\n * @param {UnixFS.DirectoryEntryLink[]} entries\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.FlatDirectory}\n */\nexport const createFlatDirectory = (entries, metadata) => ({\n  type: NodeType.Directory,\n  metadata: decodeMetadata(metadata),\n  entries\n});\n\n/**\n * @param {UnixFS.ShardedDirectoryLink[]} entries\n * @param {Uint8Array} bitfield\n * @param {number} fanout\n * @param {number} hashType\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ShardedDirectory}\n */\nexport const createShardedDirectory = (entries, bitfield, fanout, hashType, metadata = BLANK) => ({\n  type: NodeType.HAMTShard,\n  bitfield,\n  fanout: readFanout(fanout),\n  hashType: readInt(hashType),\n  entries,\n  metadata: decodeMetadata(metadata)\n});\n\n/**\n * @param {UnixFS.ShardedDirectoryLink[]} entries\n * @param {Uint8Array} bitfield\n * @param {number} fanout\n * @param {number} hashType\n * @returns {UnixFS.DirectoryShard}\n */\nexport const createDirectoryShard = (entries, bitfield, fanout, hashType) => ({\n  type: NodeType.HAMTShard,\n  bitfield,\n  fanout: readFanout(fanout),\n  hashType: readInt(hashType),\n  entries\n});\n\n/**\n *\n * @param {Uint8Array} content\n * @returns {UnixFS.ByteView<UnixFS.Raw>}\n */\nexport const encodeRaw = content => encodePB({\n  Type: NodeType.Raw,\n  // TODO:\n  Data: content.byteLength > 0 ? content : undefined,\n  filesize: content.byteLength,\n  // @ts-ignore\n  blocksizes: EMPTY\n}, []);\n\n/**\n * @param {UnixFS.File|UnixFS.FileChunk|UnixFS.FileShard} node\n * @param {boolean} [ignoreMetadata]\n * @returns {UnixFS.ByteView<UnixFS.SimpleFile|UnixFS.AdvancedFile|UnixFS.ComplexFile>}\n */\nexport const encodeFile = (node, ignoreMetadata = false) => {\n  const metadata = ignoreMetadata ? BLANK : Object(node).metadata;\n  switch (node.layout) {\n    case \"simple\":\n      return encodeSimpleFile(node.content, metadata);\n    case \"advanced\":\n      return encodeAdvancedFile(node.parts, metadata);\n    case \"complex\":\n      return encodeComplexFile(node.content, node.parts, metadata);\n    default:\n      throw new TypeError(`File with unknown layout \"${Object(node).layout}\" was passed`);\n  }\n};\n\n/**\n * @param {Uint8Array} content\n * @returns {UnixFS.ByteView<UnixFS.FileChunk>}\n */\nexport const encodeFileChunk = content => encodeSimpleFile(content, BLANK);\n\n/**\n * @param {ReadonlyArray<UnixFS.FileLink>} parts\n * @returns {UnixFS.ByteView<UnixFS.FileShard>}\n */\nexport const encodeFileShard = parts => encodePB({\n  Type: NodeType.File,\n  blocksizes: parts.map(contentByteLength),\n  filesize: cumulativeContentByteLength(parts)\n}, parts.map(encodeLink));\n\n/**\n * @param {ReadonlyArray<UnixFS.FileLink>} parts\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ByteView<UnixFS.AdvancedFile>}\n */\nexport const encodeAdvancedFile = (parts, metadata = BLANK) => encodePB({\n  Type: NodeType.File,\n  blocksizes: parts.map(contentByteLength),\n  filesize: cumulativeContentByteLength(parts),\n  ...encodeMetadata(metadata)\n}, parts.map(encodeLink));\n\n/**\n * @param {UnixFS.DAGLink} dag\n * @returns {UnixFS.PBLink}\n */\nexport const encodeLink = dag => ({\n  Name: \"\",\n  Tsize: dag.dagByteLength,\n  // @ts-ignore - @see https://github.com/multiformats/js-multiformats/pull/161\n  Hash: dag.cid\n});\n\n/**\n * @param {Uint8Array} content\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ByteView<UnixFS.SimpleFile>}\n */\n\nexport const encodeSimpleFile = (content, metadata = BLANK) => encodePB({\n  Type: NodeType.File,\n  // adding empty file to both go-ipfs and js-ipfs produces block in\n  // which `Data` is omitted but filesize and blocksizes are present.\n  // For the sake of hash consistency we do the same.\n  Data: content.byteLength > 0 ? content : undefined,\n  filesize: content.byteLength,\n  blocksizes: [],\n  ...encodeMetadata(metadata)\n}, []);\n\n/**\n *\n * @param {Uint8Array} content\n * @param {ReadonlyArray<UnixFS.FileLink>} parts\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ByteView<UnixFS.ComplexFile>}\n */\nexport const encodeComplexFile = (content, parts, metadata = BLANK) => encodePB({\n  Type: NodeType.File,\n  Data: content,\n  filesize: content.byteLength + cumulativeContentByteLength(parts),\n  blocksizes: parts.map(contentByteLength)\n}, parts.map(encodeLink));\n\n/**\n * @param {UnixFS.FlatDirectory} node\n * @returns {UnixFS.ByteView<UnixFS.FlatDirectory>}\n */\nexport const encodeDirectory = node => encodePB({\n  Type: node.type,\n  ...encodeDirectoryMetadata(node.metadata || BLANK)\n}, node.entries.map(encodeNamedLink));\n\n/**\n * @param {UnixFS.ShardedDirectory|UnixFS.DirectoryShard} node\n * @returns {UnixFS.ByteView<UnixFS.ShardedDirectory>}\n */\nexport const encodeHAMTShard = ({\n  bitfield,\n  fanout,\n  hashType,\n  entries,\n  metadata = BLANK\n}) => encodePB({\n  Type: NodeType.HAMTShard,\n  Data: bitfield.byteLength > 0 ? bitfield : undefined,\n  fanout: readFanout(fanout),\n  hashType: readInt(hashType),\n  ...encodeDirectoryMetadata(metadata)\n}, entries.map(encodeNamedLink));\n\n/**\n * @param {number} n\n * @returns {number}\n */\nconst readFanout = n => {\n  if (Math.log2(n) % 1 === 0) {\n    return n;\n  } else {\n    throw new TypeError(`Expected hamt size to be a power of two instead got ${n}`);\n  }\n};\n\n/**\n * @param {number} n\n * @returns {number}\n */\n\nconst readInt = n => {\n  if (Number.isInteger(n)) {\n    return n;\n  } else {\n    throw new TypeError(`Expected an integer value instead got ${n}`);\n  }\n};\n\n/**\n * @param {Uint8Array} bytes\n */\nconst readData = bytes => bytes.byteLength > 0 ? bytes : undefined;\n\n/**\n * @param {Uint8Array} path\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.Symlink}\n */\nexport const createSymlink = (path, metadata = BLANK) => ({\n  type: NodeType.Symlink,\n  content: path,\n  metadata: decodeMetadata(metadata)\n});\n\n/**\n * @param {UnixFS.Symlink} node\n * @param {boolean} [ignoreMetadata]\n * @returns {UnixFS.ByteView<UnixFS.Symlink>}\n */\nexport const encodeSymlink = (node, ignoreMetadata = false) => {\n  const metadata = ignoreMetadata ? BLANK : Object(node).metadata;\n  // We do not include filesize on symlinks because that is what go-ipfs does\n  // when doing `ipfs add mysymlink`. js-ipfs on the other hand seems to store\n  // it, here we choose to follow go-ipfs\n  // @see https://explore.ipld.io/#/explore/QmPZ1CTc5fYErTH2XXDGrfsPsHicYXtkZeVojGycwAfm3v\n  // @see https://github.com/ipfs/js-ipfs-unixfs/issues/195\n  return encodePB({\n    Type: NodeType.Symlink,\n    Data: node.content,\n    ...encodeMetadata(metadata || BLANK)\n  }, []);\n};\n\n/**\n * @template {UnixFS.Node} T\n * @param {T} node\n * @param {boolean} root\n */\nexport const encode = (node, root = true) => {\n  switch (node.type) {\n    case NodeType.Raw:\n      return encodeRaw(node.content);\n    case NodeType.File:\n      return encodeFile(node);\n    case NodeType.Directory:\n      return encodeDirectory(node);\n    case NodeType.HAMTShard:\n      return encodeHAMTShard(node);\n    case NodeType.Symlink:\n      return encodeSymlink(node);\n    default:\n      throw new Error(`Unknown node type ${Object(node).type}`);\n  }\n};\n\n/**\n * @param {UnixFS.ByteView<UnixFS.Node>} bytes\n * @returns {UnixFS.Node}\n */\nexport const decode = bytes => {\n  const pb = PB.decode(bytes);\n  const message = Data.decode( /** @type {Uint8Array} */pb.Data);\n  const {\n    Type: type,\n    Data: data,\n    mtime,\n    mode,\n    blocksizes,\n    ...rest\n  } = Data.toObject(message, {\n    defaults: false,\n    arrays: true,\n    longs: Number,\n    objects: false\n  });\n  const metadata = {\n    ...(mode && {\n      mode\n    }),\n    ...decodeMtime(mtime)\n  };\n  /** @type {UnixFS.PBLink[]} */\n  const links = pb.Links;\n  switch (message.Type) {\n    case NodeType.Raw:\n      return createRaw(data);\n    case NodeType.File:\n      if (links.length === 0) {\n        return new SimpleFileView(data, metadata);\n      } else if (data.byteLength === 0) {\n        return new AdvancedFileView(decodeFileLinks(rest.blocksizes, links), metadata);\n      } else {\n        return new ComplexFileView(data, decodeFileLinks(rest.blocksizes, links), metadata);\n      }\n    case NodeType.Directory:\n      return createFlatDirectory(decodeDirectoryLinks(links), metadata);\n    case NodeType.HAMTShard:\n      return createShardedDirectory(decodeDirectoryLinks(links), data || EMPTY_BUFFER, rest.fanout, rest.hashType, metadata);\n    case NodeType.Symlink:\n      return createSymlink(data, metadata);\n    default:\n      throw new TypeError(`Unsupported node type ${message.Type}`);\n  }\n};\n\n/**\n * @param {UnixFS.UnixTime|undefined} mtime\n */\nconst decodeMtime = mtime => mtime == null ? undefined : {\n  mtime: {\n    secs: mtime.Seconds,\n    nsecs: mtime.FractionalNanoseconds || 0\n  }\n};\n\n/**\n * @param {NodeType} type\n * @param {number[]|undefined} blocksizes\n */\nconst decodeBlocksizes = (type, blocksizes) => {\n  switch (type) {\n    case NodeType.File:\n      return blocksizes && blocksizes.length > 0 ? {\n        blocksizes\n      } : undefined;\n    default:\n      return undefined;\n  }\n};\n\n/**\n *\n * @param {number[]} blocksizes\n * @param {UnixFS.PBLink[]} links\n * @returns {UnixFS.FileLink[]}\n */\n\nconst decodeFileLinks = (blocksizes, links) => {\n  const parts = [];\n  const length = blocksizes.length;\n  let n = 0;\n  while (n < length) {\n    parts.push( /** @type {UnixFS.FileLink} */{\n      cid: links[n].Hash,\n      dagByteLength: links[n].Tsize || 0,\n      contentByteLength: blocksizes[n]\n    });\n  }\n  return parts;\n};\n\n/**\n * @param {UnixFS.PBLink[]} links\n * @returns {UnixFS.DirectoryEntryLink[]}\n */\nconst decodeDirectoryLinks = links => links.map(link => ( /** @type {UnixFS.DirectoryEntryLink} */{\n  cid: link.Hash,\n  name: link.Name || \"\",\n  dagByteLength: link.Tsize || 0\n}));\n\n/**\n * @param {ReadonlyArray<UnixFS.FileLink>} links\n * @returns {number}\n */\nexport const cumulativeContentByteLength = links => links.reduce((size, link) => size + link.contentByteLength, 0);\n\n/**\n * @param {Uint8Array} root\n * @param {ReadonlyArray<UnixFS.DAGLink>} links\n * @returns {number}\n */\nexport const cumulativeDagByteLength = (root, links) => links.reduce((size, link) => size + link.dagByteLength, root.byteLength);\n\n/**\n *\n * @param {UnixFS.FileLink} link\n */\nconst contentByteLength = link => link.contentByteLength;\n\n/**\n * @param {UnixFS.NamedDAGLink<unknown>} link\n * @returns {UnixFS.PBLink}\n */\nconst encodeNamedLink = ({\n  name,\n  dagByteLength,\n  cid\n}) => ({\n  Name: name,\n  Tsize: dagByteLength,\n  Hash: cid\n});\n\n/**\n * @param {UnixFS.Metadata} metadata\n */\nexport const encodeDirectoryMetadata = metadata => encodeMetadata(metadata, DEFAULT_DIRECTORY_MODE);\n\n/**\n * @param {UnixFS.Metadata} metadata\n * @param {UnixFS.Mode} defaultMode\n */\nexport const encodeMetadata = ({\n  mode,\n  mtime\n}, defaultMode = DEFAULT_FILE_MODE) => ({\n  mode: mode != null ? encodeMode(mode, defaultMode) : undefined,\n  mtime: mtime != null ? encodeMTime(mtime) : undefined\n});\n\n/**\n * @param {UnixFS.Metadata} [data]\n */\nexport const decodeMetadata = data => data == null ? BLANK : {\n  ...(data.mode == null ? undefined : {\n    mode: decodeMode(data.mode)\n  }),\n  ...(data.mtime == null ? undefined : {\n    mtime: data.mtime\n  })\n};\n\n/**\n * @param {UnixFS.MTime} mtime\n */\nconst encodeMTime = mtime => {\n  return mtime == null ? undefined : mtime.nsecs !== 0 ? {\n    Seconds: mtime.secs,\n    FractionalNanoseconds: mtime.nsecs\n  } : {\n    Seconds: mtime.secs\n  };\n};\n\n/**\n * @param {number} specifiedMode\n * @param {number} defaultMode\n */\nexport const encodeMode = (specifiedMode, defaultMode) => {\n  const mode = specifiedMode == null ? undefined : decodeMode(specifiedMode);\n  return mode === defaultMode || mode == null ? undefined : mode;\n};\n\n/**\n * @param {UnixFS.Mode} mode\n * @returns {UnixFS.Mode}\n */\nconst decodeMode = mode => mode & 0xfff | mode & 0xfffff000;\n\n/**\n * @param {{content?: Uint8Array, parts?: ReadonlyArray<UnixFS.FileLink>, metadata?: UnixFS.Metadata }} node\n * @returns {UnixFS.SimpleFile|UnixFS.AdvancedFile|UnixFS.ComplexFile}\n */\nexport const matchFile = ({\n  content = EMPTY_BUFFER,\n  parts = EMPTY,\n  metadata = BLANK,\n  ...rest\n}) => {\n  if (parts.length === 0) {\n    return new SimpleFileView(content, metadata);\n  } else if (content.byteLength === 0) {\n    return new AdvancedFileView(parts, metadata);\n  } else {\n    return new ComplexFileView(content, parts, metadata);\n  }\n};\n\n/**\n * @implements {UnixFS.SimpleFile}\n */\nclass SimpleFileView {\n  /**\n   * @param {Uint8Array} content\n   * @param {UnixFS.Metadata} metadata\n   */\n  constructor(content, metadata) {\n    this.content = content;\n    this.metadata = metadata;\n    /**\n     * @readonly\n     * @type {\"simple\"}\n     */\n    this.layout = \"simple\";\n    /**\n     * @readonly\n     * @type {NodeType.File}\n     */\n    this.type = NodeType.File;\n  }\n  get filesize() {\n    return this.content.byteLength;\n  }\n  encode() {\n    return encodeSimpleFile(this.content, this.metadata);\n  }\n}\n\n/**\n * @implements {UnixFS.AdvancedFile}\n */\nclass AdvancedFileView {\n  /**\n   * @param {ReadonlyArray<UnixFS.FileLink>} parts\n   * @param {UnixFS.Metadata} metadata\n   */\n  constructor(parts, metadata) {\n    this.parts = parts;\n    this.metadata = metadata;\n  }\n  /** @type {\"advanced\"} */\n  get layout() {\n    return \"advanced\";\n  }\n\n  /**\n   * @returns {NodeType.File}\n   */\n  get type() {\n    return NodeType.File;\n  }\n  get fileSize() {\n    return cumulativeContentByteLength(this.parts);\n  }\n  get blockSizes() {\n    return this.parts.map(contentByteLength);\n  }\n  encode() {\n    return encodeAdvancedFile(this.parts, this.metadata);\n  }\n}\n\n/**\n * @implements {UnixFS.ComplexFile}\n */\nclass ComplexFileView {\n  /**\n   * @param {Uint8Array} content\n   * @param {ReadonlyArray<UnixFS.FileLink>} parts\n   * @param {UnixFS.Metadata} metadata\n   */\n  constructor(content, parts, metadata) {\n    this.content = content;\n    this.parts = parts;\n    this.metadata = metadata;\n  }\n  /** @type {\"complex\"} */\n  get layout() {\n    return \"complex\";\n  }\n\n  /**\n   * @returns {NodeType.File}\n   */\n  get type() {\n    return NodeType.File;\n  }\n  get fileSize() {\n    return this.content.byteLength + cumulativeContentByteLength(this.parts);\n  }\n  get blockSizes() {\n    return this.parts.map(contentByteLength);\n  }\n  encode() {\n    return encodeComplexFile(this.content, this.parts, this.metadata);\n  }\n}\n\n/**\n * @param {UnixFS.File|UnixFS.Raw|UnixFS.FileChunk|UnixFS.FileShard|UnixFS.Symlink} node\n * @returns {number}\n */\nexport const filesize = node => {\n  switch (node.type) {\n    case NodeType.Raw:\n    case NodeType.Symlink:\n      return node.content.byteLength;\n    case NodeType.File:\n      switch (node.layout) {\n        case \"simple\":\n          return node.content.byteLength;\n        case \"advanced\":\n          return cumulativeContentByteLength(node.parts);\n        case \"complex\":\n          return node.content.byteLength + cumulativeContentByteLength(node.parts);\n      }\n    default:\n      return 0;\n  }\n};","map":{"version":3,"names":["PB","UnixFS","NodeType","Data","EMPTY","Object","freeze","EMPTY_BUFFER","Uint8Array","BLANK","DEFAULT_FILE_MODE","parseInt","DEFAULT_DIRECTORY_MODE","code","name","encodePB","data","links","globalThis","debug","console","log","encode","prepare","finish","Links","createRaw","content","type","Raw","createEmptyFile","metadata","createSimpleFile","File","layout","decodeMetadata","createFileChunk","createAdvancedFile","parts","createFileShard","createComplexFile","createFlatDirectory","entries","Directory","createShardedDirectory","bitfield","fanout","hashType","HAMTShard","readFanout","readInt","createDirectoryShard","encodeRaw","Type","byteLength","undefined","filesize","blocksizes","encodeFile","node","ignoreMetadata","encodeSimpleFile","encodeAdvancedFile","encodeComplexFile","TypeError","encodeFileChunk","encodeFileShard","map","contentByteLength","cumulativeContentByteLength","encodeLink","encodeMetadata","dag","Name","Tsize","dagByteLength","Hash","cid","encodeDirectory","encodeDirectoryMetadata","encodeNamedLink","encodeHAMTShard","n","Math","log2","Number","isInteger","readData","bytes","createSymlink","path","Symlink","encodeSymlink","root","Error","decode","pb","message","mtime","mode","rest","toObject","defaults","arrays","longs","objects","decodeMtime","length","SimpleFileView","AdvancedFileView","decodeFileLinks","ComplexFileView","decodeDirectoryLinks","secs","Seconds","nsecs","FractionalNanoseconds","decodeBlocksizes","push","link","reduce","size","cumulativeDagByteLength","defaultMode","encodeMode","encodeMTime","decodeMode","specifiedMode","matchFile","constructor","fileSize","blockSizes"],"sources":["C:/FACULTATE/Proiect/node_modules/@ipld/unixfs/src/codec.js"],"sourcesContent":["import * as PB from \"@ipld/dag-pb\"\nimport * as UnixFS from \"./unixfs.js\"\nimport { NodeType } from \"./unixfs.js\"\nimport { Data } from \"../gen/unixfs.js\"\n\nexport * from \"./unixfs.js\"\n\n/** @type {ReadonlyArray<any>} */\nconst EMPTY = Object.freeze([])\nconst EMPTY_BUFFER = new Uint8Array(0)\n\nconst BLANK = Object.freeze({})\nexport const DEFAULT_FILE_MODE = parseInt(\"0644\", 8)\nexport const DEFAULT_DIRECTORY_MODE = parseInt(\"0755\", 8)\n\nexport const code = PB.code\nexport const name = \"UnixFS\"\n\n/**\n * @param {UnixFS.IData} data\n * @param {ReadonlyArray<UnixFS.PBLink>} links\n */\nconst encodePB = (data, links) => {\n  Object(globalThis).debug && console.log({ data, links })\n\n  return PB.encode(\n    // We run through prepare as links need to be sorted by name which it will\n    // do.\n    PB.prepare({\n      Data: Data.encode(data).finish(),\n      // We can cast to mutable array as we know no mutation occurs there\n      Links:\n        /** @type {PB.PBLink[]} */ (links),\n    })\n  )\n}\n\n/**\n * @param {Uint8Array} content\n * @returns {UnixFS.Raw}\n */\nexport const createRaw = content => ({\n  type: NodeType.Raw,\n  content,\n})\n\n/**\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.SimpleFile}\n */\nexport const createEmptyFile = metadata =>\n  createSimpleFile(EMPTY_BUFFER, metadata)\n\n/**\n * @param {Uint8Array} content\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.SimpleFile}\n */\nexport const createSimpleFile = (content, metadata) => ({\n  type: NodeType.File,\n  layout: \"simple\",\n  content,\n  metadata: decodeMetadata(metadata),\n})\n\n/**\n * @param {Uint8Array} content\n * @returns {UnixFS.FileChunk}\n */\nexport const createFileChunk = content => ({\n  type: NodeType.File,\n  layout: \"simple\",\n  content,\n})\n\n/**\n * @param {UnixFS.FileLink[]} parts\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.AdvancedFile}\n */\nexport const createAdvancedFile = (parts, metadata) => ({\n  type: NodeType.File,\n  layout: \"advanced\",\n  parts,\n  metadata: decodeMetadata(metadata),\n})\n\n/**\n * @param {UnixFS.FileLink[]} parts\n * @returns {UnixFS.FileShard}\n */\nexport const createFileShard = parts => ({\n  type: NodeType.File,\n  layout: \"advanced\",\n  parts,\n})\n\n/**\n * @deprecated\n * @param {Uint8Array} content\n * @param {UnixFS.FileLink[]} parts\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ComplexFile}\n */\nexport const createComplexFile = (content, parts, metadata) => ({\n  type: NodeType.File,\n  layout: \"complex\",\n  content,\n  parts,\n  metadata: decodeMetadata(metadata),\n})\n\n/**\n * @param {UnixFS.DirectoryEntryLink[]} entries\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.FlatDirectory}\n */\nexport const createFlatDirectory = (entries, metadata) => ({\n  type: NodeType.Directory,\n  metadata: decodeMetadata(metadata),\n  entries,\n})\n\n/**\n * @param {UnixFS.ShardedDirectoryLink[]} entries\n * @param {Uint8Array} bitfield\n * @param {number} fanout\n * @param {number} hashType\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ShardedDirectory}\n */\nexport const createShardedDirectory = (\n  entries,\n  bitfield,\n  fanout,\n  hashType,\n  metadata = BLANK\n) => ({\n  type: NodeType.HAMTShard,\n  bitfield,\n  fanout: readFanout(fanout),\n  hashType: readInt(hashType),\n  entries,\n  metadata: decodeMetadata(metadata),\n})\n\n/**\n * @param {UnixFS.ShardedDirectoryLink[]} entries\n * @param {Uint8Array} bitfield\n * @param {number} fanout\n * @param {number} hashType\n * @returns {UnixFS.DirectoryShard}\n */\nexport const createDirectoryShard = (entries, bitfield, fanout, hashType) => ({\n  type: NodeType.HAMTShard,\n  bitfield,\n  fanout: readFanout(fanout),\n  hashType: readInt(hashType),\n  entries,\n})\n\n/**\n *\n * @param {Uint8Array} content\n * @returns {UnixFS.ByteView<UnixFS.Raw>}\n */\nexport const encodeRaw = content =>\n  encodePB(\n    {\n      Type: NodeType.Raw,\n      // TODO:\n      Data: content.byteLength > 0 ? content : undefined,\n      filesize: content.byteLength,\n      // @ts-ignore\n      blocksizes: EMPTY,\n    },\n    []\n  )\n\n/**\n * @param {UnixFS.File|UnixFS.FileChunk|UnixFS.FileShard} node\n * @param {boolean} [ignoreMetadata]\n * @returns {UnixFS.ByteView<UnixFS.SimpleFile|UnixFS.AdvancedFile|UnixFS.ComplexFile>}\n */\nexport const encodeFile = (node, ignoreMetadata = false) => {\n  const metadata = ignoreMetadata ? BLANK : Object(node).metadata\n  switch (node.layout) {\n    case \"simple\":\n      return encodeSimpleFile(node.content, metadata)\n    case \"advanced\":\n      return encodeAdvancedFile(node.parts, metadata)\n    case \"complex\":\n      return encodeComplexFile(node.content, node.parts, metadata)\n    default:\n      throw new TypeError(\n        `File with unknown layout \"${Object(node).layout}\" was passed`\n      )\n  }\n}\n\n/**\n * @param {Uint8Array} content\n * @returns {UnixFS.ByteView<UnixFS.FileChunk>}\n */\nexport const encodeFileChunk = content => encodeSimpleFile(content, BLANK)\n\n/**\n * @param {ReadonlyArray<UnixFS.FileLink>} parts\n * @returns {UnixFS.ByteView<UnixFS.FileShard>}\n */\nexport const encodeFileShard = parts =>\n  encodePB(\n    {\n      Type: NodeType.File,\n      blocksizes: parts.map(contentByteLength),\n      filesize: cumulativeContentByteLength(parts),\n    },\n    parts.map(encodeLink)\n  )\n\n/**\n * @param {ReadonlyArray<UnixFS.FileLink>} parts\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ByteView<UnixFS.AdvancedFile>}\n */\nexport const encodeAdvancedFile = (parts, metadata = BLANK) =>\n  encodePB(\n    {\n      Type: NodeType.File,\n      blocksizes: parts.map(contentByteLength),\n      filesize: cumulativeContentByteLength(parts),\n\n      ...encodeMetadata(metadata),\n    },\n    parts.map(encodeLink)\n  )\n\n/**\n * @param {UnixFS.DAGLink} dag\n * @returns {UnixFS.PBLink}\n */\nexport const encodeLink = dag => ({\n  Name: \"\",\n  Tsize: dag.dagByteLength,\n  // @ts-ignore - @see https://github.com/multiformats/js-multiformats/pull/161\n  Hash: dag.cid,\n})\n\n/**\n * @param {Uint8Array} content\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ByteView<UnixFS.SimpleFile>}\n */\n\nexport const encodeSimpleFile = (content, metadata = BLANK) =>\n  encodePB(\n    {\n      Type: NodeType.File,\n      // adding empty file to both go-ipfs and js-ipfs produces block in\n      // which `Data` is omitted but filesize and blocksizes are present.\n      // For the sake of hash consistency we do the same.\n      Data: content.byteLength > 0 ? content : undefined,\n      filesize: content.byteLength,\n      blocksizes: [],\n      ...encodeMetadata(metadata),\n    },\n    []\n  )\n\n/**\n *\n * @param {Uint8Array} content\n * @param {ReadonlyArray<UnixFS.FileLink>} parts\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ByteView<UnixFS.ComplexFile>}\n */\nexport const encodeComplexFile = (content, parts, metadata = BLANK) =>\n  encodePB(\n    {\n      Type: NodeType.File,\n      Data: content,\n      filesize: content.byteLength + cumulativeContentByteLength(parts),\n      blocksizes: parts.map(contentByteLength),\n    },\n    parts.map(encodeLink)\n  )\n\n/**\n * @param {UnixFS.FlatDirectory} node\n * @returns {UnixFS.ByteView<UnixFS.FlatDirectory>}\n */\nexport const encodeDirectory = node =>\n  encodePB(\n    {\n      Type: node.type,\n      ...encodeDirectoryMetadata(node.metadata || BLANK),\n    },\n    node.entries.map(encodeNamedLink)\n  )\n\n/**\n * @param {UnixFS.ShardedDirectory|UnixFS.DirectoryShard} node\n * @returns {UnixFS.ByteView<UnixFS.ShardedDirectory>}\n */\nexport const encodeHAMTShard = ({\n  bitfield,\n  fanout,\n  hashType,\n  entries,\n  metadata = BLANK,\n}) =>\n  encodePB(\n    {\n      Type: NodeType.HAMTShard,\n      Data: bitfield.byteLength > 0 ? bitfield : undefined,\n      fanout: readFanout(fanout),\n      hashType: readInt(hashType),\n\n      ...encodeDirectoryMetadata(metadata),\n    },\n    entries.map(encodeNamedLink)\n  )\n\n/**\n * @param {number} n\n * @returns {number}\n */\nconst readFanout = n => {\n  if (Math.log2(n) % 1 === 0) {\n    return n\n  } else {\n    throw new TypeError(\n      `Expected hamt size to be a power of two instead got ${n}`\n    )\n  }\n}\n\n/**\n * @param {number} n\n * @returns {number}\n */\n\nconst readInt = n => {\n  if (Number.isInteger(n)) {\n    return n\n  } else {\n    throw new TypeError(`Expected an integer value instead got ${n}`)\n  }\n}\n\n/**\n * @param {Uint8Array} bytes\n */\nconst readData = bytes => (bytes.byteLength > 0 ? bytes : undefined)\n\n/**\n * @param {Uint8Array} path\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.Symlink}\n */\nexport const createSymlink = (path, metadata = BLANK) => ({\n  type: NodeType.Symlink,\n  content: path,\n  metadata: decodeMetadata(metadata),\n})\n\n/**\n * @param {UnixFS.Symlink} node\n * @param {boolean} [ignoreMetadata]\n * @returns {UnixFS.ByteView<UnixFS.Symlink>}\n */\nexport const encodeSymlink = (node, ignoreMetadata = false) => {\n  const metadata = ignoreMetadata ? BLANK : Object(node).metadata\n  // We do not include filesize on symlinks because that is what go-ipfs does\n  // when doing `ipfs add mysymlink`. js-ipfs on the other hand seems to store\n  // it, here we choose to follow go-ipfs\n  // @see https://explore.ipld.io/#/explore/QmPZ1CTc5fYErTH2XXDGrfsPsHicYXtkZeVojGycwAfm3v\n  // @see https://github.com/ipfs/js-ipfs-unixfs/issues/195\n  return encodePB(\n    {\n      Type: NodeType.Symlink,\n      Data: node.content,\n      ...encodeMetadata(metadata || BLANK),\n    },\n    []\n  )\n}\n\n/**\n * @template {UnixFS.Node} T\n * @param {T} node\n * @param {boolean} root\n */\nexport const encode = (node, root = true) => {\n  switch (node.type) {\n    case NodeType.Raw:\n      return encodeRaw(node.content)\n    case NodeType.File:\n      return encodeFile(node)\n    case NodeType.Directory:\n      return encodeDirectory(node)\n    case NodeType.HAMTShard:\n      return encodeHAMTShard(node)\n    case NodeType.Symlink:\n      return encodeSymlink(node)\n    default:\n      throw new Error(`Unknown node type ${Object(node).type}`)\n  }\n}\n\n/**\n * @param {UnixFS.ByteView<UnixFS.Node>} bytes\n * @returns {UnixFS.Node}\n */\nexport const decode = bytes => {\n  const pb = PB.decode(bytes)\n  const message = Data.decode(/** @type {Uint8Array} */ (pb.Data))\n\n  const {\n    Type: type,\n    Data: data,\n    mtime,\n    mode,\n    blocksizes,\n    ...rest\n  } = Data.toObject(message, {\n    defaults: false,\n    arrays: true,\n    longs: Number,\n    objects: false,\n  })\n  const metadata = {\n    ...(mode && { mode }),\n    ...decodeMtime(mtime),\n  }\n  /** @type {UnixFS.PBLink[]} */\n  const links = pb.Links\n\n  switch (message.Type) {\n    case NodeType.Raw:\n      return createRaw(data)\n    case NodeType.File:\n      if (links.length === 0) {\n        return new SimpleFileView(data, metadata)\n      } else if (data.byteLength === 0) {\n        return new AdvancedFileView(\n          decodeFileLinks(rest.blocksizes, links),\n          metadata\n        )\n      } else {\n        return new ComplexFileView(\n          data,\n          decodeFileLinks(rest.blocksizes, links),\n          metadata\n        )\n      }\n    case NodeType.Directory:\n      return createFlatDirectory(decodeDirectoryLinks(links), metadata)\n    case NodeType.HAMTShard:\n      return createShardedDirectory(\n        decodeDirectoryLinks(links),\n        data || EMPTY_BUFFER,\n        rest.fanout,\n        rest.hashType,\n        metadata\n      )\n    case NodeType.Symlink:\n      return createSymlink(data, metadata)\n    default:\n      throw new TypeError(`Unsupported node type ${message.Type}`)\n  }\n}\n\n/**\n * @param {UnixFS.UnixTime|undefined} mtime\n */\nconst decodeMtime = mtime =>\n  mtime == null\n    ? undefined\n    : {\n        mtime: { secs: mtime.Seconds, nsecs: mtime.FractionalNanoseconds || 0 },\n      }\n\n/**\n * @param {NodeType} type\n * @param {number[]|undefined} blocksizes\n */\nconst decodeBlocksizes = (type, blocksizes) => {\n  switch (type) {\n    case NodeType.File:\n      return blocksizes && blocksizes.length > 0 ? { blocksizes } : undefined\n    default:\n      return undefined\n  }\n}\n\n/**\n *\n * @param {number[]} blocksizes\n * @param {UnixFS.PBLink[]} links\n * @returns {UnixFS.FileLink[]}\n */\n\nconst decodeFileLinks = (blocksizes, links) => {\n  const parts = []\n  const length = blocksizes.length\n  let n = 0\n  while (n < length) {\n    parts.push(\n      /** @type {UnixFS.FileLink} */ ({\n        cid: links[n].Hash,\n        dagByteLength: links[n].Tsize || 0,\n        contentByteLength: blocksizes[n],\n      })\n    )\n  }\n  return parts\n}\n\n/**\n * @param {UnixFS.PBLink[]} links\n * @returns {UnixFS.DirectoryEntryLink[]}\n */\nconst decodeDirectoryLinks = links =>\n  links.map(\n    link =>\n      /** @type {UnixFS.DirectoryEntryLink} */ ({\n        cid: link.Hash,\n        name: link.Name || \"\",\n        dagByteLength: link.Tsize || 0,\n      })\n  )\n\n/**\n * @param {ReadonlyArray<UnixFS.FileLink>} links\n * @returns {number}\n */\nexport const cumulativeContentByteLength = links =>\n  links.reduce((size, link) => size + link.contentByteLength, 0)\n\n/**\n * @param {Uint8Array} root\n * @param {ReadonlyArray<UnixFS.DAGLink>} links\n * @returns {number}\n */\nexport const cumulativeDagByteLength = (root, links) =>\n  links.reduce((size, link) => size + link.dagByteLength, root.byteLength)\n\n/**\n *\n * @param {UnixFS.FileLink} link\n */\nconst contentByteLength = link => link.contentByteLength\n\n/**\n * @param {UnixFS.NamedDAGLink<unknown>} link\n * @returns {UnixFS.PBLink}\n */\nconst encodeNamedLink = ({ name, dagByteLength, cid }) => ({\n  Name: name,\n  Tsize: dagByteLength,\n  Hash: cid,\n})\n\n/**\n * @param {UnixFS.Metadata} metadata\n */\nexport const encodeDirectoryMetadata = metadata =>\n  encodeMetadata(metadata, DEFAULT_DIRECTORY_MODE)\n\n/**\n * @param {UnixFS.Metadata} metadata\n * @param {UnixFS.Mode} defaultMode\n */\nexport const encodeMetadata = (\n  { mode, mtime },\n  defaultMode = DEFAULT_FILE_MODE\n) => ({\n  mode: mode != null ? encodeMode(mode, defaultMode) : undefined,\n  mtime: mtime != null ? encodeMTime(mtime) : undefined,\n})\n\n/**\n * @param {UnixFS.Metadata} [data]\n */\nexport const decodeMetadata = data =>\n  data == null\n    ? BLANK\n    : {\n        ...(data.mode == null ? undefined : { mode: decodeMode(data.mode) }),\n        ...(data.mtime == null ? undefined : { mtime: data.mtime }),\n      }\n\n/**\n * @param {UnixFS.MTime} mtime\n */\nconst encodeMTime = mtime => {\n  return mtime == null\n    ? undefined\n    : mtime.nsecs !== 0\n    ? { Seconds: mtime.secs, FractionalNanoseconds: mtime.nsecs }\n    : { Seconds: mtime.secs }\n}\n\n/**\n * @param {number} specifiedMode\n * @param {number} defaultMode\n */\nexport const encodeMode = (specifiedMode, defaultMode) => {\n  const mode = specifiedMode == null ? undefined : decodeMode(specifiedMode)\n  return mode === defaultMode || mode == null ? undefined : mode\n}\n\n/**\n * @param {UnixFS.Mode} mode\n * @returns {UnixFS.Mode}\n */\nconst decodeMode = mode => (mode & 0xfff) | (mode & 0xfffff000)\n\n/**\n * @param {{content?: Uint8Array, parts?: ReadonlyArray<UnixFS.FileLink>, metadata?: UnixFS.Metadata }} node\n * @returns {UnixFS.SimpleFile|UnixFS.AdvancedFile|UnixFS.ComplexFile}\n */\nexport const matchFile = ({\n  content = EMPTY_BUFFER,\n  parts = EMPTY,\n  metadata = BLANK,\n  ...rest\n}) => {\n  if (parts.length === 0) {\n    return new SimpleFileView(content, metadata)\n  } else if (content.byteLength === 0) {\n    return new AdvancedFileView(parts, metadata)\n  } else {\n    return new ComplexFileView(content, parts, metadata)\n  }\n}\n\n/**\n * @implements {UnixFS.SimpleFile}\n */\nclass SimpleFileView {\n  /**\n   * @param {Uint8Array} content\n   * @param {UnixFS.Metadata} metadata\n   */\n  constructor(content, metadata) {\n    this.content = content\n    this.metadata = metadata\n    /**\n     * @readonly\n     * @type {\"simple\"}\n     */\n    this.layout = \"simple\"\n    /**\n     * @readonly\n     * @type {NodeType.File}\n     */\n    this.type = NodeType.File\n  }\n\n  get filesize() {\n    return this.content.byteLength\n  }\n\n  encode() {\n    return encodeSimpleFile(this.content, this.metadata)\n  }\n}\n\n/**\n * @implements {UnixFS.AdvancedFile}\n */\nclass AdvancedFileView {\n  /**\n   * @param {ReadonlyArray<UnixFS.FileLink>} parts\n   * @param {UnixFS.Metadata} metadata\n   */\n  constructor(parts, metadata) {\n    this.parts = parts\n    this.metadata = metadata\n  }\n  /** @type {\"advanced\"} */\n  get layout() {\n    return \"advanced\"\n  }\n\n  /**\n   * @returns {NodeType.File}\n   */\n  get type() {\n    return NodeType.File\n  }\n  get fileSize() {\n    return cumulativeContentByteLength(this.parts)\n  }\n  get blockSizes() {\n    return this.parts.map(contentByteLength)\n  }\n\n  encode() {\n    return encodeAdvancedFile(this.parts, this.metadata)\n  }\n}\n\n/**\n * @implements {UnixFS.ComplexFile}\n */\nclass ComplexFileView {\n  /**\n   * @param {Uint8Array} content\n   * @param {ReadonlyArray<UnixFS.FileLink>} parts\n   * @param {UnixFS.Metadata} metadata\n   */\n  constructor(content, parts, metadata) {\n    this.content = content\n    this.parts = parts\n    this.metadata = metadata\n  }\n  /** @type {\"complex\"} */\n  get layout() {\n    return \"complex\"\n  }\n\n  /**\n   * @returns {NodeType.File}\n   */\n  get type() {\n    return NodeType.File\n  }\n  get fileSize() {\n    return this.content.byteLength + cumulativeContentByteLength(this.parts)\n  }\n  get blockSizes() {\n    return this.parts.map(contentByteLength)\n  }\n\n  encode() {\n    return encodeComplexFile(this.content, this.parts, this.metadata)\n  }\n}\n\n/**\n * @param {UnixFS.File|UnixFS.Raw|UnixFS.FileChunk|UnixFS.FileShard|UnixFS.Symlink} node\n * @returns {number}\n */\nexport const filesize = node => {\n  switch (node.type) {\n    case NodeType.Raw:\n    case NodeType.Symlink:\n      return node.content.byteLength\n    case NodeType.File:\n      switch (node.layout) {\n        case \"simple\":\n          return node.content.byteLength\n        case \"advanced\":\n          return cumulativeContentByteLength(node.parts)\n        case \"complex\":\n          return (\n            node.content.byteLength + cumulativeContentByteLength(node.parts)\n          )\n      }\n    default:\n      return 0\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}