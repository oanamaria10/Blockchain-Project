{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { BaseBackend, getCurrentHub } from '@sentry/core';\nimport { Severity } from '@sentry/types';\nimport { addExceptionMechanism, addExceptionTypeValue, Dsn, extractExceptionKeysForMessage, isError, isPlainObject, normalizeToSize, SyncPromise } from '@sentry/utils';\nimport { extractStackFromError, parseError, parseStack, prepareFramesForEvent } from './parsers';\nimport { HTTPSTransport, HTTPTransport } from './transports';\n/**\n * The Sentry Node SDK Backend.\n * @hidden\n */\nvar NodeBackend = /** @class */function (_super) {\n  __extends(NodeBackend, _super);\n  function NodeBackend() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  NodeBackend.prototype.eventFromException = function (exception, hint) {\n    var _this = this;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    var ex = exception;\n    var mechanism = {\n      handled: true,\n      type: 'generic'\n    };\n    if (!isError(exception)) {\n      if (isPlainObject(exception)) {\n        // This will allow us to group events based on top-level keys\n        // which is much better than creating new group when any key/value change\n        var message = \"Non-Error exception captured with keys: \" + extractExceptionKeysForMessage(exception);\n        getCurrentHub().configureScope(function (scope) {\n          scope.setExtra('__serialized__', normalizeToSize(exception));\n        });\n        ex = hint && hint.syntheticException || new Error(message);\n        ex.message = message;\n      } else {\n        // This handles when someone does: `throw \"something awesome\";`\n        // We use synthesized Error here so we can extract a (rough) stack trace.\n        ex = hint && hint.syntheticException || new Error(exception);\n        ex.message = exception;\n      }\n      mechanism.synthetic = true;\n    }\n    return new SyncPromise(function (resolve, reject) {\n      return parseError(ex, _this._options).then(function (event) {\n        addExceptionTypeValue(event, undefined, undefined);\n        addExceptionMechanism(event, mechanism);\n        resolve(__assign(__assign({}, event), {\n          event_id: hint && hint.event_id\n        }));\n      }).then(null, reject);\n    });\n  };\n  /**\n   * @inheritDoc\n   */\n  NodeBackend.prototype.eventFromMessage = function (message, level, hint) {\n    var _this = this;\n    if (level === void 0) {\n      level = Severity.Info;\n    }\n    var event = {\n      event_id: hint && hint.event_id,\n      level: level,\n      message: message\n    };\n    return new SyncPromise(function (resolve) {\n      if (_this._options.attachStacktrace && hint && hint.syntheticException) {\n        var stack = hint.syntheticException ? extractStackFromError(hint.syntheticException) : [];\n        parseStack(stack, _this._options).then(function (frames) {\n          event.stacktrace = {\n            frames: prepareFramesForEvent(frames)\n          };\n          resolve(event);\n        }).then(null, function () {\n          resolve(event);\n        });\n      } else {\n        resolve(event);\n      }\n    });\n  };\n  /**\n   * @inheritDoc\n   */\n  NodeBackend.prototype._setupTransport = function () {\n    if (!this._options.dsn) {\n      // We return the noop transport here in case there is no Dsn.\n      return _super.prototype._setupTransport.call(this);\n    }\n    var dsn = new Dsn(this._options.dsn);\n    var transportOptions = __assign(__assign(__assign(__assign(__assign({}, this._options.transportOptions), this._options.httpProxy && {\n      httpProxy: this._options.httpProxy\n    }), this._options.httpsProxy && {\n      httpsProxy: this._options.httpsProxy\n    }), this._options.caCerts && {\n      caCerts: this._options.caCerts\n    }), {\n      dsn: this._options.dsn\n    });\n    if (this._options.transport) {\n      return new this._options.transport(transportOptions);\n    }\n    if (dsn.protocol === 'http') {\n      return new HTTPTransport(transportOptions);\n    }\n    return new HTTPSTransport(transportOptions);\n  };\n  return NodeBackend;\n}(BaseBackend);\nexport { NodeBackend };","map":{"version":3,"names":["BaseBackend","getCurrentHub","Severity","addExceptionMechanism","addExceptionTypeValue","Dsn","extractExceptionKeysForMessage","isError","isPlainObject","normalizeToSize","SyncPromise","extractStackFromError","parseError","parseStack","prepareFramesForEvent","HTTPSTransport","HTTPTransport","NodeBackend","_super","__extends","prototype","eventFromException","exception","hint","_this","ex","mechanism","handled","type","message","configureScope","scope","setExtra","syntheticException","Error","synthetic","resolve","reject","_options","then","event","undefined","__assign","event_id","eventFromMessage","level","Info","attachStacktrace","stack","frames","stacktrace","_setupTransport","dsn","call","transportOptions","httpProxy","httpsProxy","caCerts","transport","protocol"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\@sentry\\node\\src\\backend.ts"],"sourcesContent":["import { BaseBackend, getCurrentHub } from '@sentry/core';\nimport { Event, EventHint, Mechanism, Options, Severity, Transport, TransportOptions } from '@sentry/types';\nimport {\n  addExceptionMechanism,\n  addExceptionTypeValue,\n  Dsn,\n  extractExceptionKeysForMessage,\n  isError,\n  isPlainObject,\n  normalizeToSize,\n  SyncPromise,\n} from '@sentry/utils';\n\nimport { extractStackFromError, parseError, parseStack, prepareFramesForEvent } from './parsers';\nimport { HTTPSTransport, HTTPTransport } from './transports';\n\n/**\n * Configuration options for the Sentry Node SDK.\n * @see NodeClient for more information.\n */\nexport interface NodeOptions extends Options {\n  /** Sets an optional server name (device name) */\n  serverName?: string;\n\n  /** Maximum time in milliseconds to wait to drain the request queue, before the process is allowed to exit. */\n  shutdownTimeout?: number;\n\n  /** Set a HTTP proxy that should be used for outbound requests. */\n  httpProxy?: string;\n\n  /** Set a HTTPS proxy that should be used for outbound requests. */\n  httpsProxy?: string;\n\n  /** HTTPS proxy certificates path */\n  caCerts?: string;\n\n  /** Sets the number of context lines for each frame when loading a file. */\n  frameContextLines?: number;\n\n  /** Callback that is executed when a fatal global error occurs. */\n  onFatalError?(error: Error): void;\n}\n\n/**\n * The Sentry Node SDK Backend.\n * @hidden\n */\nexport class NodeBackend extends BaseBackend<NodeOptions> {\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  public eventFromException(exception: any, hint?: EventHint): PromiseLike<Event> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let ex: any = exception;\n    const mechanism: Mechanism = {\n      handled: true,\n      type: 'generic',\n    };\n\n    if (!isError(exception)) {\n      if (isPlainObject(exception)) {\n        // This will allow us to group events based on top-level keys\n        // which is much better than creating new group when any key/value change\n        const message = `Non-Error exception captured with keys: ${extractExceptionKeysForMessage(exception)}`;\n\n        getCurrentHub().configureScope(scope => {\n          scope.setExtra('__serialized__', normalizeToSize(exception as Record<string, unknown>));\n        });\n\n        ex = (hint && hint.syntheticException) || new Error(message);\n        (ex as Error).message = message;\n      } else {\n        // This handles when someone does: `throw \"something awesome\";`\n        // We use synthesized Error here so we can extract a (rough) stack trace.\n        ex = (hint && hint.syntheticException) || new Error(exception as string);\n        (ex as Error).message = exception;\n      }\n      mechanism.synthetic = true;\n    }\n\n    return new SyncPromise<Event>((resolve, reject) =>\n      parseError(ex as Error, this._options)\n        .then(event => {\n          addExceptionTypeValue(event, undefined, undefined);\n          addExceptionMechanism(event, mechanism);\n\n          resolve({\n            ...event,\n            event_id: hint && hint.event_id,\n          });\n        })\n        .then(null, reject),\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public eventFromMessage(message: string, level: Severity = Severity.Info, hint?: EventHint): PromiseLike<Event> {\n    const event: Event = {\n      event_id: hint && hint.event_id,\n      level,\n      message,\n    };\n\n    return new SyncPromise<Event>(resolve => {\n      if (this._options.attachStacktrace && hint && hint.syntheticException) {\n        const stack = hint.syntheticException ? extractStackFromError(hint.syntheticException) : [];\n        parseStack(stack, this._options)\n          .then(frames => {\n            event.stacktrace = {\n              frames: prepareFramesForEvent(frames),\n            };\n            resolve(event);\n          })\n          .then(null, () => {\n            resolve(event);\n          });\n      } else {\n        resolve(event);\n      }\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  protected _setupTransport(): Transport {\n    if (!this._options.dsn) {\n      // We return the noop transport here in case there is no Dsn.\n      return super._setupTransport();\n    }\n\n    const dsn = new Dsn(this._options.dsn);\n\n    const transportOptions: TransportOptions = {\n      ...this._options.transportOptions,\n      ...(this._options.httpProxy && { httpProxy: this._options.httpProxy }),\n      ...(this._options.httpsProxy && { httpsProxy: this._options.httpsProxy }),\n      ...(this._options.caCerts && { caCerts: this._options.caCerts }),\n      dsn: this._options.dsn,\n    };\n\n    if (this._options.transport) {\n      return new this._options.transport(transportOptions);\n    }\n    if (dsn.protocol === 'http') {\n      return new HTTPTransport(transportOptions);\n    }\n    return new HTTPSTransport(transportOptions);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}