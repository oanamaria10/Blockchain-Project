{"ast":null,"code":"/**\n * UCAN core capabilities.\n */\n\nimport { capability, Schema, ok } from '@ucanto/validator';\nimport * as API from '@ucanto/interface';\nimport { equalWith, equal, and, checkLink } from './utils.js';\nexport const UCANLink = /** @type {Schema.Schema<API.UCANLink, unknown>} */\nSchema.link({\n  version: 1\n});\n\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `store/` prefixed capability for the (memory) space identified\n * by DID in the `with` field.\n */\nexport const ucan = capability({\n  can: 'ucan/*',\n  with: Schema.did(),\n  derives: equalWith\n});\n\n/**\n * `ucan/revoke` capability is a replacement for the\n * [UCAN Revocation](https://github.com/ucan-wg/spec#66-revocation) that had\n * been proposed to a UCAN working group and had a tentative support from\n * members.\n *\n * Capability can be used to revoke `nb.ucan` authorization from all proofs\n * chains that lead to the UCAN issued or being delegated to the principal\n * identified by the `with` field. Note that revoked UCAN MUST continue to\n * be valid in the invocation where proof chain does not lead to the principal\n * identified by the `with` field.\n */\nexport const revoke = capability({\n  can: 'ucan/revoke',\n  /**\n   * DID of the principal authorizing revocation.\n   */\n  with: Schema.did(),\n  nb: Schema.struct({\n    /**\n     * UCAN being revoked from all proof chains that lead to the UCAN that is\n     * either issued (iss) by or delegated to (aud) the principal identified\n     * by the `with` field.\n     */\n    ucan: UCANLink,\n    /**\n     * Proof chain illustrating the path from revoked UCAN to the one that is\n     * either issued (iss) by or delegated to (aud) the principal identified\n     * by the `with` field.\n     *\n     * If the UCAN being revoked is either issued (iss) by or delegated to (aud)\n     * the principal identified by the `with` field no `proof` is required and\n     * it can be omitted or set to an empty array.\n     *\n     * It is RECOMMENDED that `proof` is provided in all other cases otherwise\n     * it MAY not be possible to verify that revoking principal is a participant\n     * in the proof chain.\n     */\n    proof: UCANLink.array().optional()\n  }),\n  derives: (claim, from) =>\n  // With field MUST be the same\n  and(equalWith(claim, from)) ??\n  // UCAN being revoked MUST be the same\n  and(checkLink(claim.nb.ucan, from.nb.ucan, 'nb.ucan')) ??\n  // And proof chain MUST be the same\n  equal((claim.nb.proof ?? []).join('/'), (from.nb.proof ?? []).join('/'), 'nb.proof')\n});\n\n/**\n * `ucan/conclude` capability represents a receipt using a special UCAN capability.\n *\n * The UCAN invocation specification defines receipt record, that is cryptographically\n * signed description of the invocation output and requested effects. Receipt\n * structure is very similar to UCAN except it has no notion of expiry nor it is\n * possible to delegate ability to issue receipt to another principal.\n */\nexport const conclude = capability({\n  can: 'ucan/conclude',\n  /**\n   * DID of the principal representing the Conclusion Authority.\n   * MUST be the DID of the audience of the ran invocation.\n   */\n  with: Schema.did(),\n  nb: Schema.struct({\n    /**\n     * CID of the content with the Receipt.\n     */\n    receipt: Schema.link()\n  }),\n  derives: (claim, from) =>\n  // With field MUST be the same\n  and(equalWith(claim, from)) || and(checkLink(claim.nb.receipt, from.nb.receipt, 'nb.receipt')) || ok({})\n});\n\n/**\n * Issued by trusted authority (usually the one handling invocation) that attest\n * that specific UCAN delegation has been considered authentic.\n *\n * @see https://github.com/storacha/specs/blob/main/w3-session.md#authorization-session\n * \n * @example\n * ```js\n * {\n    iss: \"did:web:web3.storage\",\n    aud: \"did:key:z6Mkk89bC3JrVqKie71YEcc5M1SMVxuCgNx6zLZ8SYJsxALi\",\n    att: [{\n      \"with\": \"did:web:web3.storage\",\n      \"can\": \"ucan/attest\",\n      \"nb\": {\n        \"proof\": {\n          \"/\": \"bafyreifer23oxeyamllbmrfkkyvcqpujevuediffrpvrxmgn736f4fffui\"\n        }\n      }\n    }],\n    exp: null\n    sig: \"...\"\n  }\n * ```\n */\nexport const attest = capability({\n  can: 'ucan/attest',\n  // Should be web3.storage DID\n  with: Schema.did(),\n  nb: Schema.struct({\n    // UCAN delegation that is being attested.\n    proof: Schema.link({\n      version: 1\n    })\n  }),\n  derives: (claim, from) =>\n  // With field MUST be the same\n  and(equalWith(claim, from)) ??\n  // UCAN link MUST be the same\n  checkLink(claim.nb.proof, from.nb.proof, 'nb.proof')\n});","map":{"version":3,"names":["capability","Schema","ok","API","equalWith","equal","and","checkLink","UCANLink","link","version","ucan","can","with","did","derives","revoke","nb","struct","proof","array","optional","claim","from","join","conclude","receipt","attest"],"sources":["C:/FACULTATE/Proiect/node_modules/@web3-storage/capabilities/src/ucan.js"],"sourcesContent":["/**\n * UCAN core capabilities.\n */\n\nimport { capability, Schema, ok } from '@ucanto/validator'\nimport * as API from '@ucanto/interface'\nimport { equalWith, equal, and, checkLink } from './utils.js'\n\nexport const UCANLink =\n  /** @type {Schema.Schema<API.UCANLink, unknown>} */\n  (Schema.link({ version: 1 }))\n\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `store/` prefixed capability for the (memory) space identified\n * by DID in the `with` field.\n */\nexport const ucan = capability({\n  can: 'ucan/*',\n  with: Schema.did(),\n  derives: equalWith,\n})\n\n/**\n * `ucan/revoke` capability is a replacement for the\n * [UCAN Revocation](https://github.com/ucan-wg/spec#66-revocation) that had\n * been proposed to a UCAN working group and had a tentative support from\n * members.\n *\n * Capability can be used to revoke `nb.ucan` authorization from all proofs\n * chains that lead to the UCAN issued or being delegated to the principal\n * identified by the `with` field. Note that revoked UCAN MUST continue to\n * be valid in the invocation where proof chain does not lead to the principal\n * identified by the `with` field.\n */\nexport const revoke = capability({\n  can: 'ucan/revoke',\n  /**\n   * DID of the principal authorizing revocation.\n   */\n  with: Schema.did(),\n  nb: Schema.struct({\n    /**\n     * UCAN being revoked from all proof chains that lead to the UCAN that is\n     * either issued (iss) by or delegated to (aud) the principal identified\n     * by the `with` field.\n     */\n    ucan: UCANLink,\n    /**\n     * Proof chain illustrating the path from revoked UCAN to the one that is\n     * either issued (iss) by or delegated to (aud) the principal identified\n     * by the `with` field.\n     *\n     * If the UCAN being revoked is either issued (iss) by or delegated to (aud)\n     * the principal identified by the `with` field no `proof` is required and\n     * it can be omitted or set to an empty array.\n     *\n     * It is RECOMMENDED that `proof` is provided in all other cases otherwise\n     * it MAY not be possible to verify that revoking principal is a participant\n     * in the proof chain.\n     */\n    proof: UCANLink.array().optional(),\n  }),\n  derives: (claim, from) =>\n    // With field MUST be the same\n    and(equalWith(claim, from)) ??\n    // UCAN being revoked MUST be the same\n    and(checkLink(claim.nb.ucan, from.nb.ucan, 'nb.ucan')) ??\n    // And proof chain MUST be the same\n    equal(\n      (claim.nb.proof ?? []).join('/'),\n      (from.nb.proof ?? []).join('/'),\n      'nb.proof'\n    ),\n})\n\n/**\n * `ucan/conclude` capability represents a receipt using a special UCAN capability.\n *\n * The UCAN invocation specification defines receipt record, that is cryptographically\n * signed description of the invocation output and requested effects. Receipt\n * structure is very similar to UCAN except it has no notion of expiry nor it is\n * possible to delegate ability to issue receipt to another principal.\n */\nexport const conclude = capability({\n  can: 'ucan/conclude',\n  /**\n   * DID of the principal representing the Conclusion Authority.\n   * MUST be the DID of the audience of the ran invocation.\n   */\n  with: Schema.did(),\n  nb: Schema.struct({\n    /**\n     * CID of the content with the Receipt.\n     */\n    receipt: Schema.link(),\n  }),\n  derives: (claim, from) =>\n    // With field MUST be the same\n    and(equalWith(claim, from)) ||\n    and(checkLink(claim.nb.receipt, from.nb.receipt, 'nb.receipt')) ||\n    ok({}),\n})\n\n/**\n * Issued by trusted authority (usually the one handling invocation) that attest\n * that specific UCAN delegation has been considered authentic.\n *\n * @see https://github.com/storacha/specs/blob/main/w3-session.md#authorization-session\n * \n * @example\n * ```js\n * {\n    iss: \"did:web:web3.storage\",\n    aud: \"did:key:z6Mkk89bC3JrVqKie71YEcc5M1SMVxuCgNx6zLZ8SYJsxALi\",\n    att: [{\n      \"with\": \"did:web:web3.storage\",\n      \"can\": \"ucan/attest\",\n      \"nb\": {\n        \"proof\": {\n          \"/\": \"bafyreifer23oxeyamllbmrfkkyvcqpujevuediffrpvrxmgn736f4fffui\"\n        }\n      }\n    }],\n    exp: null\n    sig: \"...\"\n  }\n * ```\n */\nexport const attest = capability({\n  can: 'ucan/attest',\n  // Should be web3.storage DID\n  with: Schema.did(),\n  nb: Schema.struct({\n    // UCAN delegation that is being attested.\n    proof: Schema.link({ version: 1 }),\n  }),\n  derives: (claim, from) =>\n    // With field MUST be the same\n    and(equalWith(claim, from)) ??\n    // UCAN link MUST be the same\n    checkLink(claim.nb.proof, from.nb.proof, 'nb.proof'),\n})\n"],"mappings":"AAAA;AACA;AACA;;AAEA,SAASA,UAAU,EAAEC,MAAM,EAAEC,EAAE,QAAQ,mBAAmB;AAC1D,OAAO,KAAKC,GAAG,MAAM,mBAAmB;AACxC,SAASC,SAAS,EAAEC,KAAK,EAAEC,GAAG,EAAEC,SAAS,QAAQ,YAAY;AAE7D,OAAO,MAAMC,QAAQ,GACnB;AACCP,MAAM,CAACQ,IAAI,CAAC;EAAEC,OAAO,EAAE;AAAE,CAAC,CAAE;;AAE/B;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,IAAI,GAAGX,UAAU,CAAC;EAC7BY,GAAG,EAAE,QAAQ;EACbC,IAAI,EAAEZ,MAAM,CAACa,GAAG,CAAC,CAAC;EAClBC,OAAO,EAAEX;AACX,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMY,MAAM,GAAGhB,UAAU,CAAC;EAC/BY,GAAG,EAAE,aAAa;EAClB;AACF;AACA;EACEC,IAAI,EAAEZ,MAAM,CAACa,GAAG,CAAC,CAAC;EAClBG,EAAE,EAAEhB,MAAM,CAACiB,MAAM,CAAC;IAChB;AACJ;AACA;AACA;AACA;IACIP,IAAI,EAAEH,QAAQ;IACd;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIW,KAAK,EAAEX,QAAQ,CAACY,KAAK,CAAC,CAAC,CAACC,QAAQ,CAAC;EACnC,CAAC,CAAC;EACFN,OAAO,EAAEA,CAACO,KAAK,EAAEC,IAAI;EACnB;EACAjB,GAAG,CAACF,SAAS,CAACkB,KAAK,EAAEC,IAAI,CAAC,CAAC;EAC3B;EACAjB,GAAG,CAACC,SAAS,CAACe,KAAK,CAACL,EAAE,CAACN,IAAI,EAAEY,IAAI,CAACN,EAAE,CAACN,IAAI,EAAE,SAAS,CAAC,CAAC;EACtD;EACAN,KAAK,CACH,CAACiB,KAAK,CAACL,EAAE,CAACE,KAAK,IAAI,EAAE,EAAEK,IAAI,CAAC,GAAG,CAAC,EAChC,CAACD,IAAI,CAACN,EAAE,CAACE,KAAK,IAAI,EAAE,EAAEK,IAAI,CAAC,GAAG,CAAC,EAC/B,UACF;AACJ,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,QAAQ,GAAGzB,UAAU,CAAC;EACjCY,GAAG,EAAE,eAAe;EACpB;AACF;AACA;AACA;EACEC,IAAI,EAAEZ,MAAM,CAACa,GAAG,CAAC,CAAC;EAClBG,EAAE,EAAEhB,MAAM,CAACiB,MAAM,CAAC;IAChB;AACJ;AACA;IACIQ,OAAO,EAAEzB,MAAM,CAACQ,IAAI,CAAC;EACvB,CAAC,CAAC;EACFM,OAAO,EAAEA,CAACO,KAAK,EAAEC,IAAI;EACnB;EACAjB,GAAG,CAACF,SAAS,CAACkB,KAAK,EAAEC,IAAI,CAAC,CAAC,IAC3BjB,GAAG,CAACC,SAAS,CAACe,KAAK,CAACL,EAAE,CAACS,OAAO,EAAEH,IAAI,CAACN,EAAE,CAACS,OAAO,EAAE,YAAY,CAAC,CAAC,IAC/DxB,EAAE,CAAC,CAAC,CAAC;AACT,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMyB,MAAM,GAAG3B,UAAU,CAAC;EAC/BY,GAAG,EAAE,aAAa;EAClB;EACAC,IAAI,EAAEZ,MAAM,CAACa,GAAG,CAAC,CAAC;EAClBG,EAAE,EAAEhB,MAAM,CAACiB,MAAM,CAAC;IAChB;IACAC,KAAK,EAAElB,MAAM,CAACQ,IAAI,CAAC;MAAEC,OAAO,EAAE;IAAE,CAAC;EACnC,CAAC,CAAC;EACFK,OAAO,EAAEA,CAACO,KAAK,EAAEC,IAAI;EACnB;EACAjB,GAAG,CAACF,SAAS,CAACkB,KAAK,EAAEC,IAAI,CAAC,CAAC;EAC3B;EACAhB,SAAS,CAACe,KAAK,CAACL,EAAE,CAACE,KAAK,EAAEI,IAAI,CAACN,EAAE,CAACE,KAAK,EAAE,UAAU;AACvD,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}