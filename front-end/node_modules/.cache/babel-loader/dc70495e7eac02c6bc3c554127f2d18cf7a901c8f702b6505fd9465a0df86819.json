{"ast":null,"code":"import * as API from '../../api.js';\nimport { log2Ceil, trailingZeros64 } from '../../uint64.js';\nimport { PADDED_BYTES_PER_QUAD, EXPANDED_BYTES_PER_QUAD, LEAFS_PER_QUAD } from '../../constant.js';\n\n/**\n * Validates that given `size` is a valid {@link API.UnpaddedPieceSize} and\n * returns {@link API.UnpaddedPieceSize} capturing the validation at the type\n * level. If given `size` is not a valid `UnpaddedPieceSize` throws an error.\n *\n * This function is a variation on {@link validate} that throws exceptions\n * instead of returning a {@link API.Result}.\n *\n * @param {number|API.uint64} size\n * @returns {API.PaddedSize}\n */\nexport const from = size => {\n  const result = tryFrom(size);\n  if (result.error) {\n    throw result.error;\n  } else {\n    return result.ok;\n  }\n};\n\n/**\n * Validates that given `size` is a valid {@link API.UnpaddedPieceSize} that is\n * a power of 2 multiple of 127. Returns {@link API.Result} with\n * `UnpaddedPieceSize` ok case and an Error in the error case.\n *\n * @param {API.uint64|number} input\n * @returns {API.Result<API.PaddedSize, Error>}\n */\nexport const tryFrom = input => {\n  const size = BigInt(input);\n  if (size < PADDED_BYTES_PER_QUAD) {\n    return {\n      error: new RangeError(`Padded payload must contain at least ${PADDED_BYTES_PER_QUAD} bytes`)\n    };\n  }\n  if (size >> BigInt(trailingZeros64(size)) !== PADDED_BYTES_PER_QUAD) {\n    return {\n      error: new RangeError(`Padded payload size must be (2ⁿ * ${PADDED_BYTES_PER_QUAD})`)\n    };\n  }\n  return {\n    ok: size\n  };\n};\n\n/**\n * @param {API.PieceSize} size\n * @returns {API.PaddedSize}\n */\nexport const fromExpanded = size => fromQuads(size / EXPANDED_BYTES_PER_QUAD);\n\n/**\n * Takes `{@link API.PaddedPieceSize}` and returns corresponding\n * {@link API.PieceSize}.\n *\n * Please note that this function does not validate the input size and\n * relies that type-checker will ensure that user passes valid unpadded\n * piece size created with {@link from} or {@link validate} functions.\n *\n *\n * @see https://github.com/filecoin-project/go-state-types/blob/master/abi/piece.go#L14-L16\n *\n * @param {API.PaddedSize} size\n * @returns {API.PieceSize}\n */\nexport const toExpanded = size => toQauds(size) * EXPANDED_BYTES_PER_QUAD;\n\n/**\n * Calculates the padded size of the piece from the given tree height.\n *\n * @param {number} height\n * @returns {API.uint64}\n */\nexport const fromHeight = height => {\n  // We calculate number of quads tree by calculating number of nodes tree\n  // at second layer. This works because we deal with a binary tree so first\n  // layer nodes will contain 2 leaves and second layer nodes will contain 4\n  // leaves hence number of quads.\n  const quads = 2n ** BigInt(height - 2);\n  return quads * PADDED_BYTES_PER_QUAD;\n};\n\n/**\n * Calculates the height of the piece tree from unpadded size.\n *\n * @param {API.PaddedSize} size\n */\nexport const toHeight = size => log2Ceil(toWidth(size));\n\n/**\n * Takes `{@link API.PaddedPieceSize}` and returns corresponding\n * piece tree width (leaf count).\n *\n * @param {API.PaddedSize} size\n */\nexport const toWidth = size => toQauds(size) * LEAFS_PER_QUAD;\n\n/**\n *\n * @param {API.uint64} width\n * @returns {API.PaddedSize}\n */\nexport const fromWidth = width => fromQuads(width / LEAFS_PER_QUAD);\n\n/**\n * @param {API.PaddedSize} size\n */\nconst toQauds = size => size / PADDED_BYTES_PER_QUAD;\n\n/**\n *\n * @param {API.uint64} count\n * @returns {API.PaddedSize}\n */\nconst fromQuads = count => count * PADDED_BYTES_PER_QUAD;","map":{"version":3,"names":["API","log2Ceil","trailingZeros64","PADDED_BYTES_PER_QUAD","EXPANDED_BYTES_PER_QUAD","LEAFS_PER_QUAD","from","size","result","tryFrom","error","ok","input","BigInt","RangeError","fromExpanded","fromQuads","toExpanded","toQauds","fromHeight","height","quads","toHeight","toWidth","fromWidth","width","count"],"sources":["C:/FACULTATE/Proiect/node_modules/@web3-storage/data-segment/src/piece/size/padded.js"],"sourcesContent":["import * as API from '../../api.js'\nimport { log2Ceil, trailingZeros64 } from '../../uint64.js'\nimport {\n  PADDED_BYTES_PER_QUAD,\n  EXPANDED_BYTES_PER_QUAD,\n  LEAFS_PER_QUAD,\n} from '../../constant.js'\n\n/**\n * Validates that given `size` is a valid {@link API.UnpaddedPieceSize} and\n * returns {@link API.UnpaddedPieceSize} capturing the validation at the type\n * level. If given `size` is not a valid `UnpaddedPieceSize` throws an error.\n *\n * This function is a variation on {@link validate} that throws exceptions\n * instead of returning a {@link API.Result}.\n *\n * @param {number|API.uint64} size\n * @returns {API.PaddedSize}\n */\nexport const from = (size) => {\n  const result = tryFrom(size)\n  if (result.error) {\n    throw result.error\n  } else {\n    return result.ok\n  }\n}\n\n/**\n * Validates that given `size` is a valid {@link API.UnpaddedPieceSize} that is\n * a power of 2 multiple of 127. Returns {@link API.Result} with\n * `UnpaddedPieceSize` ok case and an Error in the error case.\n *\n * @param {API.uint64|number} input\n * @returns {API.Result<API.PaddedSize, Error>}\n */\nexport const tryFrom = (input) => {\n  const size = BigInt(input)\n  if (size < PADDED_BYTES_PER_QUAD) {\n    return {\n      error: new RangeError(\n        `Padded payload must contain at least ${PADDED_BYTES_PER_QUAD} bytes`\n      ),\n    }\n  }\n\n  if (size >> BigInt(trailingZeros64(size)) !== PADDED_BYTES_PER_QUAD) {\n    return {\n      error: new RangeError(\n        `Padded payload size must be (2ⁿ * ${PADDED_BYTES_PER_QUAD})`\n      ),\n    }\n  }\n\n  return { ok: size }\n}\n\n/**\n * @param {API.PieceSize} size\n * @returns {API.PaddedSize}\n */\nexport const fromExpanded = (size) => fromQuads(size / EXPANDED_BYTES_PER_QUAD)\n\n/**\n * Takes `{@link API.PaddedPieceSize}` and returns corresponding\n * {@link API.PieceSize}.\n *\n * Please note that this function does not validate the input size and\n * relies that type-checker will ensure that user passes valid unpadded\n * piece size created with {@link from} or {@link validate} functions.\n *\n *\n * @see https://github.com/filecoin-project/go-state-types/blob/master/abi/piece.go#L14-L16\n *\n * @param {API.PaddedSize} size\n * @returns {API.PieceSize}\n */\nexport const toExpanded = (size) => toQauds(size) * EXPANDED_BYTES_PER_QUAD\n\n/**\n * Calculates the padded size of the piece from the given tree height.\n *\n * @param {number} height\n * @returns {API.uint64}\n */\nexport const fromHeight = (height) => {\n  // We calculate number of quads tree by calculating number of nodes tree\n  // at second layer. This works because we deal with a binary tree so first\n  // layer nodes will contain 2 leaves and second layer nodes will contain 4\n  // leaves hence number of quads.\n  const quads = 2n ** BigInt(height - 2)\n  return quads * PADDED_BYTES_PER_QUAD\n}\n\n/**\n * Calculates the height of the piece tree from unpadded size.\n *\n * @param {API.PaddedSize} size\n */\nexport const toHeight = (size) => log2Ceil(toWidth(size))\n\n/**\n * Takes `{@link API.PaddedPieceSize}` and returns corresponding\n * piece tree width (leaf count).\n *\n * @param {API.PaddedSize} size\n */\nexport const toWidth = (size) => toQauds(size) * LEAFS_PER_QUAD\n\n/**\n *\n * @param {API.uint64} width\n * @returns {API.PaddedSize}\n */\nexport const fromWidth = (width) => fromQuads(width / LEAFS_PER_QUAD)\n\n/**\n * @param {API.PaddedSize} size\n */\nconst toQauds = (size) => size / PADDED_BYTES_PER_QUAD\n\n/**\n *\n * @param {API.uint64} count\n * @returns {API.PaddedSize}\n */\nconst fromQuads = (count) => count * PADDED_BYTES_PER_QUAD\n"],"mappings":"AAAA,OAAO,KAAKA,GAAG,MAAM,cAAc;AACnC,SAASC,QAAQ,EAAEC,eAAe,QAAQ,iBAAiB;AAC3D,SACEC,qBAAqB,EACrBC,uBAAuB,EACvBC,cAAc,QACT,mBAAmB;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,IAAI,GAAIC,IAAI,IAAK;EAC5B,MAAMC,MAAM,GAAGC,OAAO,CAACF,IAAI,CAAC;EAC5B,IAAIC,MAAM,CAACE,KAAK,EAAE;IAChB,MAAMF,MAAM,CAACE,KAAK;EACpB,CAAC,MAAM;IACL,OAAOF,MAAM,CAACG,EAAE;EAClB;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMF,OAAO,GAAIG,KAAK,IAAK;EAChC,MAAML,IAAI,GAAGM,MAAM,CAACD,KAAK,CAAC;EAC1B,IAAIL,IAAI,GAAGJ,qBAAqB,EAAE;IAChC,OAAO;MACLO,KAAK,EAAE,IAAII,UAAU,CAClB,wCAAuCX,qBAAsB,QAChE;IACF,CAAC;EACH;EAEA,IAAII,IAAI,IAAIM,MAAM,CAACX,eAAe,CAACK,IAAI,CAAC,CAAC,KAAKJ,qBAAqB,EAAE;IACnE,OAAO;MACLO,KAAK,EAAE,IAAII,UAAU,CAClB,qCAAoCX,qBAAsB,GAC7D;IACF,CAAC;EACH;EAEA,OAAO;IAAEQ,EAAE,EAAEJ;EAAK,CAAC;AACrB,CAAC;;AAED;AACA;AACA;AACA;AACA,OAAO,MAAMQ,YAAY,GAAIR,IAAI,IAAKS,SAAS,CAACT,IAAI,GAAGH,uBAAuB,CAAC;;AAE/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMa,UAAU,GAAIV,IAAI,IAAKW,OAAO,CAACX,IAAI,CAAC,GAAGH,uBAAuB;;AAE3E;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMe,UAAU,GAAIC,MAAM,IAAK;EACpC;EACA;EACA;EACA;EACA,MAAMC,KAAK,GAAG,EAAE,IAAIR,MAAM,CAACO,MAAM,GAAG,CAAC,CAAC;EACtC,OAAOC,KAAK,GAAGlB,qBAAqB;AACtC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMmB,QAAQ,GAAIf,IAAI,IAAKN,QAAQ,CAACsB,OAAO,CAAChB,IAAI,CAAC,CAAC;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMgB,OAAO,GAAIhB,IAAI,IAAKW,OAAO,CAACX,IAAI,CAAC,GAAGF,cAAc;;AAE/D;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMmB,SAAS,GAAIC,KAAK,IAAKT,SAAS,CAACS,KAAK,GAAGpB,cAAc,CAAC;;AAErE;AACA;AACA;AACA,MAAMa,OAAO,GAAIX,IAAI,IAAKA,IAAI,GAAGJ,qBAAqB;;AAEtD;AACA;AACA;AACA;AACA;AACA,MAAMa,SAAS,GAAIU,KAAK,IAAKA,KAAK,GAAGvB,qBAAqB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}