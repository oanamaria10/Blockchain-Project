{"ast":null,"code":"'use strict';\n\nconst {\n  kReadyState,\n  kController,\n  kResponse,\n  kBinaryType,\n  kWebSocketURL\n} = require('./symbols');\nconst {\n  states,\n  opcodes\n} = require('./constants');\nconst {\n  MessageEvent,\n  ErrorEvent\n} = require('./events');\n\n/* globals Blob */\n\n/**\n * @param {import('./websocket').WebSocket} ws\n */\nfunction isEstablished(ws) {\n  // If the server's response is validated as provided for above, it is\n  // said that _The WebSocket Connection is Established_ and that the\n  // WebSocket Connection is in the OPEN state.\n  return ws[kReadyState] === states.OPEN;\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n */\nfunction isClosing(ws) {\n  // Upon either sending or receiving a Close control frame, it is said\n  // that _The WebSocket Closing Handshake is Started_ and that the\n  // WebSocket connection is in the CLOSING state.\n  return ws[kReadyState] === states.CLOSING;\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n */\nfunction isClosed(ws) {\n  return ws[kReadyState] === states.CLOSED;\n}\n\n/**\n * @see https://dom.spec.whatwg.org/#concept-event-fire\n * @param {string} e\n * @param {EventTarget} target\n * @param {EventInit | undefined} eventInitDict\n */\nfunction fireEvent(e, target, eventConstructor = Event, eventInitDict) {\n  // 1. If eventConstructor is not given, then let eventConstructor be Event.\n\n  // 2. Let event be the result of creating an event given eventConstructor,\n  //    in the relevant realm of target.\n  // 3. Initialize event’s type attribute to e.\n  const event = new eventConstructor(e, eventInitDict); // eslint-disable-line new-cap\n\n  // 4. Initialize any other IDL attributes of event as described in the\n  //    invocation of this algorithm.\n\n  // 5. Return the result of dispatching event at target, with legacy target\n  //    override flag set if set.\n  target.dispatchEvent(event);\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @param {import('./websocket').WebSocket} ws\n * @param {number} type Opcode\n * @param {Buffer} data application data\n */\nfunction websocketMessageReceived(ws, type, data) {\n  // 1. If ready state is not OPEN (1), then return.\n  if (ws[kReadyState] !== states.OPEN) {\n    return;\n  }\n\n  // 2. Let dataForEvent be determined by switching on type and binary type:\n  let dataForEvent;\n  if (type === opcodes.TEXT) {\n    // -> type indicates that the data is Text\n    //      a new DOMString containing data\n    try {\n      dataForEvent = new TextDecoder('utf-8', {\n        fatal: true\n      }).decode(data);\n    } catch {\n      failWebsocketConnection(ws, 'Received invalid UTF-8 in text frame.');\n      return;\n    }\n  } else if (type === opcodes.BINARY) {\n    if (ws[kBinaryType] === 'blob') {\n      // -> type indicates that the data is Binary and binary type is \"blob\"\n      //      a new Blob object, created in the relevant Realm of the WebSocket\n      //      object, that represents data as its raw data\n      dataForEvent = new Blob([data]);\n    } else {\n      // -> type indicates that the data is Binary and binary type is \"arraybuffer\"\n      //      a new ArrayBuffer object, created in the relevant Realm of the\n      //      WebSocket object, whose contents are data\n      dataForEvent = new Uint8Array(data).buffer;\n    }\n  }\n\n  // 3. Fire an event named message at the WebSocket object, using MessageEvent,\n  //    with the origin attribute initialized to the serialization of the WebSocket\n  //    object’s url's origin, and the data attribute initialized to dataForEvent.\n  fireEvent('message', ws, MessageEvent, {\n    origin: ws[kWebSocketURL].origin,\n    data: dataForEvent\n  });\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455\n * @see https://datatracker.ietf.org/doc/html/rfc2616\n * @see https://bugs.chromium.org/p/chromium/issues/detail?id=398407\n * @param {string} protocol\n */\nfunction isValidSubprotocol(protocol) {\n  // If present, this value indicates one\n  // or more comma-separated subprotocol the client wishes to speak,\n  // ordered by preference.  The elements that comprise this value\n  // MUST be non-empty strings with characters in the range U+0021 to\n  // U+007E not including separator characters as defined in\n  // [RFC2616] and MUST all be unique strings.\n  if (protocol.length === 0) {\n    return false;\n  }\n  for (const char of protocol) {\n    const code = char.charCodeAt(0);\n    if (code < 0x21 || code > 0x7E || char === '(' || char === ')' || char === '<' || char === '>' || char === '@' || char === ',' || char === ';' || char === ':' || char === '\\\\' || char === '\"' || char === '/' || char === '[' || char === ']' || char === '?' || char === '=' || char === '{' || char === '}' || code === 32 ||\n    // SP\n    code === 9 // HT\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7-4\n * @param {number} code\n */\nfunction isValidStatusCode(code) {\n  if (code >= 1000 && code < 1015) {\n    return code !== 1004 &&\n    // reserved\n    code !== 1005 &&\n    // \"MUST NOT be set as a status code\"\n    code !== 1006 // \"MUST NOT be set as a status code\"\n    ;\n  }\n  return code >= 3000 && code <= 4999;\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n * @param {string|undefined} reason\n */\nfunction failWebsocketConnection(ws, reason) {\n  const {\n    [kController]: controller,\n    [kResponse]: response\n  } = ws;\n  controller.abort();\n  if (response?.socket && !response.socket.destroyed) {\n    response.socket.destroy();\n  }\n  if (reason) {\n    fireEvent('error', ws, ErrorEvent, {\n      error: new Error(reason)\n    });\n  }\n}\nmodule.exports = {\n  isEstablished,\n  isClosing,\n  isClosed,\n  fireEvent,\n  isValidSubprotocol,\n  isValidStatusCode,\n  failWebsocketConnection,\n  websocketMessageReceived\n};","map":{"version":3,"names":["kReadyState","kController","kResponse","kBinaryType","kWebSocketURL","require","states","opcodes","MessageEvent","ErrorEvent","isEstablished","ws","OPEN","isClosing","CLOSING","isClosed","CLOSED","fireEvent","e","target","eventConstructor","Event","eventInitDict","event","dispatchEvent","websocketMessageReceived","type","data","dataForEvent","TEXT","TextDecoder","fatal","decode","failWebsocketConnection","BINARY","Blob","Uint8Array","buffer","origin","isValidSubprotocol","protocol","length","char","code","charCodeAt","isValidStatusCode","reason","controller","response","abort","socket","destroyed","destroy","error","Error","module","exports"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/undici/lib/websocket/util.js"],"sourcesContent":["'use strict'\n\nconst { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = require('./symbols')\nconst { states, opcodes } = require('./constants')\nconst { MessageEvent, ErrorEvent } = require('./events')\n\n/* globals Blob */\n\n/**\n * @param {import('./websocket').WebSocket} ws\n */\nfunction isEstablished (ws) {\n  // If the server's response is validated as provided for above, it is\n  // said that _The WebSocket Connection is Established_ and that the\n  // WebSocket Connection is in the OPEN state.\n  return ws[kReadyState] === states.OPEN\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n */\nfunction isClosing (ws) {\n  // Upon either sending or receiving a Close control frame, it is said\n  // that _The WebSocket Closing Handshake is Started_ and that the\n  // WebSocket connection is in the CLOSING state.\n  return ws[kReadyState] === states.CLOSING\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n */\nfunction isClosed (ws) {\n  return ws[kReadyState] === states.CLOSED\n}\n\n/**\n * @see https://dom.spec.whatwg.org/#concept-event-fire\n * @param {string} e\n * @param {EventTarget} target\n * @param {EventInit | undefined} eventInitDict\n */\nfunction fireEvent (e, target, eventConstructor = Event, eventInitDict) {\n  // 1. If eventConstructor is not given, then let eventConstructor be Event.\n\n  // 2. Let event be the result of creating an event given eventConstructor,\n  //    in the relevant realm of target.\n  // 3. Initialize event’s type attribute to e.\n  const event = new eventConstructor(e, eventInitDict) // eslint-disable-line new-cap\n\n  // 4. Initialize any other IDL attributes of event as described in the\n  //    invocation of this algorithm.\n\n  // 5. Return the result of dispatching event at target, with legacy target\n  //    override flag set if set.\n  target.dispatchEvent(event)\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @param {import('./websocket').WebSocket} ws\n * @param {number} type Opcode\n * @param {Buffer} data application data\n */\nfunction websocketMessageReceived (ws, type, data) {\n  // 1. If ready state is not OPEN (1), then return.\n  if (ws[kReadyState] !== states.OPEN) {\n    return\n  }\n\n  // 2. Let dataForEvent be determined by switching on type and binary type:\n  let dataForEvent\n\n  if (type === opcodes.TEXT) {\n    // -> type indicates that the data is Text\n    //      a new DOMString containing data\n    try {\n      dataForEvent = new TextDecoder('utf-8', { fatal: true }).decode(data)\n    } catch {\n      failWebsocketConnection(ws, 'Received invalid UTF-8 in text frame.')\n      return\n    }\n  } else if (type === opcodes.BINARY) {\n    if (ws[kBinaryType] === 'blob') {\n      // -> type indicates that the data is Binary and binary type is \"blob\"\n      //      a new Blob object, created in the relevant Realm of the WebSocket\n      //      object, that represents data as its raw data\n      dataForEvent = new Blob([data])\n    } else {\n      // -> type indicates that the data is Binary and binary type is \"arraybuffer\"\n      //      a new ArrayBuffer object, created in the relevant Realm of the\n      //      WebSocket object, whose contents are data\n      dataForEvent = new Uint8Array(data).buffer\n    }\n  }\n\n  // 3. Fire an event named message at the WebSocket object, using MessageEvent,\n  //    with the origin attribute initialized to the serialization of the WebSocket\n  //    object’s url's origin, and the data attribute initialized to dataForEvent.\n  fireEvent('message', ws, MessageEvent, {\n    origin: ws[kWebSocketURL].origin,\n    data: dataForEvent\n  })\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455\n * @see https://datatracker.ietf.org/doc/html/rfc2616\n * @see https://bugs.chromium.org/p/chromium/issues/detail?id=398407\n * @param {string} protocol\n */\nfunction isValidSubprotocol (protocol) {\n  // If present, this value indicates one\n  // or more comma-separated subprotocol the client wishes to speak,\n  // ordered by preference.  The elements that comprise this value\n  // MUST be non-empty strings with characters in the range U+0021 to\n  // U+007E not including separator characters as defined in\n  // [RFC2616] and MUST all be unique strings.\n  if (protocol.length === 0) {\n    return false\n  }\n\n  for (const char of protocol) {\n    const code = char.charCodeAt(0)\n\n    if (\n      code < 0x21 ||\n      code > 0x7E ||\n      char === '(' ||\n      char === ')' ||\n      char === '<' ||\n      char === '>' ||\n      char === '@' ||\n      char === ',' ||\n      char === ';' ||\n      char === ':' ||\n      char === '\\\\' ||\n      char === '\"' ||\n      char === '/' ||\n      char === '[' ||\n      char === ']' ||\n      char === '?' ||\n      char === '=' ||\n      char === '{' ||\n      char === '}' ||\n      code === 32 || // SP\n      code === 9 // HT\n    ) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7-4\n * @param {number} code\n */\nfunction isValidStatusCode (code) {\n  if (code >= 1000 && code < 1015) {\n    return (\n      code !== 1004 && // reserved\n      code !== 1005 && // \"MUST NOT be set as a status code\"\n      code !== 1006 // \"MUST NOT be set as a status code\"\n    )\n  }\n\n  return code >= 3000 && code <= 4999\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n * @param {string|undefined} reason\n */\nfunction failWebsocketConnection (ws, reason) {\n  const { [kController]: controller, [kResponse]: response } = ws\n\n  controller.abort()\n\n  if (response?.socket && !response.socket.destroyed) {\n    response.socket.destroy()\n  }\n\n  if (reason) {\n    fireEvent('error', ws, ErrorEvent, {\n      error: new Error(reason)\n    })\n  }\n}\n\nmodule.exports = {\n  isEstablished,\n  isClosing,\n  isClosed,\n  fireEvent,\n  isValidSubprotocol,\n  isValidStatusCode,\n  failWebsocketConnection,\n  websocketMessageReceived\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}