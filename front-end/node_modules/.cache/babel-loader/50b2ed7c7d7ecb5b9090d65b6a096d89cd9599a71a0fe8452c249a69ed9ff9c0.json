{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DependencyGraph = void 0;\nconst errors_1 = require(\"../core/errors\");\nconst errors_list_1 = require(\"../core/errors-list\");\nclass DependencyGraph {\n  static async createFromResolvedFiles(resolver, resolvedFiles) {\n    const graph = new DependencyGraph();\n    // TODO refactor this to make the results deterministic\n    await Promise.all(resolvedFiles.map(resolvedFile => graph._addDependenciesFrom(resolver, resolvedFile)));\n    return graph;\n  }\n  constructor() {\n    this._resolvedFiles = new Map();\n    this._dependenciesPerFile = new Map();\n    // map absolute paths to source names\n    this._visitedFiles = new Map();\n  }\n  getResolvedFiles() {\n    return Array.from(this._resolvedFiles.values());\n  }\n  has(file) {\n    return this._resolvedFiles.has(file.sourceName);\n  }\n  isEmpty() {\n    return this._resolvedFiles.size === 0;\n  }\n  entries() {\n    return Array.from(this._dependenciesPerFile.entries()).map(([key, value]) => [this._resolvedFiles.get(key), value]);\n  }\n  getDependencies(file) {\n    const dependencies = this._dependenciesPerFile.get(file.sourceName) ?? new Set();\n    return [...dependencies];\n  }\n  getTransitiveDependencies(file) {\n    const visited = new Set();\n    const transitiveDependencies = this._getTransitiveDependencies(file, visited, []);\n    return [...transitiveDependencies];\n  }\n  getConnectedComponents() {\n    const undirectedGraph = {};\n    for (const [sourceName, dependencies] of this._dependenciesPerFile.entries()) {\n      undirectedGraph[sourceName] = undirectedGraph[sourceName] ?? new Set();\n      for (const dependency of dependencies) {\n        undirectedGraph[dependency.sourceName] = undirectedGraph[dependency.sourceName] ?? new Set();\n        undirectedGraph[sourceName].add(dependency.sourceName);\n        undirectedGraph[dependency.sourceName].add(sourceName);\n      }\n    }\n    const components = [];\n    const visited = new Set();\n    for (const node of Object.keys(undirectedGraph)) {\n      if (visited.has(node)) {\n        continue;\n      }\n      visited.add(node);\n      const component = new Set([node]);\n      const stack = [...undirectedGraph[node]];\n      while (stack.length > 0) {\n        const newNode = stack.pop();\n        if (visited.has(newNode)) {\n          continue;\n        }\n        visited.add(newNode);\n        component.add(newNode);\n        [...undirectedGraph[newNode]].forEach(adjacent => {\n          if (!visited.has(adjacent)) {\n            stack.push(adjacent);\n          }\n        });\n      }\n      components.push(component);\n    }\n    const connectedComponents = [];\n    for (const component of components) {\n      const dependencyGraph = new DependencyGraph();\n      for (const sourceName of component) {\n        const file = this._resolvedFiles.get(sourceName);\n        const dependencies = this._dependenciesPerFile.get(sourceName);\n        dependencyGraph._resolvedFiles.set(sourceName, file);\n        dependencyGraph._dependenciesPerFile.set(sourceName, dependencies);\n      }\n      connectedComponents.push(dependencyGraph);\n    }\n    return connectedComponents;\n  }\n  _getTransitiveDependencies(file, visited, path) {\n    if (visited.has(file)) {\n      return new Set();\n    }\n    visited.add(file);\n    const directDependencies = this.getDependencies(file).map(dependency => ({\n      dependency,\n      path\n    }));\n    const transitiveDependencies = new Set(directDependencies);\n    for (const {\n      dependency\n    } of transitiveDependencies) {\n      this._getTransitiveDependencies(dependency, visited, path.concat(dependency)).forEach(x => transitiveDependencies.add(x));\n    }\n    return transitiveDependencies;\n  }\n  async _addDependenciesFrom(resolver, file) {\n    const sourceName = this._visitedFiles.get(file.absolutePath);\n    if (sourceName !== undefined) {\n      if (sourceName !== file.sourceName) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.AMBIGUOUS_SOURCE_NAMES, {\n          sourcenames: `'${sourceName}' and '${file.sourceName}'`,\n          file: file.absolutePath\n        });\n      }\n      return;\n    }\n    this._visitedFiles.set(file.absolutePath, file.sourceName);\n    const dependencies = new Set();\n    this._resolvedFiles.set(file.sourceName, file);\n    this._dependenciesPerFile.set(file.sourceName, dependencies);\n    // TODO refactor this to make the results deterministic\n    await Promise.all(file.content.imports.map(async imp => {\n      const dependency = await resolver.resolveImport(file, imp);\n      dependencies.add(dependency);\n      await this._addDependenciesFrom(resolver, dependency);\n    }));\n  }\n}\nexports.DependencyGraph = DependencyGraph;","map":{"version":3,"names":["errors_1","require","errors_list_1","DependencyGraph","createFromResolvedFiles","resolver","resolvedFiles","graph","Promise","all","map","resolvedFile","_addDependenciesFrom","constructor","_resolvedFiles","Map","_dependenciesPerFile","_visitedFiles","getResolvedFiles","Array","from","values","has","file","sourceName","isEmpty","size","entries","key","value","get","getDependencies","dependencies","Set","getTransitiveDependencies","visited","transitiveDependencies","_getTransitiveDependencies","getConnectedComponents","undirectedGraph","dependency","add","components","node","Object","keys","component","stack","length","newNode","pop","forEach","adjacent","push","connectedComponents","dependencyGraph","set","path","directDependencies","concat","x","absolutePath","undefined","HardhatError","ERRORS","RESOLVER","AMBIGUOUS_SOURCE_NAMES","sourcenames","content","imports","imp","resolveImport","exports"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\internal\\solidity\\dependencyGraph.ts"],"sourcesContent":["import * as taskTypes from \"../../types/builtin-tasks\";\nimport { HardhatError } from \"../core/errors\";\nimport { ERRORS } from \"../core/errors-list\";\n\nimport { ResolvedFile, Resolver } from \"./resolver\";\n\nexport class DependencyGraph implements taskTypes.DependencyGraph {\n  public static async createFromResolvedFiles(\n    resolver: Resolver,\n    resolvedFiles: ResolvedFile[]\n  ): Promise<DependencyGraph> {\n    const graph = new DependencyGraph();\n\n    // TODO refactor this to make the results deterministic\n    await Promise.all(\n      resolvedFiles.map((resolvedFile) =>\n        graph._addDependenciesFrom(resolver, resolvedFile)\n      )\n    );\n\n    return graph;\n  }\n\n  private _resolvedFiles = new Map<string, ResolvedFile>();\n  private _dependenciesPerFile = new Map<string, Set<ResolvedFile>>();\n\n  // map absolute paths to source names\n  private readonly _visitedFiles = new Map<string, string>();\n\n  private constructor() {}\n\n  public getResolvedFiles(): ResolvedFile[] {\n    return Array.from(this._resolvedFiles.values());\n  }\n\n  public has(file: ResolvedFile): boolean {\n    return this._resolvedFiles.has(file.sourceName);\n  }\n\n  public isEmpty(): boolean {\n    return this._resolvedFiles.size === 0;\n  }\n\n  public entries(): Array<[ResolvedFile, Set<ResolvedFile>]> {\n    return Array.from(this._dependenciesPerFile.entries()).map(\n      ([key, value]) => [this._resolvedFiles.get(key)!, value]\n    );\n  }\n\n  public getDependencies(file: ResolvedFile): ResolvedFile[] {\n    const dependencies =\n      this._dependenciesPerFile.get(file.sourceName) ?? new Set();\n\n    return [...dependencies];\n  }\n\n  public getTransitiveDependencies(\n    file: ResolvedFile\n  ): taskTypes.TransitiveDependency[] {\n    const visited = new Set<ResolvedFile>();\n\n    const transitiveDependencies = this._getTransitiveDependencies(\n      file,\n      visited,\n      []\n    );\n\n    return [...transitiveDependencies];\n  }\n\n  public getConnectedComponents(): DependencyGraph[] {\n    const undirectedGraph: Record<string, Set<string>> = {};\n\n    for (const [\n      sourceName,\n      dependencies,\n    ] of this._dependenciesPerFile.entries()) {\n      undirectedGraph[sourceName] = undirectedGraph[sourceName] ?? new Set();\n      for (const dependency of dependencies) {\n        undirectedGraph[dependency.sourceName] =\n          undirectedGraph[dependency.sourceName] ?? new Set();\n        undirectedGraph[sourceName].add(dependency.sourceName);\n        undirectedGraph[dependency.sourceName].add(sourceName);\n      }\n    }\n\n    const components: Array<Set<string>> = [];\n    const visited = new Set<string>();\n\n    for (const node of Object.keys(undirectedGraph)) {\n      if (visited.has(node)) {\n        continue;\n      }\n      visited.add(node);\n      const component = new Set([node]);\n      const stack = [...undirectedGraph[node]];\n      while (stack.length > 0) {\n        const newNode = stack.pop()!;\n        if (visited.has(newNode)) {\n          continue;\n        }\n        visited.add(newNode);\n        component.add(newNode);\n        [...undirectedGraph[newNode]].forEach((adjacent) => {\n          if (!visited.has(adjacent)) {\n            stack.push(adjacent);\n          }\n        });\n      }\n\n      components.push(component);\n    }\n\n    const connectedComponents: DependencyGraph[] = [];\n    for (const component of components) {\n      const dependencyGraph = new DependencyGraph();\n\n      for (const sourceName of component) {\n        const file = this._resolvedFiles.get(sourceName)!;\n        const dependencies = this._dependenciesPerFile.get(sourceName)!;\n\n        dependencyGraph._resolvedFiles.set(sourceName, file);\n        dependencyGraph._dependenciesPerFile.set(sourceName, dependencies);\n      }\n      connectedComponents.push(dependencyGraph);\n    }\n\n    return connectedComponents;\n  }\n\n  private _getTransitiveDependencies(\n    file: ResolvedFile,\n    visited: Set<ResolvedFile>,\n    path: ResolvedFile[]\n  ): Set<taskTypes.TransitiveDependency> {\n    if (visited.has(file)) {\n      return new Set();\n    }\n    visited.add(file);\n\n    const directDependencies: taskTypes.TransitiveDependency[] =\n      this.getDependencies(file).map((dependency) => ({\n        dependency,\n        path,\n      }));\n\n    const transitiveDependencies = new Set<taskTypes.TransitiveDependency>(\n      directDependencies\n    );\n\n    for (const { dependency } of transitiveDependencies) {\n      this._getTransitiveDependencies(\n        dependency,\n        visited,\n        path.concat(dependency)\n      ).forEach((x) => transitiveDependencies.add(x));\n    }\n\n    return transitiveDependencies;\n  }\n\n  private async _addDependenciesFrom(\n    resolver: Resolver,\n    file: ResolvedFile\n  ): Promise<void> {\n    const sourceName = this._visitedFiles.get(file.absolutePath);\n\n    if (sourceName !== undefined) {\n      if (sourceName !== file.sourceName) {\n        throw new HardhatError(ERRORS.RESOLVER.AMBIGUOUS_SOURCE_NAMES, {\n          sourcenames: `'${sourceName}' and '${file.sourceName}'`,\n          file: file.absolutePath,\n        });\n      }\n\n      return;\n    }\n\n    this._visitedFiles.set(file.absolutePath, file.sourceName);\n\n    const dependencies = new Set<ResolvedFile>();\n    this._resolvedFiles.set(file.sourceName, file);\n    this._dependenciesPerFile.set(file.sourceName, dependencies);\n\n    // TODO refactor this to make the results deterministic\n    await Promise.all(\n      file.content.imports.map(async (imp) => {\n        const dependency = await resolver.resolveImport(file, imp);\n        dependencies.add(dependency);\n\n        await this._addDependenciesFrom(resolver, dependency);\n      })\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}