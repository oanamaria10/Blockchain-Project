{"ast":null,"code":"/**\n * Upload Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Account from '@web3-storage/capabilities/upload'\n * ```\n *\n * @module\n */\nimport { capability, Link, Schema, ok } from '@ucanto/validator';\nimport { codec as CAR } from '@ucanto/transport/car';\nimport { equalWith, and, equal, SpaceDID } from './utils.js';\n\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `upload/` prefixed capability for the (memory) space identified\n * by DID in the `with` field.\n */\nexport const upload = capability({\n  can: 'upload/*',\n  /**\n   * DID of the (memory) space where upload is add to the\n   * upload list.\n   */\n  with: SpaceDID,\n  derives: equalWith\n});\n\n/**\n * Schema representing a link (a.k.a CID) to a CAR file. Enforces CAR codec code and CID v1.\n */\nconst CARLink = Link.match({\n  code: CAR.code,\n  version: 1\n});\n\n/**\n * Capability allows an agent to add an arbitrary DAG (root) to the upload list\n * of the specified (memory) space (identified by did:key in the `with` field).\n * It is recommended to provide an optional list of shard links that contain\n * fragments of this DAG, as it allows system to optimize block discovery, it is\n * also a way to communicate DAG partiality - this upload contains partial DAG\n * identified by the given `root`.\n *\n * Usually when agent wants to upload a DAG it will encode it as a one or more\n * CAR files (shards) and invoke `store/add` capability for each one. Once all\n * shards are stored it will invoke `upload/add` capability (providing link to\n * a DAG root and all the shards) to add it the upload list.\n *\n * That said `upload/add` could be invoked without invoking `store/add`s e.g.\n * because another (memory) space may already have those CARs.\n *\n * Note: If DAG with the given root is already in the upload list, invocation\n * will simply update `shards` to be a union of existing and new shards.\n */\nexport const add = capability({\n  can: 'upload/add',\n  /**\n   * DID of the (memory) space where uploaded is added.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * Root CID of the DAG to be added to the upload list.\n     */\n    root: Link,\n    /**\n     * CIDs to the CAR files that contain blocks of the DAG.\n     */\n    shards: CARLink.array().optional()\n  }),\n  derives: (self, from) => {\n    return and(equalWith(self, from)) || and(equal(self.nb.root, from.nb.root, 'root')) || and(equal(self.nb.shards, from.nb.shards, 'shards')) || ok({});\n  }\n});\n\n/**\n * Capability to get upload metadata by root CID.\n * Use to check for inclusion, or find the shards for a root.\n *\n * `nb.root` is optional to allow delegation of `upload/get`\n * capability for any root. If root is specified, then the\n * capability only allows a get for that single cid.\n *\n * When used as as an invocation, `nb.root` must be specified.\n */\nexport const get = capability({\n  can: 'upload/get',\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * Root CID of the DAG to fetch upload info about.\n     */\n    root: Link.optional()\n  }),\n  derives: (self, from) => {\n    const res = equalWith(self, from);\n    if (res.error) {\n      return res;\n    }\n    if (!from.nb.root) {\n      return res;\n    }\n    // root must match if specified in the proof\n    return equal(self.nb.root, from.nb.root, 'root');\n  }\n});\n\n/**\n * Capability removes an upload (identified by it's root CID) from the upload\n * list. Please note that removing an upload does not delete corresponding shards\n * from the store, however that could be done via `store/remove` invocations.\n */\nexport const remove = capability({\n  can: 'upload/remove',\n  /**\n   * DID of the (memory) space where uploaded is removed from.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * Root CID of the DAG to be removed from the upload list.\n     */\n    root: Link\n  }),\n  derives: (self, from) => {\n    return and(equalWith(self, from)) || and(equal(self.nb.root, from.nb.root, 'root')) || ok({});\n  }\n});\n\n/**\n * Capability can be invoked to request a list of uploads in the (memory) space\n * identified by the `with` field.\n */\nexport const list = capability({\n  can: 'upload/list',\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * A pointer that can be moved back and forth on the list.\n     * It can be used to paginate a list for instance.\n     */\n    cursor: Schema.string().optional(),\n    /**\n     * Maximum number of items per page.\n     */\n    size: Schema.integer().optional(),\n    /**\n     * If true, return page of results preceding cursor. Defaults to false.\n     */\n    pre: Schema.boolean().optional()\n  })\n});\nexport const all = add.or(remove).or(list);\n\n// ⚠️ We export imports here so they are not omitted in generated typedefs\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Link, Schema };","map":{"version":3,"names":["capability","Link","Schema","ok","codec","CAR","equalWith","and","equal","SpaceDID","upload","can","with","derives","CARLink","match","code","version","add","nb","struct","root","shards","array","optional","self","from","get","res","error","remove","list","cursor","string","size","integer","pre","boolean","all","or"],"sources":["C:/FACULTATE/Proiect/node_modules/@web3-storage/capabilities/src/upload.js"],"sourcesContent":["/**\n * Upload Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Account from '@web3-storage/capabilities/upload'\n * ```\n *\n * @module\n */\nimport { capability, Link, Schema, ok } from '@ucanto/validator'\nimport { codec as CAR } from '@ucanto/transport/car'\nimport { equalWith, and, equal, SpaceDID } from './utils.js'\n\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `upload/` prefixed capability for the (memory) space identified\n * by DID in the `with` field.\n */\nexport const upload = capability({\n  can: 'upload/*',\n  /**\n   * DID of the (memory) space where upload is add to the\n   * upload list.\n   */\n  with: SpaceDID,\n  derives: equalWith,\n})\n\n/**\n * Schema representing a link (a.k.a CID) to a CAR file. Enforces CAR codec code and CID v1.\n */\nconst CARLink = Link.match({ code: CAR.code, version: 1 })\n\n/**\n * Capability allows an agent to add an arbitrary DAG (root) to the upload list\n * of the specified (memory) space (identified by did:key in the `with` field).\n * It is recommended to provide an optional list of shard links that contain\n * fragments of this DAG, as it allows system to optimize block discovery, it is\n * also a way to communicate DAG partiality - this upload contains partial DAG\n * identified by the given `root`.\n *\n * Usually when agent wants to upload a DAG it will encode it as a one or more\n * CAR files (shards) and invoke `store/add` capability for each one. Once all\n * shards are stored it will invoke `upload/add` capability (providing link to\n * a DAG root and all the shards) to add it the upload list.\n *\n * That said `upload/add` could be invoked without invoking `store/add`s e.g.\n * because another (memory) space may already have those CARs.\n *\n * Note: If DAG with the given root is already in the upload list, invocation\n * will simply update `shards` to be a union of existing and new shards.\n */\nexport const add = capability({\n  can: 'upload/add',\n  /**\n   * DID of the (memory) space where uploaded is added.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * Root CID of the DAG to be added to the upload list.\n     */\n    root: Link,\n    /**\n     * CIDs to the CAR files that contain blocks of the DAG.\n     */\n    shards: CARLink.array().optional(),\n  }),\n  derives: (self, from) => {\n    return (\n      and(equalWith(self, from)) ||\n      and(equal(self.nb.root, from.nb.root, 'root')) ||\n      and(equal(self.nb.shards, from.nb.shards, 'shards')) ||\n      ok({})\n    )\n  },\n})\n\n/**\n * Capability to get upload metadata by root CID.\n * Use to check for inclusion, or find the shards for a root.\n *\n * `nb.root` is optional to allow delegation of `upload/get`\n * capability for any root. If root is specified, then the\n * capability only allows a get for that single cid.\n *\n * When used as as an invocation, `nb.root` must be specified.\n */\nexport const get = capability({\n  can: 'upload/get',\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * Root CID of the DAG to fetch upload info about.\n     */\n    root: Link.optional(),\n  }),\n  derives: (self, from) => {\n    const res = equalWith(self, from)\n    if (res.error) {\n      return res\n    }\n    if (!from.nb.root) {\n      return res\n    }\n    // root must match if specified in the proof\n    return equal(self.nb.root, from.nb.root, 'root')\n  },\n})\n\n/**\n * Capability removes an upload (identified by it's root CID) from the upload\n * list. Please note that removing an upload does not delete corresponding shards\n * from the store, however that could be done via `store/remove` invocations.\n */\nexport const remove = capability({\n  can: 'upload/remove',\n  /**\n   * DID of the (memory) space where uploaded is removed from.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * Root CID of the DAG to be removed from the upload list.\n     */\n    root: Link,\n  }),\n  derives: (self, from) => {\n    return (\n      and(equalWith(self, from)) ||\n      and(equal(self.nb.root, from.nb.root, 'root')) ||\n      ok({})\n    )\n  },\n})\n\n/**\n * Capability can be invoked to request a list of uploads in the (memory) space\n * identified by the `with` field.\n */\nexport const list = capability({\n  can: 'upload/list',\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * A pointer that can be moved back and forth on the list.\n     * It can be used to paginate a list for instance.\n     */\n    cursor: Schema.string().optional(),\n    /**\n     * Maximum number of items per page.\n     */\n    size: Schema.integer().optional(),\n    /**\n     * If true, return page of results preceding cursor. Defaults to false.\n     */\n    pre: Schema.boolean().optional(),\n  }),\n})\n\nexport const all = add.or(remove).or(list)\n\n// ⚠️ We export imports here so they are not omitted in generated typedefs\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Link, Schema }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}