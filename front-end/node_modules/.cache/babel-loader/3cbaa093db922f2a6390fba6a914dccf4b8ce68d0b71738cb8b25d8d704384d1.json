{"ast":null,"code":"import * as BufferQueue from \"./chunker/buffer.js\";\nimport * as Chunker from \"./chunker/api.js\";\nimport { EMPTY } from \"../writer/util.js\";\nexport * from \"./chunker/api.js\";\n\n/**\n * @typedef {{\n * chunker: Chunker.Chunker\n * }} Config\n *\n *\n * @typedef {{\n * buffer: BufferQueue.View\n * config: Config\n * }} Chunker\n *\n * @typedef {Chunker & {chunks: Chunker.Chunk[]}} ChunkerWithChunks\n */\n\n/**\n * @param {Config} config\n * @returns {Chunker}\n */\nexport const open = config => ({\n  config,\n  buffer: BufferQueue.empty()\n});\n\n/**\n * @param {Chunker} state\n * @param {Uint8Array} bytes\n * @returns {ChunkerWithChunks}\n */\nexport const write = (state, bytes) => bytes.byteLength > 0 ? split(state.config, state.buffer.push(bytes), false) : {\n  ...state,\n  chunks: EMPTY\n};\n\n/**\n * @param {Chunker} state\n * @returns {ChunkerWithChunks}\n */\nexport const close = state => split(state.config, state.buffer, true);\n\n/**\n * @param {Config} config\n * @param {BufferQueue.View} buffer\n * @param {boolean} end\n * @returns {ChunkerWithChunks}\n */\n\nexport const split = (config, buffer, end) => {\n  const chunker = config.chunker;\n  const chunks = [];\n  let offset = 0;\n  for (const size of chunker.cut(chunker.context, buffer, end)) {\n    // We may be splitting empty buffer in which case there will be no chunks\n    // in it so we make sure that we do not emit empty buffer.\n    if (size > 0) {\n      const chunk = buffer.subarray(offset, offset + size);\n      chunks.push(chunk);\n      offset += size;\n    }\n  }\n  return {\n    config,\n    chunks,\n    buffer: buffer.subarray(offset)\n  };\n};","map":{"version":3,"names":["BufferQueue","Chunker","EMPTY","open","config","buffer","empty","write","state","bytes","byteLength","split","push","chunks","close","end","chunker","offset","size","cut","context","chunk","subarray"],"sources":["C:/FACULTATE/Proiect/node_modules/@ipld/unixfs/src/file/chunker.js"],"sourcesContent":["import * as BufferQueue from \"./chunker/buffer.js\"\nimport * as Chunker from \"./chunker/api.js\"\nimport { EMPTY } from \"../writer/util.js\"\nexport * from \"./chunker/api.js\"\n\n/**\n * @typedef {{\n * chunker: Chunker.Chunker\n * }} Config\n *\n *\n * @typedef {{\n * buffer: BufferQueue.View\n * config: Config\n * }} Chunker\n *\n * @typedef {Chunker & {chunks: Chunker.Chunk[]}} ChunkerWithChunks\n */\n\n/**\n * @param {Config} config\n * @returns {Chunker}\n */\nexport const open = config => ({\n  config,\n  buffer: BufferQueue.empty(),\n})\n\n/**\n * @param {Chunker} state\n * @param {Uint8Array} bytes\n * @returns {ChunkerWithChunks}\n */\nexport const write = (state, bytes) =>\n  bytes.byteLength > 0\n    ? split(state.config, state.buffer.push(bytes), false)\n    : { ...state, chunks: EMPTY }\n\n/**\n * @param {Chunker} state\n * @returns {ChunkerWithChunks}\n */\nexport const close = state => split(state.config, state.buffer, true)\n\n/**\n * @param {Config} config\n * @param {BufferQueue.View} buffer\n * @param {boolean} end\n * @returns {ChunkerWithChunks}\n */\n\nexport const split = (config, buffer, end) => {\n  const chunker = config.chunker\n  const chunks = []\n\n  let offset = 0\n  for (const size of chunker.cut(chunker.context, buffer, end)) {\n    // We may be splitting empty buffer in which case there will be no chunks\n    // in it so we make sure that we do not emit empty buffer.\n    if (size > 0) {\n      const chunk = buffer.subarray(offset, offset + size)\n      chunks.push(chunk)\n      offset += size\n    }\n  }\n\n  return { config, chunks, buffer: buffer.subarray(offset) }\n}\n"],"mappings":"AAAA,OAAO,KAAKA,WAAW,MAAM,qBAAqB;AAClD,OAAO,KAAKC,OAAO,MAAM,kBAAkB;AAC3C,SAASC,KAAK,QAAQ,mBAAmB;AACzC,cAAc,kBAAkB;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,MAAMC,IAAI,GAAGC,MAAM,KAAK;EAC7BA,MAAM;EACNC,MAAM,EAAEL,WAAW,CAACM,KAAK,CAAC;AAC5B,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,KAAK,GAAGA,CAACC,KAAK,EAAEC,KAAK,KAChCA,KAAK,CAACC,UAAU,GAAG,CAAC,GAChBC,KAAK,CAACH,KAAK,CAACJ,MAAM,EAAEI,KAAK,CAACH,MAAM,CAACO,IAAI,CAACH,KAAK,CAAC,EAAE,KAAK,CAAC,GACpD;EAAE,GAAGD,KAAK;EAAEK,MAAM,EAAEX;AAAM,CAAC;;AAEjC;AACA;AACA;AACA;AACA,OAAO,MAAMY,KAAK,GAAGN,KAAK,IAAIG,KAAK,CAACH,KAAK,CAACJ,MAAM,EAAEI,KAAK,CAACH,MAAM,EAAE,IAAI,CAAC;;AAErE;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAMM,KAAK,GAAGA,CAACP,MAAM,EAAEC,MAAM,EAAEU,GAAG,KAAK;EAC5C,MAAMC,OAAO,GAAGZ,MAAM,CAACY,OAAO;EAC9B,MAAMH,MAAM,GAAG,EAAE;EAEjB,IAAII,MAAM,GAAG,CAAC;EACd,KAAK,MAAMC,IAAI,IAAIF,OAAO,CAACG,GAAG,CAACH,OAAO,CAACI,OAAO,EAAEf,MAAM,EAAEU,GAAG,CAAC,EAAE;IAC5D;IACA;IACA,IAAIG,IAAI,GAAG,CAAC,EAAE;MACZ,MAAMG,KAAK,GAAGhB,MAAM,CAACiB,QAAQ,CAACL,MAAM,EAAEA,MAAM,GAAGC,IAAI,CAAC;MACpDL,MAAM,CAACD,IAAI,CAACS,KAAK,CAAC;MAClBJ,MAAM,IAAIC,IAAI;IAChB;EACF;EAEA,OAAO;IAAEd,MAAM;IAAES,MAAM;IAAER,MAAM,EAAEA,MAAM,CAACiB,QAAQ,CAACL,MAAM;EAAE,CAAC;AAC5D,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}