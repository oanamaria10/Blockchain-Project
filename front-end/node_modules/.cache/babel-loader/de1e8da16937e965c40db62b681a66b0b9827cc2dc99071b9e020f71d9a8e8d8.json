{"ast":null,"code":"import * as Task from \"./task.js\";\nexport * from \"./task.js\";\n\n/**\n * Turns a task (that never fails or sends messages) into an effect of it's\n * result.\n *\n * @template T\n * @param {Task.Task<T, never>} task\n * @returns {Task.Effect<T>}\n */\nexport const effect = function* (task) {\n  const message = yield* task;\n  yield* send(message);\n};\n\n/**\n * Gets a handle to the task that invoked it. Useful when task needs to\n * suspend execution until some outside event occurs, in which case handle\n * can be used resume execution (see `suspend` code example for more details)\n *\n * @template T, M, X\n * @returns {Task.Task<Task.Controller<T, X, M>, never>}\n */\nexport function* current() {\n  return /** @type {Task.Controller<T, X, M>} */yield CURRENT;\n}\n\n/**\n * Suspends the current task (task that invokes it),  which can then be\n * resumed from another task or an outside event (e.g. `setTimeout` callback)\n * by calling the `resume` with an task's handle.\n *\n * Calling this in almost all cases is preceeded by call to `current()` in\n * order to obtain a `handle` which can be passed to `resume` function\n * to resume the execution.\n *\n * Note: This task never fails, although it may never resume either. However\n * you can utilize `finally` block to do a necessary cleanup in case execution\n * is aborted.\n *\n * @example\n * ```js\n * import { current, suspend, resume } from \"actor\"\n * function * sleep(duration) {\n *    // get a reference to this task so we can resume it.\n *    const self = yield * current()\n *    // resume this task when timeout fires\n *    const id = setTimeout(() => resume(self), duration)\n *    try {\n *      // suspend this task nothing below this line will run until task is\n *      // resumed.\n *      yield * suspend()\n *    } finally {\n *      // if task is aborted finally block will still run which given you\n *      // chance to cleanup.\n *      clearTimeout(id)\n *    }\n * }\n * ```\n *\n * @returns {Task.Task<void, never>}\n */\nexport const suspend = function* () {\n  yield SUSPEND;\n};\n\n/**\n * Suspends execution for the given duration in milliseconds, after which\n * execution is resumed (unless it was aborted in the meantime).\n *\n * @example\n * ```js\n * function * demo() {\n *    console.log(\"I'm going to take small nap\")\n *    yield * sleep(200)\n *    console.log(\"I am back to work\")\n * }\n * ```\n *\n * @param {number} [duration]\n * @returns {Task.Task<void, never>}\n */\nexport function* sleep(duration = 0) {\n  const task = yield* current();\n  const id = setTimeout(enqueue, duration, task);\n  try {\n    yield* suspend();\n  } finally {\n    clearTimeout(id);\n  }\n}\n\n/**\n * Provides equivalent of `await` in async functions. Specifically it takes\n * a value that you can `await` on (that is `Promise<T>|T`) and suspends\n * execution until promise is settled. If promise succeeds execution is resumed\n * with `T` otherwise an error of type `X` is thrown (which is by default\n * `unknown` since promises do not encode error type).\n *\n * It is useful when you need to deal with potentially async set of operations\n * without having to check if thing is a promise at every step.\n *\n * Please note: This that execution is suspended even if given value is not a\n * promise, however scheduler will still resume it in the same tick of the event\n * loop after, just processing other scheduled tasks. This avoids problematic\n * race condititions that can otherwise occur when values are sometimes promises\n * and other times are not.\n *\n * @example\n * ```js\n * function * fetchJSON (url, options) {\n *    const response = yield * wait(fetch(url, options))\n *    const json = yield * wait(response.json())\n *    return json\n * }\n * ```\n *\n * @template T, [X=unknown]\n * @param {Task.Await<T>} input\n * @returns {Task.Task<T, Error>}\n */\nexport const wait = function* (input) {\n  const task = yield* current();\n  if (isAsync(input)) {\n    let failed = false;\n    /** @type {unknown} */\n    let output = undefined;\n    input.then(value => {\n      failed = false;\n      output = value;\n      enqueue(task);\n    }, error => {\n      failed = true;\n      output = error;\n      enqueue(task);\n    });\n    yield* suspend();\n    if (failed) {\n      throw output;\n    } else {\n      return /** @type {T} */output;\n    }\n  } else {\n    // This may seem redundunt but it is not, by enqueuing this task we allow\n    // scheduler to perform other queued tasks first. This way many race\n    // conditions can be avoided when values are sometimes promises and other\n    // times aren't.\n    // Unlike `await` however this will resume in the same tick.\n    main(wake(task));\n    yield* suspend();\n    return input;\n  }\n};\n\n/**\n * @template T, X, M\n * @param {Task.Controller<T, X, M>} task\n * @returns {Task.Task<void, never, never>}\n */\nfunction* wake(task) {\n  enqueue(task);\n}\n\n/**\n * Checks if value value is a promise (or it's lookalike).\n *\n * @template T\n * @param {any} node\n * @returns {node is PromiseLike<T>}\n */\n\nconst isAsync = node => node != null && typeof ( /** @type {{then?:unknown}} */node.then) === \"function\";\n\n/**\n * Task that sends given message (or rather an effect producing this message).\n * Please note, that while you could use `yield message` instead, but you'd risk\n * having to deal with potential breaking changes if library internals change\n * in the future, which in fact may happen as anticipated improvements in\n * TS generator inference could enable replace need for `yield *`.\n *\n * @see https://github.com/microsoft/TypeScript/issues/43632\n *\n * @template T\n * @param {T} message\n * @returns {Task.Effect<T>}\n */\nexport const send = function* (message) {\n  yield ( /** @type {Task.Message<T>} */message);\n};\n\n/**\n * Takes several effects and merges them into a single effect of tagged\n * variants so that their source could be identified via `type` field.\n *\n * @example\n * ```js\n * listen({\n *    read: Task.effect(dbRead),\n *    write: Task.effect(dbWrite)\n * })\n * ```\n *\n * @template {string} Tag\n * @template T\n * @param {{ [K in Tag]: Task.Effect<T> }} source\n * @returns {Task.Effect<Tagged<Tag, T>>}\n */\nexport const listen = function* (source) {\n  /** @type {Task.Fork<void, never, Tagged<Tag, T>>[]} */\n  const forks = [];\n  for (const entry of Object.entries(source)) {\n    const [name, effect] = /** @type {[Tag, Task.Effect<T>]} */entry;\n    if (effect !== NONE) {\n      forks.push(yield* fork(tag(effect, name)));\n    }\n  }\n  yield* group(forks);\n};\n\n/**\n * Takes several tasks and creates an effect of them all.\n *\n * @example\n * ```js\n * Task.effects([\n *    dbRead,\n *    dbWrite\n * ])\n * ```\n *\n * @template {string} Tag\n * @template T\n * @param {Task.Task<T, never>[]} tasks\n * @returns {Task.Effect<T>}\n */\n\nexport const effects = tasks => tasks.length > 0 ? batch(tasks.map(effect)) : NONE;\n\n/**\n * Takes several effects and combines them into a one.\n *\n * @template T\n * @param {Task.Effect<T>[]} effects\n * @returns {Task.Effect<T>}\n */\nexport function* batch(effects) {\n  const forks = [];\n  for (const effect of effects) {\n    forks.push(yield* fork(effect));\n  }\n  yield* group(forks);\n}\n\n/**\n * @template {string} Tag\n * @template T\n * @typedef {{type: Tag} & {[K in Tag]: T}} Tagged\n */\n/**\n * Tags an effect by boxing each event with an object that has `type` field\n * corresponding to given tag and same named field holding original message\n * e.g. given `nums` effect that produces numbers, `tag(nums, \"inc\")` would\n * create an effect that produces events like `{type:'inc', inc:1}`.\n *\n * @template {string} Tag\n * @template T, M, X\n * @param {Task.Task<T, X, M>} effect\n * @param {Tag} tag\n * @returns {Task.Task<T, X, Tagged<Tag, M>>}\n */\nexport const tag = (effect, tag) =>\n// @ts-ignore\neffect === NONE ? NONE : effect instanceof Tagger ? new Tagger([...effect.tags, tag], effect.source) : new Tagger([tag], effect);\n\n/**\n * @template {string} Tag\n * @template Success, Failure, Message\n *\n * @implements {Task.Task<Success, Failure, Tagged<Tag, Message>>}\n * @implements {Task.Controller<Success, Failure, Tagged<Tag, Message>>}\n */\nclass Tagger {\n  /**\n   * @param {Task.Task<Success, Failure, Message>} source\n   * @param {string[]} tags\n   */\n  constructor(tags, source) {\n    this.tags = tags;\n    this.source = source;\n    /** @type {Task.Controller<Success, Failure, Message>} */\n    this.controller;\n  }\n  /* c8 ignore next 3 */\n  [Symbol.iterator]() {\n    if (!this.controller) {\n      this.controller = this.source[Symbol.iterator]();\n    }\n    return this;\n  }\n  /**\n   * @param {Task.TaskState<Success, Message>} state\n   * @returns {Task.TaskState<Success, Tagged<Tag, Message>>}\n   */\n  box(state) {\n    if (state.done) {\n      return state;\n    } else {\n      switch (state.value) {\n        case SUSPEND:\n        case CURRENT:\n          return /** @type {Task.TaskState<Success, Tagged<Tag, Message>>} */(\n            state\n          );\n        default:\n          {\n            // Instead of boxing result at each transform step we perform in-place\n            // mutation as we know nothing else is accessing this value.\n            const tagged = /** @type {{ done: false, value: any }} */state;\n            let {\n              value\n            } = tagged;\n            for (const tag of this.tags) {\n              value = withTag(tag, value);\n            }\n            tagged.value = value;\n            return tagged;\n          }\n      }\n    }\n  }\n  /**\n   *\n   * @param {Task.Instruction<Message>} instruction\n   */\n  next(instruction) {\n    return this.box(this.controller.next(instruction));\n  }\n  /**\n   *\n   * @param {Failure} error\n   */\n  throw(error) {\n    return this.box(this.controller.throw(error));\n  }\n  /**\n   * @param {Success} value\n   */\n  return(value) {\n    return this.box(this.controller.return(value));\n  }\n  get [Symbol.toStringTag]() {\n    return \"TaggedEffect\";\n  }\n}\n\n/**\n * Returns empty `Effect`, that is produces no messages. Kind of like `[]` or\n * `\"\"` but for effects.\n *\n * @type {() => Task.Effect<never>}\n */\nexport const none = () => NONE;\n\n/**\n * Takes iterable of tasks and runs them concurrently, returning array of\n * results in an order of tasks (not the order of completion). If any of the\n * tasks fail all the rest are aborted and error is throw into calling task.\n *\n * > This is basically equivalent of `Promise.all` except cancelation logic\n * because tasks unlike promises can be cancelled.\n *\n * @template T, X\n * @param {Iterable<Task.Task<T, X>>} tasks\n * @returns {Task.Task<T[], X>}\n */\nexport const all = function* (tasks) {\n  const self = yield* current();\n\n  /** @type {(id:number) => (value:T) => void} */\n  const succeed = id => value => {\n    delete forks[id];\n    results[id] = value;\n    count -= 1;\n    if (count === 0) {\n      enqueue(self);\n    }\n  };\n\n  /** @type {(error:X) => void} */\n  const fail = error => {\n    for (const handle of forks) {\n      if (handle) {\n        enqueue(abort(handle, error));\n      }\n    }\n    enqueue(abort(self, error));\n  };\n\n  /** @type {Task.Fork<void, never>[]} */\n  let forks = [];\n  let count = 0;\n  for (const task of tasks) {\n    forks.push(yield* fork(then(task, succeed(count++), fail)));\n  }\n  const results = new Array(count);\n  if (count > 0) {\n    yield* suspend();\n  }\n  return results;\n};\n\n/**\n * @template {string} Tag\n * @template T\n * @param {Tag} tag\n * @param {Task.Message<T>} value\n */\nconst withTag = (tag, value) => ( /** @type {Tagged<Tag, T>} */\n{\n  type: tag,\n  [tag]: value\n});\n\n/**\n * Kind of like promise.then which is handy when you want to extract result\n * from the given task from the outside.\n *\n * @template T, U, X, M\n * @param {Task.Task<T, X, M>} task\n * @param {(value:T) => U} resolve\n * @param {(error:X) => U} reject\n * @returns {Task.Task<U, never, M>}\n */\nexport function* then(task, resolve, reject) {\n  try {\n    return resolve(yield* task);\n  } catch (error) {\n    return reject( /** @type {X} */error);\n  }\n}\n\n// Special control instructions recognized by a scheduler.\nconst CURRENT = Symbol(\"current\");\nconst SUSPEND = Symbol(\"suspend\");\n/** @typedef {typeof SUSPEND|typeof CURRENT} Control */\n\n/**\n * @template M\n * @param {Task.Instruction<M>} value\n * @returns {value is M}\n */\nexport const isMessage = value => {\n  switch (value) {\n    case SUSPEND:\n    case CURRENT:\n      return false;\n    default:\n      return true;\n  }\n};\n\n/**\n * @template M\n * @param {Task.Instruction<M>} value\n * @returns {value is Control}\n */\nexport const isInstruction = value => !isMessage(value);\n\n/**\n * @template T, X, M\n * @implements {Task.TaskGroup<T, X, M>}\n */\nclass Group {\n  /**\n   * @template T, X, M\n   * @param {Task.Controller<T, X, M>|Task.Fork<T, X, M>} member\n   * @returns {Task.Group<T, X, M>}\n   */\n  static of(member) {\n    return /** @type {{group?:Task.TaskGroup<T, X, M>}} */member.group || MAIN;\n  }\n\n  /**\n   * @template T, X, M\n   * @param {(Task.Controller<T, X, M>|Task.Fork<T, X, M>) & {group?:Task.TaskGroup<T, X, M>}} member\n   * @param {Task.TaskGroup<T, X, M>} group\n   */\n  static enqueue(member, group) {\n    member.group = group;\n    group.stack.active.push(member);\n  }\n  /**\n   * @param {Task.Controller<T, X, M>} driver\n   * @param {Task.Controller<T, X, M>[]} [active]\n   * @param {Set<Task.Controller<T, X, M>>} [idle]\n   * @param {Task.Stack<T, X, M>} [stack]\n   */\n  constructor(driver, active = [], idle = new Set(), stack = new Stack(active, idle)) {\n    this.driver = driver;\n    this.parent = Group.of(driver);\n    this.stack = stack;\n    this.id = ++ID;\n  }\n}\n\n/**\n * @template T, X, M\n * @implements {Task.Main<T, X, M>}\n */\nclass Main {\n  constructor() {\n    this.status = IDLE;\n    this.stack = new Stack();\n    this.id = /** @type {0} */0;\n  }\n}\n\n/**\n * @template T, X, M\n */\nclass Stack {\n  /**\n   * @param {Task.Controller<T, X, M>[]} [active]\n   * @param {Set<Task.Controller<T, X, M>>} [idle]\n   */\n  constructor(active = [], idle = new Set()) {\n    this.active = active;\n    this.idle = idle;\n  }\n\n  /**\n   *\n   * @param {Task.Stack<unknown, unknown, unknown>} stack\n   * @returns\n   */\n  static size({\n    active,\n    idle\n  }) {\n    return active.length + idle.size;\n  }\n}\n\n/**\n * Starts a main task.\n *\n * @param {Task.Task<void, never>} task\n */\nexport const main = task => enqueue(task[Symbol.iterator]());\n\n/**\n * @template T, X, M\n * @param {Task.Controller<T, X, M>} task\n */\nconst enqueue = task => {\n  let group = Group.of(task);\n  group.stack.active.push(task);\n  group.stack.idle.delete(task);\n\n  // then walk up the group chain and unblock their driver tasks.\n  while (group.parent) {\n    const {\n      idle,\n      active\n    } = group.parent.stack;\n    if (idle.has(group.driver)) {\n      idle.delete(group.driver);\n      active.push(group.driver);\n    } else {\n      // if driver was not blocked it must have been unblocked by\n      // other task so stop there.\n      break;\n    }\n    group = group.parent;\n  }\n  if (MAIN.status === IDLE) {\n    MAIN.status = ACTIVE;\n    while (true) {\n      try {\n        for (const _message of step(MAIN)) {}\n        MAIN.status = IDLE;\n        break;\n      } catch (_error) {\n        // Top level task may crash and throw an error, but given this is a main\n        // group we do not want to interupt other unrelated tasks, which is why\n        // we discard the error and the task that caused it.\n        MAIN.stack.active.shift();\n      }\n    }\n  }\n};\n\n/**\n * @template T, X, M\n * @param {Task.Controller<T, X, M>} task\n */\nexport const resume = task => enqueue(task);\n\n/**\n * @template T, X, M\n * @param {Task.Group<T, X, M>} group\n */\n\nconst step = function* (group) {\n  const {\n    active\n  } = group.stack;\n  let task = active[0];\n  group.stack.idle.delete(task);\n  while (task) {\n    /** @type {Task.TaskState<T, M>} */\n    let state = INIT;\n    // Keep processing insturctions until task is done, it send suspend request\n    // or it's has been removed from the active queue.\n    // ⚠️ Group changes require extra care so please make sure to understand\n    // the detail here. It occurs when spawned task(s) are joined into a group\n    // which will change the task driver, that is when `task === active[0]` will\n    // became false and need to to drop the task immediately otherwise race\n    // condition will occur due to task been  driven by multiple concurrent\n    // schedulers.\n    loop: while (!state.done && task === active[0]) {\n      const instruction = state.value;\n      switch (instruction) {\n        // if task is suspended we add it to the idle list and break the loop\n        // to move to a next task.\n        case SUSPEND:\n          group.stack.idle.add(task);\n          break loop;\n        // if task requested a context (which is usually to suspend itself)\n        // pass back a task reference and continue.\n        case CURRENT:\n          state = task.next(task);\n          break;\n        default:\n          // otherwise task sent a message which we yield to the driver and\n          // continue\n          state = task.next(yield ( /** @type {M & Task.Message<M>}*/instruction));\n          break;\n      }\n    }\n\n    // If task is complete, or got suspended we move to a next task\n    active.shift();\n    task = active[0];\n    group.stack.idle.delete(task);\n  }\n};\n\n/**\n * Executes given task concurrently with a current task (task that spawned it).\n * Spawned task is detached from the task that spawned it and it can outlive it\n * and / or fail without affecting a task that spawned it. If you need to wait\n * on concurrent task completion consider using `fork` instead which can be\n * later `joined`. If you just want a to block on task execution you can just\n * `yield* work()` directly instead.\n *\n * @param {Task.Task<void, never, never>} task\n * @returns {Task.Task<void, never>}\n */\nexport function* spawn(task) {\n  main(task);\n}\n\n/**\n * Executes given task concurrently with current task (the task that initiated\n * fork). Froked task is detached from the task that created it and it can\n * outlive it and / or fail without affecting it. You do however get a handle\n * for the fork which could be used to `join` the task, in which case `joining`\n * task will block until fork finishes execution.\n *\n * This is also a primary interface for executing tasks from the outside of the\n * task context. Function returns `Fork` which implements `Promise` interface\n * so it could be awaited. Please note that calling `fork` does not really do\n * anything, it lazily starts execution when you either `await fork(work())`\n * from arbitray context or `yield* fork(work())` in anothe task context.\n *\n * @template T, X, M\n * @param {Task.Task<T, X, M>} task\n * @param {Task.ForkOptions} [options]\n * @returns {Task.Fork<T, X, M>}\n */\nexport const fork = (task, options) => new Fork(task, options);\n\n/**\n * Exits task succesfully with a given return value.\n *\n * @template T, M, X\n * @param  {Task.Controller<T, M, X>} handle\n * @param {T} value\n * @returns {Task.Task<void, never>}\n */\nexport const exit = (handle, value) => conclude(handle, {\n  ok: true,\n  value\n});\n\n/**\n * Terminates task execution execution. Only takes task that produces no\n * result, if your task has non `void` return type you should use `exit` instead.\n *\n * @template M, X\n * @param {Task.Controller<void, X, M>} handle\n */\nexport const terminate = handle => conclude(handle, {\n  ok: true,\n  value: undefined\n});\n\n/**\n * Aborts given task with an error. Task error type should match provided error.\n *\n * @template T, M, X\n * @param {Task.Controller<T, X, M>} handle\n * @param {X} [error]\n */\nexport const abort = (handle, error) => conclude(handle, {\n  ok: false,\n  error\n});\n\n/**\n * Aborts given task with an given error.\n *\n * @template T, M, X\n * @param {Task.Controller<T, X, M>} handle\n * @param {Task.Result<T, X>} result\n * @returns {Task.Task<void, never> & Task.Controller<void, never>}\n */\nfunction* conclude(handle, result) {\n  try {\n    const task = handle;\n    const state = result.ok ? task.return(result.value) : task.throw(result.error);\n    if (!state.done) {\n      if (state.value === SUSPEND) {\n        const {\n          idle\n        } = Group.of(task).stack;\n        idle.add(task);\n      } else {\n        enqueue(task);\n      }\n    }\n  } catch (error) {}\n}\n\n/**\n * Groups multiple forks togather and joins joins them with current task.\n *\n * @template T, X, M\n * @param {Task.Fork<T, X, M>[]} forks\n * @returns {Task.Task<void, X, M>}\n */\nexport function* group(forks) {\n  // Abort eraly if there'se no work todo.\n  if (forks.length === 0) return;\n  const self = yield* current();\n  /** @type {Task.TaskGroup<T, X, M>} */\n  const group = new Group(self);\n  /** @type {Task.Failure<X>|null} */\n  let failure = null;\n  for (const fork of forks) {\n    const {\n      result\n    } = fork;\n    if (result) {\n      if (!result.ok && !failure) {\n        failure = result;\n      }\n      continue;\n    }\n    move(fork, group);\n  }\n\n  // Keep work looping until there is nom more work to be done\n  try {\n    if (failure) {\n      throw failure.error;\n    }\n    while (true) {\n      yield* step(group);\n      if (Stack.size(group.stack) > 0) {\n        yield* suspend();\n      } else {\n        break;\n      }\n    }\n  } catch (error) {\n    for (const task of group.stack.active) {\n      yield* abort(task, error);\n    }\n    for (const task of group.stack.idle) {\n      yield* abort(task, error);\n      enqueue(task);\n    }\n    throw error;\n  }\n}\n\n/**\n * @template T, X, M\n * @param {Task.Fork<T, X, M>} fork\n * @param {Task.TaskGroup<T, X, M>} group\n */\nconst move = (fork, group) => {\n  const from = Group.of(fork);\n  if (from !== group) {\n    const {\n      active,\n      idle\n    } = from.stack;\n    const target = group.stack;\n    fork.group = group;\n    // If it is idle just move from one group to the other\n    // and update the group task thinks it belongs to.\n    if (idle.has(fork)) {\n      idle.delete(fork);\n      target.idle.add(fork);\n    } else {\n      const index = active.indexOf(fork);\n      // If task is in the job queue, we move it to a target job queue. Moving\n      // top task in the queue requires extra care so it does not end up\n      // processed by two groups which would lead to race. For that reason\n      // `step` loop checks for group changes on each turn.\n      if (index >= 0) {\n        active.splice(index, 1);\n        target.active.push(fork);\n      }\n      // otherwise task is complete\n    }\n  }\n};\n\n/**\n * @template T, X, M\n * @param {Task.Fork<T, X, M>} fork\n * @returns {Task.Task<T, X, M>}\n */\nexport function* join(fork) {\n  // If fork is still idle activate it.\n  if (fork.status === IDLE) {\n    yield* fork;\n  }\n  if (!fork.result) {\n    yield* group([fork]);\n  }\n  const result = /** @type {Task.Result<T, X>} */fork.result;\n  if (result.ok) {\n    return result.value;\n  } else {\n    throw result.error;\n  }\n}\n\n/**\n * @template T, X\n * @implements {Task.Future<T, X>}\n */\nclass Future {\n  /**\n   * @param {Task.StateHandler<T, X>} handler\n   */\n  constructor(handler) {\n    this.handler = handler;\n    /**\n     * @abstract\n     * @type {Task.Result<T, X>|void}\n     */\n    this.result;\n  }\n  /**\n   * @type {Promise<T>}\n   */\n  get promise() {\n    const {\n      result\n    } = this;\n    const promise = result == null ? new Promise((succeed, fail) => {\n      this.handler.onsuccess = succeed;\n      this.handler.onfailure = fail;\n    }) : result.ok ? Promise.resolve(result.value) : Promise.reject(result.error);\n    Object.defineProperty(this, \"promise\", {\n      value: promise\n    });\n    return promise;\n  }\n\n  /**\n   * @template U, [E=never]\n   * @param {((value:T) => U | PromiseLike<U>)|undefined|null} [onresolve]\n   * @param {((error:X) => E|PromiseLike<E>)|undefined|null} [onreject]\n   * @returns {Promise<U|E>}\n   */\n  then(onresolve, onreject) {\n    return this.activate().promise.then(onresolve, onreject);\n  }\n  /**\n   * @template [U=never]\n   * @param {(error:X) => U} onreject\n   */\n  catch(onreject) {\n    return /** @type {Task.Future<T|U, never>} */(\n      this.activate().promise.catch(onreject)\n    );\n  }\n  /**\n   * @param {() => void} onfinally\n   * @returns {Task.Future<T, X>}\n   */\n  finally(onfinally) {\n    return /** @type {Task.Future<T, X>} */(\n      this.activate().promise.finally(onfinally)\n    );\n  }\n  /**\n   * @abstract\n   */\n  /* c8 ignore next 3 */\n  activate() {\n    return this;\n  }\n}\n\n/**\n * @template T, X, M\n * @implements {Task.Fork<T, X, M>}\n * @implements {Task.Controller<T, X, M>}\n * @implements {Task.Task<Task.Fork<T, X, M>, never>}\n * @implements {Task.Future<T, X>}\n * @extends {Future<T, X>}\n */\nclass Fork extends Future {\n  /**\n   * @param {Task.Task<T, X, M>} task\n   * @param {Task.ForkOptions} [options]\n   * @param {Task.StateHandler<T, X>} [handler]\n   * @param {Task.TaskState<T, M>} [state]\n   */\n  constructor(task, options = BLANK, handler = {}, state = INIT) {\n    super(handler);\n    this.id = ++ID;\n    this.name = options.name || \"\";\n    /** @type {Task.Task<T, X, M>} */\n    this.task = task;\n    this.state = state;\n    this.status = IDLE;\n    /** @type {Task.Result<T, X>} */\n    this.result;\n    this.handler = handler;\n\n    /** @type {Task.Controller<T, X, M>} */\n    this.controller;\n  }\n  *resume() {\n    resume(this);\n  }\n\n  /**\n   * @returns {Task.Task<T, X, M>}\n   */\n  join() {\n    return join(this);\n  }\n\n  /**\n   * @param {X} error\n   */\n  abort(error) {\n    return abort(this, error);\n  }\n  /**\n   * @param {T} value\n   */\n  exit(value) {\n    return exit(this, value);\n  }\n  get [Symbol.toStringTag]() {\n    return \"Fork\";\n  }\n\n  /**\n   * @returns {Task.Controller<Task.Fork<T, X, M>, never, never>}\n   */\n  *[Symbol.iterator]() {\n    return this.activate();\n  }\n  activate() {\n    this.controller = this.task[Symbol.iterator]();\n    this.status = ACTIVE;\n    enqueue(this);\n    return this;\n  }\n\n  /**\n   * @private\n   * @param {any} error\n   * @returns {never}\n   */\n  panic(error) {\n    this.result = {\n      ok: false,\n      error\n    };\n    this.status = FINISHED;\n    const {\n      handler\n    } = this;\n    if (handler.onfailure) {\n      handler.onfailure(error);\n    }\n    throw error;\n  }\n\n  /**\n   * @private\n   * @param {Task.TaskState<T, M>} state\n   */\n  step(state) {\n    this.state = state;\n    if (state.done) {\n      this.result = {\n        ok: true,\n        value: state.value\n      };\n      this.status = FINISHED;\n      const {\n        handler\n      } = this;\n      if (handler.onsuccess) {\n        handler.onsuccess(state.value);\n      }\n    }\n    return state;\n  }\n\n  /**\n   * @param {unknown} value\n   */\n  next(value) {\n    try {\n      return this.step(this.controller.next(value));\n    } catch (error) {\n      return this.panic(error);\n    }\n  }\n  /**\n   * @param {T} value\n   */\n  return(value) {\n    try {\n      return this.step(this.controller.return(value));\n    } catch (error) {\n      return this.panic(error);\n    }\n  }\n  /**\n   * @param {X} error\n   */\n  throw(error) {\n    try {\n      return this.step(this.controller.throw(error));\n    } catch (error) {\n      return this.panic(error);\n    }\n  }\n}\n\n/**\n * @template M\n * @param {Task.Effect<M>} init\n * @param {(message:M) => Task.Effect<M>} next\n * @returns {Task.Task<void, never, never>}\n */\nexport const loop = function* (init, next) {\n  /** @type {Task.Controller<void, never, M>} */\n  const controller = yield* current();\n  const group = new Group(controller);\n  Group.enqueue(init[Symbol.iterator](), group);\n  while (true) {\n    for (const message of step(group)) {\n      Group.enqueue(next(message)[Symbol.iterator](), group);\n    }\n    if (Stack.size(group.stack) > 0) {\n      yield* suspend();\n    } else {\n      break;\n    }\n  }\n};\nlet ID = 0;\n/** @type {Task.Status} */\nconst IDLE = \"idle\";\nconst ACTIVE = \"active\";\nconst FINISHED = \"finished\";\n/** @type {Task.TaskState<any, any>} */\nconst INIT = {\n  done: false,\n  value: CURRENT\n};\nconst BLANK = {};\n\n/** @type {Task.Effect<never>} */\nconst NONE = function* none() {}();\n\n/** @type {Task.Main<any, any, any>} */\nconst MAIN = new Main();","map":{"version":3,"names":["Task","effect","task","message","send","current","CURRENT","suspend","SUSPEND","sleep","duration","id","setTimeout","enqueue","clearTimeout","wait","input","isAsync","failed","output","undefined","then","value","error","main","wake","node","listen","source","forks","entry","Object","entries","name","NONE","push","fork","tag","group","effects","tasks","length","batch","map","Tagger","tags","constructor","controller","Symbol","iterator","box","state","done","tagged","withTag","next","instruction","throw","return","toStringTag","none","all","self","succeed","results","count","fail","handle","abort","Array","type","resolve","reject","isMessage","isInstruction","Group","of","member","MAIN","stack","active","driver","idle","Set","Stack","parent","ID","Main","status","IDLE","size","delete","has","ACTIVE","_message","step","_error","shift","resume","INIT","loop","add","spawn","options","Fork","exit","conclude","ok","terminate","result","failure","move","from","target","index","indexOf","splice","join","Future","handler","promise","Promise","onsuccess","onfailure","defineProperty","onresolve","onreject","activate","catch","finally","onfinally","BLANK","panic","FINISHED","init"],"sources":["C:/FACULTATE/Proiect/node_modules/actor/src/lib.js"],"sourcesContent":["import * as Task from \"./task.js\"\nexport * from \"./task.js\"\n\n/**\n * Turns a task (that never fails or sends messages) into an effect of it's\n * result.\n *\n * @template T\n * @param {Task.Task<T, never>} task\n * @returns {Task.Effect<T>}\n */\nexport const effect = function* (task) {\n  const message = yield* task\n  yield* send(message)\n}\n\n/**\n * Gets a handle to the task that invoked it. Useful when task needs to\n * suspend execution until some outside event occurs, in which case handle\n * can be used resume execution (see `suspend` code example for more details)\n *\n * @template T, M, X\n * @returns {Task.Task<Task.Controller<T, X, M>, never>}\n */\nexport function* current() {\n  return /** @type {Task.Controller<T, X, M>} */ (yield CURRENT)\n}\n\n/**\n * Suspends the current task (task that invokes it),  which can then be\n * resumed from another task or an outside event (e.g. `setTimeout` callback)\n * by calling the `resume` with an task's handle.\n *\n * Calling this in almost all cases is preceeded by call to `current()` in\n * order to obtain a `handle` which can be passed to `resume` function\n * to resume the execution.\n *\n * Note: This task never fails, although it may never resume either. However\n * you can utilize `finally` block to do a necessary cleanup in case execution\n * is aborted.\n *\n * @example\n * ```js\n * import { current, suspend, resume } from \"actor\"\n * function * sleep(duration) {\n *    // get a reference to this task so we can resume it.\n *    const self = yield * current()\n *    // resume this task when timeout fires\n *    const id = setTimeout(() => resume(self), duration)\n *    try {\n *      // suspend this task nothing below this line will run until task is\n *      // resumed.\n *      yield * suspend()\n *    } finally {\n *      // if task is aborted finally block will still run which given you\n *      // chance to cleanup.\n *      clearTimeout(id)\n *    }\n * }\n * ```\n *\n * @returns {Task.Task<void, never>}\n */\nexport const suspend = function* () {\n  yield SUSPEND\n}\n\n/**\n * Suspends execution for the given duration in milliseconds, after which\n * execution is resumed (unless it was aborted in the meantime).\n *\n * @example\n * ```js\n * function * demo() {\n *    console.log(\"I'm going to take small nap\")\n *    yield * sleep(200)\n *    console.log(\"I am back to work\")\n * }\n * ```\n *\n * @param {number} [duration]\n * @returns {Task.Task<void, never>}\n */\nexport function* sleep(duration = 0) {\n  const task = yield* current()\n  const id = setTimeout(enqueue, duration, task)\n\n  try {\n    yield* suspend()\n  } finally {\n    clearTimeout(id)\n  }\n}\n\n/**\n * Provides equivalent of `await` in async functions. Specifically it takes\n * a value that you can `await` on (that is `Promise<T>|T`) and suspends\n * execution until promise is settled. If promise succeeds execution is resumed\n * with `T` otherwise an error of type `X` is thrown (which is by default\n * `unknown` since promises do not encode error type).\n *\n * It is useful when you need to deal with potentially async set of operations\n * without having to check if thing is a promise at every step.\n *\n * Please note: This that execution is suspended even if given value is not a\n * promise, however scheduler will still resume it in the same tick of the event\n * loop after, just processing other scheduled tasks. This avoids problematic\n * race condititions that can otherwise occur when values are sometimes promises\n * and other times are not.\n *\n * @example\n * ```js\n * function * fetchJSON (url, options) {\n *    const response = yield * wait(fetch(url, options))\n *    const json = yield * wait(response.json())\n *    return json\n * }\n * ```\n *\n * @template T, [X=unknown]\n * @param {Task.Await<T>} input\n * @returns {Task.Task<T, Error>}\n */\nexport const wait = function* (input) {\n  const task = yield* current()\n  if (isAsync(input)) {\n    let failed = false\n    /** @type {unknown} */\n    let output = undefined\n    input.then(\n      value => {\n        failed = false\n        output = value\n        enqueue(task)\n      },\n      error => {\n        failed = true\n        output = error\n        enqueue(task)\n      }\n    )\n\n    yield* suspend()\n    if (failed) {\n      throw output\n    } else {\n      return /** @type {T} */ (output)\n    }\n  } else {\n    // This may seem redundunt but it is not, by enqueuing this task we allow\n    // scheduler to perform other queued tasks first. This way many race\n    // conditions can be avoided when values are sometimes promises and other\n    // times aren't.\n    // Unlike `await` however this will resume in the same tick.\n    main(wake(task))\n    yield* suspend()\n    return input\n  }\n}\n\n/**\n * @template T, X, M\n * @param {Task.Controller<T, X, M>} task\n * @returns {Task.Task<void, never, never>}\n */\nfunction* wake(task) {\n  enqueue(task)\n}\n\n/**\n * Checks if value value is a promise (or it's lookalike).\n *\n * @template T\n * @param {any} node\n * @returns {node is PromiseLike<T>}\n */\n\nconst isAsync = node =>\n  node != null &&\n  typeof (/** @type {{then?:unknown}} */ (node).then) === \"function\"\n\n/**\n * Task that sends given message (or rather an effect producing this message).\n * Please note, that while you could use `yield message` instead, but you'd risk\n * having to deal with potential breaking changes if library internals change\n * in the future, which in fact may happen as anticipated improvements in\n * TS generator inference could enable replace need for `yield *`.\n *\n * @see https://github.com/microsoft/TypeScript/issues/43632\n *\n * @template T\n * @param {T} message\n * @returns {Task.Effect<T>}\n */\nexport const send = function* (message) {\n  yield /** @type {Task.Message<T>} */ (message)\n}\n\n/**\n * Takes several effects and merges them into a single effect of tagged\n * variants so that their source could be identified via `type` field.\n *\n * @example\n * ```js\n * listen({\n *    read: Task.effect(dbRead),\n *    write: Task.effect(dbWrite)\n * })\n * ```\n *\n * @template {string} Tag\n * @template T\n * @param {{ [K in Tag]: Task.Effect<T> }} source\n * @returns {Task.Effect<Tagged<Tag, T>>}\n */\nexport const listen = function* (source) {\n  /** @type {Task.Fork<void, never, Tagged<Tag, T>>[]} */\n  const forks = []\n  for (const entry of Object.entries(source)) {\n    const [name, effect] = /** @type {[Tag, Task.Effect<T>]} */ (entry)\n    if (effect !== NONE) {\n      forks.push(yield* fork(tag(effect, name)))\n    }\n  }\n\n  yield* group(forks)\n}\n\n/**\n * Takes several tasks and creates an effect of them all.\n *\n * @example\n * ```js\n * Task.effects([\n *    dbRead,\n *    dbWrite\n * ])\n * ```\n *\n * @template {string} Tag\n * @template T\n * @param {Task.Task<T, never>[]} tasks\n * @returns {Task.Effect<T>}\n */\n\nexport const effects = tasks =>\n  tasks.length > 0 ? batch(tasks.map(effect)) : NONE\n\n/**\n * Takes several effects and combines them into a one.\n *\n * @template T\n * @param {Task.Effect<T>[]} effects\n * @returns {Task.Effect<T>}\n */\nexport function* batch(effects) {\n  const forks = []\n  for (const effect of effects) {\n    forks.push(yield* fork(effect))\n  }\n\n  yield* group(forks)\n}\n\n/**\n * @template {string} Tag\n * @template T\n * @typedef {{type: Tag} & {[K in Tag]: T}} Tagged\n */\n/**\n * Tags an effect by boxing each event with an object that has `type` field\n * corresponding to given tag and same named field holding original message\n * e.g. given `nums` effect that produces numbers, `tag(nums, \"inc\")` would\n * create an effect that produces events like `{type:'inc', inc:1}`.\n *\n * @template {string} Tag\n * @template T, M, X\n * @param {Task.Task<T, X, M>} effect\n * @param {Tag} tag\n * @returns {Task.Task<T, X, Tagged<Tag, M>>}\n */\nexport const tag = (effect, tag) =>\n  // @ts-ignore\n  effect === NONE\n    ? NONE\n    : effect instanceof Tagger\n    ? new Tagger([...effect.tags, tag], effect.source)\n    : new Tagger([tag], effect)\n\n/**\n * @template {string} Tag\n * @template Success, Failure, Message\n *\n * @implements {Task.Task<Success, Failure, Tagged<Tag, Message>>}\n * @implements {Task.Controller<Success, Failure, Tagged<Tag, Message>>}\n */\nclass Tagger {\n  /**\n   * @param {Task.Task<Success, Failure, Message>} source\n   * @param {string[]} tags\n   */\n  constructor(tags, source) {\n    this.tags = tags\n    this.source = source\n    /** @type {Task.Controller<Success, Failure, Message>} */\n    this.controller\n  }\n  /* c8 ignore next 3 */\n  [Symbol.iterator]() {\n    if (!this.controller) {\n      this.controller = this.source[Symbol.iterator]()\n    }\n    return this\n  }\n  /**\n   * @param {Task.TaskState<Success, Message>} state\n   * @returns {Task.TaskState<Success, Tagged<Tag, Message>>}\n   */\n  box(state) {\n    if (state.done) {\n      return state\n    } else {\n      switch (state.value) {\n        case SUSPEND:\n        case CURRENT:\n          return /** @type {Task.TaskState<Success, Tagged<Tag, Message>>} */ (\n            state\n          )\n        default: {\n          // Instead of boxing result at each transform step we perform in-place\n          // mutation as we know nothing else is accessing this value.\n          const tagged = /** @type {{ done: false, value: any }} */ (state)\n          let { value } = tagged\n          for (const tag of this.tags) {\n            value = withTag(tag, value)\n          }\n          tagged.value = value\n          return tagged\n        }\n      }\n    }\n  }\n  /**\n   *\n   * @param {Task.Instruction<Message>} instruction\n   */\n  next(instruction) {\n    return this.box(this.controller.next(instruction))\n  }\n  /**\n   *\n   * @param {Failure} error\n   */\n  throw(error) {\n    return this.box(this.controller.throw(error))\n  }\n  /**\n   * @param {Success} value\n   */\n  return(value) {\n    return this.box(this.controller.return(value))\n  }\n\n  get [Symbol.toStringTag]() {\n    return \"TaggedEffect\"\n  }\n}\n\n/**\n * Returns empty `Effect`, that is produces no messages. Kind of like `[]` or\n * `\"\"` but for effects.\n *\n * @type {() => Task.Effect<never>}\n */\nexport const none = () => NONE\n\n/**\n * Takes iterable of tasks and runs them concurrently, returning array of\n * results in an order of tasks (not the order of completion). If any of the\n * tasks fail all the rest are aborted and error is throw into calling task.\n *\n * > This is basically equivalent of `Promise.all` except cancelation logic\n * because tasks unlike promises can be cancelled.\n *\n * @template T, X\n * @param {Iterable<Task.Task<T, X>>} tasks\n * @returns {Task.Task<T[], X>}\n */\nexport const all = function* (tasks) {\n  const self = yield* current()\n\n  /** @type {(id:number) => (value:T) => void} */\n  const succeed = id => value => {\n    delete forks[id]\n    results[id] = value\n    count -= 1\n    if (count === 0) {\n      enqueue(self)\n    }\n  }\n\n  /** @type {(error:X) => void} */\n  const fail = error => {\n    for (const handle of forks) {\n      if (handle) {\n        enqueue(abort(handle, error))\n      }\n    }\n\n    enqueue(abort(self, error))\n  }\n\n  /** @type {Task.Fork<void, never>[]} */\n  let forks = []\n  let count = 0\n  for (const task of tasks) {\n    forks.push(yield* fork(then(task, succeed(count++), fail)))\n  }\n  const results = new Array(count)\n\n  if (count > 0) {\n    yield* suspend()\n  }\n\n  return results\n}\n\n/**\n * @template {string} Tag\n * @template T\n * @param {Tag} tag\n * @param {Task.Message<T>} value\n */\nconst withTag = (tag, value) =>\n  /** @type {Tagged<Tag, T>} */\n  ({ type: tag, [tag]: value })\n\n/**\n * Kind of like promise.then which is handy when you want to extract result\n * from the given task from the outside.\n *\n * @template T, U, X, M\n * @param {Task.Task<T, X, M>} task\n * @param {(value:T) => U} resolve\n * @param {(error:X) => U} reject\n * @returns {Task.Task<U, never, M>}\n */\nexport function* then(task, resolve, reject) {\n  try {\n    return resolve(yield* task)\n  } catch (error) {\n    return reject(/** @type {X} */ (error))\n  }\n}\n\n// Special control instructions recognized by a scheduler.\nconst CURRENT = Symbol(\"current\")\nconst SUSPEND = Symbol(\"suspend\")\n/** @typedef {typeof SUSPEND|typeof CURRENT} Control */\n\n/**\n * @template M\n * @param {Task.Instruction<M>} value\n * @returns {value is M}\n */\nexport const isMessage = value => {\n  switch (value) {\n    case SUSPEND:\n    case CURRENT:\n      return false\n    default:\n      return true\n  }\n}\n\n/**\n * @template M\n * @param {Task.Instruction<M>} value\n * @returns {value is Control}\n */\nexport const isInstruction = value => !isMessage(value)\n\n/**\n * @template T, X, M\n * @implements {Task.TaskGroup<T, X, M>}\n */\nclass Group {\n  /**\n   * @template T, X, M\n   * @param {Task.Controller<T, X, M>|Task.Fork<T, X, M>} member\n   * @returns {Task.Group<T, X, M>}\n   */\n  static of(member) {\n    return (\n      /** @type {{group?:Task.TaskGroup<T, X, M>}} */ (member).group || MAIN\n    )\n  }\n\n  /**\n   * @template T, X, M\n   * @param {(Task.Controller<T, X, M>|Task.Fork<T, X, M>) & {group?:Task.TaskGroup<T, X, M>}} member\n   * @param {Task.TaskGroup<T, X, M>} group\n   */\n  static enqueue(member, group) {\n    member.group = group\n    group.stack.active.push(member)\n  }\n  /**\n   * @param {Task.Controller<T, X, M>} driver\n   * @param {Task.Controller<T, X, M>[]} [active]\n   * @param {Set<Task.Controller<T, X, M>>} [idle]\n   * @param {Task.Stack<T, X, M>} [stack]\n   */\n  constructor(\n    driver,\n    active = [],\n    idle = new Set(),\n    stack = new Stack(active, idle)\n  ) {\n    this.driver = driver\n    this.parent = Group.of(driver)\n    this.stack = stack\n    this.id = ++ID\n  }\n}\n\n/**\n * @template T, X, M\n * @implements {Task.Main<T, X, M>}\n */\nclass Main {\n  constructor() {\n    this.status = IDLE\n    this.stack = new Stack()\n    this.id = /** @type {0} */ (0)\n  }\n}\n\n/**\n * @template T, X, M\n */\nclass Stack {\n  /**\n   * @param {Task.Controller<T, X, M>[]} [active]\n   * @param {Set<Task.Controller<T, X, M>>} [idle]\n   */\n  constructor(active = [], idle = new Set()) {\n    this.active = active\n    this.idle = idle\n  }\n\n  /**\n   *\n   * @param {Task.Stack<unknown, unknown, unknown>} stack\n   * @returns\n   */\n  static size({ active, idle }) {\n    return active.length + idle.size\n  }\n}\n\n/**\n * Starts a main task.\n *\n * @param {Task.Task<void, never>} task\n */\nexport const main = task => enqueue(task[Symbol.iterator]())\n\n/**\n * @template T, X, M\n * @param {Task.Controller<T, X, M>} task\n */\nconst enqueue = task => {\n  let group = Group.of(task)\n  group.stack.active.push(task)\n  group.stack.idle.delete(task)\n\n  // then walk up the group chain and unblock their driver tasks.\n  while (group.parent) {\n    const { idle, active } = group.parent.stack\n    if (idle.has(group.driver)) {\n      idle.delete(group.driver)\n      active.push(group.driver)\n    } else {\n      // if driver was not blocked it must have been unblocked by\n      // other task so stop there.\n      break\n    }\n\n    group = group.parent\n  }\n\n  if (MAIN.status === IDLE) {\n    MAIN.status = ACTIVE\n    while (true) {\n      try {\n        for (const _message of step(MAIN)) {\n        }\n        MAIN.status = IDLE\n        break\n      } catch (_error) {\n        // Top level task may crash and throw an error, but given this is a main\n        // group we do not want to interupt other unrelated tasks, which is why\n        // we discard the error and the task that caused it.\n        MAIN.stack.active.shift()\n      }\n    }\n  }\n}\n\n/**\n * @template T, X, M\n * @param {Task.Controller<T, X, M>} task\n */\nexport const resume = task => enqueue(task)\n\n/**\n * @template T, X, M\n * @param {Task.Group<T, X, M>} group\n */\n\nconst step = function* (group) {\n  const { active } = group.stack\n  let task = active[0]\n  group.stack.idle.delete(task)\n  while (task) {\n    /** @type {Task.TaskState<T, M>} */\n    let state = INIT\n    // Keep processing insturctions until task is done, it send suspend request\n    // or it's has been removed from the active queue.\n    // ⚠️ Group changes require extra care so please make sure to understand\n    // the detail here. It occurs when spawned task(s) are joined into a group\n    // which will change the task driver, that is when `task === active[0]` will\n    // became false and need to to drop the task immediately otherwise race\n    // condition will occur due to task been  driven by multiple concurrent\n    // schedulers.\n    loop: while (!state.done && task === active[0]) {\n      const instruction = state.value\n      switch (instruction) {\n        // if task is suspended we add it to the idle list and break the loop\n        // to move to a next task.\n        case SUSPEND:\n          group.stack.idle.add(task)\n          break loop\n        // if task requested a context (which is usually to suspend itself)\n        // pass back a task reference and continue.\n        case CURRENT:\n          state = task.next(task)\n          break\n        default:\n          // otherwise task sent a message which we yield to the driver and\n          // continue\n          state = task.next(\n            yield /** @type {M & Task.Message<M>}*/ (instruction)\n          )\n          break\n      }\n    }\n\n    // If task is complete, or got suspended we move to a next task\n    active.shift()\n    task = active[0]\n    group.stack.idle.delete(task)\n  }\n}\n\n/**\n * Executes given task concurrently with a current task (task that spawned it).\n * Spawned task is detached from the task that spawned it and it can outlive it\n * and / or fail without affecting a task that spawned it. If you need to wait\n * on concurrent task completion consider using `fork` instead which can be\n * later `joined`. If you just want a to block on task execution you can just\n * `yield* work()` directly instead.\n *\n * @param {Task.Task<void, never, never>} task\n * @returns {Task.Task<void, never>}\n */\nexport function* spawn(task) {\n  main(task)\n}\n\n/**\n * Executes given task concurrently with current task (the task that initiated\n * fork). Froked task is detached from the task that created it and it can\n * outlive it and / or fail without affecting it. You do however get a handle\n * for the fork which could be used to `join` the task, in which case `joining`\n * task will block until fork finishes execution.\n *\n * This is also a primary interface for executing tasks from the outside of the\n * task context. Function returns `Fork` which implements `Promise` interface\n * so it could be awaited. Please note that calling `fork` does not really do\n * anything, it lazily starts execution when you either `await fork(work())`\n * from arbitray context or `yield* fork(work())` in anothe task context.\n *\n * @template T, X, M\n * @param {Task.Task<T, X, M>} task\n * @param {Task.ForkOptions} [options]\n * @returns {Task.Fork<T, X, M>}\n */\nexport const fork = (task, options) => new Fork(task, options)\n\n/**\n * Exits task succesfully with a given return value.\n *\n * @template T, M, X\n * @param  {Task.Controller<T, M, X>} handle\n * @param {T} value\n * @returns {Task.Task<void, never>}\n */\nexport const exit = (handle, value) => conclude(handle, { ok: true, value })\n\n/**\n * Terminates task execution execution. Only takes task that produces no\n * result, if your task has non `void` return type you should use `exit` instead.\n *\n * @template M, X\n * @param {Task.Controller<void, X, M>} handle\n */\nexport const terminate = handle =>\n  conclude(handle, { ok: true, value: undefined })\n\n/**\n * Aborts given task with an error. Task error type should match provided error.\n *\n * @template T, M, X\n * @param {Task.Controller<T, X, M>} handle\n * @param {X} [error]\n */\nexport const abort = (handle, error) => conclude(handle, { ok: false, error })\n\n/**\n * Aborts given task with an given error.\n *\n * @template T, M, X\n * @param {Task.Controller<T, X, M>} handle\n * @param {Task.Result<T, X>} result\n * @returns {Task.Task<void, never> & Task.Controller<void, never>}\n */\nfunction* conclude(handle, result) {\n  try {\n    const task = handle\n    const state = result.ok\n      ? task.return(result.value)\n      : task.throw(result.error)\n\n    if (!state.done) {\n      if (state.value === SUSPEND) {\n        const { idle } = Group.of(task).stack\n        idle.add(task)\n      } else {\n        enqueue(task)\n      }\n    }\n  } catch (error) {}\n}\n\n/**\n * Groups multiple forks togather and joins joins them with current task.\n *\n * @template T, X, M\n * @param {Task.Fork<T, X, M>[]} forks\n * @returns {Task.Task<void, X, M>}\n */\nexport function* group(forks) {\n  // Abort eraly if there'se no work todo.\n  if (forks.length === 0) return\n\n  const self = yield* current()\n  /** @type {Task.TaskGroup<T, X, M>} */\n  const group = new Group(self)\n  /** @type {Task.Failure<X>|null} */\n  let failure = null\n\n  for (const fork of forks) {\n    const { result } = fork\n    if (result) {\n      if (!result.ok && !failure) {\n        failure = result\n      }\n      continue\n    }\n    move(fork, group)\n  }\n\n  // Keep work looping until there is nom more work to be done\n  try {\n    if (failure) {\n      throw failure.error\n    }\n\n    while (true) {\n      yield* step(group)\n      if (Stack.size(group.stack) > 0) {\n        yield* suspend()\n      } else {\n        break\n      }\n    }\n  } catch (error) {\n    for (const task of group.stack.active) {\n      yield* abort(task, error)\n    }\n\n    for (const task of group.stack.idle) {\n      yield* abort(task, error)\n      enqueue(task)\n    }\n\n    throw error\n  }\n}\n\n/**\n * @template T, X, M\n * @param {Task.Fork<T, X, M>} fork\n * @param {Task.TaskGroup<T, X, M>} group\n */\nconst move = (fork, group) => {\n  const from = Group.of(fork)\n  if (from !== group) {\n    const { active, idle } = from.stack\n    const target = group.stack\n    fork.group = group\n    // If it is idle just move from one group to the other\n    // and update the group task thinks it belongs to.\n    if (idle.has(fork)) {\n      idle.delete(fork)\n      target.idle.add(fork)\n    } else {\n      const index = active.indexOf(fork)\n      // If task is in the job queue, we move it to a target job queue. Moving\n      // top task in the queue requires extra care so it does not end up\n      // processed by two groups which would lead to race. For that reason\n      // `step` loop checks for group changes on each turn.\n      if (index >= 0) {\n        active.splice(index, 1)\n        target.active.push(fork)\n      }\n      // otherwise task is complete\n    }\n  }\n}\n\n/**\n * @template T, X, M\n * @param {Task.Fork<T, X, M>} fork\n * @returns {Task.Task<T, X, M>}\n */\nexport function* join(fork) {\n  // If fork is still idle activate it.\n  if (fork.status === IDLE) {\n    yield* fork\n  }\n\n  if (!fork.result) {\n    yield* group([fork])\n  }\n\n  const result = /** @type {Task.Result<T, X>} */ (fork.result)\n  if (result.ok) {\n    return result.value\n  } else {\n    throw result.error\n  }\n}\n\n/**\n * @template T, X\n * @implements {Task.Future<T, X>}\n */\nclass Future {\n  /**\n   * @param {Task.StateHandler<T, X>} handler\n   */\n  constructor(handler) {\n    this.handler = handler\n    /**\n     * @abstract\n     * @type {Task.Result<T, X>|void}\n     */\n    this.result\n  }\n  /**\n   * @type {Promise<T>}\n   */\n  get promise() {\n    const { result } = this\n    const promise =\n      result == null\n        ? new Promise((succeed, fail) => {\n            this.handler.onsuccess = succeed\n            this.handler.onfailure = fail\n          })\n        : result.ok\n        ? Promise.resolve(result.value)\n        : Promise.reject(result.error)\n    Object.defineProperty(this, \"promise\", { value: promise })\n    return promise\n  }\n\n  /**\n   * @template U, [E=never]\n   * @param {((value:T) => U | PromiseLike<U>)|undefined|null} [onresolve]\n   * @param {((error:X) => E|PromiseLike<E>)|undefined|null} [onreject]\n   * @returns {Promise<U|E>}\n   */\n  then(onresolve, onreject) {\n    return this.activate().promise.then(onresolve, onreject)\n  }\n  /**\n   * @template [U=never]\n   * @param {(error:X) => U} onreject\n   */\n  catch(onreject) {\n    return /** @type {Task.Future<T|U, never>} */ (\n      this.activate().promise.catch(onreject)\n    )\n  }\n  /**\n   * @param {() => void} onfinally\n   * @returns {Task.Future<T, X>}\n   */\n  finally(onfinally) {\n    return /** @type {Task.Future<T, X>} */ (\n      this.activate().promise.finally(onfinally)\n    )\n  }\n  /**\n   * @abstract\n   */\n  /* c8 ignore next 3 */\n  activate() {\n    return this\n  }\n}\n\n/**\n * @template T, X, M\n * @implements {Task.Fork<T, X, M>}\n * @implements {Task.Controller<T, X, M>}\n * @implements {Task.Task<Task.Fork<T, X, M>, never>}\n * @implements {Task.Future<T, X>}\n * @extends {Future<T, X>}\n */\nclass Fork extends Future {\n  /**\n   * @param {Task.Task<T, X, M>} task\n   * @param {Task.ForkOptions} [options]\n   * @param {Task.StateHandler<T, X>} [handler]\n   * @param {Task.TaskState<T, M>} [state]\n   */\n  constructor(task, options = BLANK, handler = {}, state = INIT) {\n    super(handler)\n    this.id = ++ID\n    this.name = options.name || \"\"\n    /** @type {Task.Task<T, X, M>} */\n    this.task = task\n    this.state = state\n    this.status = IDLE\n    /** @type {Task.Result<T, X>} */\n    this.result\n    this.handler = handler\n\n    /** @type {Task.Controller<T, X, M>} */\n    this.controller\n  }\n\n  *resume() {\n    resume(this)\n  }\n\n  /**\n   * @returns {Task.Task<T, X, M>}\n   */\n  join() {\n    return join(this)\n  }\n\n  /**\n   * @param {X} error\n   */\n  abort(error) {\n    return abort(this, error)\n  }\n  /**\n   * @param {T} value\n   */\n  exit(value) {\n    return exit(this, value)\n  }\n  get [Symbol.toStringTag]() {\n    return \"Fork\"\n  }\n\n  /**\n   * @returns {Task.Controller<Task.Fork<T, X, M>, never, never>}\n   */\n  *[Symbol.iterator]() {\n    return this.activate()\n  }\n\n  activate() {\n    this.controller = this.task[Symbol.iterator]()\n    this.status = ACTIVE\n    enqueue(this)\n    return this\n  }\n\n  /**\n   * @private\n   * @param {any} error\n   * @returns {never}\n   */\n  panic(error) {\n    this.result = { ok: false, error }\n    this.status = FINISHED\n    const { handler } = this\n    if (handler.onfailure) {\n      handler.onfailure(error)\n    }\n\n    throw error\n  }\n\n  /**\n   * @private\n   * @param {Task.TaskState<T, M>} state\n   */\n  step(state) {\n    this.state = state\n    if (state.done) {\n      this.result = { ok: true, value: state.value }\n      this.status = FINISHED\n      const { handler } = this\n      if (handler.onsuccess) {\n        handler.onsuccess(state.value)\n      }\n    }\n\n    return state\n  }\n\n  /**\n   * @param {unknown} value\n   */\n  next(value) {\n    try {\n      return this.step(this.controller.next(value))\n    } catch (error) {\n      return this.panic(error)\n    }\n  }\n  /**\n   * @param {T} value\n   */\n  return(value) {\n    try {\n      return this.step(this.controller.return(value))\n    } catch (error) {\n      return this.panic(error)\n    }\n  }\n  /**\n   * @param {X} error\n   */\n  throw(error) {\n    try {\n      return this.step(this.controller.throw(error))\n    } catch (error) {\n      return this.panic(error)\n    }\n  }\n}\n\n/**\n * @template M\n * @param {Task.Effect<M>} init\n * @param {(message:M) => Task.Effect<M>} next\n * @returns {Task.Task<void, never, never>}\n */\nexport const loop = function* (init, next) {\n  /** @type {Task.Controller<void, never, M>} */\n  const controller = yield* current()\n  const group = new Group(controller)\n  Group.enqueue(init[Symbol.iterator](), group)\n\n  while (true) {\n    for (const message of step(group)) {\n      Group.enqueue(next(message)[Symbol.iterator](), group)\n    }\n\n    if (Stack.size(group.stack) > 0) {\n      yield* suspend()\n    } else {\n      break\n    }\n  }\n}\n\nlet ID = 0\n/** @type {Task.Status} */\nconst IDLE = \"idle\"\nconst ACTIVE = \"active\"\nconst FINISHED = \"finished\"\n/** @type {Task.TaskState<any, any>} */\nconst INIT = { done: false, value: CURRENT }\n\nconst BLANK = {}\n\n/** @type {Task.Effect<never>} */\nconst NONE = (function* none() {})()\n\n/** @type {Task.Main<any, any, any>} */\nconst MAIN = new Main()\n"],"mappings":"AAAA,OAAO,KAAKA,IAAI,MAAM,WAAW;AACjC,cAAc,WAAW;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,MAAM,GAAG,UAAAA,CAAWC,IAAI,EAAE;EACrC,MAAMC,OAAO,GAAG,OAAOD,IAAI;EAC3B,OAAOE,IAAI,CAACD,OAAO,CAAC;AACtB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,UAAUE,OAAOA,CAAA,EAAG;EACzB,OAAO,uCAAyC,MAAMC,OAAO;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,OAAO,GAAG,UAAAA,CAAA,EAAa;EAClC,MAAMC,OAAO;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,UAAUC,KAAKA,CAACC,QAAQ,GAAG,CAAC,EAAE;EACnC,MAAMR,IAAI,GAAG,OAAOG,OAAO,CAAC,CAAC;EAC7B,MAAMM,EAAE,GAAGC,UAAU,CAACC,OAAO,EAAEH,QAAQ,EAAER,IAAI,CAAC;EAE9C,IAAI;IACF,OAAOK,OAAO,CAAC,CAAC;EAClB,CAAC,SAAS;IACRO,YAAY,CAACH,EAAE,CAAC;EAClB;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMI,IAAI,GAAG,UAAAA,CAAWC,KAAK,EAAE;EACpC,MAAMd,IAAI,GAAG,OAAOG,OAAO,CAAC,CAAC;EAC7B,IAAIY,OAAO,CAACD,KAAK,CAAC,EAAE;IAClB,IAAIE,MAAM,GAAG,KAAK;IA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}