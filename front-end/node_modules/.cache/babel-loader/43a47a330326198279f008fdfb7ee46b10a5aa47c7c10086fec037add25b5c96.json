{"ast":null,"code":"\"use strict\";\n\n/**\n * This file includes Solidity tracing heuristics for solc starting with version\n * 0.6.9.\n *\n * This solc version introduced a significant change to how sourcemaps are\n * handled for inline yul/internal functions. These were mapped to the\n * unmapped/-1 file before, which lead to many unmapped reverts. Now, they are\n * mapped to the part of the Solidity source that lead to their inlining.\n *\n * This change is a very positive change, as errors would point to the correct\n * line by default. The only problem is that we used to rely very heavily on\n * unmapped reverts to decide when our error detection heuristics were to be\n * run. In fact, this heuristics were first introduced because of unmapped\n * reverts.\n *\n * Instead of synthetically completing stack traces when unmapped reverts occur,\n * we now start from complete stack traces and adjust them if we can provide\n * more meaningful errors.\n */\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.adjustStackTrace = exports.stackTraceMayRequireAdjustments = void 0;\nconst semver_1 = __importDefault(require(\"semver\"));\nconst message_trace_1 = require(\"./message-trace\");\nconst opcodes_1 = require(\"./opcodes\");\nconst solidity_stack_trace_1 = require(\"./solidity-stack-trace\");\nconst FIRST_SOLC_VERSION_WITH_MAPPED_SMALL_INTERNAL_FUNCTIONS = \"0.6.9\";\nfunction stackTraceMayRequireAdjustments(stackTrace, decodedTrace) {\n  if (stackTrace.length === 0) {\n    return false;\n  }\n  const lastFrame = stackTrace[stackTrace.length - 1];\n  return lastFrame.type === solidity_stack_trace_1.StackTraceEntryType.REVERT_ERROR && !lastFrame.isInvalidOpcodeError && lastFrame.message.isEmpty() && semver_1.default.gte(decodedTrace.bytecode.compilerVersion, FIRST_SOLC_VERSION_WITH_MAPPED_SMALL_INTERNAL_FUNCTIONS);\n}\nexports.stackTraceMayRequireAdjustments = stackTraceMayRequireAdjustments;\nfunction adjustStackTrace(stackTrace, decodedTrace) {\n  const start = stackTrace.slice(0, -1);\n  const [revert] = stackTrace.slice(-1);\n  if (isNonContractAccountCalledError(decodedTrace)) {\n    return [...start, {\n      type: solidity_stack_trace_1.StackTraceEntryType.NONCONTRACT_ACCOUNT_CALLED_ERROR,\n      sourceReference: revert.sourceReference\n    }];\n  }\n  if (isConstructorInvalidParamsError(decodedTrace)) {\n    return [...start, {\n      type: solidity_stack_trace_1.StackTraceEntryType.INVALID_PARAMS_ERROR,\n      sourceReference: revert.sourceReference\n    }];\n  }\n  if (isCallInvalidParamsError(decodedTrace)) {\n    return [...start, {\n      type: solidity_stack_trace_1.StackTraceEntryType.INVALID_PARAMS_ERROR,\n      sourceReference: revert.sourceReference\n    }];\n  }\n  return stackTrace;\n}\nexports.adjustStackTrace = adjustStackTrace;\nfunction isNonContractAccountCalledError(decodedTrace) {\n  return matchOpcodes(decodedTrace, -9, [opcodes_1.Opcode.EXTCODESIZE, opcodes_1.Opcode.ISZERO, opcodes_1.Opcode.DUP1, opcodes_1.Opcode.ISZERO]);\n}\nfunction isConstructorInvalidParamsError(decodedTrace) {\n  if (!(0, message_trace_1.isDecodedCreateTrace)(decodedTrace)) {\n    return false;\n  }\n  return matchOpcodes(decodedTrace, -20, [opcodes_1.Opcode.CODESIZE]) && matchOpcodes(decodedTrace, -15, [opcodes_1.Opcode.CODECOPY]) && matchOpcodes(decodedTrace, -7, [opcodes_1.Opcode.LT, opcodes_1.Opcode.ISZERO]);\n}\nfunction isCallInvalidParamsError(decodedTrace) {\n  if (!(0, message_trace_1.isDecodedCallTrace)(decodedTrace)) {\n    return false;\n  }\n  return matchOpcodes(decodedTrace, -11, [opcodes_1.Opcode.CALLDATASIZE]) && matchOpcodes(decodedTrace, -7, [opcodes_1.Opcode.LT, opcodes_1.Opcode.ISZERO]);\n}\nfunction matchOpcode(decodedTrace, stepIndex, opcode) {\n  const [step] = decodedTrace.steps.slice(stepIndex, stepIndex + 1);\n  if (step === undefined || !(0, message_trace_1.isEvmStep)(step)) {\n    return false;\n  }\n  const instruction = decodedTrace.bytecode.getInstruction(step.pc);\n  return instruction.opcode === opcode;\n}\nfunction matchOpcodes(decodedTrace, firstStepIndex, opcodes) {\n  let index = firstStepIndex;\n  for (const opcode of opcodes) {\n    if (!matchOpcode(decodedTrace, index, opcode)) {\n      return false;\n    }\n    index += 1;\n  }\n  return true;\n}","map":{"version":3,"names":["semver_1","__importDefault","require","message_trace_1","opcodes_1","solidity_stack_trace_1","FIRST_SOLC_VERSION_WITH_MAPPED_SMALL_INTERNAL_FUNCTIONS","stackTraceMayRequireAdjustments","stackTrace","decodedTrace","length","lastFrame","type","StackTraceEntryType","REVERT_ERROR","isInvalidOpcodeError","message","isEmpty","default","gte","bytecode","compilerVersion","exports","adjustStackTrace","start","slice","revert","isNonContractAccountCalledError","NONCONTRACT_ACCOUNT_CALLED_ERROR","sourceReference","isConstructorInvalidParamsError","INVALID_PARAMS_ERROR","isCallInvalidParamsError","matchOpcodes","Opcode","EXTCODESIZE","ISZERO","DUP1","isDecodedCreateTrace","CODESIZE","CODECOPY","LT","isDecodedCallTrace","CALLDATASIZE","matchOpcode","stepIndex","opcode","step","steps","undefined","isEvmStep","instruction","getInstruction","pc","firstStepIndex","opcodes","index"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\internal\\hardhat-network\\stack-traces\\mapped-inlined-internal-functions-heuristics.ts"],"sourcesContent":["/**\n * This file includes Solidity tracing heuristics for solc starting with version\n * 0.6.9.\n *\n * This solc version introduced a significant change to how sourcemaps are\n * handled for inline yul/internal functions. These were mapped to the\n * unmapped/-1 file before, which lead to many unmapped reverts. Now, they are\n * mapped to the part of the Solidity source that lead to their inlining.\n *\n * This change is a very positive change, as errors would point to the correct\n * line by default. The only problem is that we used to rely very heavily on\n * unmapped reverts to decide when our error detection heuristics were to be\n * run. In fact, this heuristics were first introduced because of unmapped\n * reverts.\n *\n * Instead of synthetically completing stack traces when unmapped reverts occur,\n * we now start from complete stack traces and adjust them if we can provide\n * more meaningful errors.\n */\n\nimport semver from \"semver\";\n\nimport {\n  DecodedEvmMessageTrace,\n  isDecodedCallTrace,\n  isDecodedCreateTrace,\n  isEvmStep,\n} from \"./message-trace\";\nimport { Opcode } from \"./opcodes\";\nimport {\n  SolidityStackTrace,\n  StackTraceEntryType,\n} from \"./solidity-stack-trace\";\n\nconst FIRST_SOLC_VERSION_WITH_MAPPED_SMALL_INTERNAL_FUNCTIONS = \"0.6.9\";\n\nexport function stackTraceMayRequireAdjustments(\n  stackTrace: SolidityStackTrace,\n  decodedTrace: DecodedEvmMessageTrace\n): boolean {\n  if (stackTrace.length === 0) {\n    return false;\n  }\n\n  const lastFrame = stackTrace[stackTrace.length - 1];\n\n  return (\n    lastFrame.type === StackTraceEntryType.REVERT_ERROR &&\n    !lastFrame.isInvalidOpcodeError &&\n    lastFrame.message.isEmpty() &&\n    semver.gte(\n      decodedTrace.bytecode.compilerVersion,\n      FIRST_SOLC_VERSION_WITH_MAPPED_SMALL_INTERNAL_FUNCTIONS\n    )\n  );\n}\n\nexport function adjustStackTrace(\n  stackTrace: SolidityStackTrace,\n  decodedTrace: DecodedEvmMessageTrace\n): SolidityStackTrace {\n  const start = stackTrace.slice(0, -1);\n  const [revert] = stackTrace.slice(-1);\n\n  if (isNonContractAccountCalledError(decodedTrace)) {\n    return [\n      ...start,\n      {\n        type: StackTraceEntryType.NONCONTRACT_ACCOUNT_CALLED_ERROR,\n        sourceReference: revert.sourceReference!,\n      },\n    ];\n  }\n\n  if (isConstructorInvalidParamsError(decodedTrace)) {\n    return [\n      ...start,\n      {\n        type: StackTraceEntryType.INVALID_PARAMS_ERROR,\n        sourceReference: revert.sourceReference!,\n      },\n    ];\n  }\n\n  if (isCallInvalidParamsError(decodedTrace)) {\n    return [\n      ...start,\n      {\n        type: StackTraceEntryType.INVALID_PARAMS_ERROR,\n        sourceReference: revert.sourceReference!,\n      },\n    ];\n  }\n\n  return stackTrace;\n}\n\nfunction isNonContractAccountCalledError(\n  decodedTrace: DecodedEvmMessageTrace\n): boolean {\n  return matchOpcodes(decodedTrace, -9, [\n    Opcode.EXTCODESIZE,\n    Opcode.ISZERO,\n    Opcode.DUP1,\n    Opcode.ISZERO,\n  ]);\n}\n\nfunction isConstructorInvalidParamsError(decodedTrace: DecodedEvmMessageTrace) {\n  if (!isDecodedCreateTrace(decodedTrace)) {\n    return false;\n  }\n\n  return (\n    matchOpcodes(decodedTrace, -20, [Opcode.CODESIZE]) &&\n    matchOpcodes(decodedTrace, -15, [Opcode.CODECOPY]) &&\n    matchOpcodes(decodedTrace, -7, [Opcode.LT, Opcode.ISZERO])\n  );\n}\n\nfunction isCallInvalidParamsError(decodedTrace: DecodedEvmMessageTrace) {\n  if (!isDecodedCallTrace(decodedTrace)) {\n    return false;\n  }\n\n  return (\n    matchOpcodes(decodedTrace, -11, [Opcode.CALLDATASIZE]) &&\n    matchOpcodes(decodedTrace, -7, [Opcode.LT, Opcode.ISZERO])\n  );\n}\n\nfunction matchOpcode(\n  decodedTrace: DecodedEvmMessageTrace,\n  stepIndex: number,\n  opcode: Opcode\n): boolean {\n  const [step] = decodedTrace.steps.slice(stepIndex, stepIndex + 1);\n\n  if (step === undefined || !isEvmStep(step)) {\n    return false;\n  }\n\n  const instruction = decodedTrace.bytecode.getInstruction(step.pc);\n\n  return instruction.opcode === opcode;\n}\n\nfunction matchOpcodes(\n  decodedTrace: DecodedEvmMessageTrace,\n  firstStepIndex: number,\n  opcodes: Opcode[]\n): boolean {\n  let index = firstStepIndex;\n  for (const opcode of opcodes) {\n    if (!matchOpcode(decodedTrace, index, opcode)) {\n      return false;\n    }\n\n    index += 1;\n  }\n\n  return true;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}