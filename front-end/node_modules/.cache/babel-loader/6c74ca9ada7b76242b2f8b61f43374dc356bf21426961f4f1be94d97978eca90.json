{"ast":null,"code":"'use strict';\n\nconst {\n  InvalidArgumentError\n} = require('./core/errors');\nconst {\n  kClients,\n  kRunning,\n  kClose,\n  kDestroy,\n  kDispatch,\n  kInterceptors\n} = require('./core/symbols');\nconst DispatcherBase = require('./dispatcher-base');\nconst Pool = require('./pool');\nconst Client = require('./client');\nconst util = require('./core/util');\nconst createRedirectInterceptor = require('./interceptor/redirectInterceptor');\nconst {\n  WeakRef,\n  FinalizationRegistry\n} = require('./compat/dispatcher-weakref')();\nconst kOnConnect = Symbol('onConnect');\nconst kOnDisconnect = Symbol('onDisconnect');\nconst kOnConnectionError = Symbol('onConnectionError');\nconst kMaxRedirections = Symbol('maxRedirections');\nconst kOnDrain = Symbol('onDrain');\nconst kFactory = Symbol('factory');\nconst kFinalizer = Symbol('finalizer');\nconst kOptions = Symbol('options');\nfunction defaultFactory(origin, opts) {\n  return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);\n}\nclass Agent extends DispatcherBase {\n  constructor({\n    factory = defaultFactory,\n    maxRedirections = 0,\n    connect,\n    ...options\n  } = {}) {\n    super();\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.');\n    }\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object');\n    }\n    if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number');\n    }\n    if (connect && typeof connect !== 'function') {\n      connect = {\n        ...connect\n      };\n    }\n    this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor({\n      maxRedirections\n    })];\n    this[kOptions] = {\n      ...util.deepClone(options),\n      connect\n    };\n    this[kOptions].interceptors = options.interceptors ? {\n      ...options.interceptors\n    } : undefined;\n    this[kMaxRedirections] = maxRedirections;\n    this[kFactory] = factory;\n    this[kClients] = new Map();\n    this[kFinalizer] = new FinalizationRegistry( /* istanbul ignore next: gc is undeterministic */key => {\n      const ref = this[kClients].get(key);\n      if (ref !== undefined && ref.deref() === undefined) {\n        this[kClients].delete(key);\n      }\n    });\n    const agent = this;\n    this[kOnDrain] = (origin, targets) => {\n      agent.emit('drain', origin, [agent, ...targets]);\n    };\n    this[kOnConnect] = (origin, targets) => {\n      agent.emit('connect', origin, [agent, ...targets]);\n    };\n    this[kOnDisconnect] = (origin, targets, err) => {\n      agent.emit('disconnect', origin, [agent, ...targets], err);\n    };\n    this[kOnConnectionError] = (origin, targets, err) => {\n      agent.emit('connectionError', origin, [agent, ...targets], err);\n    };\n  }\n  get [kRunning]() {\n    let ret = 0;\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref();\n      /* istanbul ignore next: gc is undeterministic */\n      if (client) {\n        ret += client[kRunning];\n      }\n    }\n    return ret;\n  }\n  [kDispatch](opts, handler) {\n    let key;\n    if (opts.origin && (typeof opts.origin === 'string' || opts.origin instanceof URL)) {\n      key = String(opts.origin);\n    } else {\n      throw new InvalidArgumentError('opts.origin must be a non-empty string or URL.');\n    }\n    const ref = this[kClients].get(key);\n    let dispatcher = ref ? ref.deref() : null;\n    if (!dispatcher) {\n      dispatcher = this[kFactory](opts.origin, this[kOptions]).on('drain', this[kOnDrain]).on('connect', this[kOnConnect]).on('disconnect', this[kOnDisconnect]).on('connectionError', this[kOnConnectionError]);\n      this[kClients].set(key, new WeakRef(dispatcher));\n      this[kFinalizer].register(dispatcher, key);\n    }\n    return dispatcher.dispatch(opts, handler);\n  }\n  async [kClose]() {\n    const closePromises = [];\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref();\n      /* istanbul ignore else: gc is undeterministic */\n      if (client) {\n        closePromises.push(client.close());\n      }\n    }\n    await Promise.all(closePromises);\n  }\n  async [kDestroy](err) {\n    const destroyPromises = [];\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref();\n      /* istanbul ignore else: gc is undeterministic */\n      if (client) {\n        destroyPromises.push(client.destroy(err));\n      }\n    }\n    await Promise.all(destroyPromises);\n  }\n}\nmodule.exports = Agent;","map":{"version":3,"names":["InvalidArgumentError","require","kClients","kRunning","kClose","kDestroy","kDispatch","kInterceptors","DispatcherBase","Pool","Client","util","createRedirectInterceptor","WeakRef","FinalizationRegistry","kOnConnect","Symbol","kOnDisconnect","kOnConnectionError","kMaxRedirections","kOnDrain","kFactory","kFinalizer","kOptions","defaultFactory","origin","opts","connections","Agent","constructor","factory","maxRedirections","connect","options","Number","isInteger","interceptors","Array","isArray","deepClone","undefined","Map","key","ref","get","deref","delete","agent","targets","emit","err","ret","values","client","handler","URL","String","dispatcher","on","set","register","dispatch","closePromises","push","close","Promise","all","destroyPromises","destroy","module","exports"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/undici/lib/agent.js"],"sourcesContent":["'use strict'\n\nconst { InvalidArgumentError } = require('./core/errors')\nconst { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = require('./core/symbols')\nconst DispatcherBase = require('./dispatcher-base')\nconst Pool = require('./pool')\nconst Client = require('./client')\nconst util = require('./core/util')\nconst createRedirectInterceptor = require('./interceptor/redirectInterceptor')\nconst { WeakRef, FinalizationRegistry } = require('./compat/dispatcher-weakref')()\n\nconst kOnConnect = Symbol('onConnect')\nconst kOnDisconnect = Symbol('onDisconnect')\nconst kOnConnectionError = Symbol('onConnectionError')\nconst kMaxRedirections = Symbol('maxRedirections')\nconst kOnDrain = Symbol('onDrain')\nconst kFactory = Symbol('factory')\nconst kFinalizer = Symbol('finalizer')\nconst kOptions = Symbol('options')\n\nfunction defaultFactory (origin, opts) {\n  return opts && opts.connections === 1\n    ? new Client(origin, opts)\n    : new Pool(origin, opts)\n}\n\nclass Agent extends DispatcherBase {\n  constructor ({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {\n    super()\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    if (connect && typeof connect !== 'function') {\n      connect = { ...connect }\n    }\n\n    this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent)\n      ? options.interceptors.Agent\n      : [createRedirectInterceptor({ maxRedirections })]\n\n    this[kOptions] = { ...util.deepClone(options), connect }\n    this[kOptions].interceptors = options.interceptors\n      ? { ...options.interceptors }\n      : undefined\n    this[kMaxRedirections] = maxRedirections\n    this[kFactory] = factory\n    this[kClients] = new Map()\n    this[kFinalizer] = new FinalizationRegistry(/* istanbul ignore next: gc is undeterministic */ key => {\n      const ref = this[kClients].get(key)\n      if (ref !== undefined && ref.deref() === undefined) {\n        this[kClients].delete(key)\n      }\n    })\n\n    const agent = this\n\n    this[kOnDrain] = (origin, targets) => {\n      agent.emit('drain', origin, [agent, ...targets])\n    }\n\n    this[kOnConnect] = (origin, targets) => {\n      agent.emit('connect', origin, [agent, ...targets])\n    }\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      agent.emit('disconnect', origin, [agent, ...targets], err)\n    }\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      agent.emit('connectionError', origin, [agent, ...targets], err)\n    }\n  }\n\n  get [kRunning] () {\n    let ret = 0\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref()\n      /* istanbul ignore next: gc is undeterministic */\n      if (client) {\n        ret += client[kRunning]\n      }\n    }\n    return ret\n  }\n\n  [kDispatch] (opts, handler) {\n    let key\n    if (opts.origin && (typeof opts.origin === 'string' || opts.origin instanceof URL)) {\n      key = String(opts.origin)\n    } else {\n      throw new InvalidArgumentError('opts.origin must be a non-empty string or URL.')\n    }\n\n    const ref = this[kClients].get(key)\n\n    let dispatcher = ref ? ref.deref() : null\n    if (!dispatcher) {\n      dispatcher = this[kFactory](opts.origin, this[kOptions])\n        .on('drain', this[kOnDrain])\n        .on('connect', this[kOnConnect])\n        .on('disconnect', this[kOnDisconnect])\n        .on('connectionError', this[kOnConnectionError])\n\n      this[kClients].set(key, new WeakRef(dispatcher))\n      this[kFinalizer].register(dispatcher, key)\n    }\n\n    return dispatcher.dispatch(opts, handler)\n  }\n\n  async [kClose] () {\n    const closePromises = []\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref()\n      /* istanbul ignore else: gc is undeterministic */\n      if (client) {\n        closePromises.push(client.close())\n      }\n    }\n\n    await Promise.all(closePromises)\n  }\n\n  async [kDestroy] (err) {\n    const destroyPromises = []\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref()\n      /* istanbul ignore else: gc is undeterministic */\n      if (client) {\n        destroyPromises.push(client.destroy(err))\n      }\n    }\n\n    await Promise.all(destroyPromises)\n  }\n}\n\nmodule.exports = Agent\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}