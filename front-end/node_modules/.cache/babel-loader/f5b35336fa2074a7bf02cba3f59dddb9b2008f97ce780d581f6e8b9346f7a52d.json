{"ast":null,"code":"import * as CBOR from '@ipld/dag-cbor';\nimport { Token, Type } from 'cborg';\nimport { tokensToLength } from 'cborg/length';\nimport varint from 'varint';\n\n/**\n * @typedef {import('./api').CID} CID\n * @typedef {import('./api').Block} Block\n * @typedef {import('./api').CarBufferWriter} Writer\n * @typedef {import('./api').CarBufferWriterOptions} Options\n * @typedef {import('./coding').CarEncoder} CarEncoder\n */\n\n/**\n * A simple CAR writer that writes to a pre-allocated buffer.\n *\n * @class\n * @name CarBufferWriter\n * @implements {Writer}\n */\nclass CarBufferWriter {\n  /**\n   * @param {Uint8Array} bytes\n   * @param {number} headerSize\n   */\n  constructor(bytes, headerSize) {\n    /** @readonly */\n    this.bytes = bytes;\n    this.byteOffset = headerSize;\n\n    /**\n     * @readonly\n     * @type {CID[]}\n     */\n    this.roots = [];\n    this.headerSize = headerSize;\n  }\n\n  /**\n   * Add a root to this writer, to be used to create a header when the CAR is\n   * finalized with {@link CarBufferWriter.close `close()`}\n   *\n   * @param {CID} root\n   * @param {{resize?:boolean}} [options]\n   * @returns {CarBufferWriter}\n   */\n  addRoot(root, options) {\n    addRoot(this, root, options);\n    return this;\n  }\n\n  /**\n   * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.\n   * Throws if there is not enough capacity.\n   *\n   * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.\n   * @returns {CarBufferWriter}\n   */\n  write(block) {\n    addBlock(this, block);\n    return this;\n  }\n\n  /**\n   * Finalize the CAR and return it as a `Uint8Array`.\n   *\n   * @param {object} [options]\n   * @param {boolean} [options.resize]\n   * @returns {Uint8Array}\n   */\n  close(options) {\n    return close(this, options);\n  }\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {CID} root\n * @param {{resize?:boolean}} [options]\n */\nexport const addRoot = (writer, root, options = {}) => {\n  const {\n    resize = false\n  } = options;\n  const {\n    bytes,\n    headerSize,\n    byteOffset,\n    roots\n  } = writer;\n  writer.roots.push(root);\n  const size = headerLength(writer);\n  // If there is not enough space for the new root\n  if (size > headerSize) {\n    // Check if we root would fit if we were to resize the head.\n    if (size - headerSize + byteOffset < bytes.byteLength) {\n      // If resize is enabled resize head\n      if (resize) {\n        resizeHeader(writer, size);\n        // otherwise remove head and throw an error suggesting to resize\n      } else {\n        roots.pop();\n        throw new RangeError(`Header of size ${headerSize} has no capacity for new root ${root}.\n  However there is a space in the buffer and you could call addRoot(root, { resize: root }) to resize header to make a space for this root.`);\n      }\n      // If head would not fit even with resize pop new root and throw error\n    } else {\n      roots.pop();\n      throw new RangeError(`Buffer has no capacity for a new root ${root}`);\n    }\n  }\n};\n\n/**\n * Calculates number of bytes required for storing given block in CAR. Useful in\n * estimating size of an `ArrayBuffer` for the `CarBufferWriter`.\n *\n * @name CarBufferWriter.blockLength(Block)\n * @param {Block} block\n * @returns {number}\n */\nexport const blockLength = ({\n  cid,\n  bytes\n}) => {\n  const size = cid.bytes.byteLength + bytes.byteLength;\n  return varint.encodingLength(size) + size;\n};\n\n/**\n * @param {CarBufferWriter} writer\n * @param {Block} block\n */\nexport const addBlock = (writer, {\n  cid,\n  bytes\n}) => {\n  const byteLength = cid.bytes.byteLength + bytes.byteLength;\n  const size = varint.encode(byteLength);\n  if (writer.byteOffset + size.length + byteLength > writer.bytes.byteLength) {\n    throw new RangeError('Buffer has no capacity for this block');\n  } else {\n    writeBytes(writer, size);\n    writeBytes(writer, cid.bytes);\n    writeBytes(writer, bytes);\n  }\n};\n\n/**\n * @param {CarBufferWriter} writer\n * @param {object} [options]\n * @param {boolean} [options.resize]\n */\nexport const close = (writer, options = {}) => {\n  const {\n    resize = false\n  } = options;\n  const {\n    roots,\n    bytes,\n    byteOffset,\n    headerSize\n  } = writer;\n  const headerBytes = CBOR.encode({\n    version: 1,\n    roots\n  });\n  const varintBytes = varint.encode(headerBytes.length);\n  const size = varintBytes.length + headerBytes.byteLength;\n  const offset = headerSize - size;\n\n  // If header size estimate was accurate we just write header and return\n  // view into buffer.\n  if (offset === 0) {\n    writeHeader(writer, varintBytes, headerBytes);\n    return bytes.subarray(0, byteOffset);\n    // If header was overestimated and `{resize: true}` is passed resize header\n  } else if (resize) {\n    resizeHeader(writer, size);\n    writeHeader(writer, varintBytes, headerBytes);\n    return bytes.subarray(0, writer.byteOffset);\n  } else {\n    throw new RangeError(`Header size was overestimated.\nYou can use close({ resize: true }) to resize header`);\n  }\n};\n\n/**\n * @param {CarBufferWriter} writer\n * @param {number} byteLength\n */\nexport const resizeHeader = (writer, byteLength) => {\n  const {\n    bytes,\n    headerSize\n  } = writer;\n  // Move data section to a new offset\n  bytes.set(bytes.subarray(headerSize, writer.byteOffset), byteLength);\n  // Update header size & byteOffset\n  writer.byteOffset += byteLength - headerSize;\n  writer.headerSize = byteLength;\n};\n\n/**\n * @param {CarBufferWriter} writer\n * @param {number[]|Uint8Array} bytes\n */\n\nconst writeBytes = (writer, bytes) => {\n  writer.bytes.set(bytes, writer.byteOffset);\n  writer.byteOffset += bytes.length;\n};\n/**\n * @param {{bytes:Uint8Array}} writer\n * @param {number[]} varint\n * @param {Uint8Array} header\n */\nconst writeHeader = ({\n  bytes\n}, varint, header) => {\n  bytes.set(varint);\n  bytes.set(header, varint.length);\n};\nconst headerPreludeTokens = [new Token(Type.map, 2), new Token(Type.string, 'version'), new Token(Type.uint, 1), new Token(Type.string, 'roots')];\nconst CID_TAG = new Token(Type.tag, 42);\n\n/**\n * Calculates header size given the array of byteLength for roots.\n *\n * @name CarBufferWriter.calculateHeaderLength(rootLengths)\n * @param {number[]} rootLengths\n * @returns {number}\n */\nexport const calculateHeaderLength = rootLengths => {\n  const tokens = [...headerPreludeTokens];\n  tokens.push(new Token(Type.array, rootLengths.length));\n  for (const rootLength of rootLengths) {\n    tokens.push(CID_TAG);\n    tokens.push(new Token(Type.bytes, {\n      length: rootLength + 1\n    }));\n  }\n  const length = tokensToLength(tokens); // no options needed here because we have simple tokens\n  return varint.encodingLength(length) + length;\n};\n\n/**\n * Calculates header size given the array of roots.\n *\n * @name CarBufferWriter.headerLength({ roots })\n * @param {object} options\n * @param {CID[]} options.roots\n * @returns {number}\n */\nexport const headerLength = ({\n  roots\n}) => calculateHeaderLength(roots.map(cid => cid.bytes.byteLength));\n\n/**\n * Estimates header size given a count of the roots and the expected byte length\n * of the root CIDs. The default length works for a standard CIDv1 with a\n * single-byte multihash code, such as SHA2-256 (i.e. the most common CIDv1).\n *\n * @name CarBufferWriter.estimateHeaderLength(rootCount[, rootByteLength])\n * @param {number} rootCount\n * @param {number} [rootByteLength]\n * @returns {number}\n */\nexport const estimateHeaderLength = (rootCount, rootByteLength = 36) => calculateHeaderLength(new Array(rootCount).fill(rootByteLength));\n\n/**\n * Creates synchronous CAR writer that can be used to encode blocks into a given\n * buffer. Optionally you could pass `byteOffset` and `byteLength` to specify a\n * range inside buffer to write into. If car file is going to have `roots` you\n * need to either pass them under `options.roots` (from which header size will\n * be calculated) or provide `options.headerSize` to allocate required space\n * in the buffer. You may also provide known `roots` and `headerSize` to\n * allocate space for the roots that may not be known ahead of time.\n *\n * Note: Incorrect `headerSize` may lead to copying bytes inside a buffer\n * which will have a negative impact on performance.\n *\n * @name CarBufferWriter.createWriter(buffer[, options])\n * @param {ArrayBuffer} buffer\n * @param {object} [options]\n * @param {CID[]} [options.roots]\n * @param {number} [options.byteOffset]\n * @param {number} [options.byteLength]\n * @param {number} [options.headerSize]\n * @returns {CarBufferWriter}\n */\nexport const createWriter = (buffer, options = {}) => {\n  const {\n    roots = [],\n    byteOffset = 0,\n    byteLength = buffer.byteLength,\n    headerSize = headerLength({\n      roots\n    })\n  } = options;\n  const bytes = new Uint8Array(buffer, byteOffset, byteLength);\n  const writer = new CarBufferWriter(bytes, headerSize);\n  for (const root of roots) {\n    writer.addRoot(root);\n  }\n  return writer;\n};","map":{"version":3,"names":["CBOR","Token","Type","tokensToLength","varint","CarBufferWriter","constructor","bytes","headerSize","byteOffset","roots","addRoot","root","options","write","block","addBlock","close","writer","resize","push","size","headerLength","byteLength","resizeHeader","pop","RangeError","blockLength","cid","encodingLength","encode","length","writeBytes","headerBytes","version","varintBytes","offset","writeHeader","subarray","set","header","headerPreludeTokens","map","string","uint","CID_TAG","tag","calculateHeaderLength","rootLengths","tokens","array","rootLength","estimateHeaderLength","rootCount","rootByteLength","Array","fill","createWriter","buffer","Uint8Array"],"sources":["C:/FACULTATE/Proiect/node_modules/@web3-storage/access/node_modules/@ipld/car/src/buffer-writer.js"],"sourcesContent":["import * as CBOR from '@ipld/dag-cbor'\nimport { Token, Type } from 'cborg'\nimport { tokensToLength } from 'cborg/length'\nimport varint from 'varint'\n\n/**\n * @typedef {import('./api').CID} CID\n * @typedef {import('./api').Block} Block\n * @typedef {import('./api').CarBufferWriter} Writer\n * @typedef {import('./api').CarBufferWriterOptions} Options\n * @typedef {import('./coding').CarEncoder} CarEncoder\n */\n\n/**\n * A simple CAR writer that writes to a pre-allocated buffer.\n *\n * @class\n * @name CarBufferWriter\n * @implements {Writer}\n */\nclass CarBufferWriter {\n  /**\n   * @param {Uint8Array} bytes\n   * @param {number} headerSize\n   */\n  constructor (bytes, headerSize) {\n    /** @readonly */\n    this.bytes = bytes\n    this.byteOffset = headerSize\n\n    /**\n     * @readonly\n     * @type {CID[]}\n     */\n    this.roots = []\n    this.headerSize = headerSize\n  }\n\n  /**\n   * Add a root to this writer, to be used to create a header when the CAR is\n   * finalized with {@link CarBufferWriter.close `close()`}\n   *\n   * @param {CID} root\n   * @param {{resize?:boolean}} [options]\n   * @returns {CarBufferWriter}\n   */\n  addRoot (root, options) {\n    addRoot(this, root, options)\n    return this\n  }\n\n  /**\n   * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.\n   * Throws if there is not enough capacity.\n   *\n   * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.\n   * @returns {CarBufferWriter}\n   */\n  write (block) {\n    addBlock(this, block)\n    return this\n  }\n\n  /**\n   * Finalize the CAR and return it as a `Uint8Array`.\n   *\n   * @param {object} [options]\n   * @param {boolean} [options.resize]\n   * @returns {Uint8Array}\n   */\n  close (options) {\n    return close(this, options)\n  }\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {CID} root\n * @param {{resize?:boolean}} [options]\n */\nexport const addRoot = (writer, root, options = {}) => {\n  const { resize = false } = options\n  const { bytes, headerSize, byteOffset, roots } = writer\n  writer.roots.push(root)\n  const size = headerLength(writer)\n  // If there is not enough space for the new root\n  if (size > headerSize) {\n    // Check if we root would fit if we were to resize the head.\n    if (size - headerSize + byteOffset < bytes.byteLength) {\n      // If resize is enabled resize head\n      if (resize) {\n        resizeHeader(writer, size)\n      // otherwise remove head and throw an error suggesting to resize\n      } else {\n        roots.pop()\n        throw new RangeError(`Header of size ${headerSize} has no capacity for new root ${root}.\n  However there is a space in the buffer and you could call addRoot(root, { resize: root }) to resize header to make a space for this root.`)\n      }\n    // If head would not fit even with resize pop new root and throw error\n    } else {\n      roots.pop()\n      throw new RangeError(`Buffer has no capacity for a new root ${root}`)\n    }\n  }\n}\n\n/**\n * Calculates number of bytes required for storing given block in CAR. Useful in\n * estimating size of an `ArrayBuffer` for the `CarBufferWriter`.\n *\n * @name CarBufferWriter.blockLength(Block)\n * @param {Block} block\n * @returns {number}\n */\nexport const blockLength = ({ cid, bytes }) => {\n  const size = cid.bytes.byteLength + bytes.byteLength\n  return varint.encodingLength(size) + size\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {Block} block\n */\nexport const addBlock = (writer, { cid, bytes }) => {\n  const byteLength = cid.bytes.byteLength + bytes.byteLength\n  const size = varint.encode(byteLength)\n  if (writer.byteOffset + size.length + byteLength > writer.bytes.byteLength) {\n    throw new RangeError('Buffer has no capacity for this block')\n  } else {\n    writeBytes(writer, size)\n    writeBytes(writer, cid.bytes)\n    writeBytes(writer, bytes)\n  }\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {object} [options]\n * @param {boolean} [options.resize]\n */\nexport const close = (writer, options = {}) => {\n  const { resize = false } = options\n  const { roots, bytes, byteOffset, headerSize } = writer\n\n  const headerBytes = CBOR.encode({ version: 1, roots })\n  const varintBytes = varint.encode(headerBytes.length)\n\n  const size = varintBytes.length + headerBytes.byteLength\n  const offset = headerSize - size\n\n  // If header size estimate was accurate we just write header and return\n  // view into buffer.\n  if (offset === 0) {\n    writeHeader(writer, varintBytes, headerBytes)\n    return bytes.subarray(0, byteOffset)\n    // If header was overestimated and `{resize: true}` is passed resize header\n  } else if (resize) {\n    resizeHeader(writer, size)\n    writeHeader(writer, varintBytes, headerBytes)\n    return bytes.subarray(0, writer.byteOffset)\n  } else {\n    throw new RangeError(`Header size was overestimated.\nYou can use close({ resize: true }) to resize header`)\n  }\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {number} byteLength\n */\nexport const resizeHeader = (writer, byteLength) => {\n  const { bytes, headerSize } = writer\n  // Move data section to a new offset\n  bytes.set(bytes.subarray(headerSize, writer.byteOffset), byteLength)\n  // Update header size & byteOffset\n  writer.byteOffset += byteLength - headerSize\n  writer.headerSize = byteLength\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {number[]|Uint8Array} bytes\n */\n\nconst writeBytes = (writer, bytes) => {\n  writer.bytes.set(bytes, writer.byteOffset)\n  writer.byteOffset += bytes.length\n}\n/**\n * @param {{bytes:Uint8Array}} writer\n * @param {number[]} varint\n * @param {Uint8Array} header\n */\nconst writeHeader = ({ bytes }, varint, header) => {\n  bytes.set(varint)\n  bytes.set(header, varint.length)\n}\n\nconst headerPreludeTokens = [\n  new Token(Type.map, 2),\n  new Token(Type.string, 'version'),\n  new Token(Type.uint, 1),\n  new Token(Type.string, 'roots')\n]\n\nconst CID_TAG = new Token(Type.tag, 42)\n\n/**\n * Calculates header size given the array of byteLength for roots.\n *\n * @name CarBufferWriter.calculateHeaderLength(rootLengths)\n * @param {number[]} rootLengths\n * @returns {number}\n */\nexport const calculateHeaderLength = (rootLengths) => {\n  const tokens = [...headerPreludeTokens]\n  tokens.push(new Token(Type.array, rootLengths.length))\n  for (const rootLength of rootLengths) {\n    tokens.push(CID_TAG)\n    tokens.push(new Token(Type.bytes, { length: rootLength + 1 }))\n  }\n  const length = tokensToLength(tokens) // no options needed here because we have simple tokens\n  return varint.encodingLength(length) + length\n}\n\n/**\n * Calculates header size given the array of roots.\n *\n * @name CarBufferWriter.headerLength({ roots })\n * @param {object} options\n * @param {CID[]} options.roots\n * @returns {number}\n */\nexport const headerLength = ({ roots }) =>\n  calculateHeaderLength(roots.map(cid => cid.bytes.byteLength))\n\n/**\n * Estimates header size given a count of the roots and the expected byte length\n * of the root CIDs. The default length works for a standard CIDv1 with a\n * single-byte multihash code, such as SHA2-256 (i.e. the most common CIDv1).\n *\n * @name CarBufferWriter.estimateHeaderLength(rootCount[, rootByteLength])\n * @param {number} rootCount\n * @param {number} [rootByteLength]\n * @returns {number}\n */\nexport const estimateHeaderLength = (rootCount, rootByteLength = 36) =>\n  calculateHeaderLength(new Array(rootCount).fill(rootByteLength))\n\n/**\n * Creates synchronous CAR writer that can be used to encode blocks into a given\n * buffer. Optionally you could pass `byteOffset` and `byteLength` to specify a\n * range inside buffer to write into. If car file is going to have `roots` you\n * need to either pass them under `options.roots` (from which header size will\n * be calculated) or provide `options.headerSize` to allocate required space\n * in the buffer. You may also provide known `roots` and `headerSize` to\n * allocate space for the roots that may not be known ahead of time.\n *\n * Note: Incorrect `headerSize` may lead to copying bytes inside a buffer\n * which will have a negative impact on performance.\n *\n * @name CarBufferWriter.createWriter(buffer[, options])\n * @param {ArrayBuffer} buffer\n * @param {object} [options]\n * @param {CID[]} [options.roots]\n * @param {number} [options.byteOffset]\n * @param {number} [options.byteLength]\n * @param {number} [options.headerSize]\n * @returns {CarBufferWriter}\n */\nexport const createWriter = (buffer, options = {}) => {\n  const {\n    roots = [],\n    byteOffset = 0,\n    byteLength = buffer.byteLength,\n    headerSize = headerLength({ roots })\n  } = options\n  const bytes = new Uint8Array(buffer, byteOffset, byteLength)\n\n  const writer = new CarBufferWriter(bytes, headerSize)\n  for (const root of roots) {\n    writer.addRoot(root)\n  }\n\n  return writer\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}