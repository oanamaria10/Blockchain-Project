{"ast":null,"code":"// Ported from https://github.com/nodejs/undici/pull/907\n\n'use strict';\n\nconst assert = require('assert');\nconst {\n  Readable\n} = require('stream');\nconst {\n  RequestAbortedError,\n  NotSupportedError,\n  InvalidArgumentError\n} = require('../core/errors');\nconst util = require('../core/util');\nconst {\n  ReadableStreamFrom,\n  toUSVString\n} = require('../core/util');\nlet Blob;\nconst kConsume = Symbol('kConsume');\nconst kReading = Symbol('kReading');\nconst kBody = Symbol('kBody');\nconst kAbort = Symbol('abort');\nconst kContentType = Symbol('kContentType');\nconst noop = () => {};\nmodule.exports = class BodyReadable extends Readable {\n  constructor({\n    resume,\n    abort,\n    contentType = '',\n    highWaterMark = 64 * 1024 // Same as nodejs fs streams.\n  }) {\n    super({\n      autoDestroy: true,\n      read: resume,\n      highWaterMark\n    });\n    this._readableState.dataEmitted = false;\n    this[kAbort] = abort;\n    this[kConsume] = null;\n    this[kBody] = null;\n    this[kContentType] = contentType;\n\n    // Is stream being consumed through Readable API?\n    // This is an optimization so that we avoid checking\n    // for 'data' and 'readable' listeners in the hot path\n    // inside push().\n    this[kReading] = false;\n  }\n  destroy(err) {\n    if (this.destroyed) {\n      // Node < 16\n      return this;\n    }\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError();\n    }\n    if (err) {\n      this[kAbort]();\n    }\n    return super.destroy(err);\n  }\n  emit(ev, ...args) {\n    if (ev === 'data') {\n      // Node < 16.7\n      this._readableState.dataEmitted = true;\n    } else if (ev === 'error') {\n      // Node < 16\n      this._readableState.errorEmitted = true;\n    }\n    return super.emit(ev, ...args);\n  }\n  on(ev, ...args) {\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = true;\n    }\n    return super.on(ev, ...args);\n  }\n  addListener(ev, ...args) {\n    return this.on(ev, ...args);\n  }\n  off(ev, ...args) {\n    const ret = super.off(ev, ...args);\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = this.listenerCount('data') > 0 || this.listenerCount('readable') > 0;\n    }\n    return ret;\n  }\n  removeListener(ev, ...args) {\n    return this.off(ev, ...args);\n  }\n  push(chunk) {\n    if (this[kConsume] && chunk !== null && this.readableLength === 0) {\n      consumePush(this[kConsume], chunk);\n      return this[kReading] ? super.push(chunk) : true;\n    }\n    return super.push(chunk);\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-text\n  async text() {\n    return consume(this, 'text');\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-json\n  async json() {\n    return consume(this, 'json');\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-blob\n  async blob() {\n    return consume(this, 'blob');\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-arraybuffer\n  async arrayBuffer() {\n    return consume(this, 'arrayBuffer');\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-formdata\n  async formData() {\n    // TODO: Implement.\n    throw new NotSupportedError();\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-bodyused\n  get bodyUsed() {\n    return util.isDisturbed(this);\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-body\n  get body() {\n    if (!this[kBody]) {\n      this[kBody] = ReadableStreamFrom(this);\n      if (this[kConsume]) {\n        // TODO: Is this the best way to force a lock?\n        this[kBody].getReader(); // Ensure stream is locked.\n        assert(this[kBody].locked);\n      }\n    }\n    return this[kBody];\n  }\n  dump(opts) {\n    let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;\n    const signal = opts && opts.signal;\n    if (signal) {\n      try {\n        if (typeof signal !== 'object' || !('aborted' in signal)) {\n          throw new InvalidArgumentError('signal must be an AbortSignal');\n        }\n        util.throwIfAborted(signal);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    }\n    if (this.closed) {\n      return Promise.resolve(null);\n    }\n    return new Promise((resolve, reject) => {\n      const signalListenerCleanup = signal ? util.addAbortListener(signal, () => {\n        this.destroy();\n      }) : noop;\n      this.on('close', function () {\n        signalListenerCleanup();\n        if (signal && signal.aborted) {\n          reject(signal.reason || Object.assign(new Error('The operation was aborted'), {\n            name: 'AbortError'\n          }));\n        } else {\n          resolve(null);\n        }\n      }).on('error', noop).on('data', function (chunk) {\n        limit -= chunk.length;\n        if (limit <= 0) {\n          this.destroy();\n        }\n      }).resume();\n    });\n  }\n};\n\n// https://streams.spec.whatwg.org/#readablestream-locked\nfunction isLocked(self) {\n  // Consume is an implicit lock.\n  return self[kBody] && self[kBody].locked === true || self[kConsume];\n}\n\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction isUnusable(self) {\n  return util.isDisturbed(self) || isLocked(self);\n}\nasync function consume(stream, type) {\n  if (isUnusable(stream)) {\n    throw new TypeError('unusable');\n  }\n  assert(!stream[kConsume]);\n  return new Promise((resolve, reject) => {\n    stream[kConsume] = {\n      type,\n      stream,\n      resolve,\n      reject,\n      length: 0,\n      body: []\n    };\n    stream.on('error', function (err) {\n      consumeFinish(this[kConsume], err);\n    }).on('close', function () {\n      if (this[kConsume].body !== null) {\n        consumeFinish(this[kConsume], new RequestAbortedError());\n      }\n    });\n    process.nextTick(consumeStart, stream[kConsume]);\n  });\n}\nfunction consumeStart(consume) {\n  if (consume.body === null) {\n    return;\n  }\n  const {\n    _readableState: state\n  } = consume.stream;\n  for (const chunk of state.buffer) {\n    consumePush(consume, chunk);\n  }\n  if (state.endEmitted) {\n    consumeEnd(this[kConsume]);\n  } else {\n    consume.stream.on('end', function () {\n      consumeEnd(this[kConsume]);\n    });\n  }\n  consume.stream.resume();\n  while (consume.stream.read() != null) {\n    // Loop\n  }\n}\nfunction consumeEnd(consume) {\n  const {\n    type,\n    body,\n    resolve,\n    stream,\n    length\n  } = consume;\n  try {\n    if (type === 'text') {\n      resolve(toUSVString(Buffer.concat(body)));\n    } else if (type === 'json') {\n      resolve(JSON.parse(Buffer.concat(body)));\n    } else if (type === 'arrayBuffer') {\n      const dst = new Uint8Array(length);\n      let pos = 0;\n      for (const buf of body) {\n        dst.set(buf, pos);\n        pos += buf.byteLength;\n      }\n      resolve(dst.buffer);\n    } else if (type === 'blob') {\n      if (!Blob) {\n        Blob = require('buffer').Blob;\n      }\n      resolve(new Blob(body, {\n        type: stream[kContentType]\n      }));\n    }\n    consumeFinish(consume);\n  } catch (err) {\n    stream.destroy(err);\n  }\n}\nfunction consumePush(consume, chunk) {\n  consume.length += chunk.length;\n  consume.body.push(chunk);\n}\nfunction consumeFinish(consume, err) {\n  if (consume.body === null) {\n    return;\n  }\n  if (err) {\n    consume.reject(err);\n  } else {\n    consume.resolve();\n  }\n  consume.type = null;\n  consume.stream = null;\n  consume.resolve = null;\n  consume.reject = null;\n  consume.length = 0;\n  consume.body = null;\n}","map":{"version":3,"names":["assert","require","Readable","RequestAbortedError","NotSupportedError","InvalidArgumentError","util","ReadableStreamFrom","toUSVString","Blob","kConsume","Symbol","kReading","kBody","kAbort","kContentType","noop","module","exports","BodyReadable","constructor","resume","abort","contentType","highWaterMark","autoDestroy","read","_readableState","dataEmitted","destroy","err","destroyed","endEmitted","emit","ev","args","errorEmitted","on","addListener","off","ret","listenerCount","removeListener","push","chunk","readableLength","consumePush","text","consume","json","blob","arrayBuffer","formData","bodyUsed","isDisturbed","body","getReader","locked","dump","opts","limit","Number","isFinite","signal","throwIfAborted","Promise","reject","closed","resolve","signalListenerCleanup","addAbortListener","aborted","reason","Object","assign","Error","name","length","isLocked","self","isUnusable","stream","type","TypeError","consumeFinish","process","nextTick","consumeStart","state","buffer","consumeEnd","Buffer","concat","JSON","parse","dst","Uint8Array","pos","buf","set","byteLength"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/undici/lib/api/readable.js"],"sourcesContent":["// Ported from https://github.com/nodejs/undici/pull/907\n\n'use strict'\n\nconst assert = require('assert')\nconst { Readable } = require('stream')\nconst { RequestAbortedError, NotSupportedError, InvalidArgumentError } = require('../core/errors')\nconst util = require('../core/util')\nconst { ReadableStreamFrom, toUSVString } = require('../core/util')\n\nlet Blob\n\nconst kConsume = Symbol('kConsume')\nconst kReading = Symbol('kReading')\nconst kBody = Symbol('kBody')\nconst kAbort = Symbol('abort')\nconst kContentType = Symbol('kContentType')\n\nconst noop = () => {}\n\nmodule.exports = class BodyReadable extends Readable {\n  constructor ({\n    resume,\n    abort,\n    contentType = '',\n    highWaterMark = 64 * 1024 // Same as nodejs fs streams.\n  }) {\n    super({\n      autoDestroy: true,\n      read: resume,\n      highWaterMark\n    })\n\n    this._readableState.dataEmitted = false\n\n    this[kAbort] = abort\n    this[kConsume] = null\n    this[kBody] = null\n    this[kContentType] = contentType\n\n    // Is stream being consumed through Readable API?\n    // This is an optimization so that we avoid checking\n    // for 'data' and 'readable' listeners in the hot path\n    // inside push().\n    this[kReading] = false\n  }\n\n  destroy (err) {\n    if (this.destroyed) {\n      // Node < 16\n      return this\n    }\n\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError()\n    }\n\n    if (err) {\n      this[kAbort]()\n    }\n\n    return super.destroy(err)\n  }\n\n  emit (ev, ...args) {\n    if (ev === 'data') {\n      // Node < 16.7\n      this._readableState.dataEmitted = true\n    } else if (ev === 'error') {\n      // Node < 16\n      this._readableState.errorEmitted = true\n    }\n    return super.emit(ev, ...args)\n  }\n\n  on (ev, ...args) {\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = true\n    }\n    return super.on(ev, ...args)\n  }\n\n  addListener (ev, ...args) {\n    return this.on(ev, ...args)\n  }\n\n  off (ev, ...args) {\n    const ret = super.off(ev, ...args)\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = (\n        this.listenerCount('data') > 0 ||\n        this.listenerCount('readable') > 0\n      )\n    }\n    return ret\n  }\n\n  removeListener (ev, ...args) {\n    return this.off(ev, ...args)\n  }\n\n  push (chunk) {\n    if (this[kConsume] && chunk !== null && this.readableLength === 0) {\n      consumePush(this[kConsume], chunk)\n      return this[kReading] ? super.push(chunk) : true\n    }\n    return super.push(chunk)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-text\n  async text () {\n    return consume(this, 'text')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-json\n  async json () {\n    return consume(this, 'json')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-blob\n  async blob () {\n    return consume(this, 'blob')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-arraybuffer\n  async arrayBuffer () {\n    return consume(this, 'arrayBuffer')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-formdata\n  async formData () {\n    // TODO: Implement.\n    throw new NotSupportedError()\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-bodyused\n  get bodyUsed () {\n    return util.isDisturbed(this)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-body\n  get body () {\n    if (!this[kBody]) {\n      this[kBody] = ReadableStreamFrom(this)\n      if (this[kConsume]) {\n        // TODO: Is this the best way to force a lock?\n        this[kBody].getReader() // Ensure stream is locked.\n        assert(this[kBody].locked)\n      }\n    }\n    return this[kBody]\n  }\n\n  dump (opts) {\n    let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144\n    const signal = opts && opts.signal\n\n    if (signal) {\n      try {\n        if (typeof signal !== 'object' || !('aborted' in signal)) {\n          throw new InvalidArgumentError('signal must be an AbortSignal')\n        }\n        util.throwIfAborted(signal)\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n\n    if (this.closed) {\n      return Promise.resolve(null)\n    }\n\n    return new Promise((resolve, reject) => {\n      const signalListenerCleanup = signal\n        ? util.addAbortListener(signal, () => {\n          this.destroy()\n        })\n        : noop\n\n      this\n        .on('close', function () {\n          signalListenerCleanup()\n          if (signal && signal.aborted) {\n            reject(signal.reason || Object.assign(new Error('The operation was aborted'), { name: 'AbortError' }))\n          } else {\n            resolve(null)\n          }\n        })\n        .on('error', noop)\n        .on('data', function (chunk) {\n          limit -= chunk.length\n          if (limit <= 0) {\n            this.destroy()\n          }\n        })\n        .resume()\n    })\n  }\n}\n\n// https://streams.spec.whatwg.org/#readablestream-locked\nfunction isLocked (self) {\n  // Consume is an implicit lock.\n  return (self[kBody] && self[kBody].locked === true) || self[kConsume]\n}\n\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction isUnusable (self) {\n  return util.isDisturbed(self) || isLocked(self)\n}\n\nasync function consume (stream, type) {\n  if (isUnusable(stream)) {\n    throw new TypeError('unusable')\n  }\n\n  assert(!stream[kConsume])\n\n  return new Promise((resolve, reject) => {\n    stream[kConsume] = {\n      type,\n      stream,\n      resolve,\n      reject,\n      length: 0,\n      body: []\n    }\n\n    stream\n      .on('error', function (err) {\n        consumeFinish(this[kConsume], err)\n      })\n      .on('close', function () {\n        if (this[kConsume].body !== null) {\n          consumeFinish(this[kConsume], new RequestAbortedError())\n        }\n      })\n\n    process.nextTick(consumeStart, stream[kConsume])\n  })\n}\n\nfunction consumeStart (consume) {\n  if (consume.body === null) {\n    return\n  }\n\n  const { _readableState: state } = consume.stream\n\n  for (const chunk of state.buffer) {\n    consumePush(consume, chunk)\n  }\n\n  if (state.endEmitted) {\n    consumeEnd(this[kConsume])\n  } else {\n    consume.stream.on('end', function () {\n      consumeEnd(this[kConsume])\n    })\n  }\n\n  consume.stream.resume()\n\n  while (consume.stream.read() != null) {\n    // Loop\n  }\n}\n\nfunction consumeEnd (consume) {\n  const { type, body, resolve, stream, length } = consume\n\n  try {\n    if (type === 'text') {\n      resolve(toUSVString(Buffer.concat(body)))\n    } else if (type === 'json') {\n      resolve(JSON.parse(Buffer.concat(body)))\n    } else if (type === 'arrayBuffer') {\n      const dst = new Uint8Array(length)\n\n      let pos = 0\n      for (const buf of body) {\n        dst.set(buf, pos)\n        pos += buf.byteLength\n      }\n\n      resolve(dst.buffer)\n    } else if (type === 'blob') {\n      if (!Blob) {\n        Blob = require('buffer').Blob\n      }\n      resolve(new Blob(body, { type: stream[kContentType] }))\n    }\n\n    consumeFinish(consume)\n  } catch (err) {\n    stream.destroy(err)\n  }\n}\n\nfunction consumePush (consume, chunk) {\n  consume.length += chunk.length\n  consume.body.push(chunk)\n}\n\nfunction consumeFinish (consume, err) {\n  if (consume.body === null) {\n    return\n  }\n\n  if (err) {\n    consume.reject(err)\n  } else {\n    consume.resolve()\n  }\n\n  consume.type = null\n  consume.stream = null\n  consume.resolve = null\n  consume.reject = null\n  consume.length = 0\n  consume.body = null\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}