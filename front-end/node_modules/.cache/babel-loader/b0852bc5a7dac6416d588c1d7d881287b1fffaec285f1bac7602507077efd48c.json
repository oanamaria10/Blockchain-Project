{"ast":null,"code":"'use strict';\n\nconst {\n  maxUnsigned16Bit\n} = require('./constants');\n\n/** @type {import('crypto')} */\nlet crypto;\ntry {\n  crypto = require('crypto');\n} catch {}\nclass WebsocketFrameSend {\n  /**\n   * @param {Buffer|undefined} data\n   */\n  constructor(data) {\n    this.frameData = data;\n    this.maskKey = crypto.randomBytes(4);\n  }\n  createFrame(opcode) {\n    const bodyLength = this.frameData?.byteLength ?? 0;\n\n    /** @type {number} */\n    let payloadLength = bodyLength; // 0-125\n    let offset = 6;\n    if (bodyLength > maxUnsigned16Bit) {\n      offset += 8; // payload length is next 8 bytes\n      payloadLength = 127;\n    } else if (bodyLength > 125) {\n      offset += 2; // payload length is next 2 bytes\n      payloadLength = 126;\n    }\n    const buffer = Buffer.allocUnsafe(bodyLength + offset);\n\n    // Clear first 2 bytes, everything else is overwritten\n    buffer[0] = buffer[1] = 0;\n    buffer[0] |= 0x80; // FIN\n    buffer[0] = (buffer[0] & 0xF0) + opcode; // opcode\n\n    /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */\n    buffer[offset - 4] = this.maskKey[0];\n    buffer[offset - 3] = this.maskKey[1];\n    buffer[offset - 2] = this.maskKey[2];\n    buffer[offset - 1] = this.maskKey[3];\n    buffer[1] = payloadLength;\n    if (payloadLength === 126) {\n      buffer.writeUInt16BE(bodyLength, 2);\n    } else if (payloadLength === 127) {\n      // Clear extended payload length\n      buffer[2] = buffer[3] = 0;\n      buffer.writeUIntBE(bodyLength, 4, 6);\n    }\n    buffer[1] |= 0x80; // MASK\n\n    // mask body\n    for (let i = 0; i < bodyLength; i++) {\n      buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4];\n    }\n    return buffer;\n  }\n}\nmodule.exports = {\n  WebsocketFrameSend\n};","map":{"version":3,"names":["maxUnsigned16Bit","require","crypto","WebsocketFrameSend","constructor","data","frameData","maskKey","randomBytes","createFrame","opcode","bodyLength","byteLength","payloadLength","offset","buffer","Buffer","allocUnsafe","writeUInt16BE","writeUIntBE","i","module","exports"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/undici/lib/websocket/frame.js"],"sourcesContent":["'use strict'\n\nconst { maxUnsigned16Bit } = require('./constants')\n\n/** @type {import('crypto')} */\nlet crypto\ntry {\n  crypto = require('crypto')\n} catch {\n\n}\n\nclass WebsocketFrameSend {\n  /**\n   * @param {Buffer|undefined} data\n   */\n  constructor (data) {\n    this.frameData = data\n    this.maskKey = crypto.randomBytes(4)\n  }\n\n  createFrame (opcode) {\n    const bodyLength = this.frameData?.byteLength ?? 0\n\n    /** @type {number} */\n    let payloadLength = bodyLength // 0-125\n    let offset = 6\n\n    if (bodyLength > maxUnsigned16Bit) {\n      offset += 8 // payload length is next 8 bytes\n      payloadLength = 127\n    } else if (bodyLength > 125) {\n      offset += 2 // payload length is next 2 bytes\n      payloadLength = 126\n    }\n\n    const buffer = Buffer.allocUnsafe(bodyLength + offset)\n\n    // Clear first 2 bytes, everything else is overwritten\n    buffer[0] = buffer[1] = 0\n    buffer[0] |= 0x80 // FIN\n    buffer[0] = (buffer[0] & 0xF0) + opcode // opcode\n\n    /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */\n    buffer[offset - 4] = this.maskKey[0]\n    buffer[offset - 3] = this.maskKey[1]\n    buffer[offset - 2] = this.maskKey[2]\n    buffer[offset - 1] = this.maskKey[3]\n\n    buffer[1] = payloadLength\n\n    if (payloadLength === 126) {\n      buffer.writeUInt16BE(bodyLength, 2)\n    } else if (payloadLength === 127) {\n      // Clear extended payload length\n      buffer[2] = buffer[3] = 0\n      buffer.writeUIntBE(bodyLength, 4, 6)\n    }\n\n    buffer[1] |= 0x80 // MASK\n\n    // mask body\n    for (let i = 0; i < bodyLength; i++) {\n      buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4]\n    }\n\n    return buffer\n  }\n}\n\nmodule.exports = {\n  WebsocketFrameSend\n}\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAM;EAAEA;AAAiB,CAAC,GAAGC,OAAO,CAAC,aAAa,CAAC;;AAEnD;AACA,IAAIC,MAAM;AACV,IAAI;EACFA,MAAM,GAAGD,OAAO,CAAC,QAAQ,CAAC;AAC5B,CAAC,CAAC,MAAM,CAER;AAEA,MAAME,kBAAkB,CAAC;EACvB;AACF;AACA;EACEC,WAAWA,CAAEC,IAAI,EAAE;IACjB,IAAI,CAACC,SAAS,GAAGD,IAAI;IACrB,IAAI,CAACE,OAAO,GAAGL,MAAM,CAACM,WAAW,CAAC,CAAC,CAAC;EACtC;EAEAC,WAAWA,CAAEC,MAAM,EAAE;IACnB,MAAMC,UAAU,GAAG,IAAI,CAACL,SAAS,EAAEM,UAAU,IAAI,CAAC;;IAElD;IACA,IAAIC,aAAa,GAAGF,UAAU,EAAC;IAC/B,IAAIG,MAAM,GAAG,CAAC;IAEd,IAAIH,UAAU,GAAGX,gBAAgB,EAAE;MACjCc,MAAM,IAAI,CAAC,EAAC;MACZD,aAAa,GAAG,GAAG;IACrB,CAAC,MAAM,IAAIF,UAAU,GAAG,GAAG,EAAE;MAC3BG,MAAM,IAAI,CAAC,EAAC;MACZD,aAAa,GAAG,GAAG;IACrB;IAEA,MAAME,MAAM,GAAGC,MAAM,CAACC,WAAW,CAACN,UAAU,GAAGG,MAAM,CAAC;;IAEtD;IACAC,MAAM,CAAC,CAAC,CAAC,GAAGA,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC;IACzBA,MAAM,CAAC,CAAC,CAAC,IAAI,IAAI,EAAC;IAClBA,MAAM,CAAC,CAAC,CAAC,GAAG,CAACA,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,IAAIL,MAAM,EAAC;;IAExC;IACAK,MAAM,CAACD,MAAM,GAAG,CAAC,CAAC,GAAG,IAAI,CAACP,OAAO,CAAC,CAAC,CAAC;IACpCQ,MAAM,CAACD,MAAM,GAAG,CAAC,CAAC,GAAG,IAAI,CAACP,OAAO,CAAC,CAAC,CAAC;IACpCQ,MAAM,CAACD,MAAM,GAAG,CAAC,CAAC,GAAG,IAAI,CAACP,OAAO,CAAC,CAAC,CAAC;IACpCQ,MAAM,CAACD,MAAM,GAAG,CAAC,CAAC,GAAG,IAAI,CAACP,OAAO,CAAC,CAAC,CAAC;IAEpCQ,MAAM,CAAC,CAAC,CAAC,GAAGF,aAAa;IAEzB,IAAIA,aAAa,KAAK,GAAG,EAAE;MACzBE,MAAM,CAACG,aAAa,CAACP,UAAU,EAAE,CAAC,CAAC;IACrC,CAAC,MAAM,IAAIE,aAAa,KAAK,GAAG,EAAE;MAChC;MACAE,MAAM,CAAC,CAAC,CAAC,GAAGA,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC;MACzBA,MAAM,CAACI,WAAW,CAACR,UAAU,EAAE,CAAC,EAAE,CAAC,CAAC;IACtC;IAEAI,MAAM,CAAC,CAAC,CAAC,IAAI,IAAI,EAAC;;IAElB;IACA,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,UAAU,EAAES,CAAC,EAAE,EAAE;MACnCL,MAAM,CAACD,MAAM,GAAGM,CAAC,CAAC,GAAG,IAAI,CAACd,SAAS,CAACc,CAAC,CAAC,GAAG,IAAI,CAACb,OAAO,CAACa,CAAC,GAAG,CAAC,CAAC;IAC9D;IAEA,OAAOL,MAAM;EACf;AACF;AAEAM,MAAM,CAACC,OAAO,GAAG;EACfnB;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}