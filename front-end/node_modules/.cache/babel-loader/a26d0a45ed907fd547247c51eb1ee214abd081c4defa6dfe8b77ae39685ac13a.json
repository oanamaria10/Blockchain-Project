{"ast":null,"code":"'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\nvar EventEmitter = require('events').EventEmitter;\nvar Pending = require('./pending');\nvar utils = require('./utils');\nvar debug = require('debug')('mocha:runner');\nvar Runnable = require('./runnable');\nvar Suite = require('./suite');\nvar HOOK_TYPE_BEFORE_EACH = Suite.constants.HOOK_TYPE_BEFORE_EACH;\nvar HOOK_TYPE_AFTER_EACH = Suite.constants.HOOK_TYPE_AFTER_EACH;\nvar HOOK_TYPE_AFTER_ALL = Suite.constants.HOOK_TYPE_AFTER_ALL;\nvar HOOK_TYPE_BEFORE_ALL = Suite.constants.HOOK_TYPE_BEFORE_ALL;\nvar EVENT_ROOT_SUITE_RUN = Suite.constants.EVENT_ROOT_SUITE_RUN;\nvar STATE_FAILED = Runnable.constants.STATE_FAILED;\nvar STATE_PASSED = Runnable.constants.STATE_PASSED;\nvar STATE_PENDING = Runnable.constants.STATE_PENDING;\nvar stackFilter = utils.stackTraceFilter();\nvar stringify = utils.stringify;\nconst {\n  createInvalidExceptionError,\n  createUnsupportedError,\n  createFatalError,\n  isMochaError,\n  constants: errorConstants\n} = require('./errors');\n\n/**\n * Non-enumerable globals.\n * @private\n * @readonly\n */\nvar globals = ['setTimeout', 'clearTimeout', 'setInterval', 'clearInterval', 'XMLHttpRequest', 'Date', 'setImmediate', 'clearImmediate'];\nvar constants = utils.defineConstants(\n/**\n * {@link Runner}-related constants.\n * @public\n * @memberof Runner\n * @readonly\n * @alias constants\n * @static\n * @enum {string}\n */\n{\n  /**\n   * Emitted when {@link Hook} execution begins\n   */\n  EVENT_HOOK_BEGIN: 'hook',\n  /**\n   * Emitted when {@link Hook} execution ends\n   */\n  EVENT_HOOK_END: 'hook end',\n  /**\n   * Emitted when Root {@link Suite} execution begins (all files have been parsed and hooks/tests are ready for execution)\n   */\n  EVENT_RUN_BEGIN: 'start',\n  /**\n   * Emitted when Root {@link Suite} execution has been delayed via `delay` option\n   */\n  EVENT_DELAY_BEGIN: 'waiting',\n  /**\n   * Emitted when delayed Root {@link Suite} execution is triggered by user via `global.run()`\n   */\n  EVENT_DELAY_END: 'ready',\n  /**\n   * Emitted when Root {@link Suite} execution ends\n   */\n  EVENT_RUN_END: 'end',\n  /**\n   * Emitted when {@link Suite} execution begins\n   */\n  EVENT_SUITE_BEGIN: 'suite',\n  /**\n   * Emitted when {@link Suite} execution ends\n   */\n  EVENT_SUITE_END: 'suite end',\n  /**\n   * Emitted when {@link Test} execution begins\n   */\n  EVENT_TEST_BEGIN: 'test',\n  /**\n   * Emitted when {@link Test} execution ends\n   */\n  EVENT_TEST_END: 'test end',\n  /**\n   * Emitted when {@link Test} execution fails\n   */\n  EVENT_TEST_FAIL: 'fail',\n  /**\n   * Emitted when {@link Test} execution succeeds\n   */\n  EVENT_TEST_PASS: 'pass',\n  /**\n   * Emitted when {@link Test} becomes pending\n   */\n  EVENT_TEST_PENDING: 'pending',\n  /**\n   * Emitted when {@link Test} execution has failed, but will retry\n   */\n  EVENT_TEST_RETRY: 'retry',\n  /**\n   * Initial state of Runner\n   */\n  STATE_IDLE: 'idle',\n  /**\n   * State set to this value when the Runner has started running\n   */\n  STATE_RUNNING: 'running',\n  /**\n   * State set to this value when the Runner has stopped\n   */\n  STATE_STOPPED: 'stopped'\n});\nclass Runner extends EventEmitter {\n  /**\n   * Initialize a `Runner` at the Root {@link Suite}, which represents a hierarchy of {@link Suite|Suites} and {@link Test|Tests}.\n   *\n   * @extends external:EventEmitter\n   * @public\n   * @class\n   * @param {Suite} suite - Root suite\n   * @param {Object} [opts] - Settings object\n   * @param {boolean} [opts.cleanReferencesAfterRun] - Whether to clean references to test fns and hooks when a suite is done.\n   * @param {boolean} [opts.delay] - Whether to delay execution of root suite until ready.\n   * @param {boolean} [opts.dryRun] - Whether to report tests without running them.\n   * @param {boolean} [opts.failZero] - Whether to fail test run if zero tests encountered.\n   */\n  constructor(suite, opts = {}) {\n    super();\n    var self = this;\n    this._globals = [];\n    this._abort = false;\n    this.suite = suite;\n    this._opts = opts;\n    this.state = constants.STATE_IDLE;\n    this.total = suite.total();\n    this.failures = 0;\n    /**\n     * @type {Map<EventEmitter,Map<string,Set<EventListener>>>}\n     */\n    this._eventListeners = new Map();\n    this.on(constants.EVENT_TEST_END, function (test) {\n      if (test.type === 'test' && test.retriedTest() && test.parent) {\n        var idx = test.parent.tests && test.parent.tests.indexOf(test.retriedTest());\n        if (idx > -1) test.parent.tests[idx] = test;\n      }\n      self.checkGlobals(test);\n    });\n    this.on(constants.EVENT_HOOK_END, function (hook) {\n      self.checkGlobals(hook);\n    });\n    this._defaultGrep = /.*/;\n    this.grep(this._defaultGrep);\n    this.globals(this.globalProps());\n    this.uncaught = this._uncaught.bind(this);\n    this.unhandled = (reason, promise) => {\n      if (isMochaError(reason)) {\n        debug('trapped unhandled rejection coming out of Mocha; forwarding to uncaught handler:', reason);\n        this.uncaught(reason);\n      } else {\n        debug('trapped unhandled rejection from (probably) user code; re-emitting on process');\n        this._removeEventListener(process, 'unhandledRejection', this.unhandled);\n        try {\n          process.emit('unhandledRejection', reason, promise);\n        } finally {\n          this._addEventListener(process, 'unhandledRejection', this.unhandled);\n        }\n      }\n    };\n  }\n}\n\n/**\n * Wrapper for setImmediate, process.nextTick, or browser polyfill.\n *\n * @param {Function} fn\n * @private\n */\nRunner.immediately = global.setImmediate || process.nextTick;\n\n/**\n * Replacement for `target.on(eventName, listener)` that does bookkeeping to remove them when this runner instance is disposed.\n * @param {EventEmitter} target - The `EventEmitter`\n * @param {string} eventName - The event name\n * @param {string} fn - Listener function\n * @private\n */\nRunner.prototype._addEventListener = function (target, eventName, listener) {\n  debug('_addEventListener(): adding for event %s; %d current listeners', eventName, target.listenerCount(eventName));\n  /* istanbul ignore next */\n  if (this._eventListeners.has(target) && this._eventListeners.get(target).has(eventName) && this._eventListeners.get(target).get(eventName).has(listener)) {\n    debug('warning: tried to attach duplicate event listener for %s', eventName);\n    return;\n  }\n  target.on(eventName, listener);\n  const targetListeners = this._eventListeners.has(target) ? this._eventListeners.get(target) : new Map();\n  const targetEventListeners = targetListeners.has(eventName) ? targetListeners.get(eventName) : new Set();\n  targetEventListeners.add(listener);\n  targetListeners.set(eventName, targetEventListeners);\n  this._eventListeners.set(target, targetListeners);\n};\n\n/**\n * Replacement for `target.removeListener(eventName, listener)` that also updates the bookkeeping.\n * @param {EventEmitter} target - The `EventEmitter`\n * @param {string} eventName - The event name\n * @param {function} listener - Listener function\n * @private\n */\nRunner.prototype._removeEventListener = function (target, eventName, listener) {\n  target.removeListener(eventName, listener);\n  if (this._eventListeners.has(target)) {\n    const targetListeners = this._eventListeners.get(target);\n    if (targetListeners.has(eventName)) {\n      const targetEventListeners = targetListeners.get(eventName);\n      targetEventListeners.delete(listener);\n      if (!targetEventListeners.size) {\n        targetListeners.delete(eventName);\n      }\n    }\n    if (!targetListeners.size) {\n      this._eventListeners.delete(target);\n    }\n  } else {\n    debug('trying to remove listener for untracked object %s', target);\n  }\n};\n\n/**\n * Removes all event handlers set during a run on this instance.\n * Remark: this does _not_ clean/dispose the tests or suites themselves.\n */\nRunner.prototype.dispose = function () {\n  this.removeAllListeners();\n  this._eventListeners.forEach((targetListeners, target) => {\n    targetListeners.forEach((targetEventListeners, eventName) => {\n      targetEventListeners.forEach(listener => {\n        target.removeListener(eventName, listener);\n      });\n    });\n  });\n  this._eventListeners.clear();\n};\n\n/**\n * Run tests with full titles matching `re`. Updates runner.total\n * with number of tests matched.\n *\n * @public\n * @memberof Runner\n * @param {RegExp} re\n * @param {boolean} invert\n * @return {Runner} Runner instance.\n */\nRunner.prototype.grep = function (re, invert) {\n  debug('grep(): setting to %s', re);\n  this._grep = re;\n  this._invert = invert;\n  this.total = this.grepTotal(this.suite);\n  return this;\n};\n\n/**\n * Returns the number of tests matching the grep search for the\n * given suite.\n *\n * @memberof Runner\n * @public\n * @param {Suite} suite\n * @return {number}\n */\nRunner.prototype.grepTotal = function (suite) {\n  var self = this;\n  var total = 0;\n  suite.eachTest(function (test) {\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) {\n      match = !match;\n    }\n    if (match) {\n      total++;\n    }\n  });\n  return total;\n};\n\n/**\n * Return a list of global properties.\n *\n * @return {Array}\n * @private\n */\nRunner.prototype.globalProps = function () {\n  var props = Object.keys(global);\n\n  // non-enumerables\n  for (var i = 0; i < globals.length; ++i) {\n    if (~props.indexOf(globals[i])) {\n      continue;\n    }\n    props.push(globals[i]);\n  }\n  return props;\n};\n\n/**\n * Allow the given `arr` of globals.\n *\n * @public\n * @memberof Runner\n * @param {Array} arr\n * @return {Runner} Runner instance.\n */\nRunner.prototype.globals = function (arr) {\n  if (!arguments.length) {\n    return this._globals;\n  }\n  debug('globals(): setting to %O', arr);\n  this._globals = this._globals.concat(arr);\n  return this;\n};\n\n/**\n * Check for global variable leaks.\n *\n * @private\n */\nRunner.prototype.checkGlobals = function (test) {\n  if (!this.checkLeaks) {\n    return;\n  }\n  var ok = this._globals;\n  var globals = this.globalProps();\n  var leaks;\n  if (test) {\n    ok = ok.concat(test._allowedGlobals || []);\n  }\n  if (this.prevGlobalsLength === globals.length) {\n    return;\n  }\n  this.prevGlobalsLength = globals.length;\n  leaks = filterLeaks(ok, globals);\n  this._globals = this._globals.concat(leaks);\n  if (leaks.length) {\n    var msg = `global leak(s) detected: ${leaks.map(e => `'${e}'`).join(', ')}`;\n    this.fail(test, new Error(msg));\n  }\n};\n\n/**\n * Fail the given `test`.\n *\n * If `test` is a hook, failures work in the following pattern:\n * - If bail, run corresponding `after each` and `after` hooks,\n *   then exit\n * - Failed `before` hook skips all tests in a suite and subsuites,\n *   but jumps to corresponding `after` hook\n * - Failed `before each` hook skips remaining tests in a\n *   suite and jumps to corresponding `after each` hook,\n *   which is run only once\n * - Failed `after` hook does not alter execution order\n * - Failed `after each` hook skips remaining tests in a\n *   suite and subsuites, but executes other `after each`\n *   hooks\n *\n * @private\n * @param {Runnable} test\n * @param {Error} err\n * @param {boolean} [force=false] - Whether to fail a pending test.\n */\nRunner.prototype.fail = function (test, err, force) {\n  force = force === true;\n  if (test.isPending() && !force) {\n    return;\n  }\n  if (this.state === constants.STATE_STOPPED) {\n    if (err.code === errorConstants.MULTIPLE_DONE) {\n      throw err;\n    }\n    throw createFatalError('Test failed after root suite execution completed!', err);\n  }\n  ++this.failures;\n  debug('total number of failures: %d', this.failures);\n  test.state = STATE_FAILED;\n  if (!isError(err)) {\n    err = thrown2Error(err);\n  }\n  try {\n    err.stack = this.fullStackTrace || !err.stack ? err.stack : stackFilter(err.stack);\n  } catch (ignore) {\n    // some environments do not take kindly to monkeying with the stack\n  }\n  this.emit(constants.EVENT_TEST_FAIL, test, err);\n};\n\n/**\n * Run hook `name` callbacks and then invoke `fn()`.\n *\n * @private\n * @param {string} name\n * @param {Function} fn\n */\n\nRunner.prototype.hook = function (name, fn) {\n  if (this._opts.dryRun) return fn();\n  var suite = this.suite;\n  var hooks = suite.getHooks(name);\n  var self = this;\n  function next(i) {\n    var hook = hooks[i];\n    if (!hook) {\n      return fn();\n    }\n    self.currentRunnable = hook;\n    if (name === HOOK_TYPE_BEFORE_ALL) {\n      hook.ctx.currentTest = hook.parent.tests[0];\n    } else if (name === HOOK_TYPE_AFTER_ALL) {\n      hook.ctx.currentTest = hook.parent.tests[hook.parent.tests.length - 1];\n    } else {\n      hook.ctx.currentTest = self.test;\n    }\n    setHookTitle(hook);\n    hook.allowUncaught = self.allowUncaught;\n    self.emit(constants.EVENT_HOOK_BEGIN, hook);\n    if (!hook.listeners('error').length) {\n      self._addEventListener(hook, 'error', function (err) {\n        self.fail(hook, err);\n      });\n    }\n    hook.run(function cbHookRun(err) {\n      var testError = hook.error();\n      if (testError) {\n        self.fail(self.test, testError);\n      }\n      // conditional skip\n      if (hook.pending) {\n        if (name === HOOK_TYPE_AFTER_EACH) {\n          // TODO define and implement use case\n          if (self.test) {\n            self.test.pending = true;\n          }\n        } else if (name === HOOK_TYPE_BEFORE_EACH) {\n          if (self.test) {\n            self.test.pending = true;\n          }\n          self.emit(constants.EVENT_HOOK_END, hook);\n          hook.pending = false; // activates hook for next test\n          return fn(new Error('abort hookDown'));\n        } else if (name === HOOK_TYPE_BEFORE_ALL) {\n          suite.tests.forEach(function (test) {\n            test.pending = true;\n          });\n          suite.suites.forEach(function (suite) {\n            suite.pending = true;\n          });\n          hooks = [];\n        } else {\n          hook.pending = false;\n          var errForbid = createUnsupportedError('`this.skip` forbidden');\n          self.fail(hook, errForbid);\n          return fn(errForbid);\n        }\n      } else if (err) {\n        self.fail(hook, err);\n        // stop executing hooks, notify callee of hook err\n        return fn(err);\n      }\n      self.emit(constants.EVENT_HOOK_END, hook);\n      delete hook.ctx.currentTest;\n      setHookTitle(hook);\n      next(++i);\n    });\n    function setHookTitle(hook) {\n      hook.originalTitle = hook.originalTitle || hook.title;\n      if (hook.ctx && hook.ctx.currentTest) {\n        hook.title = `${hook.originalTitle} for \"${hook.ctx.currentTest.title}\"`;\n      } else {\n        var parentTitle;\n        if (hook.parent.title) {\n          parentTitle = hook.parent.title;\n        } else {\n          parentTitle = hook.parent.root ? '{root}' : '';\n        }\n        hook.title = `${hook.originalTitle} in \"${parentTitle}\"`;\n      }\n    }\n  }\n  Runner.immediately(function () {\n    next(0);\n  });\n};\n\n/**\n * Run hook `name` for the given array of `suites`\n * in order, and callback `fn(err, errSuite)`.\n *\n * @private\n * @param {string} name\n * @param {Array} suites\n * @param {Function} fn\n */\nRunner.prototype.hooks = function (name, suites, fn) {\n  var self = this;\n  var orig = this.suite;\n  function next(suite) {\n    self.suite = suite;\n    if (!suite) {\n      self.suite = orig;\n      return fn();\n    }\n    self.hook(name, function (err) {\n      if (err) {\n        var errSuite = self.suite;\n        self.suite = orig;\n        return fn(err, errSuite);\n      }\n      next(suites.pop());\n    });\n  }\n  next(suites.pop());\n};\n\n/**\n * Run 'afterEach' hooks from bottom up.\n *\n * @param {String} name\n * @param {Function} fn\n * @private\n */\nRunner.prototype.hookUp = function (name, fn) {\n  var suites = [this.suite].concat(this.parents()).reverse();\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Run 'beforeEach' hooks from top level down.\n *\n * @param {String} name\n * @param {Function} fn\n * @private\n */\nRunner.prototype.hookDown = function (name, fn) {\n  var suites = [this.suite].concat(this.parents());\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Return an array of parent Suites from\n * closest to furthest.\n *\n * @return {Array}\n * @private\n */\nRunner.prototype.parents = function () {\n  var suite = this.suite;\n  var suites = [];\n  while (suite.parent) {\n    suite = suite.parent;\n    suites.push(suite);\n  }\n  return suites;\n};\n\n/**\n * Run the current test and callback `fn(err)`.\n *\n * @param {Function} fn\n * @private\n */\nRunner.prototype.runTest = function (fn) {\n  if (this._opts.dryRun) return Runner.immediately(fn);\n  var self = this;\n  var test = this.test;\n  if (!test) {\n    return;\n  }\n  if (this.asyncOnly) {\n    test.asyncOnly = true;\n  }\n  this._addEventListener(test, 'error', function (err) {\n    self.fail(test, err);\n  });\n  if (this.allowUncaught) {\n    test.allowUncaught = true;\n    return test.run(fn);\n  }\n  try {\n    test.run(fn);\n  } catch (err) {\n    fn(err);\n  }\n};\n\n/**\n * Run tests in the given `suite` and invoke the callback `fn()` when complete.\n *\n * @private\n * @param {Suite} suite\n * @param {Function} fn\n */\nRunner.prototype.runTests = function (suite, fn) {\n  var self = this;\n  var tests = suite.tests.slice();\n  var test;\n  function hookErr(_, errSuite, after) {\n    // before/after Each hook for errSuite failed:\n    var orig = self.suite;\n\n    // for failed 'after each' hook start from errSuite parent,\n    // otherwise start from errSuite itself\n    self.suite = after ? errSuite.parent : errSuite;\n    if (self.suite) {\n      self.hookUp(HOOK_TYPE_AFTER_EACH, function (err2, errSuite2) {\n        self.suite = orig;\n        // some hooks may fail even now\n        if (err2) {\n          return hookErr(err2, errSuite2, true);\n        }\n        // report error suite\n        fn(errSuite);\n      });\n    } else {\n      // there is no need calling other 'after each' hooks\n      self.suite = orig;\n      fn(errSuite);\n    }\n  }\n  function next(err, errSuite) {\n    // if we bail after first err\n    if (self.failures && suite._bail) {\n      tests = [];\n    }\n    if (self._abort) {\n      return fn();\n    }\n    if (err) {\n      return hookErr(err, errSuite, true);\n    }\n\n    // next test\n    test = tests.shift();\n\n    // all done\n    if (!test) {\n      return fn();\n    }\n\n    // grep\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) {\n      match = !match;\n    }\n    if (!match) {\n      // Run immediately only if we have defined a grep. When we\n      // define a grep â€” It can cause maximum callstack error if\n      // the grep is doing a large recursive loop by neglecting\n      // all tests. The run immediately function also comes with\n      // a performance cost. So we don't want to run immediately\n      // if we run the whole test suite, because running the whole\n      // test suite don't do any immediate recursive loops. Thus,\n      // allowing a JS runtime to breathe.\n      if (self._grep !== self._defaultGrep) {\n        Runner.immediately(next);\n      } else {\n        next();\n      }\n      return;\n    }\n\n    // static skip, no hooks are executed\n    if (test.isPending()) {\n      if (self.forbidPending) {\n        self.fail(test, new Error('Pending test forbidden'), true);\n      } else {\n        test.state = STATE_PENDING;\n        self.emit(constants.EVENT_TEST_PENDING, test);\n      }\n      self.emit(constants.EVENT_TEST_END, test);\n      return next();\n    }\n\n    // execute test and hook(s)\n    self.emit(constants.EVENT_TEST_BEGIN, self.test = test);\n    self.hookDown(HOOK_TYPE_BEFORE_EACH, function (err, errSuite) {\n      // conditional skip within beforeEach\n      if (test.isPending()) {\n        if (self.forbidPending) {\n          self.fail(test, new Error('Pending test forbidden'), true);\n        } else {\n          test.state = STATE_PENDING;\n          self.emit(constants.EVENT_TEST_PENDING, test);\n        }\n        self.emit(constants.EVENT_TEST_END, test);\n        // skip inner afterEach hooks below errSuite level\n        var origSuite = self.suite;\n        self.suite = errSuite || self.suite;\n        return self.hookUp(HOOK_TYPE_AFTER_EACH, function (e, eSuite) {\n          self.suite = origSuite;\n          next(e, eSuite);\n        });\n      }\n      if (err) {\n        return hookErr(err, errSuite, false);\n      }\n      self.currentRunnable = self.test;\n      self.runTest(function (err) {\n        test = self.test;\n        // conditional skip within it\n        if (test.pending) {\n          if (self.forbidPending) {\n            self.fail(test, new Error('Pending test forbidden'), true);\n          } else {\n            test.state = STATE_PENDING;\n            self.emit(constants.EVENT_TEST_PENDING, test);\n          }\n          self.emit(constants.EVENT_TEST_END, test);\n          return self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n        } else if (err) {\n          var retry = test.currentRetry();\n          if (retry < test.retries()) {\n            var clonedTest = test.clone();\n            clonedTest.currentRetry(retry + 1);\n            tests.unshift(clonedTest);\n            self.emit(constants.EVENT_TEST_RETRY, test, err);\n\n            // Early return + hook trigger so that it doesn't\n            // increment the count wrong\n            return self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n          } else {\n            self.fail(test, err);\n          }\n          self.emit(constants.EVENT_TEST_END, test);\n          return self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n        }\n        test.state = STATE_PASSED;\n        self.emit(constants.EVENT_TEST_PASS, test);\n        self.emit(constants.EVENT_TEST_END, test);\n        self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n      });\n    });\n  }\n  this.next = next;\n  this.hookErr = hookErr;\n  next();\n};\n\n/**\n * Run the given `suite` and invoke the callback `fn()` when complete.\n *\n * @private\n * @param {Suite} suite\n * @param {Function} fn\n */\nRunner.prototype.runSuite = function (suite, fn) {\n  var i = 0;\n  var self = this;\n  var total = this.grepTotal(suite);\n  debug('runSuite(): running %s', suite.fullTitle());\n  if (!total || self.failures && suite._bail) {\n    debug('runSuite(): bailing');\n    return fn();\n  }\n  this.emit(constants.EVENT_SUITE_BEGIN, this.suite = suite);\n  function next(errSuite) {\n    if (errSuite) {\n      // current suite failed on a hook from errSuite\n      if (errSuite === suite) {\n        // if errSuite is current suite\n        // continue to the next sibling suite\n        return done();\n      }\n      // errSuite is among the parents of current suite\n      // stop execution of errSuite and all sub-suites\n      return done(errSuite);\n    }\n    if (self._abort) {\n      return done();\n    }\n    var curr = suite.suites[i++];\n    if (!curr) {\n      return done();\n    }\n\n    // Avoid grep neglecting large number of tests causing a\n    // huge recursive loop and thus a maximum call stack error.\n    // See comment in `this.runTests()` for more information.\n    if (self._grep !== self._defaultGrep) {\n      Runner.immediately(function () {\n        self.runSuite(curr, next);\n      });\n    } else {\n      self.runSuite(curr, next);\n    }\n  }\n  function done(errSuite) {\n    self.suite = suite;\n    self.nextSuite = next;\n\n    // remove reference to test\n    delete self.test;\n    self.hook(HOOK_TYPE_AFTER_ALL, function () {\n      self.emit(constants.EVENT_SUITE_END, suite);\n      fn(errSuite);\n    });\n  }\n  this.nextSuite = next;\n  this.hook(HOOK_TYPE_BEFORE_ALL, function (err) {\n    if (err) {\n      return done();\n    }\n    self.runTests(suite, next);\n  });\n};\n\n/**\n * Handle uncaught exceptions within runner.\n *\n * This function is bound to the instance as `Runner#uncaught` at instantiation\n * time. It's intended to be listening on the `Process.uncaughtException` event.\n * In order to not leak EE listeners, we need to ensure no more than a single\n * `uncaughtException` listener exists per `Runner`.  The only way to do\n * this--because this function needs the context (and we don't have lambdas)--is\n * to use `Function.prototype.bind`. We need strict equality to unregister and\n * _only_ unregister the _one_ listener we set from the\n * `Process.uncaughtException` event; would be poor form to just remove\n * everything. See {@link Runner#run} for where the event listener is registered\n * and unregistered.\n * @param {Error} err - Some uncaught error\n * @private\n */\nRunner.prototype._uncaught = function (err) {\n  // this is defensive to prevent future developers from mis-calling this function.\n  // it's more likely that it'd be called with the incorrect context--say, the global\n  // `process` object--than it would to be called with a context that is not a \"subclass\"\n  // of `Runner`.\n  if (!(this instanceof Runner)) {\n    throw createFatalError('Runner#uncaught() called with invalid context', this);\n  }\n  if (err instanceof Pending) {\n    debug('uncaught(): caught a Pending');\n    return;\n  }\n  // browser does not exit script when throwing in global.onerror()\n  if (this.allowUncaught && !utils.isBrowser()) {\n    debug('uncaught(): bubbling exception due to --allow-uncaught');\n    throw err;\n  }\n  if (this.state === constants.STATE_STOPPED) {\n    debug('uncaught(): throwing after run has completed!');\n    throw err;\n  }\n  if (err) {\n    debug('uncaught(): got truthy exception %O', err);\n  } else {\n    debug('uncaught(): undefined/falsy exception');\n    err = createInvalidExceptionError('Caught falsy/undefined exception which would otherwise be uncaught. No stack trace found; try a debugger', err);\n  }\n  if (!isError(err)) {\n    err = thrown2Error(err);\n    debug('uncaught(): converted \"error\" %o to Error', err);\n  }\n  err.uncaught = true;\n  var runnable = this.currentRunnable;\n  if (!runnable) {\n    runnable = new Runnable('Uncaught error outside test suite');\n    debug('uncaught(): no current Runnable; created a phony one');\n    runnable.parent = this.suite;\n    if (this.state === constants.STATE_RUNNING) {\n      debug('uncaught(): failing gracefully');\n      this.fail(runnable, err);\n    } else {\n      // Can't recover from this failure\n      debug('uncaught(): test run has not yet started; unrecoverable');\n      this.emit(constants.EVENT_RUN_BEGIN);\n      this.fail(runnable, err);\n      this.emit(constants.EVENT_RUN_END);\n    }\n    return;\n  }\n  runnable.clearTimeout();\n  if (runnable.isFailed()) {\n    debug('uncaught(): Runnable has already failed');\n    // Ignore error if already failed\n    return;\n  } else if (runnable.isPending()) {\n    debug('uncaught(): pending Runnable wound up failing!');\n    // report 'pending test' retrospectively as failed\n    this.fail(runnable, err, true);\n    return;\n  }\n\n  // we cannot recover gracefully if a Runnable has already passed\n  // then fails asynchronously\n  if (runnable.isPassed()) {\n    debug('uncaught(): Runnable has already passed; bailing gracefully');\n    this.fail(runnable, err);\n    this.abort();\n  } else {\n    debug('uncaught(): forcing Runnable to complete with Error');\n    return runnable.callback(err);\n  }\n};\n\n/**\n * Run the root suite and invoke `fn(failures)`\n * on completion.\n *\n * @public\n * @memberof Runner\n * @param {Function} fn - Callback when finished\n * @param {Object} [opts] - For subclasses\n * @param {string[]} opts.files - Files to run\n * @param {Options} opts.options - command-line options\n * @returns {Runner} Runner instance.\n */\nRunner.prototype.run = function (fn, opts = {}) {\n  var rootSuite = this.suite;\n  var options = opts.options || {};\n  debug('run(): got options: %O', options);\n  fn = fn || function () {};\n  const end = () => {\n    if (!this.total && this._opts.failZero) this.failures = 1;\n    debug('run(): root suite completed; emitting %s', constants.EVENT_RUN_END);\n    this.emit(constants.EVENT_RUN_END);\n  };\n  const begin = () => {\n    debug('run(): emitting %s', constants.EVENT_RUN_BEGIN);\n    this.emit(constants.EVENT_RUN_BEGIN);\n    debug('run(): emitted %s', constants.EVENT_RUN_BEGIN);\n    this.runSuite(rootSuite, end);\n  };\n  const prepare = () => {\n    debug('run(): starting');\n    // If there is an `only` filter\n    if (rootSuite.hasOnly()) {\n      rootSuite.filterOnly();\n      debug('run(): filtered exclusive Runnables');\n    }\n    this.state = constants.STATE_RUNNING;\n    if (this._opts.delay) {\n      this.emit(constants.EVENT_DELAY_END);\n      debug('run(): \"delay\" ended');\n    }\n    return begin();\n  };\n\n  // references cleanup to avoid memory leaks\n  if (this._opts.cleanReferencesAfterRun) {\n    this.on(constants.EVENT_SUITE_END, suite => {\n      suite.cleanReferences();\n    });\n  }\n\n  // callback\n  this.on(constants.EVENT_RUN_END, function () {\n    this.state = constants.STATE_STOPPED;\n    debug('run(): emitted %s', constants.EVENT_RUN_END);\n    fn(this.failures);\n  });\n  this._removeEventListener(process, 'uncaughtException', this.uncaught);\n  this._removeEventListener(process, 'unhandledRejection', this.unhandled);\n  this._addEventListener(process, 'uncaughtException', this.uncaught);\n  this._addEventListener(process, 'unhandledRejection', this.unhandled);\n  if (this._opts.delay) {\n    // for reporters, I guess.\n    // might be nice to debounce some dots while we wait.\n    this.emit(constants.EVENT_DELAY_BEGIN, rootSuite);\n    rootSuite.once(EVENT_ROOT_SUITE_RUN, prepare);\n    debug('run(): waiting for green light due to --delay');\n  } else {\n    Runner.immediately(prepare);\n  }\n  return this;\n};\n\n/**\n * Toggle partial object linking behavior; used for building object references from\n * unique ID's. Does nothing in serial mode, because the object references already exist.\n * Subclasses can implement this (e.g., `ParallelBufferedRunner`)\n * @abstract\n * @param {boolean} [value] - If `true`, enable partial object linking, otherwise disable\n * @returns {Runner}\n * @chainable\n * @public\n * @example\n * // this reporter needs proper object references when run in parallel mode\n * class MyReporter() {\n *   constructor(runner) {\n *     this.runner.linkPartialObjects(true)\n *       .on(EVENT_SUITE_BEGIN, suite => {\n           // this Suite may be the same object...\n *       })\n *       .on(EVENT_TEST_BEGIN, test => {\n *         // ...as the `test.parent` property\n *       });\n *   }\n * }\n */\nRunner.prototype.linkPartialObjects = function (value) {\n  return this;\n};\n\n/*\n * Like {@link Runner#run}, but does not accept a callback and returns a `Promise` instead of a `Runner`.\n * This function cannot reject; an `unhandledRejection` event will bubble up to the `process` object instead.\n * @public\n * @memberof Runner\n * @param {Object} [opts] - Options for {@link Runner#run}\n * @returns {Promise<number>} Failure count\n */\nRunner.prototype.runAsync = async function runAsync(opts = {}) {\n  return new Promise(resolve => {\n    this.run(resolve, opts);\n  });\n};\n\n/**\n * Cleanly abort execution.\n *\n * @memberof Runner\n * @public\n * @return {Runner} Runner instance.\n */\nRunner.prototype.abort = function () {\n  debug('abort(): aborting');\n  this._abort = true;\n  return this;\n};\n\n/**\n * Returns `true` if Mocha is running in parallel mode.  For reporters.\n *\n * Subclasses should return an appropriate value.\n * @public\n * @returns {false}\n */\nRunner.prototype.isParallelMode = function isParallelMode() {\n  return false;\n};\n\n/**\n * Configures an alternate reporter for worker processes to use. Subclasses\n * using worker processes should implement this.\n * @public\n * @param {string} path - Absolute path to alternate reporter for worker processes to use\n * @returns {Runner}\n * @throws When in serial mode\n * @chainable\n * @abstract\n */\nRunner.prototype.workerReporter = function () {\n  throw createUnsupportedError('workerReporter() not supported in serial mode');\n};\n\n/**\n * Filter leaks with the given globals flagged as `ok`.\n *\n * @private\n * @param {Array} ok\n * @param {Array} globals\n * @return {Array}\n */\nfunction filterLeaks(ok, globals) {\n  return globals.filter(function (key) {\n    // Firefox and Chrome exposes iframes as index inside the window object\n    if (/^\\d+/.test(key)) {\n      return false;\n    }\n\n    // in firefox\n    // if runner runs in an iframe, this iframe's window.getInterface method\n    // not init at first it is assigned in some seconds\n    if (global.navigator && /^getInterface/.test(key)) {\n      return false;\n    }\n\n    // an iframe could be approached by window[iframeIndex]\n    // in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak\n    if (global.navigator && /^\\d+/.test(key)) {\n      return false;\n    }\n\n    // Opera and IE expose global variables for HTML element IDs (issue #243)\n    if (/^mocha-/.test(key)) {\n      return false;\n    }\n    var matched = ok.filter(function (ok) {\n      if (~ok.indexOf('*')) {\n        return key.indexOf(ok.split('*')[0]) === 0;\n      }\n      return key === ok;\n    });\n    return !matched.length && (!global.navigator || key !== 'onerror');\n  });\n}\n\n/**\n * Check if argument is an instance of Error object or a duck-typed equivalent.\n *\n * @private\n * @param {Object} err - object to check\n * @param {string} err.message - error message\n * @returns {boolean}\n */\nfunction isError(err) {\n  return err instanceof Error || err && typeof err.message === 'string';\n}\n\n/**\n *\n * Converts thrown non-extensible type into proper Error.\n *\n * @private\n * @param {*} thrown - Non-extensible type thrown by code\n * @return {Error}\n */\nfunction thrown2Error(err) {\n  return new Error(`the ${utils.canonicalType(err)} ${stringify(err)} was thrown, throw an Error :)`);\n}\nRunner.constants = constants;\n\n/**\n * Node.js' `EventEmitter`\n * @external EventEmitter\n * @see {@link https://nodejs.org/api/events.html#events_class_eventemitter}\n */\n\nmodule.exports = Runner;","map":{"version":3,"names":["EventEmitter","require","Pending","utils","debug","Runnable","Suite","HOOK_TYPE_BEFORE_EACH","constants","HOOK_TYPE_AFTER_EACH","HOOK_TYPE_AFTER_ALL","HOOK_TYPE_BEFORE_ALL","EVENT_ROOT_SUITE_RUN","STATE_FAILED","STATE_PASSED","STATE_PENDING","stackFilter","stackTraceFilter","stringify","createInvalidExceptionError","createUnsupportedError","createFatalError","isMochaError","errorConstants","globals","defineConstants","EVENT_HOOK_BEGIN","EVENT_HOOK_END","EVENT_RUN_BEGIN","EVENT_DELAY_BEGIN","EVENT_DELAY_END","EVENT_RUN_END","EVENT_SUITE_BEGIN","EVENT_SUITE_END","EVENT_TEST_BEGIN","EVENT_TEST_END","EVENT_TEST_FAIL","EVENT_TEST_PASS","EVENT_TEST_PENDING","EVENT_TEST_RETRY","STATE_IDLE","STATE_RUNNING","STATE_STOPPED","Runner","constructor","suite","opts","self","_globals","_abort","_opts","state","total","failures","_eventListeners","Map","on","test","type","retriedTest","parent","idx","tests","indexOf","checkGlobals","hook","_defaultGrep","grep","globalProps","uncaught","_uncaught","bind","unhandled","reason","promise","_removeEventListener","process","emit","_addEventListener","immediately","global","setImmediate","nextTick","prototype","target","eventName","listener","listenerCount","has","get","targetListeners","targetEventListeners","Set","add","set","removeListener","delete","size","dispose","removeAllListeners","forEach","clear","re","invert","_grep","_invert","grepTotal","eachTest","match","fullTitle","props","Object","keys","i","length","push","arr","arguments","concat","checkLeaks","ok","leaks","_allowedGlobals","prevGlobalsLength","filterLeaks","msg","map","e","join","fail","Error","err","force","isPending","code","MULTIPLE_DONE","isError","thrown2Error","stack","fullStackTrace","ignore","name","fn","dryRun","hooks","getHooks","next","currentRunnable","ctx","currentTest","setHookTitle","allowUncaught","listeners","run","cbHookRun","testError","error","pending","suites","errForbid","originalTitle","title","parentTitle","root","orig","errSuite","pop","hookUp","parents","reverse","hookDown","runTest","asyncOnly","runTests","slice","hookErr","_","after","err2","errSuite2","_bail","shift","forbidPending","origSuite","eSuite","retry","currentRetry","retries","clonedTest","clone","unshift","runSuite","done","curr","nextSuite","isBrowser","runnable","clearTimeout","isFailed","isPassed","abort","callback","rootSuite","options","end","failZero","begin","prepare","hasOnly","filterOnly","delay","cleanReferencesAfterRun","cleanReferences","once","linkPartialObjects","value","runAsync","Promise","resolve","isParallelMode","workerReporter","filter","key","navigator","matched","split","message","canonicalType","module","exports"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/mocha/lib/runner.js"],"sourcesContent":["'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\nvar EventEmitter = require('events').EventEmitter;\nvar Pending = require('./pending');\nvar utils = require('./utils');\nvar debug = require('debug')('mocha:runner');\nvar Runnable = require('./runnable');\nvar Suite = require('./suite');\nvar HOOK_TYPE_BEFORE_EACH = Suite.constants.HOOK_TYPE_BEFORE_EACH;\nvar HOOK_TYPE_AFTER_EACH = Suite.constants.HOOK_TYPE_AFTER_EACH;\nvar HOOK_TYPE_AFTER_ALL = Suite.constants.HOOK_TYPE_AFTER_ALL;\nvar HOOK_TYPE_BEFORE_ALL = Suite.constants.HOOK_TYPE_BEFORE_ALL;\nvar EVENT_ROOT_SUITE_RUN = Suite.constants.EVENT_ROOT_SUITE_RUN;\nvar STATE_FAILED = Runnable.constants.STATE_FAILED;\nvar STATE_PASSED = Runnable.constants.STATE_PASSED;\nvar STATE_PENDING = Runnable.constants.STATE_PENDING;\nvar stackFilter = utils.stackTraceFilter();\nvar stringify = utils.stringify;\n\nconst {\n  createInvalidExceptionError,\n  createUnsupportedError,\n  createFatalError,\n  isMochaError,\n  constants: errorConstants\n} = require('./errors');\n\n/**\n * Non-enumerable globals.\n * @private\n * @readonly\n */\nvar globals = [\n  'setTimeout',\n  'clearTimeout',\n  'setInterval',\n  'clearInterval',\n  'XMLHttpRequest',\n  'Date',\n  'setImmediate',\n  'clearImmediate'\n];\n\nvar constants = utils.defineConstants(\n  /**\n   * {@link Runner}-related constants.\n   * @public\n   * @memberof Runner\n   * @readonly\n   * @alias constants\n   * @static\n   * @enum {string}\n   */\n  {\n    /**\n     * Emitted when {@link Hook} execution begins\n     */\n    EVENT_HOOK_BEGIN: 'hook',\n    /**\n     * Emitted when {@link Hook} execution ends\n     */\n    EVENT_HOOK_END: 'hook end',\n    /**\n     * Emitted when Root {@link Suite} execution begins (all files have been parsed and hooks/tests are ready for execution)\n     */\n    EVENT_RUN_BEGIN: 'start',\n    /**\n     * Emitted when Root {@link Suite} execution has been delayed via `delay` option\n     */\n    EVENT_DELAY_BEGIN: 'waiting',\n    /**\n     * Emitted when delayed Root {@link Suite} execution is triggered by user via `global.run()`\n     */\n    EVENT_DELAY_END: 'ready',\n    /**\n     * Emitted when Root {@link Suite} execution ends\n     */\n    EVENT_RUN_END: 'end',\n    /**\n     * Emitted when {@link Suite} execution begins\n     */\n    EVENT_SUITE_BEGIN: 'suite',\n    /**\n     * Emitted when {@link Suite} execution ends\n     */\n    EVENT_SUITE_END: 'suite end',\n    /**\n     * Emitted when {@link Test} execution begins\n     */\n    EVENT_TEST_BEGIN: 'test',\n    /**\n     * Emitted when {@link Test} execution ends\n     */\n    EVENT_TEST_END: 'test end',\n    /**\n     * Emitted when {@link Test} execution fails\n     */\n    EVENT_TEST_FAIL: 'fail',\n    /**\n     * Emitted when {@link Test} execution succeeds\n     */\n    EVENT_TEST_PASS: 'pass',\n    /**\n     * Emitted when {@link Test} becomes pending\n     */\n    EVENT_TEST_PENDING: 'pending',\n    /**\n     * Emitted when {@link Test} execution has failed, but will retry\n     */\n    EVENT_TEST_RETRY: 'retry',\n    /**\n     * Initial state of Runner\n     */\n    STATE_IDLE: 'idle',\n    /**\n     * State set to this value when the Runner has started running\n     */\n    STATE_RUNNING: 'running',\n    /**\n     * State set to this value when the Runner has stopped\n     */\n    STATE_STOPPED: 'stopped'\n  }\n);\n\nclass Runner extends EventEmitter {\n  /**\n   * Initialize a `Runner` at the Root {@link Suite}, which represents a hierarchy of {@link Suite|Suites} and {@link Test|Tests}.\n   *\n   * @extends external:EventEmitter\n   * @public\n   * @class\n   * @param {Suite} suite - Root suite\n   * @param {Object} [opts] - Settings object\n   * @param {boolean} [opts.cleanReferencesAfterRun] - Whether to clean references to test fns and hooks when a suite is done.\n   * @param {boolean} [opts.delay] - Whether to delay execution of root suite until ready.\n   * @param {boolean} [opts.dryRun] - Whether to report tests without running them.\n   * @param {boolean} [opts.failZero] - Whether to fail test run if zero tests encountered.\n   */\n  constructor(suite, opts = {}) {\n    super();\n\n    var self = this;\n    this._globals = [];\n    this._abort = false;\n    this.suite = suite;\n    this._opts = opts;\n    this.state = constants.STATE_IDLE;\n    this.total = suite.total();\n    this.failures = 0;\n    /**\n     * @type {Map<EventEmitter,Map<string,Set<EventListener>>>}\n     */\n    this._eventListeners = new Map();\n    this.on(constants.EVENT_TEST_END, function (test) {\n      if (test.type === 'test' && test.retriedTest() && test.parent) {\n        var idx =\n          test.parent.tests && test.parent.tests.indexOf(test.retriedTest());\n        if (idx > -1) test.parent.tests[idx] = test;\n      }\n      self.checkGlobals(test);\n    });\n    this.on(constants.EVENT_HOOK_END, function (hook) {\n      self.checkGlobals(hook);\n    });\n    this._defaultGrep = /.*/;\n    this.grep(this._defaultGrep);\n    this.globals(this.globalProps());\n\n    this.uncaught = this._uncaught.bind(this);\n    this.unhandled = (reason, promise) => {\n      if (isMochaError(reason)) {\n        debug(\n          'trapped unhandled rejection coming out of Mocha; forwarding to uncaught handler:',\n          reason\n        );\n        this.uncaught(reason);\n      } else {\n        debug(\n          'trapped unhandled rejection from (probably) user code; re-emitting on process'\n        );\n        this._removeEventListener(\n          process,\n          'unhandledRejection',\n          this.unhandled\n        );\n        try {\n          process.emit('unhandledRejection', reason, promise);\n        } finally {\n          this._addEventListener(process, 'unhandledRejection', this.unhandled);\n        }\n      }\n    };\n  }\n}\n\n/**\n * Wrapper for setImmediate, process.nextTick, or browser polyfill.\n *\n * @param {Function} fn\n * @private\n */\nRunner.immediately = global.setImmediate || process.nextTick;\n\n/**\n * Replacement for `target.on(eventName, listener)` that does bookkeeping to remove them when this runner instance is disposed.\n * @param {EventEmitter} target - The `EventEmitter`\n * @param {string} eventName - The event name\n * @param {string} fn - Listener function\n * @private\n */\nRunner.prototype._addEventListener = function (target, eventName, listener) {\n  debug(\n    '_addEventListener(): adding for event %s; %d current listeners',\n    eventName,\n    target.listenerCount(eventName)\n  );\n  /* istanbul ignore next */\n  if (\n    this._eventListeners.has(target) &&\n    this._eventListeners.get(target).has(eventName) &&\n    this._eventListeners.get(target).get(eventName).has(listener)\n  ) {\n    debug(\n      'warning: tried to attach duplicate event listener for %s',\n      eventName\n    );\n    return;\n  }\n  target.on(eventName, listener);\n  const targetListeners = this._eventListeners.has(target)\n    ? this._eventListeners.get(target)\n    : new Map();\n  const targetEventListeners = targetListeners.has(eventName)\n    ? targetListeners.get(eventName)\n    : new Set();\n  targetEventListeners.add(listener);\n  targetListeners.set(eventName, targetEventListeners);\n  this._eventListeners.set(target, targetListeners);\n};\n\n/**\n * Replacement for `target.removeListener(eventName, listener)` that also updates the bookkeeping.\n * @param {EventEmitter} target - The `EventEmitter`\n * @param {string} eventName - The event name\n * @param {function} listener - Listener function\n * @private\n */\nRunner.prototype._removeEventListener = function (target, eventName, listener) {\n  target.removeListener(eventName, listener);\n\n  if (this._eventListeners.has(target)) {\n    const targetListeners = this._eventListeners.get(target);\n    if (targetListeners.has(eventName)) {\n      const targetEventListeners = targetListeners.get(eventName);\n      targetEventListeners.delete(listener);\n      if (!targetEventListeners.size) {\n        targetListeners.delete(eventName);\n      }\n    }\n    if (!targetListeners.size) {\n      this._eventListeners.delete(target);\n    }\n  } else {\n    debug('trying to remove listener for untracked object %s', target);\n  }\n};\n\n/**\n * Removes all event handlers set during a run on this instance.\n * Remark: this does _not_ clean/dispose the tests or suites themselves.\n */\nRunner.prototype.dispose = function () {\n  this.removeAllListeners();\n  this._eventListeners.forEach((targetListeners, target) => {\n    targetListeners.forEach((targetEventListeners, eventName) => {\n      targetEventListeners.forEach(listener => {\n        target.removeListener(eventName, listener);\n      });\n    });\n  });\n  this._eventListeners.clear();\n};\n\n/**\n * Run tests with full titles matching `re`. Updates runner.total\n * with number of tests matched.\n *\n * @public\n * @memberof Runner\n * @param {RegExp} re\n * @param {boolean} invert\n * @return {Runner} Runner instance.\n */\nRunner.prototype.grep = function (re, invert) {\n  debug('grep(): setting to %s', re);\n  this._grep = re;\n  this._invert = invert;\n  this.total = this.grepTotal(this.suite);\n  return this;\n};\n\n/**\n * Returns the number of tests matching the grep search for the\n * given suite.\n *\n * @memberof Runner\n * @public\n * @param {Suite} suite\n * @return {number}\n */\nRunner.prototype.grepTotal = function (suite) {\n  var self = this;\n  var total = 0;\n\n  suite.eachTest(function (test) {\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) {\n      match = !match;\n    }\n    if (match) {\n      total++;\n    }\n  });\n\n  return total;\n};\n\n/**\n * Return a list of global properties.\n *\n * @return {Array}\n * @private\n */\nRunner.prototype.globalProps = function () {\n  var props = Object.keys(global);\n\n  // non-enumerables\n  for (var i = 0; i < globals.length; ++i) {\n    if (~props.indexOf(globals[i])) {\n      continue;\n    }\n    props.push(globals[i]);\n  }\n\n  return props;\n};\n\n/**\n * Allow the given `arr` of globals.\n *\n * @public\n * @memberof Runner\n * @param {Array} arr\n * @return {Runner} Runner instance.\n */\nRunner.prototype.globals = function (arr) {\n  if (!arguments.length) {\n    return this._globals;\n  }\n  debug('globals(): setting to %O', arr);\n  this._globals = this._globals.concat(arr);\n  return this;\n};\n\n/**\n * Check for global variable leaks.\n *\n * @private\n */\nRunner.prototype.checkGlobals = function (test) {\n  if (!this.checkLeaks) {\n    return;\n  }\n  var ok = this._globals;\n\n  var globals = this.globalProps();\n  var leaks;\n\n  if (test) {\n    ok = ok.concat(test._allowedGlobals || []);\n  }\n\n  if (this.prevGlobalsLength === globals.length) {\n    return;\n  }\n  this.prevGlobalsLength = globals.length;\n\n  leaks = filterLeaks(ok, globals);\n  this._globals = this._globals.concat(leaks);\n\n  if (leaks.length) {\n    var msg = `global leak(s) detected: ${leaks.map(e => `'${e}'`).join(', ')}`;\n    this.fail(test, new Error(msg));\n  }\n};\n\n/**\n * Fail the given `test`.\n *\n * If `test` is a hook, failures work in the following pattern:\n * - If bail, run corresponding `after each` and `after` hooks,\n *   then exit\n * - Failed `before` hook skips all tests in a suite and subsuites,\n *   but jumps to corresponding `after` hook\n * - Failed `before each` hook skips remaining tests in a\n *   suite and jumps to corresponding `after each` hook,\n *   which is run only once\n * - Failed `after` hook does not alter execution order\n * - Failed `after each` hook skips remaining tests in a\n *   suite and subsuites, but executes other `after each`\n *   hooks\n *\n * @private\n * @param {Runnable} test\n * @param {Error} err\n * @param {boolean} [force=false] - Whether to fail a pending test.\n */\nRunner.prototype.fail = function (test, err, force) {\n  force = force === true;\n  if (test.isPending() && !force) {\n    return;\n  }\n  if (this.state === constants.STATE_STOPPED) {\n    if (err.code === errorConstants.MULTIPLE_DONE) {\n      throw err;\n    }\n    throw createFatalError(\n      'Test failed after root suite execution completed!',\n      err\n    );\n  }\n\n  ++this.failures;\n  debug('total number of failures: %d', this.failures);\n  test.state = STATE_FAILED;\n\n  if (!isError(err)) {\n    err = thrown2Error(err);\n  }\n\n  try {\n    err.stack =\n      this.fullStackTrace || !err.stack ? err.stack : stackFilter(err.stack);\n  } catch (ignore) {\n    // some environments do not take kindly to monkeying with the stack\n  }\n\n  this.emit(constants.EVENT_TEST_FAIL, test, err);\n};\n\n/**\n * Run hook `name` callbacks and then invoke `fn()`.\n *\n * @private\n * @param {string} name\n * @param {Function} fn\n */\n\nRunner.prototype.hook = function (name, fn) {\n  if (this._opts.dryRun) return fn();\n\n  var suite = this.suite;\n  var hooks = suite.getHooks(name);\n  var self = this;\n\n  function next(i) {\n    var hook = hooks[i];\n    if (!hook) {\n      return fn();\n    }\n    self.currentRunnable = hook;\n\n    if (name === HOOK_TYPE_BEFORE_ALL) {\n      hook.ctx.currentTest = hook.parent.tests[0];\n    } else if (name === HOOK_TYPE_AFTER_ALL) {\n      hook.ctx.currentTest = hook.parent.tests[hook.parent.tests.length - 1];\n    } else {\n      hook.ctx.currentTest = self.test;\n    }\n\n    setHookTitle(hook);\n\n    hook.allowUncaught = self.allowUncaught;\n\n    self.emit(constants.EVENT_HOOK_BEGIN, hook);\n\n    if (!hook.listeners('error').length) {\n      self._addEventListener(hook, 'error', function (err) {\n        self.fail(hook, err);\n      });\n    }\n\n    hook.run(function cbHookRun(err) {\n      var testError = hook.error();\n      if (testError) {\n        self.fail(self.test, testError);\n      }\n      // conditional skip\n      if (hook.pending) {\n        if (name === HOOK_TYPE_AFTER_EACH) {\n          // TODO define and implement use case\n          if (self.test) {\n            self.test.pending = true;\n          }\n        } else if (name === HOOK_TYPE_BEFORE_EACH) {\n          if (self.test) {\n            self.test.pending = true;\n          }\n          self.emit(constants.EVENT_HOOK_END, hook);\n          hook.pending = false; // activates hook for next test\n          return fn(new Error('abort hookDown'));\n        } else if (name === HOOK_TYPE_BEFORE_ALL) {\n          suite.tests.forEach(function (test) {\n            test.pending = true;\n          });\n          suite.suites.forEach(function (suite) {\n            suite.pending = true;\n          });\n          hooks = [];\n        } else {\n          hook.pending = false;\n          var errForbid = createUnsupportedError('`this.skip` forbidden');\n          self.fail(hook, errForbid);\n          return fn(errForbid);\n        }\n      } else if (err) {\n        self.fail(hook, err);\n        // stop executing hooks, notify callee of hook err\n        return fn(err);\n      }\n      self.emit(constants.EVENT_HOOK_END, hook);\n      delete hook.ctx.currentTest;\n      setHookTitle(hook);\n      next(++i);\n    });\n\n    function setHookTitle(hook) {\n      hook.originalTitle = hook.originalTitle || hook.title;\n      if (hook.ctx && hook.ctx.currentTest) {\n        hook.title = `${hook.originalTitle} for \"${hook.ctx.currentTest.title}\"`;\n      } else {\n        var parentTitle;\n        if (hook.parent.title) {\n          parentTitle = hook.parent.title;\n        } else {\n          parentTitle = hook.parent.root ? '{root}' : '';\n        }\n        hook.title = `${hook.originalTitle} in \"${parentTitle}\"`;\n      }\n    }\n  }\n\n  Runner.immediately(function () {\n    next(0);\n  });\n};\n\n/**\n * Run hook `name` for the given array of `suites`\n * in order, and callback `fn(err, errSuite)`.\n *\n * @private\n * @param {string} name\n * @param {Array} suites\n * @param {Function} fn\n */\nRunner.prototype.hooks = function (name, suites, fn) {\n  var self = this;\n  var orig = this.suite;\n\n  function next(suite) {\n    self.suite = suite;\n\n    if (!suite) {\n      self.suite = orig;\n      return fn();\n    }\n\n    self.hook(name, function (err) {\n      if (err) {\n        var errSuite = self.suite;\n        self.suite = orig;\n        return fn(err, errSuite);\n      }\n\n      next(suites.pop());\n    });\n  }\n\n  next(suites.pop());\n};\n\n/**\n * Run 'afterEach' hooks from bottom up.\n *\n * @param {String} name\n * @param {Function} fn\n * @private\n */\nRunner.prototype.hookUp = function (name, fn) {\n  var suites = [this.suite].concat(this.parents()).reverse();\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Run 'beforeEach' hooks from top level down.\n *\n * @param {String} name\n * @param {Function} fn\n * @private\n */\nRunner.prototype.hookDown = function (name, fn) {\n  var suites = [this.suite].concat(this.parents());\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Return an array of parent Suites from\n * closest to furthest.\n *\n * @return {Array}\n * @private\n */\nRunner.prototype.parents = function () {\n  var suite = this.suite;\n  var suites = [];\n  while (suite.parent) {\n    suite = suite.parent;\n    suites.push(suite);\n  }\n  return suites;\n};\n\n/**\n * Run the current test and callback `fn(err)`.\n *\n * @param {Function} fn\n * @private\n */\nRunner.prototype.runTest = function (fn) {\n  if (this._opts.dryRun) return Runner.immediately(fn);\n\n  var self = this;\n  var test = this.test;\n\n  if (!test) {\n    return;\n  }\n\n  if (this.asyncOnly) {\n    test.asyncOnly = true;\n  }\n  this._addEventListener(test, 'error', function (err) {\n    self.fail(test, err);\n  });\n  if (this.allowUncaught) {\n    test.allowUncaught = true;\n    return test.run(fn);\n  }\n  try {\n    test.run(fn);\n  } catch (err) {\n    fn(err);\n  }\n};\n\n/**\n * Run tests in the given `suite` and invoke the callback `fn()` when complete.\n *\n * @private\n * @param {Suite} suite\n * @param {Function} fn\n */\nRunner.prototype.runTests = function (suite, fn) {\n  var self = this;\n  var tests = suite.tests.slice();\n  var test;\n\n  function hookErr(_, errSuite, after) {\n    // before/after Each hook for errSuite failed:\n    var orig = self.suite;\n\n    // for failed 'after each' hook start from errSuite parent,\n    // otherwise start from errSuite itself\n    self.suite = after ? errSuite.parent : errSuite;\n\n    if (self.suite) {\n      self.hookUp(HOOK_TYPE_AFTER_EACH, function (err2, errSuite2) {\n        self.suite = orig;\n        // some hooks may fail even now\n        if (err2) {\n          return hookErr(err2, errSuite2, true);\n        }\n        // report error suite\n        fn(errSuite);\n      });\n    } else {\n      // there is no need calling other 'after each' hooks\n      self.suite = orig;\n      fn(errSuite);\n    }\n  }\n\n  function next(err, errSuite) {\n    // if we bail after first err\n    if (self.failures && suite._bail) {\n      tests = [];\n    }\n\n    if (self._abort) {\n      return fn();\n    }\n\n    if (err) {\n      return hookErr(err, errSuite, true);\n    }\n\n    // next test\n    test = tests.shift();\n\n    // all done\n    if (!test) {\n      return fn();\n    }\n\n    // grep\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) {\n      match = !match;\n    }\n    if (!match) {\n      // Run immediately only if we have defined a grep. When we\n      // define a grep â€” It can cause maximum callstack error if\n      // the grep is doing a large recursive loop by neglecting\n      // all tests. The run immediately function also comes with\n      // a performance cost. So we don't want to run immediately\n      // if we run the whole test suite, because running the whole\n      // test suite don't do any immediate recursive loops. Thus,\n      // allowing a JS runtime to breathe.\n      if (self._grep !== self._defaultGrep) {\n        Runner.immediately(next);\n      } else {\n        next();\n      }\n      return;\n    }\n\n    // static skip, no hooks are executed\n    if (test.isPending()) {\n      if (self.forbidPending) {\n        self.fail(test, new Error('Pending test forbidden'), true);\n      } else {\n        test.state = STATE_PENDING;\n        self.emit(constants.EVENT_TEST_PENDING, test);\n      }\n      self.emit(constants.EVENT_TEST_END, test);\n      return next();\n    }\n\n    // execute test and hook(s)\n    self.emit(constants.EVENT_TEST_BEGIN, (self.test = test));\n    self.hookDown(HOOK_TYPE_BEFORE_EACH, function (err, errSuite) {\n      // conditional skip within beforeEach\n      if (test.isPending()) {\n        if (self.forbidPending) {\n          self.fail(test, new Error('Pending test forbidden'), true);\n        } else {\n          test.state = STATE_PENDING;\n          self.emit(constants.EVENT_TEST_PENDING, test);\n        }\n        self.emit(constants.EVENT_TEST_END, test);\n        // skip inner afterEach hooks below errSuite level\n        var origSuite = self.suite;\n        self.suite = errSuite || self.suite;\n        return self.hookUp(HOOK_TYPE_AFTER_EACH, function (e, eSuite) {\n          self.suite = origSuite;\n          next(e, eSuite);\n        });\n      }\n      if (err) {\n        return hookErr(err, errSuite, false);\n      }\n      self.currentRunnable = self.test;\n      self.runTest(function (err) {\n        test = self.test;\n        // conditional skip within it\n        if (test.pending) {\n          if (self.forbidPending) {\n            self.fail(test, new Error('Pending test forbidden'), true);\n          } else {\n            test.state = STATE_PENDING;\n            self.emit(constants.EVENT_TEST_PENDING, test);\n          }\n          self.emit(constants.EVENT_TEST_END, test);\n          return self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n        } else if (err) {\n          var retry = test.currentRetry();\n          if (retry < test.retries()) {\n            var clonedTest = test.clone();\n            clonedTest.currentRetry(retry + 1);\n            tests.unshift(clonedTest);\n\n            self.emit(constants.EVENT_TEST_RETRY, test, err);\n\n            // Early return + hook trigger so that it doesn't\n            // increment the count wrong\n            return self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n          } else {\n            self.fail(test, err);\n          }\n          self.emit(constants.EVENT_TEST_END, test);\n          return self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n        }\n\n        test.state = STATE_PASSED;\n        self.emit(constants.EVENT_TEST_PASS, test);\n        self.emit(constants.EVENT_TEST_END, test);\n        self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n      });\n    });\n  }\n\n  this.next = next;\n  this.hookErr = hookErr;\n  next();\n};\n\n/**\n * Run the given `suite` and invoke the callback `fn()` when complete.\n *\n * @private\n * @param {Suite} suite\n * @param {Function} fn\n */\nRunner.prototype.runSuite = function (suite, fn) {\n  var i = 0;\n  var self = this;\n  var total = this.grepTotal(suite);\n\n  debug('runSuite(): running %s', suite.fullTitle());\n\n  if (!total || (self.failures && suite._bail)) {\n    debug('runSuite(): bailing');\n    return fn();\n  }\n\n  this.emit(constants.EVENT_SUITE_BEGIN, (this.suite = suite));\n\n  function next(errSuite) {\n    if (errSuite) {\n      // current suite failed on a hook from errSuite\n      if (errSuite === suite) {\n        // if errSuite is current suite\n        // continue to the next sibling suite\n        return done();\n      }\n      // errSuite is among the parents of current suite\n      // stop execution of errSuite and all sub-suites\n      return done(errSuite);\n    }\n\n    if (self._abort) {\n      return done();\n    }\n\n    var curr = suite.suites[i++];\n    if (!curr) {\n      return done();\n    }\n\n    // Avoid grep neglecting large number of tests causing a\n    // huge recursive loop and thus a maximum call stack error.\n    // See comment in `this.runTests()` for more information.\n    if (self._grep !== self._defaultGrep) {\n      Runner.immediately(function () {\n        self.runSuite(curr, next);\n      });\n    } else {\n      self.runSuite(curr, next);\n    }\n  }\n\n  function done(errSuite) {\n    self.suite = suite;\n    self.nextSuite = next;\n\n    // remove reference to test\n    delete self.test;\n\n    self.hook(HOOK_TYPE_AFTER_ALL, function () {\n      self.emit(constants.EVENT_SUITE_END, suite);\n      fn(errSuite);\n    });\n  }\n\n  this.nextSuite = next;\n\n  this.hook(HOOK_TYPE_BEFORE_ALL, function (err) {\n    if (err) {\n      return done();\n    }\n    self.runTests(suite, next);\n  });\n};\n\n/**\n * Handle uncaught exceptions within runner.\n *\n * This function is bound to the instance as `Runner#uncaught` at instantiation\n * time. It's intended to be listening on the `Process.uncaughtException` event.\n * In order to not leak EE listeners, we need to ensure no more than a single\n * `uncaughtException` listener exists per `Runner`.  The only way to do\n * this--because this function needs the context (and we don't have lambdas)--is\n * to use `Function.prototype.bind`. We need strict equality to unregister and\n * _only_ unregister the _one_ listener we set from the\n * `Process.uncaughtException` event; would be poor form to just remove\n * everything. See {@link Runner#run} for where the event listener is registered\n * and unregistered.\n * @param {Error} err - Some uncaught error\n * @private\n */\nRunner.prototype._uncaught = function (err) {\n  // this is defensive to prevent future developers from mis-calling this function.\n  // it's more likely that it'd be called with the incorrect context--say, the global\n  // `process` object--than it would to be called with a context that is not a \"subclass\"\n  // of `Runner`.\n  if (!(this instanceof Runner)) {\n    throw createFatalError(\n      'Runner#uncaught() called with invalid context',\n      this\n    );\n  }\n  if (err instanceof Pending) {\n    debug('uncaught(): caught a Pending');\n    return;\n  }\n  // browser does not exit script when throwing in global.onerror()\n  if (this.allowUncaught && !utils.isBrowser()) {\n    debug('uncaught(): bubbling exception due to --allow-uncaught');\n    throw err;\n  }\n\n  if (this.state === constants.STATE_STOPPED) {\n    debug('uncaught(): throwing after run has completed!');\n    throw err;\n  }\n\n  if (err) {\n    debug('uncaught(): got truthy exception %O', err);\n  } else {\n    debug('uncaught(): undefined/falsy exception');\n    err = createInvalidExceptionError(\n      'Caught falsy/undefined exception which would otherwise be uncaught. No stack trace found; try a debugger',\n      err\n    );\n  }\n\n  if (!isError(err)) {\n    err = thrown2Error(err);\n    debug('uncaught(): converted \"error\" %o to Error', err);\n  }\n  err.uncaught = true;\n\n  var runnable = this.currentRunnable;\n\n  if (!runnable) {\n    runnable = new Runnable('Uncaught error outside test suite');\n    debug('uncaught(): no current Runnable; created a phony one');\n    runnable.parent = this.suite;\n\n    if (this.state === constants.STATE_RUNNING) {\n      debug('uncaught(): failing gracefully');\n      this.fail(runnable, err);\n    } else {\n      // Can't recover from this failure\n      debug('uncaught(): test run has not yet started; unrecoverable');\n      this.emit(constants.EVENT_RUN_BEGIN);\n      this.fail(runnable, err);\n      this.emit(constants.EVENT_RUN_END);\n    }\n\n    return;\n  }\n\n  runnable.clearTimeout();\n\n  if (runnable.isFailed()) {\n    debug('uncaught(): Runnable has already failed');\n    // Ignore error if already failed\n    return;\n  } else if (runnable.isPending()) {\n    debug('uncaught(): pending Runnable wound up failing!');\n    // report 'pending test' retrospectively as failed\n    this.fail(runnable, err, true);\n    return;\n  }\n\n  // we cannot recover gracefully if a Runnable has already passed\n  // then fails asynchronously\n  if (runnable.isPassed()) {\n    debug('uncaught(): Runnable has already passed; bailing gracefully');\n    this.fail(runnable, err);\n    this.abort();\n  } else {\n    debug('uncaught(): forcing Runnable to complete with Error');\n    return runnable.callback(err);\n  }\n};\n\n/**\n * Run the root suite and invoke `fn(failures)`\n * on completion.\n *\n * @public\n * @memberof Runner\n * @param {Function} fn - Callback when finished\n * @param {Object} [opts] - For subclasses\n * @param {string[]} opts.files - Files to run\n * @param {Options} opts.options - command-line options\n * @returns {Runner} Runner instance.\n */\nRunner.prototype.run = function (fn, opts = {}) {\n  var rootSuite = this.suite;\n  var options = opts.options || {};\n\n  debug('run(): got options: %O', options);\n  fn = fn || function () {};\n\n  const end = () => {\n    if (!this.total && this._opts.failZero) this.failures = 1;\n\n    debug('run(): root suite completed; emitting %s', constants.EVENT_RUN_END);\n    this.emit(constants.EVENT_RUN_END);\n  };\n\n  const begin = () => {\n    debug('run(): emitting %s', constants.EVENT_RUN_BEGIN);\n    this.emit(constants.EVENT_RUN_BEGIN);\n    debug('run(): emitted %s', constants.EVENT_RUN_BEGIN);\n\n    this.runSuite(rootSuite, end);\n  };\n\n  const prepare = () => {\n    debug('run(): starting');\n    // If there is an `only` filter\n    if (rootSuite.hasOnly()) {\n      rootSuite.filterOnly();\n      debug('run(): filtered exclusive Runnables');\n    }\n    this.state = constants.STATE_RUNNING;\n    if (this._opts.delay) {\n      this.emit(constants.EVENT_DELAY_END);\n      debug('run(): \"delay\" ended');\n    }\n\n    return begin();\n  };\n\n  // references cleanup to avoid memory leaks\n  if (this._opts.cleanReferencesAfterRun) {\n    this.on(constants.EVENT_SUITE_END, suite => {\n      suite.cleanReferences();\n    });\n  }\n\n  // callback\n  this.on(constants.EVENT_RUN_END, function () {\n    this.state = constants.STATE_STOPPED;\n    debug('run(): emitted %s', constants.EVENT_RUN_END);\n    fn(this.failures);\n  });\n\n  this._removeEventListener(process, 'uncaughtException', this.uncaught);\n  this._removeEventListener(process, 'unhandledRejection', this.unhandled);\n  this._addEventListener(process, 'uncaughtException', this.uncaught);\n  this._addEventListener(process, 'unhandledRejection', this.unhandled);\n\n  if (this._opts.delay) {\n    // for reporters, I guess.\n    // might be nice to debounce some dots while we wait.\n    this.emit(constants.EVENT_DELAY_BEGIN, rootSuite);\n    rootSuite.once(EVENT_ROOT_SUITE_RUN, prepare);\n    debug('run(): waiting for green light due to --delay');\n  } else {\n    Runner.immediately(prepare);\n  }\n\n  return this;\n};\n\n/**\n * Toggle partial object linking behavior; used for building object references from\n * unique ID's. Does nothing in serial mode, because the object references already exist.\n * Subclasses can implement this (e.g., `ParallelBufferedRunner`)\n * @abstract\n * @param {boolean} [value] - If `true`, enable partial object linking, otherwise disable\n * @returns {Runner}\n * @chainable\n * @public\n * @example\n * // this reporter needs proper object references when run in parallel mode\n * class MyReporter() {\n *   constructor(runner) {\n *     this.runner.linkPartialObjects(true)\n *       .on(EVENT_SUITE_BEGIN, suite => {\n           // this Suite may be the same object...\n *       })\n *       .on(EVENT_TEST_BEGIN, test => {\n *         // ...as the `test.parent` property\n *       });\n *   }\n * }\n */\nRunner.prototype.linkPartialObjects = function (value) {\n  return this;\n};\n\n/*\n * Like {@link Runner#run}, but does not accept a callback and returns a `Promise` instead of a `Runner`.\n * This function cannot reject; an `unhandledRejection` event will bubble up to the `process` object instead.\n * @public\n * @memberof Runner\n * @param {Object} [opts] - Options for {@link Runner#run}\n * @returns {Promise<number>} Failure count\n */\nRunner.prototype.runAsync = async function runAsync(opts = {}) {\n  return new Promise(resolve => {\n    this.run(resolve, opts);\n  });\n};\n\n/**\n * Cleanly abort execution.\n *\n * @memberof Runner\n * @public\n * @return {Runner} Runner instance.\n */\nRunner.prototype.abort = function () {\n  debug('abort(): aborting');\n  this._abort = true;\n\n  return this;\n};\n\n/**\n * Returns `true` if Mocha is running in parallel mode.  For reporters.\n *\n * Subclasses should return an appropriate value.\n * @public\n * @returns {false}\n */\nRunner.prototype.isParallelMode = function isParallelMode() {\n  return false;\n};\n\n/**\n * Configures an alternate reporter for worker processes to use. Subclasses\n * using worker processes should implement this.\n * @public\n * @param {string} path - Absolute path to alternate reporter for worker processes to use\n * @returns {Runner}\n * @throws When in serial mode\n * @chainable\n * @abstract\n */\nRunner.prototype.workerReporter = function () {\n  throw createUnsupportedError('workerReporter() not supported in serial mode');\n};\n\n/**\n * Filter leaks with the given globals flagged as `ok`.\n *\n * @private\n * @param {Array} ok\n * @param {Array} globals\n * @return {Array}\n */\nfunction filterLeaks(ok, globals) {\n  return globals.filter(function (key) {\n    // Firefox and Chrome exposes iframes as index inside the window object\n    if (/^\\d+/.test(key)) {\n      return false;\n    }\n\n    // in firefox\n    // if runner runs in an iframe, this iframe's window.getInterface method\n    // not init at first it is assigned in some seconds\n    if (global.navigator && /^getInterface/.test(key)) {\n      return false;\n    }\n\n    // an iframe could be approached by window[iframeIndex]\n    // in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak\n    if (global.navigator && /^\\d+/.test(key)) {\n      return false;\n    }\n\n    // Opera and IE expose global variables for HTML element IDs (issue #243)\n    if (/^mocha-/.test(key)) {\n      return false;\n    }\n\n    var matched = ok.filter(function (ok) {\n      if (~ok.indexOf('*')) {\n        return key.indexOf(ok.split('*')[0]) === 0;\n      }\n      return key === ok;\n    });\n    return !matched.length && (!global.navigator || key !== 'onerror');\n  });\n}\n\n/**\n * Check if argument is an instance of Error object or a duck-typed equivalent.\n *\n * @private\n * @param {Object} err - object to check\n * @param {string} err.message - error message\n * @returns {boolean}\n */\nfunction isError(err) {\n  return err instanceof Error || (err && typeof err.message === 'string');\n}\n\n/**\n *\n * Converts thrown non-extensible type into proper Error.\n *\n * @private\n * @param {*} thrown - Non-extensible type thrown by code\n * @return {Error}\n */\nfunction thrown2Error(err) {\n  return new Error(\n    `the ${utils.canonicalType(err)} ${stringify(\n      err\n    )} was thrown, throw an Error :)`\n  );\n}\n\nRunner.constants = constants;\n\n/**\n * Node.js' `EventEmitter`\n * @external EventEmitter\n * @see {@link https://nodejs.org/api/events.html#events_class_eventemitter}\n */\n\nmodule.exports = Runner;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}