{"ast":null,"code":"import functionTimeout, { isTimeoutError } from 'function-timeout';\nimport timeSpan from 'time-span';\nimport cloneRegexp from 'clone-regexp'; // TODO: Use `structuredClone` instead when targeting Node.js 18.\n\nconst resultToMatch = result => ({\n  match: result[0],\n  index: result.index,\n  groups: result.slice(1),\n  namedGroups: result.groups ?? {},\n  input: result.input\n});\nexport function isMatch(regex, string, {\n  timeout\n} = {}) {\n  try {\n    return functionTimeout(() => cloneRegexp(regex).test(string), {\n      timeout\n    })();\n  } catch (error) {\n    if (isTimeoutError(error)) {\n      return false;\n    }\n    throw error;\n  }\n}\nexport function firstMatch(regex, string, {\n  timeout\n} = {}) {\n  try {\n    const result = functionTimeout(() => cloneRegexp(regex).exec(string), {\n      timeout\n    })();\n    if (result === null) {\n      return;\n    }\n    return resultToMatch(result);\n  } catch (error) {\n    if (isTimeoutError(error)) {\n      return;\n    }\n    throw error;\n  }\n}\nexport function matches(regex, string, {\n  timeout = Number.POSITIVE_INFINITY,\n  matchTimeout = Number.POSITIVE_INFINITY\n} = {}) {\n  if (!regex.global) {\n    throw new Error('The regex must have the global flag, otherwise, use `firstMatch()` instead');\n  }\n  return {\n    *[Symbol.iterator]() {\n      try {\n        const matches = string.matchAll(regex); // The regex is only executed when iterated over.\n\n        while (true) {\n          const nextMatch = functionTimeout(() => matches.next(), {\n            timeout: timeout !== Number.POSITIVE_INFINITY || matchTimeout !== Number.POSITIVE_INFINITY ? Math.min(timeout, matchTimeout) : undefined\n          }); // `matches.next` must be called within an arrow function so that it doesn't loose its context.\n\n          const end = timeSpan();\n          const {\n            value,\n            done\n          } = nextMatch();\n          timeout -= Math.ceil(end());\n          if (done) {\n            break;\n          }\n          yield resultToMatch(value);\n        }\n      } catch (error) {\n        if (!isTimeoutError(error)) {\n          throw error;\n        }\n      }\n    }\n  };\n}","map":{"version":3,"names":["functionTimeout","isTimeoutError","timeSpan","cloneRegexp","resultToMatch","result","match","index","groups","slice","namedGroups","input","isMatch","regex","string","timeout","test","error","firstMatch","exec","matches","Number","POSITIVE_INFINITY","matchTimeout","global","Error","Symbol","iterator","matchAll","nextMatch","next","Math","min","undefined","end","value","done","ceil"],"sources":["C:/FACULTATE/Proiect/node_modules/super-regex/index.js"],"sourcesContent":["import functionTimeout, {isTimeoutError} from 'function-timeout';\nimport timeSpan from 'time-span';\nimport cloneRegexp from 'clone-regexp'; // TODO: Use `structuredClone` instead when targeting Node.js 18.\n\nconst resultToMatch = result => ({\n\tmatch: result[0],\n\tindex: result.index,\n\tgroups: result.slice(1),\n\tnamedGroups: result.groups ?? {},\n\tinput: result.input,\n});\n\nexport function isMatch(regex, string, {timeout} = {}) {\n\ttry {\n\t\treturn functionTimeout(() => cloneRegexp(regex).test(string), {timeout})();\n\t} catch (error) {\n\t\tif (isTimeoutError(error)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthrow error;\n\t}\n}\n\nexport function firstMatch(regex, string, {timeout} = {}) {\n\ttry {\n\t\tconst result = functionTimeout(() => cloneRegexp(regex).exec(string), {timeout})();\n\n\t\tif (result === null) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn resultToMatch(result);\n\t} catch (error) {\n\t\tif (isTimeoutError(error)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthrow error;\n\t}\n}\n\nexport function matches(regex, string, {timeout = Number.POSITIVE_INFINITY, matchTimeout = Number.POSITIVE_INFINITY} = {}) {\n\tif (!regex.global) {\n\t\tthrow new Error('The regex must have the global flag, otherwise, use `firstMatch()` instead');\n\t}\n\n\treturn {\n\t\t* [Symbol.iterator]() {\n\t\t\ttry {\n\t\t\t\tconst matches = string.matchAll(regex); // The regex is only executed when iterated over.\n\n\t\t\t\twhile (true) {\n\t\t\t\t\tconst nextMatch = functionTimeout(() => matches.next(), {timeout: (timeout !== Number.POSITIVE_INFINITY || matchTimeout !== Number.POSITIVE_INFINITY) ? Math.min(timeout, matchTimeout) : undefined}); // `matches.next` must be called within an arrow function so that it doesn't loose its context.\n\n\t\t\t\t\tconst end = timeSpan();\n\t\t\t\t\tconst {value, done} = nextMatch();\n\t\t\t\t\ttimeout -= Math.ceil(end());\n\n\t\t\t\t\tif (done) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tyield resultToMatch(value);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (!isTimeoutError(error)) {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t};\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}