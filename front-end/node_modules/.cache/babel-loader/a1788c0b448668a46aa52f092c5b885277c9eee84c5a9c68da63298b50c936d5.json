{"ast":null,"code":"import * as API from \"./directory/api.js\";\nimport * as File from \"./file.js\";\nimport * as UnixFS from \"./codec.js\";\nexport * from \"./directory/api.js\";\nexport const configure = File.configure;\nexport const defaults = File.defaults;\n\n/**\n * @template [Layout=unknown]\n * @param {API.Options<Layout>} config\n * @returns {API.View<Layout>}\n */\nexport const create = ({\n  writer,\n  settings = defaults(),\n  metadata = {}\n}) => new DirectoryWriter({\n  writer,\n  metadata,\n  settings,\n  entries: new Map(),\n  closed: false\n});\n\n/**\n * @template {unknown} L\n * @template {{ state: API.State<L> }} View\n * @param {View} view\n * @param {string} name\n * @param {API.EntryLink} link\n * @param {API.WriteOptions} options\n */\nexport const set = (view, name, link, {\n  overwrite = false\n} = {}) => {\n  const writable = asWritable(view.state);\n  if (name.includes(\"/\")) {\n    throw new Error(`Directory entry name \"${name}\" contains forbidden \"/\" character`);\n  }\n  if (!overwrite && writable.entries.has(name)) {\n    throw new Error(`Directory already contains entry with name \"${name}\"`);\n  } else {\n    writable.entries.set(name, link);\n    return view;\n  }\n};\n\n/**\n * @template {unknown} L\n * @template {{ state: API.State<L> }} View\n * @param {View} view\n * @param {string} name\n */\nexport const remove = (view, name) => {\n  const writer = asWritable(view.state);\n  writer.entries.delete(name);\n  return view;\n};\n\n/**\n * @template {API.State} Writer\n * @param {Writer} writer\n * @returns {Writer}\n */\nconst asWritable = writer => {\n  if (!writer.closed) {\n    return writer;\n  } else {\n    throw new Error(`Can not change written directory, but you can .fork() and make changes to it`);\n  }\n};\n\n/**\n * @template {unknown} Layout\n * @param {{ state: API.State<Layout> }} view\n * @param {API.CloseOptions} options\n * @returns {Promise<UnixFS.DirectoryLink>}\n */\nexport const close = async (view, {\n  closeWriter = false,\n  releaseLock = false\n} = {}) => {\n  const {\n    writer,\n    settings,\n    metadata\n  } = asWritable(view.state);\n  view.state.closed = true;\n  const entries = [...links(view)];\n  const node = UnixFS.createFlatDirectory(entries, metadata);\n  const bytes = UnixFS.encodeDirectory(node);\n  const digest = await settings.hasher.digest(bytes);\n  /** @type {UnixFS.Link<UnixFS.Directory>} */\n  const cid = settings.linker.createLink(UnixFS.code, digest);\n\n  // we make sure that writer has some capacity for this write. If it\n  // does not we await.\n  if ((writer.desiredSize || 0) <= 0) {\n    await writer.ready;\n  }\n  // once writer has some capacity we write a block, however we do not\n  // await completion as we don't care when it's taken off the stream.\n  writer.write({\n    cid,\n    bytes\n  });\n  if (closeWriter) {\n    await writer.close();\n  } else if (releaseLock) {\n    writer.releaseLock();\n  }\n  return {\n    cid,\n    dagByteLength: UnixFS.cumulativeDagByteLength(bytes, entries)\n  };\n};\n\n/**\n * @template {unknown} Layout\n * @param {{ state: API.State<Layout> }} view\n * @returns {IterableIterator<UnixFS.DirectoryEntryLink>}\n */\nexport const links = function* ({\n  state\n}) {\n  for (const [name, {\n    dagByteLength,\n    cid\n  }] of state.entries) {\n    yield ( /** @type {UnixFS.DirectoryEntryLink} */{\n      name,\n      dagByteLength,\n      cid\n    });\n  }\n};\n\n/**\n * @template L1, L2\n * @param {API.View<L1>} state\n * @param {Partial<API.Options<L1|L2>>} options\n * @returns {API.View<L1|L2>}\n */\nexport const fork = ({\n  state\n}, {\n  writer = state.writer,\n  metadata = state.metadata,\n  settings = state.settings\n} = {}) => new DirectoryWriter({\n  writer,\n  metadata,\n  settings,\n  entries: new Map(state.entries.entries()),\n  closed: false\n});\n\n/**\n * @template [Layout=unknown]\n * @implements {API.View<Layout>}\n */\nclass DirectoryWriter {\n  /**\n   * @param {API.State<Layout>} state\n   */\n  constructor(state) {\n    this.state = state;\n  }\n  get writer() {\n    return this.state.writer;\n  }\n  get settings() {\n    return this.state.settings;\n  }\n  links() {\n    return links(this);\n  }\n\n  /**\n   * @param {string} name\n   * @param {UnixFS.FileLink | UnixFS.DirectoryLink} link\n   * @param {API.WriteOptions} [options]\n   */\n\n  set(name, link, options) {\n    return set(this, name, link, options);\n  }\n\n  /**\n   * @param {string} name\n   */\n  remove(name) {\n    return remove(this, name);\n  }\n\n  /**\n   * @template L\n   * @param {Partial<API.Options<L>>} [options]\n   * @returns {API.View<Layout|L>}\n   */\n  fork(options) {\n    return fork(this, options);\n  }\n\n  /**\n   * @param {API.CloseOptions} [options]\n   * @returns {Promise<UnixFS.DirectoryLink>}\n   */\n  close(options) {\n    return close(this, options);\n  }\n  entries() {\n    return this.state.entries.entries();\n  }\n  /**\n   * @param {string} name\n   */\n  has(name) {\n    return this.state.entries.has(name);\n  }\n  get size() {\n    return this.state.entries.size;\n  }\n}","map":{"version":3,"names":["API","File","UnixFS","configure","defaults","create","writer","settings","metadata","DirectoryWriter","entries","Map","closed","set","view","name","link","overwrite","writable","asWritable","state","includes","Error","has","remove","delete","close","closeWriter","releaseLock","links","node","createFlatDirectory","bytes","encodeDirectory","digest","hasher","cid","linker","createLink","code","desiredSize","ready","write","dagByteLength","cumulativeDagByteLength","fork","constructor","options","size"],"sources":["C:/FACULTATE/Proiect/node_modules/@ipld/unixfs/src/directory.js"],"sourcesContent":["import * as API from \"./directory/api.js\"\nimport * as File from \"./file.js\"\nimport * as UnixFS from \"./codec.js\"\nexport * from \"./directory/api.js\"\n\nexport const configure = File.configure\nexport const defaults = File.defaults\n\n/**\n * @template [Layout=unknown]\n * @param {API.Options<Layout>} config\n * @returns {API.View<Layout>}\n */\nexport const create = ({ writer, settings = defaults(), metadata = {} }) =>\n  new DirectoryWriter({\n    writer,\n    metadata,\n    settings,\n    entries: new Map(),\n    closed: false,\n  })\n\n/**\n * @template {unknown} L\n * @template {{ state: API.State<L> }} View\n * @param {View} view\n * @param {string} name\n * @param {API.EntryLink} link\n * @param {API.WriteOptions} options\n */\nexport const set = (view, name, link, { overwrite = false } = {}) => {\n  const writable = asWritable(view.state)\n  if (name.includes(\"/\")) {\n    throw new Error(\n      `Directory entry name \"${name}\" contains forbidden \"/\" character`\n    )\n  }\n  if (!overwrite && writable.entries.has(name)) {\n    throw new Error(`Directory already contains entry with name \"${name}\"`)\n  } else {\n    writable.entries.set(name, link)\n    return view\n  }\n}\n\n/**\n * @template {unknown} L\n * @template {{ state: API.State<L> }} View\n * @param {View} view\n * @param {string} name\n */\nexport const remove = (view, name) => {\n  const writer = asWritable(view.state)\n  writer.entries.delete(name)\n  return view\n}\n\n/**\n * @template {API.State} Writer\n * @param {Writer} writer\n * @returns {Writer}\n */\nconst asWritable = writer => {\n  if (!writer.closed) {\n    return writer\n  } else {\n    throw new Error(\n      `Can not change written directory, but you can .fork() and make changes to it`\n    )\n  }\n}\n\n/**\n * @template {unknown} Layout\n * @param {{ state: API.State<Layout> }} view\n * @param {API.CloseOptions} options\n * @returns {Promise<UnixFS.DirectoryLink>}\n */\nexport const close = async (\n  view,\n  { closeWriter = false, releaseLock = false } = {}\n) => {\n  const { writer, settings, metadata } = asWritable(view.state)\n  view.state.closed = true\n  const entries = [...links(view)]\n  const node = UnixFS.createFlatDirectory(entries, metadata)\n  const bytes = UnixFS.encodeDirectory(node)\n  const digest = await settings.hasher.digest(bytes)\n  /** @type {UnixFS.Link<UnixFS.Directory>} */\n  const cid = settings.linker.createLink(UnixFS.code, digest)\n\n  // we make sure that writer has some capacity for this write. If it\n  // does not we await.\n  if ((writer.desiredSize || 0) <= 0) {\n    await writer.ready\n  }\n  // once writer has some capacity we write a block, however we do not\n  // await completion as we don't care when it's taken off the stream.\n  writer.write({ cid, bytes })\n\n  if (closeWriter) {\n    await writer.close()\n  } else if (releaseLock) {\n    writer.releaseLock()\n  }\n\n  return {\n    cid,\n    dagByteLength: UnixFS.cumulativeDagByteLength(bytes, entries),\n  }\n}\n\n/**\n * @template {unknown} Layout\n * @param {{ state: API.State<Layout> }} view\n * @returns {IterableIterator<UnixFS.DirectoryEntryLink>}\n */\nexport const links = function* ({ state }) {\n  for (const [name, { dagByteLength, cid }] of state.entries) {\n    yield /** @type {UnixFS.DirectoryEntryLink} */ ({\n      name,\n      dagByteLength,\n      cid,\n    })\n  }\n}\n\n/**\n * @template L1, L2\n * @param {API.View<L1>} state\n * @param {Partial<API.Options<L1|L2>>} options\n * @returns {API.View<L1|L2>}\n */\nexport const fork = (\n  { state },\n  {\n    writer = state.writer,\n    metadata = state.metadata,\n    settings = state.settings,\n  } = {}\n) =>\n  new DirectoryWriter({\n    writer,\n    metadata,\n    settings,\n    entries: new Map(state.entries.entries()),\n    closed: false,\n  })\n\n/**\n * @template [Layout=unknown]\n * @implements {API.View<Layout>}\n */\nclass DirectoryWriter {\n  /**\n   * @param {API.State<Layout>} state\n   */\n  constructor(state) {\n    this.state = state\n  }\n  get writer() {\n    return this.state.writer\n  }\n  get settings() {\n    return this.state.settings\n  }\n\n  links() {\n    return links(this)\n  }\n\n  /**\n   * @param {string} name\n   * @param {UnixFS.FileLink | UnixFS.DirectoryLink} link\n   * @param {API.WriteOptions} [options]\n   */\n\n  set(name, link, options) {\n    return set(this, name, link, options)\n  }\n\n  /**\n   * @param {string} name\n   */\n  remove(name) {\n    return remove(this, name)\n  }\n\n  /**\n   * @template L\n   * @param {Partial<API.Options<L>>} [options]\n   * @returns {API.View<Layout|L>}\n   */\n  fork(options) {\n    return fork(this, options)\n  }\n\n  /**\n   * @param {API.CloseOptions} [options]\n   * @returns {Promise<UnixFS.DirectoryLink>}\n   */\n  close(options) {\n    return close(this, options)\n  }\n\n  entries() {\n    return this.state.entries.entries()\n  }\n  /**\n   * @param {string} name\n   */\n  has(name) {\n    return this.state.entries.has(name)\n  }\n  get size() {\n    return this.state.entries.size\n  }\n}\n"],"mappings":"AAAA,OAAO,KAAKA,GAAG,MAAM,oBAAoB;AACzC,OAAO,KAAKC,IAAI,MAAM,WAAW;AACjC,OAAO,KAAKC,MAAM,MAAM,YAAY;AACpC,cAAc,oBAAoB;AAElC,OAAO,MAAMC,SAAS,GAAGF,IAAI,CAACE,SAAS;AACvC,OAAO,MAAMC,QAAQ,GAAGH,IAAI,CAACG,QAAQ;;AAErC;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,MAAM,GAAGA,CAAC;EAAEC,MAAM;EAAEC,QAAQ,GAAGH,QAAQ,CAAC,CAAC;EAAEI,QAAQ,GAAG,CAAC;AAAE,CAAC,KACrE,IAAIC,eAAe,CAAC;EAClBH,MAAM;EACNE,QAAQ;EACRD,QAAQ;EACRG,OAAO,EAAE,IAAIC,GAAG,CAAC,CAAC;EAClBC,MAAM,EAAE;AACV,CAAC,CAAC;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,GAAG,GAAGA,CAACC,IAAI,EAAEC,IAAI,EAAEC,IAAI,EAAE;EAAEC,SAAS,GAAG;AAAM,CAAC,GAAG,CAAC,CAAC,KAAK;EACnE,MAAMC,QAAQ,GAAGC,UAAU,CAACL,IAAI,CAACM,KAAK,CAAC;EACvC,IAAIL,IAAI,CAACM,QAAQ,CAAC,GAAG,CAAC,EAAE;IACtB,MAAM,IAAIC,KAAK,CACZ,yBAAwBP,IAAK,oCAChC,CAAC;EACH;EACA,IAAI,CAACE,SAAS,IAAIC,QAAQ,CAACR,OAAO,CAACa,GAAG,CAACR,IAAI,CAAC,EAAE;IAC5C,MAAM,IAAIO,KAAK,CAAE,+CAA8CP,IAAK,GAAE,CAAC;EACzE,CAAC,MAAM;IACLG,QAAQ,CAACR,OAAO,CAACG,GAAG,CAACE,IAAI,EAAEC,IAAI,CAAC;IAChC,OAAOF,IAAI;EACb;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMU,MAAM,GAAGA,CAACV,IAAI,EAAEC,IAAI,KAAK;EACpC,MAAMT,MAAM,GAAGa,UAAU,CAACL,IAAI,CAACM,KAAK,CAAC;EACrCd,MAAM,CAACI,OAAO,CAACe,MAAM,CAACV,IAAI,CAAC;EAC3B,OAAOD,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAMK,UAAU,GAAGb,MAAM,IAAI;EAC3B,IAAI,CAACA,MAAM,CAACM,MAAM,EAAE;IAClB,OAAON,MAAM;EACf,CAAC,MAAM;IACL,MAAM,IAAIgB,KAAK,CACZ,8EACH,CAAC;EACH;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMI,KAAK,GAAG,MAAAA,CACnBZ,IAAI,EACJ;EAAEa,WAAW,GAAG,KAAK;EAAEC,WAAW,GAAG;AAAM,CAAC,GAAG,CAAC,CAAC,KAC9C;EACH,MAAM;IAAEtB,MAAM;IAAEC,QAAQ;IAAEC;EAAS,CAAC,GAAGW,UAAU,CAACL,IAAI,CAACM,KAAK,CAAC;EAC7DN,IAAI,CAACM,KAAK,CAACR,MAAM,GAAG,IAAI;EACxB,MAAMF,OAAO,GAAG,CAAC,GAAGmB,KAAK,CAACf,IAAI,CAAC,CAAC;EAChC,MAAMgB,IAAI,GAAG5B,MAAM,CAAC6B,mBAAmB,CAACrB,OAAO,EAAEF,QAAQ,CAAC;EAC1D,MAAMwB,KAAK,GAAG9B,MAAM,CAAC+B,eAAe,CAACH,IAAI,CAAC;EAC1C,MAAMI,MAAM,GAAG,MAAM3B,QAAQ,CAAC4B,MAAM,CAACD,MAAM,CAACF,KAAK,CAAC;EAClD;EACA,MAAMI,GAAG,GAAG7B,QAAQ,CAAC8B,MAAM,CAACC,UAAU,CAACpC,MAAM,CAACqC,IAAI,EAAEL,MAAM,CAAC;;EAE3D;EACA;EACA,IAAI,CAAC5B,MAAM,CAACkC,WAAW,IAAI,CAAC,KAAK,CAAC,EAAE;IAClC,MAAMlC,MAAM,CAACmC,KAAK;EACpB;EACA;EACA;EACAnC,MAAM,CAACoC,KAAK,CAAC;IAAEN,GAAG;IAAEJ;EAAM,CAAC,CAAC;EAE5B,IAAIL,WAAW,EAAE;IACf,MAAMrB,MAAM,CAACoB,KAAK,CAAC,CAAC;EACtB,CAAC,MAAM,IAAIE,WAAW,EAAE;IACtBtB,MAAM,CAACsB,WAAW,CAAC,CAAC;EACtB;EAEA,OAAO;IACLQ,GAAG;IACHO,aAAa,EAAEzC,MAAM,CAAC0C,uBAAuB,CAACZ,KAAK,EAAEtB,OAAO;EAC9D,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMmB,KAAK,GAAG,UAAAA,CAAW;EAAET;AAAM,CAAC,EAAE;EACzC,KAAK,MAAM,CAACL,IAAI,EAAE;IAAE4B,aAAa;IAAEP;EAAI,CAAC,CAAC,IAAIhB,KAAK,CAACV,OAAO,EAAE;IAC1D,QAAM,wCAA0C;MAC9CK,IAAI;MACJ4B,aAAa;MACbP;IACF,CAAC,CAAC;EACJ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMS,IAAI,GAAGA,CAClB;EAAEzB;AAAM,CAAC,EACT;EACEd,MAAM,GAAGc,KAAK,CAACd,MAAM;EACrBE,QAAQ,GAAGY,KAAK,CAACZ,QAAQ;EACzBD,QAAQ,GAAGa,KAAK,CAACb;AACnB,CAAC,GAAG,CAAC,CAAC,KAEN,IAAIE,eAAe,CAAC;EAClBH,MAAM;EACNE,QAAQ;EACRD,QAAQ;EACRG,OAAO,EAAE,IAAIC,GAAG,CAACS,KAAK,CAACV,OAAO,CAACA,OAAO,CAAC,CAAC,CAAC;EACzCE,MAAM,EAAE;AACV,CAAC,CAAC;;AAEJ;AACA;AACA;AACA;AACA,MAAMH,eAAe,CAAC;EACpB;AACF;AACA;EACEqC,WAAWA,CAAC1B,KAAK,EAAE;IACjB,IAAI,CAACA,KAAK,GAAGA,KAAK;EACpB;EACA,IAAId,MAAMA,CAAA,EAAG;IACX,OAAO,IAAI,CAACc,KAAK,CAACd,MAAM;EAC1B;EACA,IAAIC,QAAQA,CAAA,EAAG;IACb,OAAO,IAAI,CAACa,KAAK,CAACb,QAAQ;EAC5B;EAEAsB,KAAKA,CAAA,EAAG;IACN,OAAOA,KAAK,CAAC,IAAI,CAAC;EACpB;;EAEA;AACF;AACA;AACA;AACA;;EAEEhB,GAAGA,CAACE,IAAI,EAAEC,IAAI,EAAE+B,OAAO,EAAE;IACvB,OAAOlC,GAAG,CAAC,IAAI,EAAEE,IAAI,EAAEC,IAAI,EAAE+B,OAAO,CAAC;EACvC;;EAEA;AACF;AACA;EACEvB,MAAMA,CAACT,IAAI,EAAE;IACX,OAAOS,MAAM,CAAC,IAAI,EAAET,IAAI,CAAC;EAC3B;;EAEA;AACF;AACA;AACA;AACA;EACE8B,IAAIA,CAACE,OAAO,EAAE;IACZ,OAAOF,IAAI,CAAC,IAAI,EAAEE,OAAO,CAAC;EAC5B;;EAEA;AACF;AACA;AACA;EACErB,KAAKA,CAACqB,OAAO,EAAE;IACb,OAAOrB,KAAK,CAAC,IAAI,EAAEqB,OAAO,CAAC;EAC7B;EAEArC,OAAOA,CAAA,EAAG;IACR,OAAO,IAAI,CAACU,KAAK,CAACV,OAAO,CAACA,OAAO,CAAC,CAAC;EACrC;EACA;AACF;AACA;EACEa,GAAGA,CAACR,IAAI,EAAE;IACR,OAAO,IAAI,CAACK,KAAK,CAACV,OAAO,CAACa,GAAG,CAACR,IAAI,CAAC;EACrC;EACA,IAAIiC,IAAIA,CAAA,EAAG;IACT,OAAO,IAAI,CAAC5B,KAAK,CAACV,OAAO,CAACsC,IAAI;EAChC;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}