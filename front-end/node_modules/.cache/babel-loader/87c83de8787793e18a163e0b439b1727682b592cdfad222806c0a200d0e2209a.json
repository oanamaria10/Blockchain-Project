{"ast":null,"code":"import * as UCAN from \"./ucan.js\";\nimport { base58btc } from \"multiformats/bases/base58\";\nimport { varint } from \"multiformats\";\nimport * as UTF8 from \"./utf8.js\";\nconst DID_PREFIX = \"did:\";\nconst DID_PREFIX_SIZE = DID_PREFIX.length;\nconst DID_KEY_PREFIX = `did:key:`;\nconst DID_KEY_PREFIX_SIZE = DID_KEY_PREFIX.length;\nexport const ED25519 = 0xed;\nexport const RSA = 0x1205;\nexport const P256 = 0x1200;\nexport const P384 = 0x1201;\nexport const P521 = 0x1202;\nexport const SECP256K1 = 0xe7;\nexport const BLS12381G1 = 0xea;\nexport const BLS12381G2 = 0xeb;\nexport const DID_CORE = 0x0d1d;\nconst METHOD_OFFSET = varint.encodingLength(DID_CORE);\n\n/**\n * @typedef {typeof ED25519|typeof RSA|typeof P256|typeof P384|typeof P521|typeof DID_CORE} Code\n */\n\n/**\n * Parses a DID string into a DID buffer view\n *\n * @template {UCAN.DID} ID\n * @param {ID|UCAN.ToString<unknown>} did\n * @returns {UCAN.PrincipalView<ID>}\n */\nexport const parse = did => {\n  if (!did.startsWith(DID_PREFIX)) {\n    throw new RangeError(`Invalid DID \"${did}\", must start with 'did:'`);\n  } else if (did.startsWith(DID_KEY_PREFIX)) {\n    const key = base58btc.decode(did.slice(DID_KEY_PREFIX_SIZE));\n    return decode(key);\n  } else {\n    const suffix = UTF8.encode(did.slice(DID_PREFIX_SIZE));\n    const bytes = new Uint8Array(suffix.byteLength + METHOD_OFFSET);\n    varint.encodeTo(DID_CORE, bytes);\n    bytes.set(suffix, METHOD_OFFSET);\n    return new DID(bytes);\n  }\n};\n\n/**\n * @template {UCAN.DID} ID\n * @param {UCAN.Principal<ID>} id\n * @returns {ID}\n */\nexport const format = id => id.did();\n\n/**\n * @template {UCAN.DID} ID\n * @param {UCAN.PrincipalView<ID>|UCAN.ByteView<UCAN.Principal<ID>>|UCAN.Principal<ID>|ID|UCAN.ToJSONString<unknown>} principal\n * @returns {UCAN.PrincipalView<ID>}\n */\nexport const from = principal => {\n  if (principal instanceof DID) {\n    return principal;\n  } else if (principal instanceof Uint8Array) {\n    return decode(principal);\n  } else if (typeof principal === \"string\") {\n    return parse(principal);\n  } else {\n    return parse(principal.did());\n  }\n};\n\n/**\n * @template {UCAN.DID} ID\n * @param {UCAN.ByteView<UCAN.Principal<ID>>} bytes\n * @returns {UCAN.PrincipalView<ID>}\n */\nexport const decode = bytes => {\n  const [code] = varint.decode(bytes);\n  const {\n    buffer,\n    byteOffset,\n    byteLength\n  } = bytes;\n  switch (code) {\n    case P256:\n      if (bytes.length > 35) {\n        throw new RangeError(`Only p256-pub compressed is supported.`);\n      }\n    case ED25519:\n    case RSA:\n    case P384:\n    case P521:\n    case BLS12381G1:\n    case BLS12381G2:\n    case SECP256K1:\n      return /** @type {UCAN.PrincipalView<any>} */(\n        new DIDKey(buffer, byteOffset, byteLength)\n      );\n    case DID_CORE:\n      return new DID(buffer, byteOffset, byteLength);\n    default:\n      throw new RangeError(`Unsupported DID encoding, unknown multicode 0x${code.toString(16)}.`);\n  }\n};\n\n/**\n * @template {UCAN.DID} ID\n * @param {UCAN.Principal<ID>} principal\n * @returns {UCAN.PrincipalView<ID>}\n */\nexport const encode = principal => parse(principal.did());\n\n/**\n * @template {UCAN.DID} ID\n * @implements {UCAN.PrincipalView<ID>}\n * @extends {Uint8Array}\n */\nclass DID extends Uint8Array {\n  /**\n   * @returns {ID}\n   */\n  did() {\n    const bytes = new Uint8Array(this.buffer, this.byteOffset + METHOD_OFFSET);\n    return /** @type {ID} */`did:${UTF8.decode(bytes)}`;\n  }\n  toJSON() {\n    return this.did();\n  }\n}\n\n/**\n * @implements {UCAN.PrincipalView<UCAN.DID<\"key\">>}\n * @extends {DID<UCAN.DID<\"key\">>}\n */\nclass DIDKey extends DID {\n  /**\n   * @return {`did:key:${string}`}\n   */\n  did() {\n    return `did:key:${base58btc.encode(this)}`;\n  }\n}","map":{"version":3,"names":["UCAN","base58btc","varint","UTF8","DID_PREFIX","DID_PREFIX_SIZE","length","DID_KEY_PREFIX","DID_KEY_PREFIX_SIZE","ED25519","RSA","P256","P384","P521","SECP256K1","BLS12381G1","BLS12381G2","DID_CORE","METHOD_OFFSET","encodingLength","parse","did","startsWith","RangeError","key","decode","slice","suffix","encode","bytes","Uint8Array","byteLength","encodeTo","set","DID","format","id","from","principal","code","buffer","byteOffset","DIDKey","toString","toJSON"],"sources":["C:/FACULTATE/Proiect/node_modules/@ipld/dag-ucan/src/did.js"],"sourcesContent":["import * as UCAN from \"./ucan.js\"\nimport { base58btc } from \"multiformats/bases/base58\"\nimport { varint } from \"multiformats\"\nimport * as UTF8 from \"./utf8.js\"\n\nconst DID_PREFIX = \"did:\"\nconst DID_PREFIX_SIZE = DID_PREFIX.length\nconst DID_KEY_PREFIX = `did:key:`\nconst DID_KEY_PREFIX_SIZE = DID_KEY_PREFIX.length\n\nexport const ED25519 = 0xed\nexport const RSA = 0x1205\nexport const P256 = 0x1200\nexport const P384 = 0x1201\nexport const P521 = 0x1202\nexport const SECP256K1 = 0xe7\nexport const BLS12381G1 = 0xea\nexport const BLS12381G2 = 0xeb\nexport const DID_CORE = 0x0d1d\nconst METHOD_OFFSET = varint.encodingLength(DID_CORE)\n\n/**\n * @typedef {typeof ED25519|typeof RSA|typeof P256|typeof P384|typeof P521|typeof DID_CORE} Code\n */\n\n/**\n * Parses a DID string into a DID buffer view\n *\n * @template {UCAN.DID} ID\n * @param {ID|UCAN.ToString<unknown>} did\n * @returns {UCAN.PrincipalView<ID>}\n */\nexport const parse = did => {\n  if (!did.startsWith(DID_PREFIX)) {\n    throw new RangeError(`Invalid DID \"${did}\", must start with 'did:'`)\n  } else if (did.startsWith(DID_KEY_PREFIX)) {\n    const key = base58btc.decode(did.slice(DID_KEY_PREFIX_SIZE))\n    return decode(key)\n  } else {\n    const suffix = UTF8.encode(did.slice(DID_PREFIX_SIZE))\n    const bytes = new Uint8Array(suffix.byteLength + METHOD_OFFSET)\n    varint.encodeTo(DID_CORE, bytes)\n    bytes.set(suffix, METHOD_OFFSET)\n    return new DID(bytes)\n  }\n}\n\n/**\n * @template {UCAN.DID} ID\n * @param {UCAN.Principal<ID>} id\n * @returns {ID}\n */\nexport const format = id => id.did()\n\n/**\n * @template {UCAN.DID} ID\n * @param {UCAN.PrincipalView<ID>|UCAN.ByteView<UCAN.Principal<ID>>|UCAN.Principal<ID>|ID|UCAN.ToJSONString<unknown>} principal\n * @returns {UCAN.PrincipalView<ID>}\n */\nexport const from = principal => {\n  if (principal instanceof DID) {\n    return principal\n  } else if (principal instanceof Uint8Array) {\n    return decode(principal)\n  } else if (typeof principal === \"string\") {\n    return parse(principal)\n  } else {\n    return parse(principal.did())\n  }\n}\n\n/**\n * @template {UCAN.DID} ID\n * @param {UCAN.ByteView<UCAN.Principal<ID>>} bytes\n * @returns {UCAN.PrincipalView<ID>}\n */\nexport const decode = bytes => {\n  const [code] = varint.decode(bytes)\n  const { buffer, byteOffset, byteLength } = bytes\n  switch (code) {\n    case P256:\n      if (bytes.length > 35) {\n        throw new RangeError(`Only p256-pub compressed is supported.`)\n      }\n    case ED25519:\n    case RSA:\n    case P384:\n    case P521:\n    case BLS12381G1:\n    case BLS12381G2:\n    case SECP256K1:\n      return /** @type {UCAN.PrincipalView<any>} */ (\n        new DIDKey(buffer, byteOffset, byteLength)\n      )\n    case DID_CORE:\n      return new DID(buffer, byteOffset, byteLength)\n    default:\n      throw new RangeError(\n        `Unsupported DID encoding, unknown multicode 0x${code.toString(16)}.`\n      )\n  }\n}\n\n/**\n * @template {UCAN.DID} ID\n * @param {UCAN.Principal<ID>} principal\n * @returns {UCAN.PrincipalView<ID>}\n */\nexport const encode = principal => parse(principal.did())\n\n/**\n * @template {UCAN.DID} ID\n * @implements {UCAN.PrincipalView<ID>}\n * @extends {Uint8Array}\n */\nclass DID extends Uint8Array {\n  /**\n   * @returns {ID}\n   */\n  did() {\n    const bytes = new Uint8Array(this.buffer, this.byteOffset + METHOD_OFFSET)\n    return /** @type {ID} */ (`did:${UTF8.decode(bytes)}`)\n  }\n\n  toJSON() {\n    return this.did()\n  }\n}\n\n/**\n * @implements {UCAN.PrincipalView<UCAN.DID<\"key\">>}\n * @extends {DID<UCAN.DID<\"key\">>}\n */\nclass DIDKey extends DID {\n  /**\n   * @return {`did:key:${string}`}\n   */\n  did() {\n    return `did:key:${base58btc.encode(this)}`\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}