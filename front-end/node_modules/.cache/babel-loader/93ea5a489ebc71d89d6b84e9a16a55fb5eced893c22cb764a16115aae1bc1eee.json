{"ast":null,"code":"var Utils = require(\"./util\"),\n  Headers = require(\"./headers\"),\n  Constants = Utils.Constants,\n  Methods = require(\"./methods\");\nmodule.exports = function ( /*Buffer*/input) {\n  var _entryHeader = new Headers.EntryHeader(),\n    _entryName = Buffer.alloc(0),\n    _comment = Buffer.alloc(0),\n    _isDirectory = false,\n    uncompressedData = null,\n    _extra = Buffer.alloc(0);\n  function getCompressedDataFromZip() {\n    if (!input || !Buffer.isBuffer(input)) {\n      return Buffer.alloc(0);\n    }\n    _entryHeader.loadDataHeaderFromBinary(input);\n    return input.slice(_entryHeader.realDataOffset, _entryHeader.realDataOffset + _entryHeader.compressedSize);\n  }\n  function crc32OK(data) {\n    // if bit 3 (0x08) of the general-purpose flags field is set, then the CRC-32 and file sizes are not known when the header is written\n    if ((_entryHeader.flags & 0x8) !== 0x8) {\n      if (Utils.crc32(data) !== _entryHeader.dataHeader.crc) {\n        return false;\n      }\n    } else {\n      // @TODO: load and check data descriptor header\n      // The fields in the local header are filled with zero, and the CRC-32 and size are appended in a 12-byte structure\n      // (optionally preceded by a 4-byte signature) immediately after the compressed data:\n    }\n    return true;\n  }\n  function decompress( /*Boolean*/async, /*Function*/callback, /*String*/pass) {\n    if (typeof callback === 'undefined' && typeof async === 'string') {\n      pass = async;\n      async = void 0;\n    }\n    if (_isDirectory) {\n      if (async && callback) {\n        callback(Buffer.alloc(0), Utils.Errors.DIRECTORY_CONTENT_ERROR); //si added error.\n      }\n      return Buffer.alloc(0);\n    }\n    var compressedData = getCompressedDataFromZip();\n    if (compressedData.length === 0) {\n      // File is empty, nothing to decompress.\n      if (async && callback) callback(compressedData);\n      return compressedData;\n    }\n    var data = Buffer.alloc(_entryHeader.size);\n    switch (_entryHeader.method) {\n      case Utils.Constants.STORED:\n        compressedData.copy(data);\n        if (!crc32OK(data)) {\n          if (async && callback) callback(data, Utils.Errors.BAD_CRC); //si added error\n          throw new Error(Utils.Errors.BAD_CRC);\n        } else {\n          //si added otherwise did not seem to return data.\n          if (async && callback) callback(data);\n          return data;\n        }\n      case Utils.Constants.DEFLATED:\n        var inflater = new Methods.Inflater(compressedData);\n        if (!async) {\n          var result = inflater.inflate(data);\n          result.copy(data, 0);\n          if (!crc32OK(data)) {\n            throw new Error(Utils.Errors.BAD_CRC + \" \" + _entryName.toString());\n          }\n          return data;\n        } else {\n          inflater.inflateAsync(function (result) {\n            result.copy(data, 0);\n            if (!crc32OK(data)) {\n              if (callback) callback(data, Utils.Errors.BAD_CRC); //si added error\n            } else {\n              //si added otherwise did not seem to return data.\n              if (callback) callback(data);\n            }\n          });\n        }\n        break;\n      default:\n        if (async && callback) callback(Buffer.alloc(0), Utils.Errors.UNKNOWN_METHOD);\n        throw new Error(Utils.Errors.UNKNOWN_METHOD);\n    }\n  }\n  function compress( /*Boolean*/async, /*Function*/callback) {\n    if ((!uncompressedData || !uncompressedData.length) && Buffer.isBuffer(input)) {\n      // no data set or the data wasn't changed to require recompression\n      if (async && callback) callback(getCompressedDataFromZip());\n      return getCompressedDataFromZip();\n    }\n    if (uncompressedData.length && !_isDirectory) {\n      var compressedData;\n      // Local file header\n      switch (_entryHeader.method) {\n        case Utils.Constants.STORED:\n          _entryHeader.compressedSize = _entryHeader.size;\n          compressedData = Buffer.alloc(uncompressedData.length);\n          uncompressedData.copy(compressedData);\n          if (async && callback) callback(compressedData);\n          return compressedData;\n        default:\n        case Utils.Constants.DEFLATED:\n          var deflater = new Methods.Deflater(uncompressedData);\n          if (!async) {\n            var deflated = deflater.deflate();\n            _entryHeader.compressedSize = deflated.length;\n            return deflated;\n          } else {\n            deflater.deflateAsync(function (data) {\n              compressedData = Buffer.alloc(data.length);\n              _entryHeader.compressedSize = data.length;\n              data.copy(compressedData);\n              callback && callback(compressedData);\n            });\n          }\n          deflater = null;\n          break;\n      }\n    } else {\n      if (async && callback) {\n        callback(Buffer.alloc(0));\n      } else {\n        return Buffer.alloc(0);\n      }\n    }\n  }\n  function readUInt64LE(buffer, offset) {\n    return (buffer.readUInt32LE(offset + 4) << 4) + buffer.readUInt32LE(offset);\n  }\n  function parseExtra(data) {\n    var offset = 0;\n    var signature, size, part;\n    while (offset < data.length) {\n      signature = data.readUInt16LE(offset);\n      offset += 2;\n      size = data.readUInt16LE(offset);\n      offset += 2;\n      part = data.slice(offset, offset + size);\n      offset += size;\n      if (Constants.ID_ZIP64 === signature) {\n        parseZip64ExtendedInformation(part);\n      }\n    }\n  }\n\n  //Override header field values with values from the ZIP64 extra field\n  function parseZip64ExtendedInformation(data) {\n    var size, compressedSize, offset, diskNumStart;\n    if (data.length >= Constants.EF_ZIP64_SCOMP) {\n      size = readUInt64LE(data, Constants.EF_ZIP64_SUNCOMP);\n      if (_entryHeader.size === Constants.EF_ZIP64_OR_32) {\n        _entryHeader.size = size;\n      }\n    }\n    if (data.length >= Constants.EF_ZIP64_RHO) {\n      compressedSize = readUInt64LE(data, Constants.EF_ZIP64_SCOMP);\n      if (_entryHeader.compressedSize === Constants.EF_ZIP64_OR_32) {\n        _entryHeader.compressedSize = compressedSize;\n      }\n    }\n    if (data.length >= Constants.EF_ZIP64_DSN) {\n      offset = readUInt64LE(data, Constants.EF_ZIP64_RHO);\n      if (_entryHeader.offset === Constants.EF_ZIP64_OR_32) {\n        _entryHeader.offset = offset;\n      }\n    }\n    if (data.length >= Constants.EF_ZIP64_DSN + 4) {\n      diskNumStart = data.readUInt32LE(Constants.EF_ZIP64_DSN);\n      if (_entryHeader.diskNumStart === Constants.EF_ZIP64_OR_16) {\n        _entryHeader.diskNumStart = diskNumStart;\n      }\n    }\n  }\n  return {\n    get entryName() {\n      return _entryName.toString();\n    },\n    get rawEntryName() {\n      return _entryName;\n    },\n    set entryName(val) {\n      _entryName = Utils.toBuffer(val);\n      var lastChar = _entryName[_entryName.length - 1];\n      _isDirectory = lastChar === 47 || lastChar === 92;\n      _entryHeader.fileNameLength = _entryName.length;\n    },\n    get extra() {\n      return _extra;\n    },\n    set extra(val) {\n      _extra = val;\n      _entryHeader.extraLength = val.length;\n      parseExtra(val);\n    },\n    get comment() {\n      return _comment.toString();\n    },\n    set comment(val) {\n      _comment = Utils.toBuffer(val);\n      _entryHeader.commentLength = _comment.length;\n    },\n    get name() {\n      var n = _entryName.toString();\n      return _isDirectory ? n.substr(n.length - 1).split(\"/\").pop() : n.split(\"/\").pop();\n    },\n    get isDirectory() {\n      return _isDirectory;\n    },\n    getCompressedData: function () {\n      return compress(false, null);\n    },\n    getCompressedDataAsync: function ( /*Function*/callback) {\n      compress(true, callback);\n    },\n    setData: function (value) {\n      uncompressedData = Utils.toBuffer(value);\n      if (!_isDirectory && uncompressedData.length) {\n        _entryHeader.size = uncompressedData.length;\n        _entryHeader.method = Utils.Constants.DEFLATED;\n        _entryHeader.crc = Utils.crc32(value);\n        _entryHeader.changed = true;\n      } else {\n        // folders and blank files should be stored\n        _entryHeader.method = Utils.Constants.STORED;\n      }\n    },\n    getData: function (pass) {\n      if (_entryHeader.changed) {\n        return uncompressedData;\n      } else {\n        return decompress(false, null, pass);\n      }\n    },\n    getDataAsync: function ( /*Function*/callback, pass) {\n      if (_entryHeader.changed) {\n        callback(uncompressedData);\n      } else {\n        decompress(true, callback, pass);\n      }\n    },\n    set attr(attr) {\n      _entryHeader.attr = attr;\n    },\n    get attr() {\n      return _entryHeader.attr;\n    },\n    set header( /*Buffer*/data) {\n      _entryHeader.loadFromBinary(data);\n    },\n    get header() {\n      return _entryHeader;\n    },\n    packHeader: function () {\n      var header = _entryHeader.entryHeaderToBinary();\n      // add\n      _entryName.copy(header, Utils.Constants.CENHDR);\n      if (_entryHeader.extraLength) {\n        _extra.copy(header, Utils.Constants.CENHDR + _entryName.length);\n      }\n      if (_entryHeader.commentLength) {\n        _comment.copy(header, Utils.Constants.CENHDR + _entryName.length + _entryHeader.extraLength, _comment.length);\n      }\n      return header;\n    },\n    toString: function () {\n      return '{\\n' + '\\t\"entryName\" : \"' + _entryName.toString() + \"\\\",\\n\" + '\\t\"name\" : \"' + (_isDirectory ? _entryName.toString().replace(/\\/$/, '').split(\"/\").pop() : _entryName.toString().split(\"/\").pop()) + \"\\\",\\n\" + '\\t\"comment\" : \"' + _comment.toString() + \"\\\",\\n\" + '\\t\"isDirectory\" : ' + _isDirectory + \",\\n\" + '\\t\"header\" : ' + _entryHeader.toString().replace(/\\t/mg, \"\\t\\t\").replace(/}/mg, \"\\t}\") + \",\\n\" + '\\t\"compressedData\" : <' + (input && input.length + \" bytes buffer\" || \"null\") + \">\\n\" + '\\t\"data\" : <' + (uncompressedData && uncompressedData.length + \" bytes buffer\" || \"null\") + \">\\n\" + '}';\n    }\n  };\n};","map":{"version":3,"names":["Utils","require","Headers","Constants","Methods","module","exports","input","_entryHeader","EntryHeader","_entryName","Buffer","alloc","_comment","_isDirectory","uncompressedData","_extra","getCompressedDataFromZip","isBuffer","loadDataHeaderFromBinary","slice","realDataOffset","compressedSize","crc32OK","data","flags","crc32","dataHeader","crc","decompress","async","callback","pass","Errors","DIRECTORY_CONTENT_ERROR","compressedData","length","size","method","STORED","copy","BAD_CRC","Error","DEFLATED","inflater","Inflater","result","inflate","toString","inflateAsync","UNKNOWN_METHOD","compress","deflater","Deflater","deflated","deflate","deflateAsync","readUInt64LE","buffer","offset","readUInt32LE","parseExtra","signature","part","readUInt16LE","ID_ZIP64","parseZip64ExtendedInformation","diskNumStart","EF_ZIP64_SCOMP","EF_ZIP64_SUNCOMP","EF_ZIP64_OR_32","EF_ZIP64_RHO","EF_ZIP64_DSN","EF_ZIP64_OR_16","entryName","rawEntryName","val","toBuffer","lastChar","fileNameLength","extra","extraLength","comment","commentLength","name","n","substr","split","pop","isDirectory","getCompressedData","getCompressedDataAsync","setData","value","changed","getData","getDataAsync","attr","header","loadFromBinary","packHeader","entryHeaderToBinary","CENHDR","replace"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/adm-zip/zipEntry.js"],"sourcesContent":["var Utils = require(\"./util\"),\r\n    Headers = require(\"./headers\"),\r\n    Constants = Utils.Constants,\r\n    Methods = require(\"./methods\");\r\n\r\nmodule.exports = function (/*Buffer*/input) {\r\n\r\n    var _entryHeader = new Headers.EntryHeader(),\r\n        _entryName = Buffer.alloc(0),\r\n        _comment = Buffer.alloc(0),\r\n        _isDirectory = false,\r\n        uncompressedData = null,\r\n        _extra = Buffer.alloc(0);\r\n\r\n    function getCompressedDataFromZip() {\r\n        if (!input || !Buffer.isBuffer(input)) {\r\n            return Buffer.alloc(0);\r\n        }\r\n        _entryHeader.loadDataHeaderFromBinary(input);\r\n        return input.slice(_entryHeader.realDataOffset, _entryHeader.realDataOffset + _entryHeader.compressedSize)\r\n    }\r\n\r\n    function crc32OK(data) {\r\n        // if bit 3 (0x08) of the general-purpose flags field is set, then the CRC-32 and file sizes are not known when the header is written\r\n        if ((_entryHeader.flags & 0x8) !== 0x8) {\r\n           if (Utils.crc32(data) !== _entryHeader.dataHeader.crc) {\r\n               return false;\r\n           }\r\n        } else {\r\n            // @TODO: load and check data descriptor header\r\n            // The fields in the local header are filled with zero, and the CRC-32 and size are appended in a 12-byte structure\r\n            // (optionally preceded by a 4-byte signature) immediately after the compressed data:\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function decompress(/*Boolean*/async, /*Function*/callback, /*String*/pass) {\r\n        if(typeof callback === 'undefined' && typeof async === 'string') {\r\n            pass=async;\r\n            async=void 0;\r\n        }\r\n        if (_isDirectory) {\r\n            if (async && callback) {\r\n                callback(Buffer.alloc(0), Utils.Errors.DIRECTORY_CONTENT_ERROR); //si added error.\r\n            }\r\n            return Buffer.alloc(0);\r\n        }\r\n\r\n        var compressedData = getCompressedDataFromZip();\r\n\r\n        if (compressedData.length === 0) {\r\n            // File is empty, nothing to decompress.\r\n            if (async && callback) callback(compressedData);\r\n            return compressedData;\r\n        }\r\n\r\n        var data = Buffer.alloc(_entryHeader.size);\r\n\r\n        switch (_entryHeader.method) {\r\n            case Utils.Constants.STORED:\r\n                compressedData.copy(data);\r\n                if (!crc32OK(data)) {\r\n                    if (async && callback) callback(data, Utils.Errors.BAD_CRC);//si added error\r\n                    throw new Error(Utils.Errors.BAD_CRC);\r\n                } else {//si added otherwise did not seem to return data.\r\n                    if (async && callback) callback(data);\r\n                    return data;\r\n                }\r\n            case Utils.Constants.DEFLATED:\r\n                var inflater = new Methods.Inflater(compressedData);\r\n                if (!async) {\r\n                    var result = inflater.inflate(data);\r\n                    result.copy(data, 0);\r\n                    if (!crc32OK(data)) {\r\n                        throw new Error(Utils.Errors.BAD_CRC + \" \" + _entryName.toString());\r\n                    }\r\n                    return data;\r\n                } else {\r\n                    inflater.inflateAsync(function(result) {\r\n                        result.copy(data, 0);\r\n                        if (!crc32OK(data)) {\r\n                            if (callback) callback(data, Utils.Errors.BAD_CRC); //si added error\r\n                        } else { //si added otherwise did not seem to return data.\r\n                            if (callback) callback(data);\r\n                        }\r\n                    })\r\n                }\r\n                break;\r\n            default:\r\n                if (async && callback) callback(Buffer.alloc(0), Utils.Errors.UNKNOWN_METHOD);\r\n                throw new Error(Utils.Errors.UNKNOWN_METHOD);\r\n        }\r\n    }\r\n\r\n    function compress(/*Boolean*/async, /*Function*/callback) {\r\n        if ((!uncompressedData || !uncompressedData.length) && Buffer.isBuffer(input)) {\r\n            // no data set or the data wasn't changed to require recompression\r\n            if (async && callback) callback(getCompressedDataFromZip());\r\n            return getCompressedDataFromZip();\r\n        }\r\n\r\n        if (uncompressedData.length && !_isDirectory) {\r\n            var compressedData;\r\n            // Local file header\r\n            switch (_entryHeader.method) {\r\n                case Utils.Constants.STORED:\r\n                    _entryHeader.compressedSize = _entryHeader.size;\r\n\r\n                    compressedData = Buffer.alloc(uncompressedData.length);\r\n                    uncompressedData.copy(compressedData);\r\n\r\n                    if (async && callback) callback(compressedData);\r\n                    return compressedData;\r\n                default:\r\n                case Utils.Constants.DEFLATED:\r\n\r\n                    var deflater = new Methods.Deflater(uncompressedData);\r\n                    if (!async) {\r\n                        var deflated = deflater.deflate();\r\n                        _entryHeader.compressedSize = deflated.length;\r\n                        return deflated;\r\n                    } else {\r\n                        deflater.deflateAsync(function(data) {\r\n                            compressedData = Buffer.alloc(data.length);\r\n                            _entryHeader.compressedSize = data.length;\r\n                            data.copy(compressedData);\r\n                            callback && callback(compressedData);\r\n                        })\r\n                    }\r\n                    deflater = null;\r\n                    break;\r\n            }\r\n        } else {\r\n            if (async && callback) {\r\n                callback(Buffer.alloc(0));\r\n            } else {\r\n                return Buffer.alloc(0);\r\n            }\r\n        }\r\n    }\r\n\r\n    function readUInt64LE(buffer, offset) {\r\n        return (buffer.readUInt32LE(offset + 4) << 4) + buffer.readUInt32LE(offset);\r\n    }\r\n\r\n    function parseExtra(data) {\r\n        var offset = 0;\r\n        var signature, size, part;\r\n        while(offset<data.length) {\r\n            signature = data.readUInt16LE(offset);\r\n            offset += 2;\r\n            size = data.readUInt16LE(offset);\r\n            offset += 2;\r\n            part = data.slice(offset, offset+size);\r\n            offset += size;\r\n            if(Constants.ID_ZIP64 === signature) {\r\n                parseZip64ExtendedInformation(part);\r\n            }\r\n        }\r\n    }\r\n\r\n    //Override header field values with values from the ZIP64 extra field\r\n    function parseZip64ExtendedInformation(data) {\r\n        var size, compressedSize, offset, diskNumStart;\r\n\r\n        if(data.length >= Constants.EF_ZIP64_SCOMP) {\r\n            size = readUInt64LE(data, Constants.EF_ZIP64_SUNCOMP);\r\n            if(_entryHeader.size === Constants.EF_ZIP64_OR_32) {\r\n                _entryHeader.size = size;\r\n            }\r\n        }\r\n        if(data.length >= Constants.EF_ZIP64_RHO) {\r\n            compressedSize = readUInt64LE(data, Constants.EF_ZIP64_SCOMP);\r\n            if(_entryHeader.compressedSize === Constants.EF_ZIP64_OR_32) {\r\n                _entryHeader.compressedSize = compressedSize;\r\n            }\r\n        }\r\n        if(data.length >= Constants.EF_ZIP64_DSN) {\r\n            offset = readUInt64LE(data, Constants.EF_ZIP64_RHO);\r\n            if(_entryHeader.offset === Constants.EF_ZIP64_OR_32) {\r\n                _entryHeader.offset = offset;\r\n            }\r\n        }\r\n        if(data.length >= Constants.EF_ZIP64_DSN+4) {\r\n            diskNumStart = data.readUInt32LE(Constants.EF_ZIP64_DSN);\r\n            if(_entryHeader.diskNumStart === Constants.EF_ZIP64_OR_16) {\r\n                _entryHeader.diskNumStart = diskNumStart;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    return {\r\n        get entryName () { return _entryName.toString(); },\r\n        get rawEntryName() { return _entryName; },\r\n        set entryName (val) {\r\n            _entryName = Utils.toBuffer(val);\r\n            var lastChar = _entryName[_entryName.length - 1];\r\n            _isDirectory = (lastChar === 47) || (lastChar === 92);\r\n            _entryHeader.fileNameLength = _entryName.length;\r\n        },\r\n\r\n        get extra () { return _extra; },\r\n        set extra (val) {\r\n            _extra = val;\r\n            _entryHeader.extraLength = val.length;\r\n            parseExtra(val);\r\n        },\r\n\r\n        get comment () { return _comment.toString(); },\r\n        set comment (val) {\r\n            _comment = Utils.toBuffer(val);\r\n            _entryHeader.commentLength = _comment.length;\r\n        },\r\n\r\n        get name () { var n = _entryName.toString(); return _isDirectory ? n.substr(n.length - 1).split(\"/\").pop() : n.split(\"/\").pop(); },\r\n        get isDirectory () { return _isDirectory },\r\n\r\n        getCompressedData : function() {\r\n            return compress(false, null)\r\n        },\r\n\r\n        getCompressedDataAsync : function(/*Function*/callback) {\r\n            compress(true, callback)\r\n        },\r\n\r\n        setData : function(value) {\r\n            uncompressedData = Utils.toBuffer(value);\r\n            if (!_isDirectory && uncompressedData.length) {\r\n                _entryHeader.size = uncompressedData.length;\r\n                _entryHeader.method = Utils.Constants.DEFLATED;\r\n                _entryHeader.crc = Utils.crc32(value);\r\n                _entryHeader.changed = true;\r\n            } else { // folders and blank files should be stored\r\n                _entryHeader.method = Utils.Constants.STORED;\r\n            }\r\n        },\r\n\r\n        getData : function(pass) {\r\n            if (_entryHeader.changed) {\r\n\t\t\t\treturn uncompressedData;\r\n\t\t\t} else {\r\n\t\t\t\treturn decompress(false, null, pass);\r\n            }\r\n        },\r\n\r\n        getDataAsync : function(/*Function*/callback, pass) {\r\n\t\t\tif (_entryHeader.changed) {\r\n\t\t\t\tcallback(uncompressedData)\r\n\t\t\t} else {\r\n\t\t\t\tdecompress(true, callback, pass)\r\n            }\r\n        },\r\n\r\n        set attr(attr) { _entryHeader.attr = attr; },\r\n        get attr() { return _entryHeader.attr; },\r\n\r\n        set header(/*Buffer*/data) {\r\n            _entryHeader.loadFromBinary(data);\r\n        },\r\n\r\n        get header() {\r\n            return _entryHeader;\r\n        },\r\n\r\n        packHeader : function() {\r\n            var header = _entryHeader.entryHeaderToBinary();\r\n            // add\r\n            _entryName.copy(header, Utils.Constants.CENHDR);\r\n            if (_entryHeader.extraLength) {\r\n                _extra.copy(header, Utils.Constants.CENHDR + _entryName.length)\r\n            }\r\n            if (_entryHeader.commentLength) {\r\n                _comment.copy(header, Utils.Constants.CENHDR + _entryName.length + _entryHeader.extraLength, _comment.length);\r\n            }\r\n            return header;\r\n        },\r\n\r\n        toString : function() {\r\n            return '{\\n' +\r\n                '\\t\"entryName\" : \"' + _entryName.toString() + \"\\\",\\n\" +\r\n                '\\t\"name\" : \"' + (_isDirectory ? _entryName.toString().replace(/\\/$/, '').split(\"/\").pop() : _entryName.toString().split(\"/\").pop()) + \"\\\",\\n\" +\r\n                '\\t\"comment\" : \"' + _comment.toString() + \"\\\",\\n\" +\r\n                '\\t\"isDirectory\" : ' + _isDirectory + \",\\n\" +\r\n                '\\t\"header\" : ' + _entryHeader.toString().replace(/\\t/mg, \"\\t\\t\").replace(/}/mg, \"\\t}\")  + \",\\n\" +\r\n                '\\t\"compressedData\" : <' + (input && input.length  + \" bytes buffer\" || \"null\") + \">\\n\" +\r\n                '\\t\"data\" : <' + (uncompressedData && uncompressedData.length  + \" bytes buffer\" || \"null\") + \">\\n\" +\r\n                '}';\r\n        }\r\n    }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}