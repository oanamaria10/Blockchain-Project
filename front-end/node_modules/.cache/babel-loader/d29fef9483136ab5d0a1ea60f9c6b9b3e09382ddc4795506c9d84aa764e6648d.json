{"ast":null,"code":"import * as varint from './varint.js';\nimport * as Digest from './hashes/digest.js';\nimport { base58btc } from './bases/base58.js';\nimport { base32 } from './bases/base32.js';\nimport { coerce } from './bytes.js';\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\";\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js';\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport const format = (link, base) => {\n  const {\n    bytes,\n    version\n  } = link;\n  switch (version) {\n    case 0:\n      return toStringV0(bytes, baseCache(link), /** @type {API.MultibaseEncoder<\"z\">} */base || base58btc.encoder);\n    default:\n      return toStringV1(bytes, baseCache(link), /** @type {API.MultibaseEncoder<Prefix>} */base || base32.encoder);\n  }\n};\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nconst cache = new WeakMap();\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nconst baseCache = cid => {\n  const baseCache = cache.get(cid);\n  if (baseCache == null) {\n    const baseCache = new Map();\n    cache.set(cid, baseCache);\n    return baseCache;\n  }\n  return baseCache;\n};\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   *\n   */\n  constructor(version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code;\n    /** @readonly */\n    this.version = version;\n    /** @readonly */\n    this.multihash = multihash;\n    /** @readonly */\n    this.bytes = bytes;\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes;\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID() {\n    return this;\n  }\n\n  // ArrayBufferView\n  get byteOffset() {\n    return this.bytes.byteOffset;\n  }\n\n  // ArrayBufferView\n  get byteLength() {\n    return this.bytes.byteLength;\n  }\n\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n  toV0() {\n    switch (this.version) {\n      case 0:\n        {\n          return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */this;\n        }\n      case 1:\n        {\n          const {\n            code,\n            multihash\n          } = this;\n          if (code !== DAG_PB_CODE) {\n            throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n          }\n\n          // sha2-256\n          if (multihash.code !== SHA_256_CODE) {\n            throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n          }\n          return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */(\n            CID.createV0( /** @type {API.MultihashDigest<API.SHA_256>} */multihash)\n          );\n        }\n      default:\n        {\n          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);\n        }\n    }\n  }\n\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n  toV1() {\n    switch (this.version) {\n      case 0:\n        {\n          const {\n            code,\n            digest\n          } = this.multihash;\n          const multihash = Digest.create(code, digest);\n          return /** @type {CID<Data, Format, Alg, 1>} */(\n            CID.createV1(this.code, multihash)\n          );\n        }\n      case 1:\n        {\n          return /** @type {CID<Data, Format, Alg, 1>} */this;\n        }\n      default:\n        {\n          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);\n        }\n    }\n  }\n\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n  equals(other) {\n    return CID.equals(this, other);\n  }\n\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n  static equals(self, other) {\n    const unknown = /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */\n    other;\n    return unknown && self.code === unknown.code && self.version === unknown.version && Digest.equals(self.multihash, unknown.multihash);\n  }\n\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n  toString(base) {\n    return format(this, base);\n  }\n  toJSON() {\n    return {\n      code: this.code,\n      version: this.version,\n      hash: this.multihash.bytes\n    };\n  }\n  link() {\n    return this;\n  }\n  get [Symbol.toStringTag]() {\n    return 'CID';\n  }\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return `CID(${this.toString()})`;\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returs null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n  static asCID(input) {\n    if (input == null) {\n      return null;\n    }\n    const value = /** @type {any} */input;\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value;\n    } else if (value['/'] != null && value['/'] === value.bytes || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const {\n        version,\n        code,\n        multihash,\n        bytes\n      } = value;\n      return new CID(version, code, /** @type {API.MultihashDigest<Alg>} */multihash, bytes || encodeCID(version, code, multihash.bytes));\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const {\n        version,\n        multihash,\n        code\n      } = value;\n      const digest = /** @type {API.MultihashDigest<Alg>} */\n      Digest.decode(multihash);\n      return CID.create(version, code, digest);\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null;\n    }\n  }\n\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n  static create(version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported');\n    }\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest');\n    }\n    switch (version) {\n      case 0:\n        {\n          if (code !== DAG_PB_CODE) {\n            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);\n          } else {\n            return new CID(version, code, digest, digest.bytes);\n          }\n        }\n      case 1:\n        {\n          const bytes = encodeCID(version, code, digest.bytes);\n          return new CID(version, code, digest, bytes);\n        }\n      default:\n        {\n          throw new Error('Invalid version');\n        }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n  static createV0(digest) {\n    return CID.create(0, DAG_PB_CODE, digest);\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n  static createV1(code, digest) {\n    return CID.create(1, code, digest);\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static decode(bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes);\n    if (remainder.length) {\n      throw new Error('Incorrect length');\n    }\n    return cid;\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n  static decodeFirst(bytes) {\n    const specs = CID.inspectBytes(bytes);\n    const prefixSize = specs.size - specs.multihashSize;\n    const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length');\n    }\n    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);\n    const digest = new Digest.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);\n    const cid = specs.version === 0 ? CID.createV0( /** @type {API.MultihashDigest<API.SHA_256>} */digest) : CID.createV1(specs.codec, digest);\n    return [( /** @type {CID<T, C, A, V>} */cid), bytes.subarray(specs.size)];\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n  static inspectBytes(initialBytes) {\n    let offset = 0;\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset));\n      offset += length;\n      return i;\n    };\n    let version = /** @type {V} */next();\n    let codec = /** @type {C} */DAG_PB_CODE;\n    if ( /** @type {number} */version === 18) {\n      // CIDv0\n      version = /** @type {V} */0;\n      offset = 0;\n    } else {\n      codec = /** @type {C} */next();\n    }\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`);\n    }\n    const prefixSize = offset;\n    const multihashCode = /** @type {A} */next(); // multihash code\n    const digestSize = next(); // multihash length\n    const size = offset + digestSize;\n    const multihashSize = size - prefixSize;\n    return {\n      version,\n      codec,\n      multihashCode,\n      digestSize,\n      multihashSize,\n      size\n    };\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static parse(source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base);\n    const cid = CID.decode(bytes);\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source);\n    return cid;\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q':\n      {\n        const decoder = base || base58btc;\n        return [( /** @type {Prefix} */base58btc.prefix), decoder.decode(`${base58btc.prefix}${source}`)];\n      }\n    case base58btc.prefix:\n      {\n        const decoder = base || base58btc;\n        return [( /** @type {Prefix} */base58btc.prefix), decoder.decode(source)];\n      }\n    case base32.prefix:\n      {\n        const decoder = base || base32;\n        return [( /** @type {Prefix} */base32.prefix), decoder.decode(source)];\n      }\n    default:\n      {\n        if (base == null) {\n          throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');\n        }\n        return [( /** @type {Prefix} */source[0]), base.decode(source)];\n      }\n  }\n};\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nconst toStringV0 = (bytes, cache, base) => {\n  const {\n    prefix\n  } = base;\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`);\n  }\n  const cid = cache.get(prefix);\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1);\n    cache.set(prefix, cid);\n    return cid;\n  } else {\n    return cid;\n  }\n};\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nconst toStringV1 = (bytes, cache, base) => {\n  const {\n    prefix\n  } = base;\n  const cid = cache.get(prefix);\n  if (cid == null) {\n    const cid = base.encode(bytes);\n    cache.set(prefix, cid);\n    return cid;\n  } else {\n    return cid;\n  }\n};\nconst DAG_PB_CODE = 0x70;\nconst SHA_256_CODE = 0x12;\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version);\n  const hashOffset = codeOffset + varint.encodingLength(code);\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength);\n  varint.encodeTo(version, bytes, 0);\n  varint.encodeTo(code, bytes, codeOffset);\n  bytes.set(multihash, hashOffset);\n  return bytes;\n};\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID');","map":{"version":3,"names":["varint","Digest","base58btc","base32","coerce","API","format","link","base","bytes","version","toStringV0","baseCache","encoder","toStringV1","cache","WeakMap","cid","get","Map","set","CID","constructor","code","multihash","asCID","byteOffset","byteLength","toV0","DAG_PB_CODE","Error","SHA_256_CODE","createV0","toV1","digest","create","createV1","equals","other","self","unknown","toString","toJSON","hash","Symbol","toStringTag","for","input","value","encodeCID","cidSymbol","decode","Uint8Array","remainder","decodeFirst","length","specs","inspectBytes","prefixSize","size","multihashSize","multihashBytes","subarray","digestBytes","digestSize","multihashCode","codec","initialBytes","offset","next","i","RangeError","parse","source","prefix","parseCIDtoBytes","decoder","name","encode","slice","codeOffset","encodingLength","hashOffset","encodeTo"],"sources":["C:/FACULTATE/Proiect/node_modules/@libp2p/peer-id/node_modules/multiformats/src/cid.js"],"sourcesContent":["import * as varint from './varint.js'\nimport * as Digest from './hashes/digest.js'\nimport { base58btc } from './bases/base58.js'\nimport { base32 } from './bases/base32.js'\nimport { coerce } from './bytes.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport const format = (link, base) => {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<\"z\">} */ (base) || base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<Prefix>} */ (base || base32.encoder)\n      )\n  }\n}\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nconst cache = new WeakMap()\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nconst baseCache = cid => {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   *\n   */\n  constructor (version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code\n    /** @readonly */\n    this.version = version\n    /** @readonly */\n    this.multihash = multihash\n    /** @readonly */\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID () {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset () {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength () {\n    return this.bytes.byteLength\n  }\n\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n  toV0 () {\n    switch (this.version) {\n      case 0: {\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (this)\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (\n          CID.createV0(\n            /** @type {API.MultihashDigest<API.SHA_256>} */ (multihash)\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n  toV1 () {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return /** @type {CID<Data, Format, Alg, 1>} */ (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return /** @type {CID<Data, Format, Alg, 1>} */ (this)\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n  equals (other) {\n    return CID.equals(this, other)\n  }\n\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n  static equals (self, other) {\n    const unknown =\n      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ (\n        other\n      )\n    return (\n      unknown &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n  toString (base) {\n    return format(this, base)\n  }\n\n  toJSON () {\n    return {\n      code: this.code,\n      version: this.version,\n      hash: this.multihash.bytes\n    }\n  }\n\n  link () {\n    return this\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'CID'\n  }\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returs null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n  static asCID (input) {\n    if (input == null) {\n      return null\n    }\n\n    const value = /** @type {any} */ (input)\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        /** @type {API.MultihashDigest<Alg>} */ (multihash),\n        bytes || encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest =\n        /** @type {API.MultihashDigest<Alg>} */\n        (Digest.decode(multihash))\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n  static create (version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n  static createV0 (digest) {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n  static createV1 (code, digest) {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static decode (bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n  static decodeFirst (bytes) {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ (digest))\n        : CID.createV1(specs.codec, digest)\n    return [/** @type {CID<T, C, A, V>} */(cid), bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n  static inspectBytes (initialBytes) {\n    let offset = 0\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = /** @type {V} */ (next())\n    let codec = /** @type {C} */ (DAG_PB_CODE)\n    if (/** @type {number} */(version) === 18) {\n      // CIDv0\n      version = /** @type {V} */ (0)\n      offset = 0\n    } else {\n      codec = /** @type {C} */ (next())\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = /** @type {A} */ (next()) // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static parse (source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base || base58btc\n      return [\n        /** @type {Prefix} */ (base58btc.prefix),\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base || base58btc\n      return [/** @type {Prefix} */(base58btc.prefix), decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base || base32\n      return [/** @type {Prefix} */(base32.prefix), decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [/** @type {Prefix} */(source[0]), base.decode(source)]\n    }\n  }\n}\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nconst toStringV0 = (bytes, cache, base) => {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nconst toStringV1 = (bytes, cache, base) => {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}