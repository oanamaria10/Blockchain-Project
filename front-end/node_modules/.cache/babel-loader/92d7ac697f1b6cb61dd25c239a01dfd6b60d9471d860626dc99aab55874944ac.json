{"ast":null,"code":"import { makeCborEncoders, objectToTokens } from './encode.js';\nimport { quickEncodeToken } from './jump.js';\n\n/**\n * @typedef {import('../interface').EncodeOptions} EncodeOptions\n * @typedef {import('../interface').TokenTypeEncoder} TokenTypeEncoder\n * @typedef {import('../interface').TokenOrNestedTokens} TokenOrNestedTokens\n */\n\nconst cborEncoders = makeCborEncoders();\n\n/** @type {EncodeOptions} */\nconst defaultEncodeOptions = {\n  float64: false,\n  quickEncodeToken\n};\n\n/**\n * Calculate the byte length of the given data when encoded as CBOR with the\n * options provided.\n * This calculation will be accurate if the same options are used as when\n * performing a normal encode. Some encode options can change the encoding\n * output length.\n *\n * @param {any} data\n * @param {EncodeOptions} [options]\n * @returns {number}\n */\nexport function encodedLength(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  options.mapSorter = undefined; // won't change the length\n  const tokens = objectToTokens(data, options);\n  return tokensToLength(tokens, cborEncoders, options);\n}\n\n/**\n * Calculate the byte length of the data as represented by the given tokens when\n * encoded as CBOR with the options provided.\n * This function is for advanced users and would not normally be called\n * directly. See `encodedLength()` for appropriate use.\n *\n * @param {TokenOrNestedTokens} tokens\n * @param {TokenTypeEncoder[]} [encoders]\n * @param {EncodeOptions} [options]\n */\nexport function tokensToLength(tokens, encoders = cborEncoders, options = defaultEncodeOptions) {\n  if (Array.isArray(tokens)) {\n    let len = 0;\n    for (const token of tokens) {\n      len += tokensToLength(token, encoders, options);\n    }\n    return len;\n  } else {\n    const encoder = encoders[tokens.type.major];\n    /* c8 ignore next 3 */\n    if (encoder.encodedSize === undefined || typeof encoder.encodedSize !== 'function') {\n      throw new Error(`Encoder for ${tokens.type.name} does not have an encodedSize()`);\n    }\n    return encoder.encodedSize(tokens, options);\n  }\n}","map":{"version":3,"names":["makeCborEncoders","objectToTokens","quickEncodeToken","cborEncoders","defaultEncodeOptions","float64","encodedLength","data","options","Object","assign","mapSorter","undefined","tokens","tokensToLength","encoders","Array","isArray","len","token","encoder","type","major","encodedSize","Error","name"],"sources":["C:/FACULTATE/Proiect/node_modules/@web3-storage/access/node_modules/cborg/lib/length.js"],"sourcesContent":["import { makeCborEncoders, objectToTokens } from './encode.js'\nimport { quickEncodeToken } from './jump.js'\n\n/**\n * @typedef {import('../interface').EncodeOptions} EncodeOptions\n * @typedef {import('../interface').TokenTypeEncoder} TokenTypeEncoder\n * @typedef {import('../interface').TokenOrNestedTokens} TokenOrNestedTokens\n */\n\nconst cborEncoders = makeCborEncoders()\n\n/** @type {EncodeOptions} */\nconst defaultEncodeOptions = {\n  float64: false,\n  quickEncodeToken\n}\n\n/**\n * Calculate the byte length of the given data when encoded as CBOR with the\n * options provided.\n * This calculation will be accurate if the same options are used as when\n * performing a normal encode. Some encode options can change the encoding\n * output length.\n *\n * @param {any} data\n * @param {EncodeOptions} [options]\n * @returns {number}\n */\nexport function encodedLength (data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options)\n  options.mapSorter = undefined // won't change the length\n  const tokens = objectToTokens(data, options)\n  return tokensToLength(tokens, cborEncoders, options)\n}\n\n/**\n * Calculate the byte length of the data as represented by the given tokens when\n * encoded as CBOR with the options provided.\n * This function is for advanced users and would not normally be called\n * directly. See `encodedLength()` for appropriate use.\n *\n * @param {TokenOrNestedTokens} tokens\n * @param {TokenTypeEncoder[]} [encoders]\n * @param {EncodeOptions} [options]\n */\nexport function tokensToLength (tokens, encoders = cborEncoders, options = defaultEncodeOptions) {\n  if (Array.isArray(tokens)) {\n    let len = 0\n    for (const token of tokens) {\n      len += tokensToLength(token, encoders, options)\n    }\n    return len\n  } else {\n    const encoder = encoders[tokens.type.major]\n    /* c8 ignore next 3 */\n    if (encoder.encodedSize === undefined || typeof encoder.encodedSize !== 'function') {\n      throw new Error(`Encoder for ${tokens.type.name} does not have an encodedSize()`)\n    }\n    return encoder.encodedSize(tokens, options)\n  }\n}\n"],"mappings":"AAAA,SAASA,gBAAgB,EAAEC,cAAc,QAAQ,aAAa;AAC9D,SAASC,gBAAgB,QAAQ,WAAW;;AAE5C;AACA;AACA;AACA;AACA;;AAEA,MAAMC,YAAY,GAAGH,gBAAgB,CAAC,CAAC;;AAEvC;AACA,MAAMI,oBAAoB,GAAG;EAC3BC,OAAO,EAAE,KAAK;EACdH;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASI,aAAaA,CAAEC,IAAI,EAAEC,OAAO,EAAE;EAC5CA,OAAO,GAAGC,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEN,oBAAoB,EAAEI,OAAO,CAAC;EAC1DA,OAAO,CAACG,SAAS,GAAGC,SAAS,EAAC;EAC9B,MAAMC,MAAM,GAAGZ,cAAc,CAACM,IAAI,EAAEC,OAAO,CAAC;EAC5C,OAAOM,cAAc,CAACD,MAAM,EAAEV,YAAY,EAAEK,OAAO,CAAC;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASM,cAAcA,CAAED,MAAM,EAAEE,QAAQ,GAAGZ,YAAY,EAAEK,OAAO,GAAGJ,oBAAoB,EAAE;EAC/F,IAAIY,KAAK,CAACC,OAAO,CAACJ,MAAM,CAAC,EAAE;IACzB,IAAIK,GAAG,GAAG,CAAC;IACX,KAAK,MAAMC,KAAK,IAAIN,MAAM,EAAE;MAC1BK,GAAG,IAAIJ,cAAc,CAACK,KAAK,EAAEJ,QAAQ,EAAEP,OAAO,CAAC;IACjD;IACA,OAAOU,GAAG;EACZ,CAAC,MAAM;IACL,MAAME,OAAO,GAAGL,QAAQ,CAACF,MAAM,CAACQ,IAAI,CAACC,KAAK,CAAC;IAC3C;IACA,IAAIF,OAAO,CAACG,WAAW,KAAKX,SAAS,IAAI,OAAOQ,OAAO,CAACG,WAAW,KAAK,UAAU,EAAE;MAClF,MAAM,IAAIC,KAAK,CAAE,eAAcX,MAAM,CAACQ,IAAI,CAACI,IAAK,iCAAgC,CAAC;IACnF;IACA,OAAOL,OAAO,CAACG,WAAW,CAACV,MAAM,EAAEL,OAAO,CAAC;EAC7C;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}