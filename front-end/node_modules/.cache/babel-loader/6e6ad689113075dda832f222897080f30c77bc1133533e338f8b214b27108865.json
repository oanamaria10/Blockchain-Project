{"ast":null,"code":"import * as PermaMap from \"@perma/map\";\nimport * as UnixFSPermaMap from \"@perma/map/unixfs\";\nimport * as PB from \"@ipld/dag-pb\";\nimport { murmur364 } from \"@multiformats/murmur3\";\nimport { Block } from 'multiformats/block';\nimport * as API from \"./directory/api.js\";\nimport * as File from \"./file.js\";\nimport * as UnixFS from \"./codec.js\";\nimport { set, remove } from \"./directory.js\";\nexport * from \"./directory/api.js\";\nexport { set, remove } from \"./directory.js\";\nexport const configure = File.configure;\nexport const defaults = File.defaults;\n\n/**\n * @template [Layout=unknown]\n * @param {API.Options<Layout>} config\n * @returns {API.View<Layout>}\n */\nexport const create = ({\n  writer,\n  settings = defaults(),\n  metadata = {}\n}) => new HAMTDirectoryWriter({\n  writer,\n  metadata,\n  settings,\n  entries: new HashMap(),\n  closed: false\n});\n\n/**\n * @template {API.State} Writer\n * @param {Writer} writer\n * @returns {Writer}\n */\nconst asWritable = writer => {\n  if (!writer.closed) {\n    return writer;\n  } else {\n    throw new Error(\"Can not change written HAMT directory, but you can .fork() and make changes to it\");\n  }\n};\n\n/**\n * @template {unknown} Layout\n * @param {{ state: API.State<Layout> }} view\n * @param {API.CloseOptions} options\n * @returns {Promise<UnixFS.DirectoryLink>}\n */\nexport const close = async (view, {\n  closeWriter = false,\n  releaseLock = false\n} = {}) => {\n  const {\n    writer,\n    settings,\n    metadata\n  } = asWritable(view.state);\n  view.state.closed = true;\n  const {\n    entries\n  } = view.state;\n  /* c8 ignore next 3 */\n  if (!(entries instanceof HashMap)) {\n    throw new Error(`not a HAMT: ${entries}`);\n  }\n  const hamt = entries.builder.build();\n  const blocks = iterateBlocks(hamt, hamt.root, settings);\n\n  /** @type {UnixFS.BlockView<UnixFS.DirectoryShard>?} */\n  let root = null;\n  for await (const block of blocks) {\n    root = block;\n    // we make sure that writer has some capacity for this write. If it\n    // does not we await.\n    if ((writer.desiredSize || 0) <= 0) {\n      await writer.ready;\n    }\n    // once writer has some capacity we write a block, however we do not\n    // await completion as we don't care when it's taken off the stream.\n    writer.write(block);\n  }\n  /* c8 ignore next */\n  if (root == null) throw new Error(\"no root block yielded\");\n  if (closeWriter) {\n    await writer.close();\n  } else if (releaseLock) {\n    writer.releaseLock();\n  }\n  return {\n    cid: root.cid,\n    dagByteLength: UnixFS.cumulativeDagByteLength(root.bytes, root.value.entries)\n  };\n};\n\n/**\n * @template {unknown} Layout\n * @param {UnixFSPermaMap.PersistentHashMap<API.EntryLink>} hamt\n * @param {UnixFSPermaMap.BitmapIndexedNode<API.EntryLink>} node\n * @param {API.EncoderSettings<Layout>} settings\n * @returns {AsyncIterableIterator<UnixFS.BlockView<UnixFS.DirectoryShard>>}\n */\nconst iterateBlocks = async function* (hamt, node, settings) {\n  /** @type {UnixFS.DirectoryEntryLink[]} */\n  const entries = [];\n  for (const ent of UnixFSPermaMap.iterate(node)) {\n    if ('key' in ent) {\n      entries.push( /** @type {UnixFS.DirectoryEntryLink} */{\n        name: `${ent.prefix ?? ''}${ent.key ?? ''}`,\n        dagByteLength: ent.value.dagByteLength,\n        cid: ent.value.cid\n      });\n    } else {\n      /** @type {UnixFS.BlockView<UnixFS.DirectoryShard>?} */\n      let root = null;\n      for await (const block of iterateBlocks(hamt, ent.node, settings)) {\n        yield block;\n        root = block;\n      }\n      /* c8 ignore next */\n      if (root == null) throw new Error(\"no root block yielded\");\n      entries.push( /** @type {UnixFS.ShardedDirectoryLink} */{\n        name: ent.prefix,\n        dagByteLength: UnixFS.cumulativeDagByteLength(root.bytes, root.value.entries),\n        cid: root.cid\n      });\n    }\n  }\n  const shard = UnixFS.createDirectoryShard(entries, UnixFSPermaMap.bitField(node), UnixFSPermaMap.tableSize(hamt), murmur364.code);\n  yield await encodeHAMTShardBlock(shard, settings);\n};\n\n/**\n * @template {unknown} Layout\n * @param {UnixFS.DirectoryShard} shard\n * @param {API.EncoderSettings<Layout>} settings\n * @returns {Promise<UnixFS.BlockView<UnixFS.DirectoryShard>>}\n */\nasync function encodeHAMTShardBlock(shard, settings) {\n  const bytes = UnixFS.encodeHAMTShard(shard);\n  const hash = await settings.hasher.digest(bytes);\n  const cid = settings.linker.createLink(PB.code, hash);\n  // @ts-ignore Link is not CID\n  return new Block({\n    cid,\n    bytes,\n    value: shard\n  });\n}\n\n/**\n * @template L1, L2\n * @param {API.View<L1>} state\n * @param {Partial<API.Options<L1|L2>>} options\n * @returns {API.View<L1|L2>}\n */\nexport const fork = ({\n  state\n}, {\n  writer = state.writer,\n  metadata = state.metadata,\n  settings = state.settings\n} = {}) => new HAMTDirectoryWriter({\n  writer,\n  metadata,\n  settings,\n  entries: new HashMap(UnixFSPermaMap.from(state.entries.entries()).createBuilder()),\n  closed: false\n});\n\n/**\n * @template [Layout=unknown]\n * @implements {API.View<Layout>}\n */\nclass HAMTDirectoryWriter {\n  /**\n   * @param {API.State<Layout>} state\n   */\n  constructor(state) {\n    this.state = state;\n  }\n  get writer() {\n    return this.state.writer;\n  }\n  get settings() {\n    return this.state.settings;\n  }\n\n  /**\n   * @param {string} name\n   * @param {UnixFS.FileLink | UnixFS.DirectoryLink} link\n   * @param {API.WriteOptions} [options]\n   */\n\n  set(name, link, options) {\n    return set(this, name, link, options);\n  }\n\n  /**\n   * @param {string} name\n   */\n  remove(name) {\n    return remove(this, name);\n  }\n\n  /**\n   * @template L\n   * @param {Partial<API.Options<L>>} [options]\n   * @returns {API.View<Layout|L>}\n   */\n  fork(options) {\n    return fork(this, options);\n  }\n\n  /**\n   * @param {API.CloseOptions} [options]\n   * @returns {Promise<UnixFS.DirectoryLink>}\n   */\n  close(options) {\n    return close(this, options);\n  }\n  entries() {\n    return this.state.entries.entries();\n  }\n  /**\n   * @param {string} name\n   */\n  has(name) {\n    return this.state.entries.has(name);\n  }\n  get size() {\n    return this.state.entries.size;\n  }\n}\n\n/**\n * @implements {Map<string, API.EntryLink>}\n */\nclass HashMap extends Map {\n  /**\n   * @param {UnixFSPermaMap.HashMapBuilder} [builder]\n   */\n  constructor(builder = UnixFSPermaMap.builder()) {\n    super();\n    /** @type {UnixFSPermaMap.HashMapBuilder} */\n    this.builder = builder;\n  }\n  clear() {\n    this.builder = UnixFSPermaMap.builder();\n  }\n\n  /**\n   * @param {string} key\n   */\n  delete(key) {\n    const {\n      root\n    } = this.builder;\n    this.builder.delete(key);\n    return this.builder.root !== root;\n  }\n\n  /**\n   * @param {(value: API.EntryLink, key: string, map: Map<string, API.EntryLink>) => void} callbackfn\n   * @param {any} [thisArg]\n   */\n  forEach(callbackfn, thisArg = this) {\n    for (const [k, v] of this.builder.root.entries()) {\n      callbackfn.call(thisArg, v, k, this);\n    }\n  }\n\n  /**\n   * @param {string} key\n   */\n  get(key) {\n    return PermaMap.get(this.builder, key);\n  }\n\n  /**\n   * @param {string} key\n   */\n  has(key) {\n    return PermaMap.has(this.builder, key);\n  }\n\n  /**\n   * @param {string} key \n   * @param {API.EntryLink} value \n   */\n  set(key, value) {\n    this.builder.set(key, value);\n    return this;\n  }\n  get size() {\n    return this.builder.size;\n  }\n  [Symbol.iterator]() {\n    return this.builder.root.entries();\n  }\n  entries() {\n    return this.builder.root.entries();\n  }\n  keys() {\n    return this.builder.root.keys();\n  }\n  values() {\n    return this.builder.root.values();\n  }\n}","map":{"version":3,"names":["PermaMap","UnixFSPermaMap","PB","murmur364","Block","API","File","UnixFS","set","remove","configure","defaults","create","writer","settings","metadata","HAMTDirectoryWriter","entries","HashMap","closed","asWritable","Error","close","view","closeWriter","releaseLock","state","hamt","builder","build","blocks","iterateBlocks","root","block","desiredSize","ready","write","cid","dagByteLength","cumulativeDagByteLength","bytes","value","node","ent","iterate","push","name","prefix","key","shard","createDirectoryShard","bitField","tableSize","code","encodeHAMTShardBlock","encodeHAMTShard","hash","hasher","digest","linker","createLink","fork","from","createBuilder","constructor","link","options","has","size","Map","clear","delete","forEach","callbackfn","thisArg","k","v","call","get","Symbol","iterator","keys","values"],"sources":["C:/FACULTATE/Proiect/node_modules/@ipld/unixfs/src/sharded-directory.js"],"sourcesContent":["\nimport * as PermaMap from \"@perma/map\"\nimport * as UnixFSPermaMap from \"@perma/map/unixfs\"\nimport * as PB from \"@ipld/dag-pb\"\nimport { murmur364 } from \"@multiformats/murmur3\"\nimport { Block } from 'multiformats/block'\nimport * as API from \"./directory/api.js\"\nimport * as File from \"./file.js\"\nimport * as UnixFS from \"./codec.js\"\nimport { set, remove } from \"./directory.js\"\n\nexport * from \"./directory/api.js\"\nexport { set, remove } from \"./directory.js\"\n\nexport const configure = File.configure\nexport const defaults = File.defaults\n\n/**\n * @template [Layout=unknown]\n * @param {API.Options<Layout>} config\n * @returns {API.View<Layout>}\n */\nexport const create = ({ writer, settings = defaults(), metadata = {} }) =>\n  new HAMTDirectoryWriter({\n    writer,\n    metadata,\n    settings,\n    entries: new HashMap(),\n    closed: false,\n  })\n\n/**\n * @template {API.State} Writer\n * @param {Writer} writer\n * @returns {Writer}\n */\nconst asWritable = writer => {\n  if (!writer.closed) {\n    return writer\n  } else {\n    throw new Error(\"Can not change written HAMT directory, but you can .fork() and make changes to it\")\n  }\n}\n\n/**\n * @template {unknown} Layout\n * @param {{ state: API.State<Layout> }} view\n * @param {API.CloseOptions} options\n * @returns {Promise<UnixFS.DirectoryLink>}\n */\nexport const close = async (\n  view,\n  { closeWriter = false, releaseLock = false } = {}\n) => {\n  const { writer, settings, metadata } = asWritable(view.state)\n  view.state.closed = true\n\n  const { entries } = view.state\n  /* c8 ignore next 3 */\n  if (!(entries instanceof HashMap)) {\n    throw new Error(`not a HAMT: ${entries}`)\n  }\n\n  const hamt = entries.builder.build()\n  const blocks = iterateBlocks(hamt, hamt.root, settings)\n\n  /** @type {UnixFS.BlockView<UnixFS.DirectoryShard>?} */\n  let root = null\n  for await (const block of blocks) {\n    root = block\n    // we make sure that writer has some capacity for this write. If it\n    // does not we await.\n    if ((writer.desiredSize || 0) <= 0) {\n      await writer.ready\n    }\n    // once writer has some capacity we write a block, however we do not\n    // await completion as we don't care when it's taken off the stream.\n    writer.write(block)\n  }\n  /* c8 ignore next */\n  if (root == null) throw new Error(\"no root block yielded\")\n\n  if (closeWriter) {\n    await writer.close()\n  } else if (releaseLock) {\n    writer.releaseLock()\n  }\n\n  return {\n    cid: root.cid,\n    dagByteLength: UnixFS.cumulativeDagByteLength(root.bytes, root.value.entries),\n  }\n}\n\n/**\n * @template {unknown} Layout\n * @param {UnixFSPermaMap.PersistentHashMap<API.EntryLink>} hamt\n * @param {UnixFSPermaMap.BitmapIndexedNode<API.EntryLink>} node\n * @param {API.EncoderSettings<Layout>} settings\n * @returns {AsyncIterableIterator<UnixFS.BlockView<UnixFS.DirectoryShard>>}\n */\nconst iterateBlocks = async function* (hamt, node, settings) {\n  /** @type {UnixFS.DirectoryEntryLink[]} */\n  const entries = []\n  for (const ent of UnixFSPermaMap.iterate(node)) {\n    if ('key' in ent) {\n      entries.push(/** @type {UnixFS.DirectoryEntryLink} */ ({\n        name: `${ent.prefix ?? ''}${ent.key ?? ''}`,\n        dagByteLength: ent.value.dagByteLength,\n        cid: ent.value.cid,\n      }))\n    } else {\n      /** @type {UnixFS.BlockView<UnixFS.DirectoryShard>?} */\n      let root = null\n      for await (const block of iterateBlocks(hamt, ent.node, settings)) {\n        yield block\n        root = block\n      }\n      /* c8 ignore next */\n      if (root == null) throw new Error(\"no root block yielded\")\n\n      entries.push(/** @type {UnixFS.ShardedDirectoryLink} */ ({\n        name: ent.prefix,\n        dagByteLength: UnixFS.cumulativeDagByteLength(root.bytes, root.value.entries),\n        cid: root.cid\n      }))\n    }\n  }\n\n  const shard = UnixFS.createDirectoryShard(\n    entries,\n    UnixFSPermaMap.bitField(node),\n    UnixFSPermaMap.tableSize(hamt),\n    murmur364.code\n  )\n  yield await encodeHAMTShardBlock(shard, settings)\n}\n\n/**\n * @template {unknown} Layout\n * @param {UnixFS.DirectoryShard} shard\n * @param {API.EncoderSettings<Layout>} settings\n * @returns {Promise<UnixFS.BlockView<UnixFS.DirectoryShard>>}\n */\nasync function encodeHAMTShardBlock (shard, settings) {\n  const bytes = UnixFS.encodeHAMTShard(shard)\n  const hash = await settings.hasher.digest(bytes)\n  const cid = settings.linker.createLink(PB.code, hash)\n  // @ts-ignore Link is not CID\n  return new Block({ cid, bytes, value: shard })\n}\n\n/**\n * @template L1, L2\n * @param {API.View<L1>} state\n * @param {Partial<API.Options<L1|L2>>} options\n * @returns {API.View<L1|L2>}\n */\nexport const fork = (\n  { state },\n  {\n    writer = state.writer,\n    metadata = state.metadata,\n    settings = state.settings,\n  } = {}\n) =>\n  new HAMTDirectoryWriter({\n    writer,\n    metadata,\n    settings,\n    entries: new HashMap(UnixFSPermaMap.from(state.entries.entries()).createBuilder()),\n    closed: false,\n  })\n\n/**\n * @template [Layout=unknown]\n * @implements {API.View<Layout>}\n */\nclass HAMTDirectoryWriter {\n  /**\n   * @param {API.State<Layout>} state\n   */\n  constructor(state) {\n    this.state = state\n  }\n  get writer() {\n    return this.state.writer\n  }\n  get settings() {\n    return this.state.settings\n  }\n\n  /**\n   * @param {string} name\n   * @param {UnixFS.FileLink | UnixFS.DirectoryLink} link\n   * @param {API.WriteOptions} [options]\n   */\n\n  set(name, link, options) {\n    return set(this, name, link, options)\n  }\n\n  /**\n   * @param {string} name\n   */\n  remove(name) {\n    return remove(this, name)\n  }\n\n  /**\n   * @template L\n   * @param {Partial<API.Options<L>>} [options]\n   * @returns {API.View<Layout|L>}\n   */\n  fork(options) {\n    return fork(this, options)\n  }\n\n  /**\n   * @param {API.CloseOptions} [options]\n   * @returns {Promise<UnixFS.DirectoryLink>}\n   */\n  close(options) {\n    return close(this, options)\n  }\n\n  entries() {\n    return this.state.entries.entries()\n  }\n  /**\n   * @param {string} name\n   */\n  has(name) {\n    return this.state.entries.has(name)\n  }\n  get size() {\n    return this.state.entries.size\n  }\n}\n\n/**\n * @implements {Map<string, API.EntryLink>}\n */\nclass HashMap extends Map {\n  /**\n   * @param {UnixFSPermaMap.HashMapBuilder} [builder]\n   */\n  constructor (builder = UnixFSPermaMap.builder()) {\n    super()\n    /** @type {UnixFSPermaMap.HashMapBuilder} */\n    this.builder = builder\n  }\n\n  clear() {\n    this.builder = UnixFSPermaMap.builder()\n  }\n\n  /**\n   * @param {string} key\n   */\n  delete(key) {\n    const { root } = this.builder\n    this.builder.delete(key)\n    return this.builder.root !== root\n  }\n\n  /**\n   * @param {(value: API.EntryLink, key: string, map: Map<string, API.EntryLink>) => void} callbackfn\n   * @param {any} [thisArg]\n   */\n  forEach(callbackfn, thisArg = this) {\n    for (const [k, v] of this.builder.root.entries()) {\n      callbackfn.call(thisArg, v, k, this)\n    }\n  }\n\n  /**\n   * @param {string} key\n   */\n  get(key) {\n    return PermaMap.get(this.builder, key)\n  }\n\n  /**\n   * @param {string} key\n   */\n  has(key) {\n    return PermaMap.has(this.builder, key)\n  }\n\n  /**\n   * @param {string} key \n   * @param {API.EntryLink} value \n   */\n  set(key, value) {\n    this.builder.set(key, value)\n    return this\n  }\n\n  get size () {\n    return this.builder.size\n  }\n\n  [Symbol.iterator]() {\n    return this.builder.root.entries()\n  }\n\n  entries() {\n    return this.builder.root.entries()\n  }\n\n  keys() {\n    return this.builder.root.keys()\n  }\n\n  values() {\n    return this.builder.root.values()\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}