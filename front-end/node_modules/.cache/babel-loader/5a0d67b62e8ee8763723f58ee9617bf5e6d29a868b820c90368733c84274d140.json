{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeInstructions = void 0;\nconst model_1 = require(\"./model\");\nconst opcodes_1 = require(\"./opcodes\");\nfunction jumpLetterToJumpType(letter) {\n  if (letter === \"i\") {\n    return model_1.JumpType.INTO_FUNCTION;\n  }\n  if (letter === \"o\") {\n    return model_1.JumpType.OUTOF_FUNCTION;\n  }\n  return model_1.JumpType.NOT_JUMP;\n}\nfunction uncompressSourcemaps(compressedSourcemap) {\n  const mappings = [];\n  const compressedMappings = compressedSourcemap.split(\";\");\n  for (let i = 0; i < compressedMappings.length; i++) {\n    const parts = compressedMappings[i].split(\":\");\n    const hasParts0 = parts[0] !== undefined && parts[0] !== \"\";\n    const hasParts1 = parts[1] !== undefined && parts[1] !== \"\";\n    const hasParts2 = parts[2] !== undefined && parts[2] !== \"\";\n    const hasParts3 = parts[3] !== undefined && parts[3] !== \"\";\n    const hasEveryPart = hasParts0 && hasParts1 && hasParts2 && hasParts3;\n    // See: https://github.com/nomiclabs/hardhat/issues/593\n    if (i === 0 && !hasEveryPart) {\n      mappings.push({\n        jumpType: model_1.JumpType.NOT_JUMP,\n        location: {\n          file: -1,\n          offset: 0,\n          length: 0\n        }\n      });\n      continue;\n    }\n    mappings.push({\n      location: {\n        offset: hasParts0 ? +parts[0] : mappings[i - 1].location.offset,\n        length: hasParts1 ? +parts[1] : mappings[i - 1].location.length,\n        file: hasParts2 ? +parts[2] : mappings[i - 1].location.file\n      },\n      jumpType: hasParts3 ? jumpLetterToJumpType(parts[3]) : mappings[i - 1].jumpType\n    });\n  }\n  return mappings;\n}\nfunction addUnmappedInstructions(instructions, bytecode, bytesIndex) {\n  const lastInstrPc = instructions[instructions.length - 1].pc;\n  let nextPc = lastInstrPc + 1;\n  while (bytecode[nextPc] !== opcodes_1.Opcode.INVALID) {\n    const opcode = bytecode[nextPc];\n    let pushData;\n    let pushDataLenth = 0;\n    if ((0, opcodes_1.isPush)(opcode)) {\n      pushDataLenth = (0, opcodes_1.getPushLength)(opcode);\n      pushData = bytecode.slice(bytesIndex + 1, bytesIndex + 1 + pushDataLenth);\n    }\n    const jumpType = (0, opcodes_1.isJump)(opcode) ? model_1.JumpType.INTERNAL_JUMP : model_1.JumpType.NOT_JUMP;\n    const instruction = new model_1.Instruction(nextPc, opcode, jumpType, pushData);\n    instructions.push(instruction);\n    nextPc += 1 + pushDataLenth;\n  }\n}\nfunction decodeInstructions(bytecode, compressedSourcemaps, fileIdToSourceFile, isDeployment) {\n  const sourceMaps = uncompressSourcemaps(compressedSourcemaps);\n  const instructions = [];\n  let bytesIndex = 0;\n  // Solidity inlines some data after the contract, so we stop decoding\n  // as soon as we have enough instructions as uncompressed mappings. This is\n  // not very documented, but we manually tested that it works.\n  while (instructions.length < sourceMaps.length) {\n    const pc = bytesIndex;\n    const opcode = bytecode[pc];\n    const sourceMap = sourceMaps[instructions.length];\n    let pushData;\n    let location;\n    const jumpType = (0, opcodes_1.isJump)(opcode) && sourceMap.jumpType === model_1.JumpType.NOT_JUMP ? model_1.JumpType.INTERNAL_JUMP : sourceMap.jumpType;\n    if ((0, opcodes_1.isPush)(opcode)) {\n      const length = (0, opcodes_1.getPushLength)(opcode);\n      pushData = bytecode.slice(bytesIndex + 1, bytesIndex + 1 + length);\n    }\n    if (sourceMap.location.file !== -1) {\n      const file = fileIdToSourceFile.get(sourceMap.location.file);\n      if (file !== undefined) {\n        location = new model_1.SourceLocation(file, sourceMap.location.offset, sourceMap.location.length);\n      }\n    }\n    const instruction = new model_1.Instruction(pc, opcode, jumpType, pushData, location);\n    instructions.push(instruction);\n    bytesIndex += (0, opcodes_1.getOpcodeLength)(opcode);\n  }\n  // See: https://github.com/ethereum/solidity/issues/9133\n  if (isDeployment) {\n    addUnmappedInstructions(instructions, bytecode, bytesIndex);\n  }\n  return instructions;\n}\nexports.decodeInstructions = decodeInstructions;","map":{"version":3,"names":["model_1","require","opcodes_1","jumpLetterToJumpType","letter","JumpType","INTO_FUNCTION","OUTOF_FUNCTION","NOT_JUMP","uncompressSourcemaps","compressedSourcemap","mappings","compressedMappings","split","i","length","parts","hasParts0","undefined","hasParts1","hasParts2","hasParts3","hasEveryPart","push","jumpType","location","file","offset","addUnmappedInstructions","instructions","bytecode","bytesIndex","lastInstrPc","pc","nextPc","Opcode","INVALID","opcode","pushData","pushDataLenth","isPush","getPushLength","slice","isJump","INTERNAL_JUMP","instruction","Instruction","decodeInstructions","compressedSourcemaps","fileIdToSourceFile","isDeployment","sourceMaps","sourceMap","get","SourceLocation","getOpcodeLength","exports"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\internal\\hardhat-network\\stack-traces\\source-maps.ts"],"sourcesContent":["import { Instruction, JumpType, SourceFile, SourceLocation } from \"./model\";\nimport {\n  getOpcodeLength,\n  getPushLength,\n  isJump,\n  isPush,\n  Opcode,\n} from \"./opcodes\";\n\nexport interface SourceMapLocation {\n  offset: number;\n  length: number;\n  file: number;\n}\n\nexport interface SourceMap {\n  location: SourceMapLocation;\n  jumpType: JumpType;\n}\n\nfunction jumpLetterToJumpType(letter: string): JumpType {\n  if (letter === \"i\") {\n    return JumpType.INTO_FUNCTION;\n  }\n\n  if (letter === \"o\") {\n    return JumpType.OUTOF_FUNCTION;\n  }\n  return JumpType.NOT_JUMP;\n}\n\nfunction uncompressSourcemaps(compressedSourcemap: string): SourceMap[] {\n  const mappings: SourceMap[] = [];\n\n  const compressedMappings = compressedSourcemap.split(\";\");\n\n  for (let i = 0; i < compressedMappings.length; i++) {\n    const parts = compressedMappings[i].split(\":\");\n\n    const hasParts0 = parts[0] !== undefined && parts[0] !== \"\";\n    const hasParts1 = parts[1] !== undefined && parts[1] !== \"\";\n    const hasParts2 = parts[2] !== undefined && parts[2] !== \"\";\n    const hasParts3 = parts[3] !== undefined && parts[3] !== \"\";\n\n    const hasEveryPart = hasParts0 && hasParts1 && hasParts2 && hasParts3;\n\n    // See: https://github.com/nomiclabs/hardhat/issues/593\n    if (i === 0 && !hasEveryPart) {\n      mappings.push({\n        jumpType: JumpType.NOT_JUMP,\n        location: {\n          file: -1,\n          offset: 0,\n          length: 0,\n        },\n      });\n\n      continue;\n    }\n\n    mappings.push({\n      location: {\n        offset: hasParts0 ? +parts[0] : mappings[i - 1].location.offset,\n        length: hasParts1 ? +parts[1] : mappings[i - 1].location.length,\n        file: hasParts2 ? +parts[2] : mappings[i - 1].location.file,\n      },\n      jumpType: hasParts3\n        ? jumpLetterToJumpType(parts[3])\n        : mappings[i - 1].jumpType,\n    });\n  }\n\n  return mappings;\n}\n\nfunction addUnmappedInstructions(\n  instructions: Instruction[],\n  bytecode: Buffer,\n  bytesIndex: number\n) {\n  const lastInstrPc = instructions[instructions.length - 1].pc;\n  let nextPc = lastInstrPc + 1;\n\n  while (bytecode[nextPc] !== Opcode.INVALID) {\n    const opcode = bytecode[nextPc];\n    let pushData: Buffer | undefined;\n\n    let pushDataLenth = 0;\n    if (isPush(opcode)) {\n      pushDataLenth = getPushLength(opcode);\n      pushData = bytecode.slice(bytesIndex + 1, bytesIndex + 1 + pushDataLenth);\n    }\n\n    const jumpType = isJump(opcode)\n      ? JumpType.INTERNAL_JUMP\n      : JumpType.NOT_JUMP;\n\n    const instruction = new Instruction(nextPc, opcode, jumpType, pushData);\n    instructions.push(instruction);\n\n    nextPc += 1 + pushDataLenth;\n  }\n}\n\nexport function decodeInstructions(\n  bytecode: Buffer,\n  compressedSourcemaps: string,\n  fileIdToSourceFile: Map<number, SourceFile>,\n  isDeployment: boolean\n): Instruction[] {\n  const sourceMaps = uncompressSourcemaps(compressedSourcemaps);\n\n  const instructions: Instruction[] = [];\n\n  let bytesIndex = 0;\n\n  // Solidity inlines some data after the contract, so we stop decoding\n  // as soon as we have enough instructions as uncompressed mappings. This is\n  // not very documented, but we manually tested that it works.\n  while (instructions.length < sourceMaps.length) {\n    const pc = bytesIndex;\n    const opcode = bytecode[pc];\n    const sourceMap = sourceMaps[instructions.length];\n    let pushData: Buffer | undefined;\n    let location: SourceLocation | undefined;\n\n    const jumpType =\n      isJump(opcode) && sourceMap.jumpType === JumpType.NOT_JUMP\n        ? JumpType.INTERNAL_JUMP\n        : sourceMap.jumpType;\n\n    if (isPush(opcode)) {\n      const length = getPushLength(opcode);\n      pushData = bytecode.slice(bytesIndex + 1, bytesIndex + 1 + length);\n    }\n\n    if (sourceMap.location.file !== -1) {\n      const file = fileIdToSourceFile.get(sourceMap.location.file);\n\n      if (file !== undefined) {\n        location = new SourceLocation(\n          file,\n          sourceMap.location.offset,\n          sourceMap.location.length\n        );\n      }\n    }\n\n    const instruction = new Instruction(\n      pc,\n      opcode,\n      jumpType,\n      pushData,\n      location\n    );\n\n    instructions.push(instruction);\n\n    bytesIndex += getOpcodeLength(opcode);\n  }\n\n  // See: https://github.com/ethereum/solidity/issues/9133\n  if (isDeployment) {\n    addUnmappedInstructions(instructions, bytecode, bytesIndex);\n  }\n\n  return instructions;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}