{"ast":null,"code":"import * as Task from \"actor\";\nimport * as API from \"./api.js\";\nimport * as Layout from \"./layout/api.js\";\nimport * as UnixFS from \"../codec.js\";\nimport * as Chunker from \"./chunker.js\";\nimport { EMPTY_BUFFER, panic, unreachable } from \"../writer/util.js\";\nimport * as Queue from \"./layout/queue.js\";\n\n/**\n * @template Layout\n * @typedef {{\n * readonly status: 'open'\n * readonly metadata: UnixFS.Metadata\n * readonly config: API.EncoderSettings<Layout>\n * readonly writer: API.BlockWriter\n * chunker: Chunker.Chunker\n * layout: Layout\n * nodeQueue: Queue.Queue\n * }} Open\n */\n/**\n * @template Layout\n * @typedef {{\n * readonly status: 'closed'\n * readonly metadata: UnixFS.Metadata\n * readonly config: API.EncoderSettings<Layout>\n * readonly writer: API.BlockWriter\n * readonly rootID: Layout.NodeID\n * readonly end?: Task.Fork<void, never>\n * chunker?: null\n * layout?: null\n * nodeQueue: Queue.Queue\n * }} Closed\n */\n/**\n * @template Layout\n * @typedef {{\n * readonly status: 'linked'\n * readonly metadata: UnixFS.Metadata\n * readonly config: API.EncoderSettings<Layout>\n * readonly writer: API.BlockWriter\n * readonly link: Layout.Link\n * chunker?: null\n * layout?: null\n * nodeQueue: Queue.Queue\n * }} Linked\n */\n\n/**\n * @template Layout\n * @typedef {Open<Layout>|Closed<Layout>|Linked<Layout>} State\n */\n\n/**\n * @template {object} Layout\n * @typedef {{\n * state: State<Layout>\n * effect: Task.Effect<Message>\n * }} Update\n */\n/**\n * @typedef {never\n * |{type:\"write\", bytes:Uint8Array}\n * |{type:\"link\", link:API.EncodedFile}\n * |{type:\"block\"}\n * |{type: \"close\"}\n * |{type: \"end\"}\n * } Message\n */\n\n/**\n * @template Layout\n * @param {Message} message\n * @param {State<Layout>} state\n */\nexport const update = (message, state) => {\n  switch (message.type) {\n    case \"write\":\n      return write(state, message.bytes);\n    case \"link\":\n      return link(state, message.link);\n    /* c8 ignore next 2 */\n    case \"block\":\n      return {\n        state,\n        effect: Task.none()\n      };\n    case \"close\":\n      return close(state);\n    case \"end\":\n      return {\n        state,\n        effect: Task.none()\n      };\n    default:\n      return unreachable`File Writer got unknown message ${message}`;\n  }\n};\n\n/**\n * @template Layout\n * @param {API.BlockWriter} writer\n * @param {UnixFS.Metadata} metadata\n * @param {API.EncoderSettings} config\n * @returns {State<Layout>}\n */\nexport const init = (writer, metadata, config) => {\n  return {\n    status: \"open\",\n    metadata,\n    config,\n    writer,\n    chunker: Chunker.open({\n      chunker: config.chunker\n    }),\n    layout: config.fileLayout.open(),\n    // Note: Writing in large slices e.g. 1GiB at a time creates large queues\n    // with around `16353` items. Immutable version ends up copying it every\n    // time state of the queue changes, which introduces significant overhead.\n    // To avoid this overhead we use mutable implementation which is API\n    // compatible but makes in place updates.\n    // TODO: We should consider using Persistent bit-partitioned vector tries\n    // instead of arrays which would provide immutable interface with neglegable\n    // overhead.\n    // @see https://github.com/Gozala/vectrie\n    nodeQueue: Queue.mutable()\n  };\n};\n/**\n * @template Layout\n * @param {State<Layout>} state\n * @param {Uint8Array} bytes\n * @returns {Update<Layout>}\n */\nexport const write = (state, bytes) => {\n  if (state.status === \"open\") {\n    // Chunk up provided bytes\n    const {\n      chunks,\n      ...chunker\n    } = Chunker.write(state.chunker, bytes);\n\n    // Pass chunks to layout engine to produce nodes\n    const {\n      nodes,\n      leaves,\n      layout\n    } = state.config.fileLayout.write(state.layout, chunks);\n    const {\n      linked,\n      ...nodeQueue\n    } = Queue.addNodes(nodes, state.nodeQueue);\n\n    // Create leaf encode tasks for all new leaves\n    const tasks = [...encodeLeaves(leaves, state.config), ...encodeBranches(linked, state.config)];\n    return {\n      state: {\n        ...state,\n        chunker,\n        layout,\n        nodeQueue\n      },\n      effect: Task.listen({\n        link: Task.effects(tasks)\n      })\n    };\n  } else {\n    return panic(\"Unable to perform write on closed file\");\n  }\n};\n\n/**\n * @template Layout\n * @param {State<Layout>} state\n * @param {API.EncodedFile} entry\n * @returns {Update<Layout>}\n */\nexport const link = (state, {\n  id,\n  link,\n  block\n}) => {\n  let {\n    linked,\n    ...nodeQueue\n  } = Queue.addLink(id, link, state.nodeQueue);\n  const tasks = encodeBranches(linked, state.config);\n\n  /** @type {State<Layout>} */\n  const newState = state.status === \"closed\" && id === state.rootID ? {\n    ...state,\n    status: \"linked\",\n    link,\n    nodeQueue\n  } : {\n    ...state,\n    nodeQueue\n  };\n\n  // If we just linked a root and there is a **suspended** \"end\" task we create\n  // a task to resume it.\n  const end = state.status === \"closed\" && id === state.rootID && state.end ? state.end.resume() : Task.none();\n  return {\n    state: newState,\n    effect: Task.listen({\n      link: Task.effects(tasks),\n      block: writeBlock(state.writer, block),\n      end\n    })\n  };\n};\n\n/**\n * @template Layout\n * @param {State<Layout>} state\n * @returns {Update<Layout>}\n */\nexport const close = state => {\n  if (state.status === \"open\") {\n    const {\n      chunks\n    } = Chunker.close(state.chunker);\n    const {\n      layout,\n      ...write\n    } = state.config.fileLayout.write(state.layout, chunks);\n    const {\n      root,\n      ...close\n    } = state.config.fileLayout.close(layout, state.metadata);\n    const [nodes, leaves] = isLeafNode(root) ? [[...write.nodes, ...close.nodes], [...write.leaves, ...close.leaves, root]] : [[...write.nodes, ...close.nodes, root], [...write.leaves, ...close.leaves]];\n    const {\n      linked,\n      ...nodeQueue\n    } = Queue.addNodes(nodes, state.nodeQueue);\n    const tasks = [...encodeLeaves(leaves, state.config), ...encodeBranches(linked, state.config)];\n\n    // We want to keep run loop around until root node is linked. To\n    // accomplish this we fork a task that suspends itself, which we will\n    // resume when root is linked (see link function).\n    // Below we join this forked task in our effect, this way effect is not\n    // complete until task forked task is, which will do once we link the\n    // root.\n    const fork = Task.fork(Task.suspend());\n    return {\n      state: {\n        ...state,\n        chunker: null,\n        layout: null,\n        rootID: root.id,\n        status: \"closed\",\n        end: fork,\n        nodeQueue\n      },\n      effect: Task.listen({\n        link: Task.effects(tasks),\n        end: Task.join(fork)\n      })\n    };\n  } else {\n    return {\n      state,\n      effect: Task.none()\n    };\n  }\n};\n\n/**\n * Creates concurrent leaf encode tasks. Each one will have an ID corresponding\n * to index in the queue.\n *\n * @param {Layout.Leaf[]} leaves\n * @param {API.EncoderSettings} config\n */\nconst encodeLeaves = (leaves, config) => leaves.map(leaf => encodeLeaf(config, leaf, config.fileChunkEncoder));\n\n/**\n * @param {API.EncoderSettings} config\n * @param {Layout.Leaf} leaf\n * @param {API.FileChunkEncoder} encoder\n * @returns {Task.Task<API.EncodedFile, never>}\n */\nconst encodeLeaf = function* ({\n  hasher,\n  linker\n}, {\n  id,\n  content\n}, encoder) {\n  const bytes = encoder.encode(content ? asUint8Array(content) : EMPTY_BUFFER);\n  const hash = yield* Task.wait(hasher.digest(bytes));\n  const cid = linker.createLink(encoder.code, hash);\n  const block = {\n    cid,\n    bytes\n  };\n  const link = /** @type {UnixFS.FileLink} */{\n    cid,\n    contentByteLength: content ? content.byteLength : 0,\n    dagByteLength: bytes.byteLength\n  };\n  return {\n    id,\n    block,\n    link\n  };\n};\n\n/**\n * @param {Queue.LinkedNode[]} nodes\n * @param {API.EncoderSettings} config\n */\nconst encodeBranches = (nodes, config) => nodes.map(node => encodeBranch(config, node));\n\n/**\n * @template Layout\n * @param {API.EncoderSettings<Layout>} config\n * @param {Queue.LinkedNode} node\n * @param {UnixFS.Metadata} [metadata]\n * @returns {Task.Task<API.EncodedFile>}\n */\nexport const encodeBranch = function* (config, {\n  id,\n  links\n}, metadata) {\n  const bytes = config.fileEncoder.encode({\n    type: UnixFS.NodeType.File,\n    layout: \"advanced\",\n    parts: links,\n    metadata\n  });\n  const hash = yield* Task.wait(Promise.resolve(config.hasher.digest(bytes)));\n  const cid = config.linker.createLink(config.fileEncoder.code, hash);\n  const block = {\n    bytes,\n    cid\n  };\n  const link = /** @type {UnixFS.FileLink} */{\n    cid,\n    contentByteLength: UnixFS.cumulativeContentByteLength(links),\n    dagByteLength: UnixFS.cumulativeDagByteLength(bytes, links)\n  };\n  return {\n    id,\n    block,\n    link\n  };\n};\n\n/**\n * @param {API.BlockWriter} writer\n * @param {UnixFS.Block} block\n * @returns {Task.Task<void, never>}\n */\n\nexport const writeBlock = function* (writer, block) {\n  if ((writer.desiredSize || 0) <= 0) {\n    yield* Task.wait(writer.ready);\n  }\n  writer.write(block);\n};\n\n/**\n *\n * @param {Uint8Array|Chunker.Chunk} buffer\n * @returns\n */\n\nconst asUint8Array = buffer => buffer instanceof Uint8Array ? buffer : buffer.copyTo(new Uint8Array(buffer.byteLength), 0);\n\n/**\n * @param {Layout.Node} node\n * @returns {node is Layout.Leaf}\n */\nconst isLeafNode = node => node.children == null;","map":{"version":3,"names":["Task","API","Layout","UnixFS","Chunker","EMPTY_BUFFER","panic","unreachable","Queue","update","message","state","type","write","bytes","link","effect","none","close","init","writer","metadata","config","status","chunker","open","layout","fileLayout","nodeQueue","mutable","chunks","nodes","leaves","linked","addNodes","tasks","encodeLeaves","encodeBranches","listen","effects","id","block","addLink","newState","rootID","end","resume","writeBlock","root","isLeafNode","fork","suspend","join","map","leaf","encodeLeaf","fileChunkEncoder","hasher","linker","content","encoder","encode","asUint8Array","hash","wait","digest","cid","createLink","code","contentByteLength","byteLength","dagByteLength","node","encodeBranch","links","fileEncoder","NodeType","File","parts","Promise","resolve","cumulativeContentByteLength","cumulativeDagByteLength","desiredSize","ready","buffer","Uint8Array","copyTo","children"],"sources":["C:/FACULTATE/Proiect/node_modules/@ipld/unixfs/src/file/writer.js"],"sourcesContent":["import * as Task from \"actor\"\nimport * as API from \"./api.js\"\nimport * as Layout from \"./layout/api.js\"\nimport * as UnixFS from \"../codec.js\"\nimport * as Chunker from \"./chunker.js\"\nimport { EMPTY_BUFFER, panic, unreachable } from \"../writer/util.js\"\nimport * as Queue from \"./layout/queue.js\"\n\n/**\n * @template Layout\n * @typedef {{\n * readonly status: 'open'\n * readonly metadata: UnixFS.Metadata\n * readonly config: API.EncoderSettings<Layout>\n * readonly writer: API.BlockWriter\n * chunker: Chunker.Chunker\n * layout: Layout\n * nodeQueue: Queue.Queue\n * }} Open\n */\n/**\n * @template Layout\n * @typedef {{\n * readonly status: 'closed'\n * readonly metadata: UnixFS.Metadata\n * readonly config: API.EncoderSettings<Layout>\n * readonly writer: API.BlockWriter\n * readonly rootID: Layout.NodeID\n * readonly end?: Task.Fork<void, never>\n * chunker?: null\n * layout?: null\n * nodeQueue: Queue.Queue\n * }} Closed\n */\n/**\n * @template Layout\n * @typedef {{\n * readonly status: 'linked'\n * readonly metadata: UnixFS.Metadata\n * readonly config: API.EncoderSettings<Layout>\n * readonly writer: API.BlockWriter\n * readonly link: Layout.Link\n * chunker?: null\n * layout?: null\n * nodeQueue: Queue.Queue\n * }} Linked\n */\n\n/**\n * @template Layout\n * @typedef {Open<Layout>|Closed<Layout>|Linked<Layout>} State\n */\n\n/**\n * @template {object} Layout\n * @typedef {{\n * state: State<Layout>\n * effect: Task.Effect<Message>\n * }} Update\n */\n/**\n * @typedef {never\n * |{type:\"write\", bytes:Uint8Array}\n * |{type:\"link\", link:API.EncodedFile}\n * |{type:\"block\"}\n * |{type: \"close\"}\n * |{type: \"end\"}\n * } Message\n */\n\n/**\n * @template Layout\n * @param {Message} message\n * @param {State<Layout>} state\n */\nexport const update = (message, state) => {\n  switch (message.type) {\n    case \"write\":\n      return write(state, message.bytes)\n    case \"link\":\n      return link(state, message.link)\n    /* c8 ignore next 2 */\n    case \"block\":\n      return { state, effect: Task.none() }\n    case \"close\":\n      return close(state)\n    case \"end\":\n      return { state, effect: Task.none() }\n    default:\n      return unreachable`File Writer got unknown message ${message}`\n  }\n}\n\n/**\n * @template Layout\n * @param {API.BlockWriter} writer\n * @param {UnixFS.Metadata} metadata\n * @param {API.EncoderSettings} config\n * @returns {State<Layout>}\n */\nexport const init = (writer, metadata, config) => {\n  return {\n    status: \"open\",\n    metadata,\n    config,\n    writer,\n    chunker: Chunker.open({ chunker: config.chunker }),\n    layout: config.fileLayout.open(),\n    // Note: Writing in large slices e.g. 1GiB at a time creates large queues\n    // with around `16353` items. Immutable version ends up copying it every\n    // time state of the queue changes, which introduces significant overhead.\n    // To avoid this overhead we use mutable implementation which is API\n    // compatible but makes in place updates.\n    // TODO: We should consider using Persistent bit-partitioned vector tries\n    // instead of arrays which would provide immutable interface with neglegable\n    // overhead.\n    // @see https://github.com/Gozala/vectrie\n    nodeQueue: Queue.mutable(),\n  }\n}\n/**\n * @template Layout\n * @param {State<Layout>} state\n * @param {Uint8Array} bytes\n * @returns {Update<Layout>}\n */\nexport const write = (state, bytes) => {\n  if (state.status === \"open\") {\n    // Chunk up provided bytes\n    const { chunks, ...chunker } = Chunker.write(state.chunker, bytes)\n\n    // Pass chunks to layout engine to produce nodes\n    const { nodes, leaves, layout } = state.config.fileLayout.write(\n      state.layout,\n      chunks\n    )\n\n    const { linked, ...nodeQueue } = Queue.addNodes(nodes, state.nodeQueue)\n\n    // Create leaf encode tasks for all new leaves\n    const tasks = [\n      ...encodeLeaves(leaves, state.config),\n      ...encodeBranches(linked, state.config),\n    ]\n\n    return {\n      state: {\n        ...state,\n        chunker,\n        layout,\n        nodeQueue,\n      },\n      effect: Task.listen({\n        link: Task.effects(tasks),\n      }),\n    }\n  } else {\n    return panic(\"Unable to perform write on closed file\")\n  }\n}\n\n/**\n * @template Layout\n * @param {State<Layout>} state\n * @param {API.EncodedFile} entry\n * @returns {Update<Layout>}\n */\nexport const link = (state, { id, link, block }) => {\n  let { linked, ...nodeQueue } = Queue.addLink(id, link, state.nodeQueue)\n\n  const tasks = encodeBranches(linked, state.config)\n\n  /** @type {State<Layout>} */\n  const newState =\n    state.status === \"closed\" && id === state.rootID\n      ? {\n          ...state,\n          status: \"linked\",\n          link,\n          nodeQueue,\n        }\n      : { ...state, nodeQueue }\n\n  // If we just linked a root and there is a **suspended** \"end\" task we create\n  // a task to resume it.\n  const end =\n    state.status === \"closed\" && id === state.rootID && state.end\n      ? state.end.resume()\n      : Task.none()\n\n  return {\n    state: newState,\n    effect: Task.listen({\n      link: Task.effects(tasks),\n      block: writeBlock(state.writer, block),\n      end,\n    }),\n  }\n}\n\n/**\n * @template Layout\n * @param {State<Layout>} state\n * @returns {Update<Layout>}\n */\nexport const close = state => {\n  if (state.status === \"open\") {\n    const { chunks } = Chunker.close(state.chunker)\n    const { layout, ...write } = state.config.fileLayout.write(\n      state.layout,\n      chunks\n    )\n\n    const { root, ...close } = state.config.fileLayout.close(\n      layout,\n      state.metadata\n    )\n\n    const [nodes, leaves] = isLeafNode(root)\n      ? [\n          [...write.nodes, ...close.nodes],\n          [...write.leaves, ...close.leaves, root],\n        ]\n      : [\n          [...write.nodes, ...close.nodes, root],\n          [...write.leaves, ...close.leaves],\n        ]\n\n    const { linked, ...nodeQueue } = Queue.addNodes(nodes, state.nodeQueue)\n\n    const tasks = [\n      ...encodeLeaves(leaves, state.config),\n      ...encodeBranches(linked, state.config),\n    ]\n\n    // We want to keep run loop around until root node is linked. To\n    // accomplish this we fork a task that suspends itself, which we will\n    // resume when root is linked (see link function).\n    // Below we join this forked task in our effect, this way effect is not\n    // complete until task forked task is, which will do once we link the\n    // root.\n    const fork = Task.fork(Task.suspend())\n\n    return {\n      state: {\n        ...state,\n        chunker: null,\n        layout: null,\n        rootID: root.id,\n        status: \"closed\",\n        end: fork,\n        nodeQueue,\n      },\n      effect: Task.listen({\n        link: Task.effects(tasks),\n        end: Task.join(fork),\n      }),\n    }\n  } else {\n    return { state, effect: Task.none() }\n  }\n}\n\n/**\n * Creates concurrent leaf encode tasks. Each one will have an ID corresponding\n * to index in the queue.\n *\n * @param {Layout.Leaf[]} leaves\n * @param {API.EncoderSettings} config\n */\nconst encodeLeaves = (leaves, config) =>\n  leaves.map(leaf => encodeLeaf(config, leaf, config.fileChunkEncoder))\n\n/**\n * @param {API.EncoderSettings} config\n * @param {Layout.Leaf} leaf\n * @param {API.FileChunkEncoder} encoder\n * @returns {Task.Task<API.EncodedFile, never>}\n */\nconst encodeLeaf = function* ({ hasher, linker }, { id, content }, encoder) {\n  const bytes = encoder.encode(content ? asUint8Array(content) : EMPTY_BUFFER)\n  const hash = yield* Task.wait(hasher.digest(bytes))\n  const cid = linker.createLink(encoder.code, hash)\n\n  const block = { cid, bytes }\n  const link = /** @type {UnixFS.FileLink} */ ({\n    cid,\n    contentByteLength: content ? content.byteLength : 0,\n    dagByteLength: bytes.byteLength,\n  })\n\n  return { id, block, link }\n}\n\n/**\n * @param {Queue.LinkedNode[]} nodes\n * @param {API.EncoderSettings} config\n */\nconst encodeBranches = (nodes, config) =>\n  nodes.map(node => encodeBranch(config, node))\n\n/**\n * @template Layout\n * @param {API.EncoderSettings<Layout>} config\n * @param {Queue.LinkedNode} node\n * @param {UnixFS.Metadata} [metadata]\n * @returns {Task.Task<API.EncodedFile>}\n */\nexport const encodeBranch = function* (config, { id, links }, metadata) {\n  const bytes = config.fileEncoder.encode({\n    type: UnixFS.NodeType.File,\n    layout: \"advanced\",\n    parts: links,\n    metadata,\n  })\n  const hash = yield* Task.wait(Promise.resolve(config.hasher.digest(bytes)))\n  const cid = config.linker.createLink(config.fileEncoder.code, hash)\n  const block = { bytes, cid }\n  const link = /** @type {UnixFS.FileLink} */ ({\n    cid,\n    contentByteLength: UnixFS.cumulativeContentByteLength(links),\n    dagByteLength: UnixFS.cumulativeDagByteLength(bytes, links),\n  })\n\n  return { id, block, link }\n}\n\n/**\n * @param {API.BlockWriter} writer\n * @param {UnixFS.Block} block\n * @returns {Task.Task<void, never>}\n */\n\nexport const writeBlock = function* (writer, block) {\n  if ((writer.desiredSize || 0) <= 0) {\n    yield* Task.wait(writer.ready)\n  }\n  writer.write(block)\n}\n\n/**\n *\n * @param {Uint8Array|Chunker.Chunk} buffer\n * @returns\n */\n\nconst asUint8Array = buffer =>\n  buffer instanceof Uint8Array\n    ? buffer\n    : buffer.copyTo(new Uint8Array(buffer.byteLength), 0)\n\n/**\n * @param {Layout.Node} node\n * @returns {node is Layout.Leaf}\n */\nconst isLeafNode = node => node.children == null\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}