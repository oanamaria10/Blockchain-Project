{"ast":null,"code":"import * as API from '@ucanto/interface';\nimport * as CBOR from '@ipld/dag-cbor';\nexport { code, name, decode } from '@ipld/dag-cbor';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { create as createLink, isLink } from 'multiformats/link';\n\n// @see https://www.iana.org/assignments/media-types/application/vnd.ipld.dag-cbor\nexport const contentType = 'application/vnd.ipld.dag-cbor';\n\n/**\n * @param {unknown} data\n * @param {Set<unknown>} seen\n * @returns {unknown}\n */\nconst prepare = (data, seen) => {\n  if (seen.has(data)) {\n    throw new TypeError('Can not encode circular structure');\n  }\n  // top level undefined is ok\n  if (data === undefined && seen.size === 0) {\n    return null;\n  }\n  if (data === null) {\n    return null;\n  }\n  if (typeof data === 'symbol' && seen.size === 0) {\n    return null;\n  }\n  if (isLink(data)) {\n    return data;\n  }\n  if (ArrayBuffer.isView(data)) {\n    return data;\n  }\n  if (Array.isArray(data)) {\n    seen.add(data);\n    const items = [];\n    for (const item of data) {\n      items.push(item === undefined || typeof item === 'symbol' ? null : prepare(item, seen));\n    }\n    return items;\n  }\n  if (typeof ( /** @type {{toJSON?:unknown}} */data.toJSON) === 'function') {\n    seen.add(data);\n    const json = /** @type {{toJSON():unknown}} */data.toJSON();\n    return prepare(json, seen);\n  }\n  if (typeof data === 'object') {\n    seen.add(data);\n    /** @type {Record<string, unknown>} */\n    const object = {};\n    for (const [key, value] of Object.entries(data)) {\n      if (value !== undefined && typeof value !== 'symbol') {\n        object[key] = prepare(value, new Set(seen));\n      }\n    }\n    return object;\n  }\n  return data;\n};\n\n/**\n * @template T\n * @param {T} data\n * @returns {CBOR.ByteView<T>}\n */\nexport const encode = data => ( /** @type {CBOR.ByteView<T>} */CBOR.encode(prepare(data, new Set())));\n\n/**\n * @template T\n * @param {API.ByteView<T>} bytes\n * @param {{hasher?: API.MultihashHasher }} options\n * @returns {Promise<API.Link<T, typeof CBOR.code>>}\n *\n */\nexport const link = async (bytes, {\n  hasher = sha256\n} = {}) => {\n  return /** @type {API.Link<T, typeof CBOR.code>} */(\n    createLink(CBOR.code, await hasher.digest(bytes))\n  );\n};\n\n/**\n * @template T\n * @param {T} data\n * @param {{hasher?: API.MultihashHasher }} [options]\n * @returns {Promise<API.Block<T, typeof CBOR.code>>}\n */\nexport const write = async (data, options) => {\n  const bytes = encode(data);\n  const cid = await link(bytes, options);\n  return {\n    cid,\n    bytes\n  };\n};","map":{"version":3,"names":["API","CBOR","code","name","decode","sha256","create","createLink","isLink","contentType","prepare","data","seen","has","TypeError","undefined","size","ArrayBuffer","isView","Array","isArray","add","items","item","push","toJSON","json","object","key","value","Object","entries","Set","encode","link","bytes","hasher","digest","write","options","cid"],"sources":["C:/FACULTATE/Proiect/node_modules/@ucanto/core/src/cbor.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport * as CBOR from '@ipld/dag-cbor'\nexport { code, name, decode } from '@ipld/dag-cbor'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { create as createLink, isLink } from 'multiformats/link'\n\n// @see https://www.iana.org/assignments/media-types/application/vnd.ipld.dag-cbor\nexport const contentType = 'application/vnd.ipld.dag-cbor'\n\n/**\n * @param {unknown} data\n * @param {Set<unknown>} seen\n * @returns {unknown}\n */\nconst prepare = (data, seen) => {\n  if (seen.has(data)) {\n    throw new TypeError('Can not encode circular structure')\n  }\n  // top level undefined is ok\n  if (data === undefined && seen.size === 0) {\n    return null\n  }\n\n  if (data === null) {\n    return null\n  }\n\n  if (typeof data === 'symbol' && seen.size === 0) {\n    return null\n  }\n\n  if (isLink(data)) {\n    return data\n  }\n\n  if (ArrayBuffer.isView(data)) {\n    return data\n  }\n\n  if (Array.isArray(data)) {\n    seen.add(data)\n    const items = []\n    for (const item of data) {\n      items.push(\n        item === undefined || typeof item === 'symbol'\n          ? null\n          : prepare(item, seen)\n      )\n    }\n    return items\n  }\n\n  if (typeof (/** @type {{toJSON?:unknown}} */ (data).toJSON) === 'function') {\n    seen.add(data)\n    const json = /** @type {{toJSON():unknown}} */ (data).toJSON()\n    return prepare(json, seen)\n  }\n\n  if (typeof data === 'object') {\n    seen.add(data)\n    /** @type {Record<string, unknown>} */\n    const object = {}\n    for (const [key, value] of Object.entries(data)) {\n      if (value !== undefined && typeof value !== 'symbol') {\n        object[key] = prepare(value, new Set(seen))\n      }\n    }\n    return object\n  }\n\n  return data\n}\n\n/**\n * @template T\n * @param {T} data\n * @returns {CBOR.ByteView<T>}\n */\nexport const encode = data =>\n  /** @type {CBOR.ByteView<T>} */ (CBOR.encode(prepare(data, new Set())))\n\n/**\n * @template T\n * @param {API.ByteView<T>} bytes\n * @param {{hasher?: API.MultihashHasher }} options\n * @returns {Promise<API.Link<T, typeof CBOR.code>>}\n *\n */\nexport const link = async (bytes, { hasher = sha256 } = {}) => {\n  return /** @type {API.Link<T, typeof CBOR.code>} */ (\n    createLink(CBOR.code, await hasher.digest(bytes))\n  )\n}\n\n/**\n * @template T\n * @param {T} data\n * @param {{hasher?: API.MultihashHasher }} [options]\n * @returns {Promise<API.Block<T, typeof CBOR.code>>}\n */\nexport const write = async (data, options) => {\n  const bytes = encode(data)\n  const cid = await link(bytes, options)\n\n  return { cid, bytes }\n}\n"],"mappings":"AAAA,OAAO,KAAKA,GAAG,MAAM,mBAAmB;AACxC,OAAO,KAAKC,IAAI,MAAM,gBAAgB;AACtC,SAASC,IAAI,EAAEC,IAAI,EAAEC,MAAM,QAAQ,gBAAgB;AACnD,SAASC,MAAM,QAAQ,0BAA0B;AACjD,SAASC,MAAM,IAAIC,UAAU,EAAEC,MAAM,QAAQ,mBAAmB;;AAEhE;AACA,OAAO,MAAMC,WAAW,GAAG,+BAA+B;;AAE1D;AACA;AACA;AACA;AACA;AACA,MAAMC,OAAO,GAAGA,CAACC,IAAI,EAAEC,IAAI,KAAK;EAC9B,IAAIA,IAAI,CAACC,GAAG,CAACF,IAAI,CAAC,EAAE;IAClB,MAAM,IAAIG,SAAS,CAAC,mCAAmC,CAAC;EAC1D;EACA;EACA,IAAIH,IAAI,KAAKI,SAAS,IAAIH,IAAI,CAACI,IAAI,KAAK,CAAC,EAAE;IACzC,OAAO,IAAI;EACb;EAEA,IAAIL,IAAI,KAAK,IAAI,EAAE;IACjB,OAAO,IAAI;EACb;EAEA,IAAI,OAAOA,IAAI,KAAK,QAAQ,IAAIC,IAAI,CAACI,IAAI,KAAK,CAAC,EAAE;IAC/C,OAAO,IAAI;EACb;EAEA,IAAIR,MAAM,CAACG,IAAI,CAAC,EAAE;IAChB,OAAOA,IAAI;EACb;EAEA,IAAIM,WAAW,CAACC,MAAM,CAACP,IAAI,CAAC,EAAE;IAC5B,OAAOA,IAAI;EACb;EAEA,IAAIQ,KAAK,CAACC,OAAO,CAACT,IAAI,CAAC,EAAE;IACvBC,IAAI,CAACS,GAAG,CAACV,IAAI,CAAC;IACd,MAAMW,KAAK,GAAG,EAAE;IAChB,KAAK,MAAMC,IAAI,IAAIZ,IAAI,EAAE;MACvBW,KAAK,CAACE,IAAI,CACRD,IAAI,KAAKR,SAAS,IAAI,OAAOQ,IAAI,KAAK,QAAQ,GAC1C,IAAI,GACJb,OAAO,CAACa,IAAI,EAAEX,IAAI,CACxB,CAAC;IACH;IACA,OAAOU,KAAK;EACd;EAEA,IAAI,SAAQ,gCAAkCX,IAAI,CAAEc,MAAM,CAAC,KAAK,UAAU,EAAE;IAC1Eb,IAAI,CAACS,GAAG,CAACV,IAAI,CAAC;IACd,MAAMe,IAAI,GAAG,iCAAmCf,IAAI,CAAEc,MAAM,CAAC,CAAC;IAC9D,OAAOf,OAAO,CAACgB,IAAI,EAAEd,IAAI,CAAC;EAC5B;EAEA,IAAI,OAAOD,IAAI,KAAK,QAAQ,EAAE;IAC5BC,IAAI,CAACS,GAAG,CAACV,IAAI,CAAC;IACd;IACA,MAAMgB,MAAM,GAAG,CAAC,CAAC;IACjB,KAAK,MAAM,CAACC,GAAG,EAAEC,KAAK,CAAC,IAAIC,MAAM,CAACC,OAAO,CAACpB,IAAI,CAAC,EAAE;MAC/C,IAAIkB,KAAK,KAAKd,SAAS,IAAI,OAAOc,KAAK,KAAK,QAAQ,EAAE;QACpDF,MAAM,CAACC,GAAG,CAAC,GAAGlB,OAAO,CAACmB,KAAK,EAAE,IAAIG,GAAG,CAACpB,IAAI,CAAC,CAAC;MAC7C;IACF;IACA,OAAOe,MAAM;EACf;EAEA,OAAOhB,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMsB,MAAM,GAAGtB,IAAI,MACxB,+BAAiCV,IAAI,CAACgC,MAAM,CAACvB,OAAO,CAACC,IAAI,EAAE,IAAIqB,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;;AAEzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAME,IAAI,GAAG,MAAAA,CAAOC,KAAK,EAAE;EAAEC,MAAM,GAAG/B;AAAO,CAAC,GAAG,CAAC,CAAC,KAAK;EAC7D,OAAO;IACLE,UAAU,CAACN,IAAI,CAACC,IAAI,EAAE,MAAMkC,MAAM,CAACC,MAAM,CAACF,KAAK,CAAC;EAAC;AAErD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMG,KAAK,GAAG,MAAAA,CAAO3B,IAAI,EAAE4B,OAAO,KAAK;EAC5C,MAAMJ,KAAK,GAAGF,MAAM,CAACtB,IAAI,CAAC;EAC1B,MAAM6B,GAAG,GAAG,MAAMN,IAAI,CAACC,KAAK,EAAEI,OAAO,CAAC;EAEtC,OAAO;IAAEC,GAAG;IAAEL;EAAM,CAAC;AACvB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}