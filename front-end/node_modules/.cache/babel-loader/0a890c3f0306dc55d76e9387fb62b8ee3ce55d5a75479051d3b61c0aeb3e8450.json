{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getContractAtFromArtifact = exports.deployContract = exports.getContractAt = exports.getContractFactoryFromArtifact = exports.getContractFactory = exports.getImpersonatedSigner = exports.getSigner = exports.getSigners = void 0;\nconst plugins_1 = require(\"hardhat/plugins\");\nconst pluginName = \"hardhat-ethers\";\nfunction isArtifact(artifact) {\n  const {\n    contractName,\n    sourceName,\n    abi,\n    bytecode,\n    deployedBytecode,\n    linkReferences,\n    deployedLinkReferences\n  } = artifact;\n  return typeof contractName === \"string\" && typeof sourceName === \"string\" && Array.isArray(abi) && typeof bytecode === \"string\" && typeof deployedBytecode === \"string\" && linkReferences !== undefined && deployedLinkReferences !== undefined;\n}\nasync function getSigners(hre) {\n  const accounts = await hre.ethers.provider.listAccounts();\n  const signersWithAddress = await Promise.all(accounts.map(account => getSigner(hre, account)));\n  return signersWithAddress;\n}\nexports.getSigners = getSigners;\nasync function getSigner(hre, address) {\n  const {\n    SignerWithAddress: SignerWithAddressImpl\n  } = await Promise.resolve().then(() => __importStar(require(\"../signers\")));\n  const signer = hre.ethers.provider.getSigner(address);\n  const signerWithAddress = await SignerWithAddressImpl.create(signer);\n  return signerWithAddress;\n}\nexports.getSigner = getSigner;\nasync function getImpersonatedSigner(hre, address) {\n  await hre.ethers.provider.send(\"hardhat_impersonateAccount\", [address]);\n  return getSigner(hre, address);\n}\nexports.getImpersonatedSigner = getImpersonatedSigner;\nasync function getContractFactory(hre, nameOrAbi, bytecodeOrFactoryOptions, signer) {\n  if (typeof nameOrAbi === \"string\") {\n    const artifact = await hre.artifacts.readArtifact(nameOrAbi);\n    return getContractFactoryFromArtifact(hre, artifact, bytecodeOrFactoryOptions);\n  }\n  return getContractFactoryByAbiAndBytecode(hre, nameOrAbi, bytecodeOrFactoryOptions, signer);\n}\nexports.getContractFactory = getContractFactory;\nfunction isFactoryOptions(signerOrOptions) {\n  const {\n    Signer\n  } = require(\"ethers\");\n  return signerOrOptions !== undefined && !Signer.isSigner(signerOrOptions);\n}\nasync function getContractFactoryFromArtifact(hre, artifact, signerOrOptions) {\n  let libraries = {};\n  let signer;\n  if (!isArtifact(artifact)) {\n    throw new plugins_1.NomicLabsHardhatPluginError(pluginName, `You are trying to create a contract factory from an artifact, but you have not passed a valid artifact parameter.`);\n  }\n  if (isFactoryOptions(signerOrOptions)) {\n    signer = signerOrOptions.signer;\n    libraries = signerOrOptions.libraries ?? {};\n  } else {\n    signer = signerOrOptions;\n  }\n  if (artifact.bytecode === \"0x\") {\n    throw new plugins_1.NomicLabsHardhatPluginError(pluginName, `You are trying to create a contract factory for the contract ${artifact.contractName}, which is abstract and can't be deployed.\nIf you want to call a contract using ${artifact.contractName} as its interface use the \"getContractAt\" function instead.`);\n  }\n  const linkedBytecode = await collectLibrariesAndLink(artifact, libraries);\n  return getContractFactoryByAbiAndBytecode(hre, artifact.abi, linkedBytecode, signer);\n}\nexports.getContractFactoryFromArtifact = getContractFactoryFromArtifact;\nasync function collectLibrariesAndLink(artifact, libraries) {\n  const {\n    utils\n  } = require(\"ethers\");\n  const neededLibraries = [];\n  for (const [sourceName, sourceLibraries] of Object.entries(artifact.linkReferences)) {\n    for (const libName of Object.keys(sourceLibraries)) {\n      neededLibraries.push({\n        sourceName,\n        libName\n      });\n    }\n  }\n  const linksToApply = new Map();\n  for (const [linkedLibraryName, linkedLibraryAddress] of Object.entries(libraries)) {\n    if (!utils.isAddress(linkedLibraryAddress)) {\n      throw new plugins_1.NomicLabsHardhatPluginError(pluginName, `You tried to link the contract ${artifact.contractName} with the library ${linkedLibraryName}, but provided this invalid address: ${linkedLibraryAddress}`);\n    }\n    const matchingNeededLibraries = neededLibraries.filter(lib => {\n      return lib.libName === linkedLibraryName || `${lib.sourceName}:${lib.libName}` === linkedLibraryName;\n    });\n    if (matchingNeededLibraries.length === 0) {\n      let detailedMessage;\n      if (neededLibraries.length > 0) {\n        const libraryFQNames = neededLibraries.map(lib => `${lib.sourceName}:${lib.libName}`).map(x => `* ${x}`).join(\"\\n\");\n        detailedMessage = `The libraries needed are:\n${libraryFQNames}`;\n      } else {\n        detailedMessage = \"This contract doesn't need linking any libraries.\";\n      }\n      throw new plugins_1.NomicLabsHardhatPluginError(pluginName, `You tried to link the contract ${artifact.contractName} with ${linkedLibraryName}, which is not one of its libraries.\n${detailedMessage}`);\n    }\n    if (matchingNeededLibraries.length > 1) {\n      const matchingNeededLibrariesFQNs = matchingNeededLibraries.map(({\n        sourceName,\n        libName\n      }) => `${sourceName}:${libName}`).map(x => `* ${x}`).join(\"\\n\");\n      throw new plugins_1.NomicLabsHardhatPluginError(pluginName, `The library name ${linkedLibraryName} is ambiguous for the contract ${artifact.contractName}.\nIt may resolve to one of the following libraries:\n${matchingNeededLibrariesFQNs}\n\nTo fix this, choose one of these fully qualified library names and replace where appropriate.`);\n    }\n    const [neededLibrary] = matchingNeededLibraries;\n    const neededLibraryFQN = `${neededLibrary.sourceName}:${neededLibrary.libName}`;\n    // The only way for this library to be already mapped is\n    // for it to be given twice in the libraries user input:\n    // once as a library name and another as a fully qualified library name.\n    if (linksToApply.has(neededLibraryFQN)) {\n      throw new plugins_1.NomicLabsHardhatPluginError(pluginName, `The library names ${neededLibrary.libName} and ${neededLibraryFQN} refer to the same library and were given as two separate library links.\nRemove one of them and review your library links before proceeding.`);\n    }\n    linksToApply.set(neededLibraryFQN, {\n      sourceName: neededLibrary.sourceName,\n      libraryName: neededLibrary.libName,\n      address: linkedLibraryAddress\n    });\n  }\n  if (linksToApply.size < neededLibraries.length) {\n    const missingLibraries = neededLibraries.map(lib => `${lib.sourceName}:${lib.libName}`).filter(libFQName => !linksToApply.has(libFQName)).map(x => `* ${x}`).join(\"\\n\");\n    throw new plugins_1.NomicLabsHardhatPluginError(pluginName, `The contract ${artifact.contractName} is missing links for the following libraries:\n${missingLibraries}\n\nLearn more about linking contracts at https://hardhat.org/hardhat-runner/plugins/nomiclabs-hardhat-ethers#library-linking\n`);\n  }\n  return linkBytecode(artifact, [...linksToApply.values()]);\n}\nasync function getContractFactoryByAbiAndBytecode(hre, abi, bytecode, signer) {\n  const {\n    ContractFactory\n  } = require(\"ethers\");\n  if (signer === undefined) {\n    const signers = await hre.ethers.getSigners();\n    signer = signers[0];\n  }\n  const abiWithAddedGas = addGasToAbiMethodsIfNecessary(hre.network.config, abi);\n  return new ContractFactory(abiWithAddedGas, bytecode, signer);\n}\nasync function getContractAt(hre, nameOrAbi, address, signer) {\n  if (typeof nameOrAbi === \"string\") {\n    const artifact = await hre.artifacts.readArtifact(nameOrAbi);\n    return getContractAtFromArtifact(hre, artifact, address, signer);\n  }\n  const {\n    Contract\n  } = require(\"ethers\");\n  if (signer === undefined) {\n    const signers = await hre.ethers.getSigners();\n    signer = signers[0];\n  }\n  // If there's no signer, we want to put the provider for the selected network here.\n  // This allows read only operations on the contract interface.\n  const signerOrProvider = signer !== undefined ? signer : hre.ethers.provider;\n  const abiWithAddedGas = addGasToAbiMethodsIfNecessary(hre.network.config, nameOrAbi);\n  return new Contract(address, abiWithAddedGas, signerOrProvider);\n}\nexports.getContractAt = getContractAt;\nasync function deployContract(hre, name, argsOrSignerOrOptions, signerOrOptions) {\n  let args = [];\n  if (Array.isArray(argsOrSignerOrOptions)) {\n    args = argsOrSignerOrOptions;\n  } else {\n    signerOrOptions = argsOrSignerOrOptions;\n  }\n  const factory = await getContractFactory(hre, name, signerOrOptions);\n  return factory.deploy(...args);\n}\nexports.deployContract = deployContract;\nasync function getContractAtFromArtifact(hre, artifact, address, signer) {\n  if (!isArtifact(artifact)) {\n    throw new plugins_1.NomicLabsHardhatPluginError(pluginName, `You are trying to create a contract by artifact, but you have not passed a valid artifact parameter.`);\n  }\n  const factory = await getContractFactoryByAbiAndBytecode(hre, artifact.abi, \"0x\", signer);\n  let contract = factory.attach(address);\n  // If there's no signer, we connect the contract instance to the provider for the selected network.\n  if (contract.provider === null) {\n    contract = contract.connect(hre.ethers.provider);\n  }\n  return contract;\n}\nexports.getContractAtFromArtifact = getContractAtFromArtifact;\n// This helper adds a `gas` field to the ABI function elements if the network\n// is set up to use a fixed amount of gas.\n// This is done so that ethers doesn't automatically estimate gas limits on\n// every call.\nfunction addGasToAbiMethodsIfNecessary(networkConfig, abi) {\n  const {\n    BigNumber\n  } = require(\"ethers\");\n  if (networkConfig.gas === \"auto\" || networkConfig.gas === undefined) {\n    return abi;\n  }\n  // ethers adds 21000 to whatever the abi `gas` field has. This may lead to\n  // OOG errors, as people may set the default gas to the same value as the\n  // block gas limit, especially on Hardhat Network.\n  // To avoid this, we substract 21000.\n  // HOTFIX: We substract 1M for now. See: https://github.com/ethers-io/ethers.js/issues/1058#issuecomment-703175279\n  const gasLimit = BigNumber.from(networkConfig.gas).sub(1000000).toHexString();\n  const modifiedAbi = [];\n  for (const abiElement of abi) {\n    if (abiElement.type !== \"function\") {\n      modifiedAbi.push(abiElement);\n      continue;\n    }\n    modifiedAbi.push({\n      ...abiElement,\n      gas: gasLimit\n    });\n  }\n  return modifiedAbi;\n}\nfunction linkBytecode(artifact, libraries) {\n  let bytecode = artifact.bytecode;\n  // TODO: measure performance impact\n  for (const {\n    sourceName,\n    libraryName,\n    address\n  } of libraries) {\n    const linkReferences = artifact.linkReferences[sourceName][libraryName];\n    for (const {\n      start,\n      length\n    } of linkReferences) {\n      bytecode = bytecode.substr(0, 2 + start * 2) + address.substr(2) + bytecode.substr(2 + (start + length) * 2);\n    }\n  }\n  return bytecode;\n}","map":{"version":3,"names":["plugins_1","require","pluginName","isArtifact","artifact","contractName","sourceName","abi","bytecode","deployedBytecode","linkReferences","deployedLinkReferences","Array","isArray","undefined","getSigners","hre","accounts","ethers","provider","listAccounts","signersWithAddress","Promise","all","map","account","getSigner","exports","address","SignerWithAddress","SignerWithAddressImpl","resolve","then","__importStar","signer","signerWithAddress","create","getImpersonatedSigner","send","getContractFactory","nameOrAbi","bytecodeOrFactoryOptions","artifacts","readArtifact","getContractFactoryFromArtifact","getContractFactoryByAbiAndBytecode","isFactoryOptions","signerOrOptions","Signer","isSigner","libraries","NomicLabsHardhatPluginError","linkedBytecode","collectLibrariesAndLink","utils","neededLibraries","sourceLibraries","Object","entries","libName","keys","push","linksToApply","Map","linkedLibraryName","linkedLibraryAddress","isAddress","matchingNeededLibraries","filter","lib","length","detailedMessage","libraryFQNames","x","join","matchingNeededLibrariesFQNs","neededLibrary","neededLibraryFQN","has","set","libraryName","size","missingLibraries","libFQName","linkBytecode","values","ContractFactory","signers","abiWithAddedGas","addGasToAbiMethodsIfNecessary","network","config","getContractAt","getContractAtFromArtifact","Contract","signerOrProvider","deployContract","name","argsOrSignerOrOptions","args","factory","deploy","contract","attach","connect","networkConfig","BigNumber","gas","gasLimit","from","sub","toHexString","modifiedAbi","abiElement","type","start","substr"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\@nomiclabs\\hardhat-ethers\\src\\internal\\helpers.ts"],"sourcesContent":["import type { ethers } from \"ethers\";\nimport type { SignerWithAddress } from \"../signers\";\nimport type { FactoryOptions, Libraries } from \"../types\";\n\nimport { NomicLabsHardhatPluginError } from \"hardhat/plugins\";\nimport {\n  Artifact,\n  HardhatRuntimeEnvironment,\n  NetworkConfig,\n} from \"hardhat/types\";\n\ninterface Link {\n  sourceName: string;\n  libraryName: string;\n  address: string;\n}\n\nconst pluginName = \"hardhat-ethers\";\n\nfunction isArtifact(artifact: any): artifact is Artifact {\n  const {\n    contractName,\n    sourceName,\n    abi,\n    bytecode,\n    deployedBytecode,\n    linkReferences,\n    deployedLinkReferences,\n  } = artifact;\n\n  return (\n    typeof contractName === \"string\" &&\n    typeof sourceName === \"string\" &&\n    Array.isArray(abi) &&\n    typeof bytecode === \"string\" &&\n    typeof deployedBytecode === \"string\" &&\n    linkReferences !== undefined &&\n    deployedLinkReferences !== undefined\n  );\n}\n\nexport async function getSigners(\n  hre: HardhatRuntimeEnvironment\n): Promise<SignerWithAddress[]> {\n  const accounts = await hre.ethers.provider.listAccounts();\n\n  const signersWithAddress = await Promise.all(\n    accounts.map((account) => getSigner(hre, account))\n  );\n\n  return signersWithAddress;\n}\n\nexport async function getSigner(\n  hre: HardhatRuntimeEnvironment,\n  address: string\n): Promise<SignerWithAddress> {\n  const { SignerWithAddress: SignerWithAddressImpl } = await import(\n    \"../signers\"\n  );\n\n  const signer = hre.ethers.provider.getSigner(address);\n\n  const signerWithAddress = await SignerWithAddressImpl.create(signer);\n\n  return signerWithAddress;\n}\n\nexport async function getImpersonatedSigner(\n  hre: HardhatRuntimeEnvironment,\n  address: string\n): Promise<SignerWithAddress> {\n  await hre.ethers.provider.send(\"hardhat_impersonateAccount\", [address]);\n  return getSigner(hre, address);\n}\n\nexport function getContractFactory(\n  hre: HardhatRuntimeEnvironment,\n  name: string,\n  signerOrOptions?: ethers.Signer | FactoryOptions\n): Promise<ethers.ContractFactory>;\n\nexport function getContractFactory(\n  hre: HardhatRuntimeEnvironment,\n  abi: any[],\n  bytecode: ethers.utils.BytesLike,\n  signer?: ethers.Signer\n): Promise<ethers.ContractFactory>;\n\nexport async function getContractFactory(\n  hre: HardhatRuntimeEnvironment,\n  nameOrAbi: string | any[],\n  bytecodeOrFactoryOptions?:\n    | (ethers.Signer | FactoryOptions)\n    | ethers.utils.BytesLike,\n  signer?: ethers.Signer\n) {\n  if (typeof nameOrAbi === \"string\") {\n    const artifact = await hre.artifacts.readArtifact(nameOrAbi);\n\n    return getContractFactoryFromArtifact(\n      hre,\n      artifact,\n      bytecodeOrFactoryOptions as ethers.Signer | FactoryOptions | undefined\n    );\n  }\n\n  return getContractFactoryByAbiAndBytecode(\n    hre,\n    nameOrAbi,\n    bytecodeOrFactoryOptions as ethers.utils.BytesLike,\n    signer\n  );\n}\n\nfunction isFactoryOptions(\n  signerOrOptions?: ethers.Signer | FactoryOptions\n): signerOrOptions is FactoryOptions {\n  const { Signer } = require(\"ethers\") as typeof ethers;\n  return signerOrOptions !== undefined && !Signer.isSigner(signerOrOptions);\n}\n\nexport async function getContractFactoryFromArtifact(\n  hre: HardhatRuntimeEnvironment,\n  artifact: Artifact,\n  signerOrOptions?: ethers.Signer | FactoryOptions\n) {\n  let libraries: Libraries = {};\n  let signer: ethers.Signer | undefined;\n\n  if (!isArtifact(artifact)) {\n    throw new NomicLabsHardhatPluginError(\n      pluginName,\n      `You are trying to create a contract factory from an artifact, but you have not passed a valid artifact parameter.`\n    );\n  }\n\n  if (isFactoryOptions(signerOrOptions)) {\n    signer = signerOrOptions.signer;\n    libraries = signerOrOptions.libraries ?? {};\n  } else {\n    signer = signerOrOptions;\n  }\n\n  if (artifact.bytecode === \"0x\") {\n    throw new NomicLabsHardhatPluginError(\n      pluginName,\n      `You are trying to create a contract factory for the contract ${artifact.contractName}, which is abstract and can't be deployed.\nIf you want to call a contract using ${artifact.contractName} as its interface use the \"getContractAt\" function instead.`\n    );\n  }\n\n  const linkedBytecode = await collectLibrariesAndLink(artifact, libraries);\n\n  return getContractFactoryByAbiAndBytecode(\n    hre,\n    artifact.abi,\n    linkedBytecode,\n    signer\n  );\n}\n\nasync function collectLibrariesAndLink(\n  artifact: Artifact,\n  libraries: Libraries\n) {\n  const { utils } = require(\"ethers\") as typeof ethers;\n\n  const neededLibraries: Array<{\n    sourceName: string;\n    libName: string;\n  }> = [];\n  for (const [sourceName, sourceLibraries] of Object.entries(\n    artifact.linkReferences\n  )) {\n    for (const libName of Object.keys(sourceLibraries)) {\n      neededLibraries.push({ sourceName, libName });\n    }\n  }\n\n  const linksToApply: Map<string, Link> = new Map();\n  for (const [linkedLibraryName, linkedLibraryAddress] of Object.entries(\n    libraries\n  )) {\n    if (!utils.isAddress(linkedLibraryAddress)) {\n      throw new NomicLabsHardhatPluginError(\n        pluginName,\n        `You tried to link the contract ${artifact.contractName} with the library ${linkedLibraryName}, but provided this invalid address: ${linkedLibraryAddress}`\n      );\n    }\n\n    const matchingNeededLibraries = neededLibraries.filter((lib) => {\n      return (\n        lib.libName === linkedLibraryName ||\n        `${lib.sourceName}:${lib.libName}` === linkedLibraryName\n      );\n    });\n\n    if (matchingNeededLibraries.length === 0) {\n      let detailedMessage: string;\n      if (neededLibraries.length > 0) {\n        const libraryFQNames = neededLibraries\n          .map((lib) => `${lib.sourceName}:${lib.libName}`)\n          .map((x) => `* ${x}`)\n          .join(\"\\n\");\n        detailedMessage = `The libraries needed are:\n${libraryFQNames}`;\n      } else {\n        detailedMessage = \"This contract doesn't need linking any libraries.\";\n      }\n      throw new NomicLabsHardhatPluginError(\n        pluginName,\n        `You tried to link the contract ${artifact.contractName} with ${linkedLibraryName}, which is not one of its libraries.\n${detailedMessage}`\n      );\n    }\n\n    if (matchingNeededLibraries.length > 1) {\n      const matchingNeededLibrariesFQNs = matchingNeededLibraries\n        .map(({ sourceName, libName }) => `${sourceName}:${libName}`)\n        .map((x) => `* ${x}`)\n        .join(\"\\n\");\n      throw new NomicLabsHardhatPluginError(\n        pluginName,\n        `The library name ${linkedLibraryName} is ambiguous for the contract ${artifact.contractName}.\nIt may resolve to one of the following libraries:\n${matchingNeededLibrariesFQNs}\n\nTo fix this, choose one of these fully qualified library names and replace where appropriate.`\n      );\n    }\n\n    const [neededLibrary] = matchingNeededLibraries;\n\n    const neededLibraryFQN = `${neededLibrary.sourceName}:${neededLibrary.libName}`;\n\n    // The only way for this library to be already mapped is\n    // for it to be given twice in the libraries user input:\n    // once as a library name and another as a fully qualified library name.\n    if (linksToApply.has(neededLibraryFQN)) {\n      throw new NomicLabsHardhatPluginError(\n        pluginName,\n        `The library names ${neededLibrary.libName} and ${neededLibraryFQN} refer to the same library and were given as two separate library links.\nRemove one of them and review your library links before proceeding.`\n      );\n    }\n\n    linksToApply.set(neededLibraryFQN, {\n      sourceName: neededLibrary.sourceName,\n      libraryName: neededLibrary.libName,\n      address: linkedLibraryAddress,\n    });\n  }\n\n  if (linksToApply.size < neededLibraries.length) {\n    const missingLibraries = neededLibraries\n      .map((lib) => `${lib.sourceName}:${lib.libName}`)\n      .filter((libFQName) => !linksToApply.has(libFQName))\n      .map((x) => `* ${x}`)\n      .join(\"\\n\");\n\n    throw new NomicLabsHardhatPluginError(\n      pluginName,\n      `The contract ${artifact.contractName} is missing links for the following libraries:\n${missingLibraries}\n\nLearn more about linking contracts at https://hardhat.org/hardhat-runner/plugins/nomiclabs-hardhat-ethers#library-linking\n`\n    );\n  }\n\n  return linkBytecode(artifact, [...linksToApply.values()]);\n}\n\nasync function getContractFactoryByAbiAndBytecode(\n  hre: HardhatRuntimeEnvironment,\n  abi: any[],\n  bytecode: ethers.utils.BytesLike,\n  signer?: ethers.Signer\n) {\n  const { ContractFactory } = require(\"ethers\") as typeof ethers;\n\n  if (signer === undefined) {\n    const signers = await hre.ethers.getSigners();\n    signer = signers[0];\n  }\n\n  const abiWithAddedGas = addGasToAbiMethodsIfNecessary(\n    hre.network.config,\n    abi\n  );\n\n  return new ContractFactory(abiWithAddedGas, bytecode, signer);\n}\n\nexport async function getContractAt(\n  hre: HardhatRuntimeEnvironment,\n  nameOrAbi: string | any[],\n  address: string,\n  signer?: ethers.Signer\n) {\n  if (typeof nameOrAbi === \"string\") {\n    const artifact = await hre.artifacts.readArtifact(nameOrAbi);\n\n    return getContractAtFromArtifact(hre, artifact, address, signer);\n  }\n\n  const { Contract } = require(\"ethers\") as typeof ethers;\n\n  if (signer === undefined) {\n    const signers = await hre.ethers.getSigners();\n    signer = signers[0];\n  }\n\n  // If there's no signer, we want to put the provider for the selected network here.\n  // This allows read only operations on the contract interface.\n  const signerOrProvider: ethers.Signer | ethers.providers.Provider =\n    signer !== undefined ? signer : hre.ethers.provider;\n\n  const abiWithAddedGas = addGasToAbiMethodsIfNecessary(\n    hre.network.config,\n    nameOrAbi\n  );\n\n  return new Contract(address, abiWithAddedGas, signerOrProvider);\n}\n\nexport async function deployContract(\n  hre: HardhatRuntimeEnvironment,\n  name: string,\n  args?: any[],\n  signerOrOptions?: ethers.Signer | FactoryOptions\n): Promise<ethers.Contract>;\n\nexport async function deployContract(\n  hre: HardhatRuntimeEnvironment,\n  name: string,\n  signerOrOptions?: ethers.Signer | FactoryOptions\n): Promise<ethers.Contract>;\n\nexport async function deployContract(\n  hre: HardhatRuntimeEnvironment,\n  name: string,\n  argsOrSignerOrOptions?: any[] | ethers.Signer | FactoryOptions,\n  signerOrOptions?: ethers.Signer | FactoryOptions\n): Promise<ethers.Contract> {\n  let args = [];\n  if (Array.isArray(argsOrSignerOrOptions)) {\n    args = argsOrSignerOrOptions;\n  } else {\n    signerOrOptions = argsOrSignerOrOptions;\n  }\n  const factory = await getContractFactory(hre, name, signerOrOptions);\n  return factory.deploy(...args);\n}\n\nexport async function getContractAtFromArtifact(\n  hre: HardhatRuntimeEnvironment,\n  artifact: Artifact,\n  address: string,\n  signer?: ethers.Signer\n) {\n  if (!isArtifact(artifact)) {\n    throw new NomicLabsHardhatPluginError(\n      pluginName,\n      `You are trying to create a contract by artifact, but you have not passed a valid artifact parameter.`\n    );\n  }\n\n  const factory = await getContractFactoryByAbiAndBytecode(\n    hre,\n    artifact.abi,\n    \"0x\",\n    signer\n  );\n\n  let contract = factory.attach(address);\n  // If there's no signer, we connect the contract instance to the provider for the selected network.\n  if (contract.provider === null) {\n    contract = contract.connect(hre.ethers.provider);\n  }\n\n  return contract;\n}\n\n// This helper adds a `gas` field to the ABI function elements if the network\n// is set up to use a fixed amount of gas.\n// This is done so that ethers doesn't automatically estimate gas limits on\n// every call.\nfunction addGasToAbiMethodsIfNecessary(\n  networkConfig: NetworkConfig,\n  abi: any[]\n): any[] {\n  const { BigNumber } = require(\"ethers\") as typeof ethers;\n\n  if (networkConfig.gas === \"auto\" || networkConfig.gas === undefined) {\n    return abi;\n  }\n\n  // ethers adds 21000 to whatever the abi `gas` field has. This may lead to\n  // OOG errors, as people may set the default gas to the same value as the\n  // block gas limit, especially on Hardhat Network.\n  // To avoid this, we substract 21000.\n  // HOTFIX: We substract 1M for now. See: https://github.com/ethers-io/ethers.js/issues/1058#issuecomment-703175279\n  const gasLimit = BigNumber.from(networkConfig.gas).sub(1000000).toHexString();\n\n  const modifiedAbi: any[] = [];\n\n  for (const abiElement of abi) {\n    if (abiElement.type !== \"function\") {\n      modifiedAbi.push(abiElement);\n      continue;\n    }\n\n    modifiedAbi.push({\n      ...abiElement,\n      gas: gasLimit,\n    });\n  }\n\n  return modifiedAbi;\n}\n\nfunction linkBytecode(artifact: Artifact, libraries: Link[]): string {\n  let bytecode = artifact.bytecode;\n\n  // TODO: measure performance impact\n  for (const { sourceName, libraryName, address } of libraries) {\n    const linkReferences = artifact.linkReferences[sourceName][libraryName];\n    for (const { start, length } of linkReferences) {\n      bytecode =\n        bytecode.substr(0, 2 + start * 2) +\n        address.substr(2) +\n        bytecode.substr(2 + (start + length) * 2);\n    }\n  }\n\n  return bytecode;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA,MAAAA,SAAA,GAAAC,OAAA;AAaA,MAAMC,UAAU,GAAG,gBAAgB;AAEnC,SAASC,UAAUA,CAACC,QAAa;EAC/B,MAAM;IACJC,YAAY;IACZC,UAAU;IACVC,GAAG;IACHC,QAAQ;IACRC,gBAAgB;IAChBC,cAAc;IACdC;EAAsB,CACvB,GAAGP,QAAQ;EAEZ,OACE,OAAOC,YAAY,KAAK,QAAQ,IAChC,OAAOC,UAAU,KAAK,QAAQ,IAC9BM,KAAK,CAACC,OAAO,CAACN,GAAG,CAAC,IAClB,OAAOC,QAAQ,KAAK,QAAQ,IAC5B,OAAOC,gBAAgB,KAAK,QAAQ,IACpCC,cAAc,KAAKI,SAAS,IAC5BH,sBAAsB,KAAKG,SAAS;AAExC;AAEO,eAAeC,UAAUA,CAC9BC,GAA8B;EAE9B,MAAMC,QAAQ,GAAG,MAAMD,GAAG,CAACE,MAAM,CAACC,QAAQ,CAACC,YAAY,EAAE;EAEzD,MAAMC,kBAAkB,GAAG,MAAMC,OAAO,CAACC,GAAG,CAC1CN,QAAQ,CAACO,GAAG,CAAEC,OAAO,IAAKC,SAAS,CAACV,GAAG,EAAES,OAAO,CAAC,CAAC,CACnD;EAED,OAAOJ,kBAAkB;AAC3B;AAVAM,OAAA,CAAAZ,UAAA,GAAAA,UAAA;AAYO,eAAeW,SAASA,CAC7BV,GAA8B,EAC9BY,OAAe;EAEf,MAAM;IAAEC,iBAAiB,EAAEC;EAAqB,CAAE,GAAG,MAAAR,OAAA,CAAAS,OAAA,GAAAC,IAAA,OAAAC,YAAA,CAAAhC,OAAA,CACnD,YAAY,GACb;EAED,MAAMiC,MAAM,GAAGlB,GAAG,CAACE,MAAM,CAACC,QAAQ,CAACO,SAAS,CAACE,OAAO,CAAC;EAErD,MAAMO,iBAAiB,GAAG,MAAML,qBAAqB,CAACM,MAAM,CAACF,MAAM,CAAC;EAEpE,OAAOC,iBAAiB;AAC1B;AAbAR,OAAA,CAAAD,SAAA,GAAAA,SAAA;AAeO,eAAeW,qBAAqBA,CACzCrB,GAA8B,EAC9BY,OAAe;EAEf,MAAMZ,GAAG,CAACE,MAAM,CAACC,QAAQ,CAACmB,IAAI,CAAC,4BAA4B,EAAE,CAACV,OAAO,CAAC,CAAC;EACvE,OAAOF,SAAS,CAACV,GAAG,EAAEY,OAAO,CAAC;AAChC;AANAD,OAAA,CAAAU,qBAAA,GAAAA,qBAAA;AAqBO,eAAeE,kBAAkBA,CACtCvB,GAA8B,EAC9BwB,SAAyB,EACzBC,wBAE0B,EAC1BP,MAAsB;EAEtB,IAAI,OAAOM,SAAS,KAAK,QAAQ,EAAE;IACjC,MAAMpC,QAAQ,GAAG,MAAMY,GAAG,CAAC0B,SAAS,CAACC,YAAY,CAACH,SAAS,CAAC;IAE5D,OAAOI,8BAA8B,CACnC5B,GAAG,EACHZ,QAAQ,EACRqC,wBAAsE,CACvE;;EAGH,OAAOI,kCAAkC,CACvC7B,GAAG,EACHwB,SAAS,EACTC,wBAAkD,EAClDP,MAAM,CACP;AACH;AAxBAP,OAAA,CAAAY,kBAAA,GAAAA,kBAAA;AA0BA,SAASO,gBAAgBA,CACvBC,eAAgD;EAEhD,MAAM;IAAEC;EAAM,CAAE,GAAG/C,OAAO,CAAC,QAAQ,CAAkB;EACrD,OAAO8C,eAAe,KAAKjC,SAAS,IAAI,CAACkC,MAAM,CAACC,QAAQ,CAACF,eAAe,CAAC;AAC3E;AAEO,eAAeH,8BAA8BA,CAClD5B,GAA8B,EAC9BZ,QAAkB,EAClB2C,eAAgD;EAEhD,IAAIG,SAAS,GAAc,EAAE;EAC7B,IAAIhB,MAAiC;EAErC,IAAI,CAAC/B,UAAU,CAACC,QAAQ,CAAC,EAAE;IACzB,MAAM,IAAIJ,SAAA,CAAAmD,2BAA2B,CACnCjD,UAAU,EACV,mHAAmH,CACpH;;EAGH,IAAI4C,gBAAgB,CAACC,eAAe,CAAC,EAAE;IACrCb,MAAM,GAAGa,eAAe,CAACb,MAAM;IAC/BgB,SAAS,GAAGH,eAAe,CAACG,SAAS,IAAI,EAAE;GAC5C,MAAM;IACLhB,MAAM,GAAGa,eAAe;;EAG1B,IAAI3C,QAAQ,CAACI,QAAQ,KAAK,IAAI,EAAE;IAC9B,MAAM,IAAIR,SAAA,CAAAmD,2BAA2B,CACnCjD,UAAU,EACV,gEAAgEE,QAAQ,CAACC,YAAY;uCACpDD,QAAQ,CAACC,YAAY,6DAA6D,CACpH;;EAGH,MAAM+C,cAAc,GAAG,MAAMC,uBAAuB,CAACjD,QAAQ,EAAE8C,SAAS,CAAC;EAEzE,OAAOL,kCAAkC,CACvC7B,GAAG,EACHZ,QAAQ,CAACG,GAAG,EACZ6C,cAAc,EACdlB,MAAM,CACP;AACH;AAtCAP,OAAA,CAAAiB,8BAAA,GAAAA,8BAAA;AAwCA,eAAeS,uBAAuBA,CACpCjD,QAAkB,EAClB8C,SAAoB;EAEpB,MAAM;IAAEI;EAAK,CAAE,GAAGrD,OAAO,CAAC,QAAQ,CAAkB;EAEpD,MAAMsD,eAAe,GAGhB,EAAE;EACP,KAAK,MAAM,CAACjD,UAAU,EAAEkD,eAAe,CAAC,IAAIC,MAAM,CAACC,OAAO,CACxDtD,QAAQ,CAACM,cAAc,CACxB,EAAE;IACD,KAAK,MAAMiD,OAAO,IAAIF,MAAM,CAACG,IAAI,CAACJ,eAAe,CAAC,EAAE;MAClDD,eAAe,CAACM,IAAI,CAAC;QAAEvD,UAAU;QAAEqD;MAAO,CAAE,CAAC;;;EAIjD,MAAMG,YAAY,GAAsB,IAAIC,GAAG,EAAE;EACjD,KAAK,MAAM,CAACC,iBAAiB,EAAEC,oBAAoB,CAAC,IAAIR,MAAM,CAACC,OAAO,CACpER,SAAS,CACV,EAAE;IACD,IAAI,CAACI,KAAK,CAACY,SAAS,CAACD,oBAAoB,CAAC,EAAE;MAC1C,MAAM,IAAIjE,SAAA,CAAAmD,2BAA2B,CACnCjD,UAAU,EACV,kCAAkCE,QAAQ,CAACC,YAAY,qBAAqB2D,iBAAiB,wCAAwCC,oBAAoB,EAAE,CAC5J;;IAGH,MAAME,uBAAuB,GAAGZ,eAAe,CAACa,MAAM,CAAEC,GAAG,IAAI;MAC7D,OACEA,GAAG,CAACV,OAAO,KAAKK,iBAAiB,IACjC,GAAGK,GAAG,CAAC/D,UAAU,IAAI+D,GAAG,CAACV,OAAO,EAAE,KAAKK,iBAAiB;IAE5D,CAAC,CAAC;IAEF,IAAIG,uBAAuB,CAACG,MAAM,KAAK,CAAC,EAAE;MACxC,IAAIC,eAAuB;MAC3B,IAAIhB,eAAe,CAACe,MAAM,GAAG,CAAC,EAAE;QAC9B,MAAME,cAAc,GAAGjB,eAAe,CACnC/B,GAAG,CAAE6C,GAAG,IAAK,GAAGA,GAAG,CAAC/D,UAAU,IAAI+D,GAAG,CAACV,OAAO,EAAE,CAAC,CAChDnC,GAAG,CAAEiD,CAAC,IAAK,KAAKA,CAAC,EAAE,CAAC,CACpBC,IAAI,CAAC,IAAI,CAAC;QACbH,eAAe,GAAG;EACxBC,cAAc,EAAE;OACX,MAAM;QACLD,eAAe,GAAG,mDAAmD;;MAEvE,MAAM,IAAIvE,SAAA,CAAAmD,2BAA2B,CACnCjD,UAAU,EACV,kCAAkCE,QAAQ,CAACC,YAAY,SAAS2D,iBAAiB;EACvFO,eAAe,EAAE,CACZ;;IAGH,IAAIJ,uBAAuB,CAACG,MAAM,GAAG,CAAC,EAAE;MACtC,MAAMK,2BAA2B,GAAGR,uBAAuB,CACxD3C,GAAG,CAAC,CAAC;QAAElB,UAAU;QAAEqD;MAAO,CAAE,KAAK,GAAGrD,UAAU,IAAIqD,OAAO,EAAE,CAAC,CAC5DnC,GAAG,CAAEiD,CAAC,IAAK,KAAKA,CAAC,EAAE,CAAC,CACpBC,IAAI,CAAC,IAAI,CAAC;MACb,MAAM,IAAI1E,SAAA,CAAAmD,2BAA2B,CACnCjD,UAAU,EACV,oBAAoB8D,iBAAiB,kCAAkC5D,QAAQ,CAACC,YAAY;;EAElGsE,2BAA2B;;8FAEiE,CACvF;;IAGH,MAAM,CAACC,aAAa,CAAC,GAAGT,uBAAuB;IAE/C,MAAMU,gBAAgB,GAAG,GAAGD,aAAa,CAACtE,UAAU,IAAIsE,aAAa,CAACjB,OAAO,EAAE;IAE/E;IACA;IACA;IACA,IAAIG,YAAY,CAACgB,GAAG,CAACD,gBAAgB,CAAC,EAAE;MACtC,MAAM,IAAI7E,SAAA,CAAAmD,2BAA2B,CACnCjD,UAAU,EACV,qBAAqB0E,aAAa,CAACjB,OAAO,QAAQkB,gBAAgB;oEACN,CAC7D;;IAGHf,YAAY,CAACiB,GAAG,CAACF,gBAAgB,EAAE;MACjCvE,UAAU,EAAEsE,aAAa,CAACtE,UAAU;MACpC0E,WAAW,EAAEJ,aAAa,CAACjB,OAAO;MAClC/B,OAAO,EAAEqC;KACV,CAAC;;EAGJ,IAAIH,YAAY,CAACmB,IAAI,GAAG1B,eAAe,CAACe,MAAM,EAAE;IAC9C,MAAMY,gBAAgB,GAAG3B,eAAe,CACrC/B,GAAG,CAAE6C,GAAG,IAAK,GAAGA,GAAG,CAAC/D,UAAU,IAAI+D,GAAG,CAACV,OAAO,EAAE,CAAC,CAChDS,MAAM,CAAEe,SAAS,IAAK,CAACrB,YAAY,CAACgB,GAAG,CAACK,SAAS,CAAC,CAAC,CACnD3D,GAAG,CAAEiD,CAAC,IAAK,KAAKA,CAAC,EAAE,CAAC,CACpBC,IAAI,CAAC,IAAI,CAAC;IAEb,MAAM,IAAI1E,SAAA,CAAAmD,2BAA2B,CACnCjD,UAAU,EACV,gBAAgBE,QAAQ,CAACC,YAAY;EACzC6E,gBAAgB;;;CAGjB,CACI;;EAGH,OAAOE,YAAY,CAAChF,QAAQ,EAAE,CAAC,GAAG0D,YAAY,CAACuB,MAAM,EAAE,CAAC,CAAC;AAC3D;AAEA,eAAexC,kCAAkCA,CAC/C7B,GAA8B,EAC9BT,GAAU,EACVC,QAAgC,EAChC0B,MAAsB;EAEtB,MAAM;IAAEoD;EAAe,CAAE,GAAGrF,OAAO,CAAC,QAAQ,CAAkB;EAE9D,IAAIiC,MAAM,KAAKpB,SAAS,EAAE;IACxB,MAAMyE,OAAO,GAAG,MAAMvE,GAAG,CAACE,MAAM,CAACH,UAAU,EAAE;IAC7CmB,MAAM,GAAGqD,OAAO,CAAC,CAAC,CAAC;;EAGrB,MAAMC,eAAe,GAAGC,6BAA6B,CACnDzE,GAAG,CAAC0E,OAAO,CAACC,MAAM,EAClBpF,GAAG,CACJ;EAED,OAAO,IAAI+E,eAAe,CAACE,eAAe,EAAEhF,QAAQ,EAAE0B,MAAM,CAAC;AAC/D;AAEO,eAAe0D,aAAaA,CACjC5E,GAA8B,EAC9BwB,SAAyB,EACzBZ,OAAe,EACfM,MAAsB;EAEtB,IAAI,OAAOM,SAAS,KAAK,QAAQ,EAAE;IACjC,MAAMpC,QAAQ,GAAG,MAAMY,GAAG,CAAC0B,SAAS,CAACC,YAAY,CAACH,SAAS,CAAC;IAE5D,OAAOqD,yBAAyB,CAAC7E,GAAG,EAAEZ,QAAQ,EAAEwB,OAAO,EAAEM,MAAM,CAAC;;EAGlE,MAAM;IAAE4D;EAAQ,CAAE,GAAG7F,OAAO,CAAC,QAAQ,CAAkB;EAEvD,IAAIiC,MAAM,KAAKpB,SAAS,EAAE;IACxB,MAAMyE,OAAO,GAAG,MAAMvE,GAAG,CAACE,MAAM,CAACH,UAAU,EAAE;IAC7CmB,MAAM,GAAGqD,OAAO,CAAC,CAAC,CAAC;;EAGrB;EACA;EACA,MAAMQ,gBAAgB,GACpB7D,MAAM,KAAKpB,SAAS,GAAGoB,MAAM,GAAGlB,GAAG,CAACE,MAAM,CAACC,QAAQ;EAErD,MAAMqE,eAAe,GAAGC,6BAA6B,CACnDzE,GAAG,CAAC0E,OAAO,CAACC,MAAM,EAClBnD,SAAS,CACV;EAED,OAAO,IAAIsD,QAAQ,CAAClE,OAAO,EAAE4D,eAAe,EAAEO,gBAAgB,CAAC;AACjE;AA9BApE,OAAA,CAAAiE,aAAA,GAAAA,aAAA;AA6CO,eAAeI,cAAcA,CAClChF,GAA8B,EAC9BiF,IAAY,EACZC,qBAA8D,EAC9DnD,eAAgD;EAEhD,IAAIoD,IAAI,GAAG,EAAE;EACb,IAAIvF,KAAK,CAACC,OAAO,CAACqF,qBAAqB,CAAC,EAAE;IACxCC,IAAI,GAAGD,qBAAqB;GAC7B,MAAM;IACLnD,eAAe,GAAGmD,qBAAqB;;EAEzC,MAAME,OAAO,GAAG,MAAM7D,kBAAkB,CAACvB,GAAG,EAAEiF,IAAI,EAAElD,eAAe,CAAC;EACpE,OAAOqD,OAAO,CAACC,MAAM,CAAC,GAAGF,IAAI,CAAC;AAChC;AAdAxE,OAAA,CAAAqE,cAAA,GAAAA,cAAA;AAgBO,eAAeH,yBAAyBA,CAC7C7E,GAA8B,EAC9BZ,QAAkB,EAClBwB,OAAe,EACfM,MAAsB;EAEtB,IAAI,CAAC/B,UAAU,CAACC,QAAQ,CAAC,EAAE;IACzB,MAAM,IAAIJ,SAAA,CAAAmD,2BAA2B,CACnCjD,UAAU,EACV,sGAAsG,CACvG;;EAGH,MAAMkG,OAAO,GAAG,MAAMvD,kCAAkC,CACtD7B,GAAG,EACHZ,QAAQ,CAACG,GAAG,EACZ,IAAI,EACJ2B,MAAM,CACP;EAED,IAAIoE,QAAQ,GAAGF,OAAO,CAACG,MAAM,CAAC3E,OAAO,CAAC;EACtC;EACA,IAAI0E,QAAQ,CAACnF,QAAQ,KAAK,IAAI,EAAE;IAC9BmF,QAAQ,GAAGA,QAAQ,CAACE,OAAO,CAACxF,GAAG,CAACE,MAAM,CAACC,QAAQ,CAAC;;EAGlD,OAAOmF,QAAQ;AACjB;AA3BA3E,OAAA,CAAAkE,yBAAA,GAAAA,yBAAA;AA6BA;AACA;AACA;AACA;AACA,SAASJ,6BAA6BA,CACpCgB,aAA4B,EAC5BlG,GAAU;EAEV,MAAM;IAAEmG;EAAS,CAAE,GAAGzG,OAAO,CAAC,QAAQ,CAAkB;EAExD,IAAIwG,aAAa,CAACE,GAAG,KAAK,MAAM,IAAIF,aAAa,CAACE,GAAG,KAAK7F,SAAS,EAAE;IACnE,OAAOP,GAAG;;EAGZ;EACA;EACA;EACA;EACA;EACA,MAAMqG,QAAQ,GAAGF,SAAS,CAACG,IAAI,CAACJ,aAAa,CAACE,GAAG,CAAC,CAACG,GAAG,CAAC,OAAO,CAAC,CAACC,WAAW,EAAE;EAE7E,MAAMC,WAAW,GAAU,EAAE;EAE7B,KAAK,MAAMC,UAAU,IAAI1G,GAAG,EAAE;IAC5B,IAAI0G,UAAU,CAACC,IAAI,KAAK,UAAU,EAAE;MAClCF,WAAW,CAACnD,IAAI,CAACoD,UAAU,CAAC;MAC5B;;IAGFD,WAAW,CAACnD,IAAI,CAAC;MACf,GAAGoD,UAAU;MACbN,GAAG,EAAEC;KACN,CAAC;;EAGJ,OAAOI,WAAW;AACpB;AAEA,SAAS5B,YAAYA,CAAChF,QAAkB,EAAE8C,SAAiB;EACzD,IAAI1C,QAAQ,GAAGJ,QAAQ,CAACI,QAAQ;EAEhC;EACA,KAAK,MAAM;IAAEF,UAAU;IAAE0E,WAAW;IAAEpD;EAAO,CAAE,IAAIsB,SAAS,EAAE;IAC5D,MAAMxC,cAAc,GAAGN,QAAQ,CAACM,cAAc,CAACJ,UAAU,CAAC,CAAC0E,WAAW,CAAC;IACvE,KAAK,MAAM;MAAEmC,KAAK;MAAE7C;IAAM,CAAE,IAAI5D,cAAc,EAAE;MAC9CF,QAAQ,GACNA,QAAQ,CAAC4G,MAAM,CAAC,CAAC,EAAE,CAAC,GAAGD,KAAK,GAAG,CAAC,CAAC,GACjCvF,OAAO,CAACwF,MAAM,CAAC,CAAC,CAAC,GACjB5G,QAAQ,CAAC4G,MAAM,CAAC,CAAC,GAAG,CAACD,KAAK,GAAG7C,MAAM,IAAI,CAAC,CAAC;;;EAI/C,OAAO9D,QAAQ;AACjB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}