{"ast":null,"code":"'use strict';\n\nconst {\n  webidl\n} = require('../fetch/webidl');\nconst {\n  DOMException\n} = require('../fetch/constants');\nconst {\n  URLSerializer\n} = require('../fetch/dataURL');\nconst {\n  getGlobalOrigin\n} = require('../fetch/global');\nconst {\n  staticPropertyDescriptors,\n  states,\n  opcodes,\n  emptyBuffer\n} = require('./constants');\nconst {\n  kWebSocketURL,\n  kReadyState,\n  kController,\n  kBinaryType,\n  kResponse,\n  kSentClose,\n  kByteParser\n} = require('./symbols');\nconst {\n  isEstablished,\n  isClosing,\n  isValidSubprotocol,\n  failWebsocketConnection,\n  fireEvent\n} = require('./util');\nconst {\n  establishWebSocketConnection\n} = require('./connection');\nconst {\n  WebsocketFrameSend\n} = require('./frame');\nconst {\n  ByteParser\n} = require('./receiver');\nconst {\n  kEnumerableProperty,\n  isBlobLike\n} = require('../core/util');\nconst {\n  getGlobalDispatcher\n} = require('../global');\nconst {\n  types\n} = require('util');\nlet experimentalWarned = false;\n\n// https://websockets.spec.whatwg.org/#interface-definition\nclass WebSocket extends EventTarget {\n  #events = {\n    open: null,\n    error: null,\n    close: null,\n    message: null\n  };\n  #bufferedAmount = 0;\n  #protocol = '';\n  #extensions = '';\n\n  /**\n   * @param {string} url\n   * @param {string|string[]} protocols\n   */\n  constructor(url, protocols = []) {\n    super();\n    webidl.argumentLengthCheck(arguments, 1, {\n      header: 'WebSocket constructor'\n    });\n    if (!experimentalWarned) {\n      experimentalWarned = true;\n      process.emitWarning('WebSockets are experimental, expect them to change at any time.', {\n        code: 'UNDICI-WS'\n      });\n    }\n    const options = webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'](protocols);\n    url = webidl.converters.USVString(url);\n    protocols = options.protocols;\n\n    // 1. Let baseURL be this's relevant settings object's API base URL.\n    const baseURL = getGlobalOrigin();\n\n    // 1. Let urlRecord be the result of applying the URL parser to url with baseURL.\n    let urlRecord;\n    try {\n      urlRecord = new URL(url, baseURL);\n    } catch (e) {\n      // 3. If urlRecord is failure, then throw a \"SyntaxError\" DOMException.\n      throw new DOMException(e, 'SyntaxError');\n    }\n\n    // 4. If urlRecord’s scheme is \"http\", then set urlRecord’s scheme to \"ws\".\n    if (urlRecord.protocol === 'http:') {\n      urlRecord.protocol = 'ws:';\n    } else if (urlRecord.protocol === 'https:') {\n      // 5. Otherwise, if urlRecord’s scheme is \"https\", set urlRecord’s scheme to \"wss\".\n      urlRecord.protocol = 'wss:';\n    }\n\n    // 6. If urlRecord’s scheme is not \"ws\" or \"wss\", then throw a \"SyntaxError\" DOMException.\n    if (urlRecord.protocol !== 'ws:' && urlRecord.protocol !== 'wss:') {\n      throw new DOMException(`Expected a ws: or wss: protocol, got ${urlRecord.protocol}`, 'SyntaxError');\n    }\n\n    // 7. If urlRecord’s fragment is non-null, then throw a \"SyntaxError\"\n    //    DOMException.\n    if (urlRecord.hash || urlRecord.href.endsWith('#')) {\n      throw new DOMException('Got fragment', 'SyntaxError');\n    }\n\n    // 8. If protocols is a string, set protocols to a sequence consisting\n    //    of just that string.\n    if (typeof protocols === 'string') {\n      protocols = [protocols];\n    }\n\n    // 9. If any of the values in protocols occur more than once or otherwise\n    //    fail to match the requirements for elements that comprise the value\n    //    of `Sec-WebSocket-Protocol` fields as defined by The WebSocket\n    //    protocol, then throw a \"SyntaxError\" DOMException.\n    if (protocols.length !== new Set(protocols.map(p => p.toLowerCase())).size) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError');\n    }\n    if (protocols.length > 0 && !protocols.every(p => isValidSubprotocol(p))) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError');\n    }\n\n    // 10. Set this's url to urlRecord.\n    this[kWebSocketURL] = new URL(urlRecord.href);\n\n    // 11. Let client be this's relevant settings object.\n\n    // 12. Run this step in parallel:\n\n    //    1. Establish a WebSocket connection given urlRecord, protocols,\n    //       and client.\n    this[kController] = establishWebSocketConnection(urlRecord, protocols, this, response => this.#onConnectionEstablished(response), options);\n\n    // Each WebSocket object has an associated ready state, which is a\n    // number representing the state of the connection. Initially it must\n    // be CONNECTING (0).\n    this[kReadyState] = WebSocket.CONNECTING;\n\n    // The extensions attribute must initially return the empty string.\n\n    // The protocol attribute must initially return the empty string.\n\n    // Each WebSocket object has an associated binary type, which is a\n    // BinaryType. Initially it must be \"blob\".\n    this[kBinaryType] = 'blob';\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-close\n   * @param {number|undefined} code\n   * @param {string|undefined} reason\n   */\n  close(code = undefined, reason = undefined) {\n    webidl.brandCheck(this, WebSocket);\n    if (code !== undefined) {\n      code = webidl.converters['unsigned short'](code, {\n        clamp: true\n      });\n    }\n    if (reason !== undefined) {\n      reason = webidl.converters.USVString(reason);\n    }\n\n    // 1. If code is present, but is neither an integer equal to 1000 nor an\n    //    integer in the range 3000 to 4999, inclusive, throw an\n    //    \"InvalidAccessError\" DOMException.\n    if (code !== undefined) {\n      if (code !== 1000 && (code < 3000 || code > 4999)) {\n        throw new DOMException('invalid code', 'InvalidAccessError');\n      }\n    }\n    let reasonByteLength = 0;\n\n    // 2. If reason is present, then run these substeps:\n    if (reason !== undefined) {\n      // 1. Let reasonBytes be the result of encoding reason.\n      // 2. If reasonBytes is longer than 123 bytes, then throw a\n      //    \"SyntaxError\" DOMException.\n      reasonByteLength = Buffer.byteLength(reason);\n      if (reasonByteLength > 123) {\n        throw new DOMException(`Reason must be less than 123 bytes; received ${reasonByteLength}`, 'SyntaxError');\n      }\n    }\n\n    // 3. Run the first matching steps from the following list:\n    if (this[kReadyState] === WebSocket.CLOSING || this[kReadyState] === WebSocket.CLOSED) {\n      // If this's ready state is CLOSING (2) or CLOSED (3)\n      // Do nothing.\n    } else if (!isEstablished(this)) {\n      // If the WebSocket connection is not yet established\n      // Fail the WebSocket connection and set this's ready state\n      // to CLOSING (2).\n      failWebsocketConnection(this, 'Connection was closed before it was established.');\n      this[kReadyState] = WebSocket.CLOSING;\n    } else if (!isClosing(this)) {\n      // If the WebSocket closing handshake has not yet been started\n      // Start the WebSocket closing handshake and set this's ready\n      // state to CLOSING (2).\n      // - If neither code nor reason is present, the WebSocket Close\n      //   message must not have a body.\n      // - If code is present, then the status code to use in the\n      //   WebSocket Close message must be the integer given by code.\n      // - If reason is also present, then reasonBytes must be\n      //   provided in the Close message after the status code.\n\n      const frame = new WebsocketFrameSend();\n\n      // If neither code nor reason is present, the WebSocket Close\n      // message must not have a body.\n\n      // If code is present, then the status code to use in the\n      // WebSocket Close message must be the integer given by code.\n      if (code !== undefined && reason === undefined) {\n        frame.frameData = Buffer.allocUnsafe(2);\n        frame.frameData.writeUInt16BE(code, 0);\n      } else if (code !== undefined && reason !== undefined) {\n        // If reason is also present, then reasonBytes must be\n        // provided in the Close message after the status code.\n        frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);\n        frame.frameData.writeUInt16BE(code, 0);\n        // the body MAY contain UTF-8-encoded data with value /reason/\n        frame.frameData.write(reason, 2, 'utf-8');\n      } else {\n        frame.frameData = emptyBuffer;\n      }\n\n      /** @type {import('stream').Duplex} */\n      const socket = this[kResponse].socket;\n      socket.write(frame.createFrame(opcodes.CLOSE), err => {\n        if (!err) {\n          this[kSentClose] = true;\n        }\n      });\n\n      // Upon either sending or receiving a Close control frame, it is said\n      // that _The WebSocket Closing Handshake is Started_ and that the\n      // WebSocket connection is in the CLOSING state.\n      this[kReadyState] = states.CLOSING;\n    } else {\n      // Otherwise\n      // Set this's ready state to CLOSING (2).\n      this[kReadyState] = WebSocket.CLOSING;\n    }\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-send\n   * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data\n   */\n  send(data) {\n    webidl.brandCheck(this, WebSocket);\n    webidl.argumentLengthCheck(arguments, 1, {\n      header: 'WebSocket.send'\n    });\n    data = webidl.converters.WebSocketSendData(data);\n\n    // 1. If this's ready state is CONNECTING, then throw an\n    //    \"InvalidStateError\" DOMException.\n    if (this[kReadyState] === WebSocket.CONNECTING) {\n      throw new DOMException('Sent before connected.', 'InvalidStateError');\n    }\n\n    // 2. Run the appropriate set of steps from the following list:\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-6.1\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-5.2\n\n    if (!isEstablished(this) || isClosing(this)) {\n      return;\n    }\n\n    /** @type {import('stream').Duplex} */\n    const socket = this[kResponse].socket;\n\n    // If data is a string\n    if (typeof data === 'string') {\n      // If the WebSocket connection is established and the WebSocket\n      // closing handshake has not yet started, then the user agent\n      // must send a WebSocket Message comprised of the data argument\n      // using a text frame opcode; if the data cannot be sent, e.g.\n      // because it would need to be buffered but the buffer is full,\n      // the user agent must flag the WebSocket as full and then close\n      // the WebSocket connection. Any invocation of this method with a\n      // string argument that does not throw an exception must increase\n      // the bufferedAmount attribute by the number of bytes needed to\n      // express the argument as UTF-8.\n\n      const value = Buffer.from(data);\n      const frame = new WebsocketFrameSend(value);\n      const buffer = frame.createFrame(opcodes.TEXT);\n      this.#bufferedAmount += value.byteLength;\n      socket.write(buffer, () => {\n        this.#bufferedAmount -= value.byteLength;\n      });\n    } else if (types.isArrayBuffer(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need\n      // to be buffered but the buffer is full, the user agent must flag\n      // the WebSocket as full and then close the WebSocket connection.\n      // The data to be sent is the data stored in the buffer described\n      // by the ArrayBuffer object. Any invocation of this method with an\n      // ArrayBuffer argument that does not throw an exception must\n      // increase the bufferedAmount attribute by the length of the\n      // ArrayBuffer in bytes.\n\n      const value = Buffer.from(data);\n      const frame = new WebsocketFrameSend(value);\n      const buffer = frame.createFrame(opcodes.BINARY);\n      this.#bufferedAmount += value.byteLength;\n      socket.write(buffer, () => {\n        this.#bufferedAmount -= value.byteLength;\n      });\n    } else if (ArrayBuffer.isView(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The\n      // data to be sent is the data stored in the section of the buffer\n      // described by the ArrayBuffer object that data references. Any\n      // invocation of this method with this kind of argument that does\n      // not throw an exception must increase the bufferedAmount attribute\n      // by the length of data’s buffer in bytes.\n\n      const ab = Buffer.from(data, data.byteOffset, data.byteLength);\n      const frame = new WebsocketFrameSend(ab);\n      const buffer = frame.createFrame(opcodes.BINARY);\n      this.#bufferedAmount += ab.byteLength;\n      socket.write(buffer, () => {\n        this.#bufferedAmount -= ab.byteLength;\n      });\n    } else if (isBlobLike(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The data\n      // to be sent is the raw data represented by the Blob object. Any\n      // invocation of this method with a Blob argument that does not throw\n      // an exception must increase the bufferedAmount attribute by the size\n      // of the Blob object’s raw data, in bytes.\n\n      const frame = new WebsocketFrameSend();\n      data.arrayBuffer().then(ab => {\n        const value = Buffer.from(ab);\n        frame.frameData = value;\n        const buffer = frame.createFrame(opcodes.BINARY);\n        this.#bufferedAmount += value.byteLength;\n        socket.write(buffer, () => {\n          this.#bufferedAmount -= value.byteLength;\n        });\n      });\n    }\n  }\n  get readyState() {\n    webidl.brandCheck(this, WebSocket);\n\n    // The readyState getter steps are to return this's ready state.\n    return this[kReadyState];\n  }\n  get bufferedAmount() {\n    webidl.brandCheck(this, WebSocket);\n    return this.#bufferedAmount;\n  }\n  get url() {\n    webidl.brandCheck(this, WebSocket);\n\n    // The url getter steps are to return this's url, serialized.\n    return URLSerializer(this[kWebSocketURL]);\n  }\n  get extensions() {\n    webidl.brandCheck(this, WebSocket);\n    return this.#extensions;\n  }\n  get protocol() {\n    webidl.brandCheck(this, WebSocket);\n    return this.#protocol;\n  }\n  get onopen() {\n    webidl.brandCheck(this, WebSocket);\n    return this.#events.open;\n  }\n  set onopen(fn) {\n    webidl.brandCheck(this, WebSocket);\n    if (this.#events.open) {\n      this.removeEventListener('open', this.#events.open);\n    }\n    if (typeof fn === 'function') {\n      this.#events.open = fn;\n      this.addEventListener('open', fn);\n    } else {\n      this.#events.open = null;\n    }\n  }\n  get onerror() {\n    webidl.brandCheck(this, WebSocket);\n    return this.#events.error;\n  }\n  set onerror(fn) {\n    webidl.brandCheck(this, WebSocket);\n    if (this.#events.error) {\n      this.removeEventListener('error', this.#events.error);\n    }\n    if (typeof fn === 'function') {\n      this.#events.error = fn;\n      this.addEventListener('error', fn);\n    } else {\n      this.#events.error = null;\n    }\n  }\n  get onclose() {\n    webidl.brandCheck(this, WebSocket);\n    return this.#events.close;\n  }\n  set onclose(fn) {\n    webidl.brandCheck(this, WebSocket);\n    if (this.#events.close) {\n      this.removeEventListener('close', this.#events.close);\n    }\n    if (typeof fn === 'function') {\n      this.#events.close = fn;\n      this.addEventListener('close', fn);\n    } else {\n      this.#events.close = null;\n    }\n  }\n  get onmessage() {\n    webidl.brandCheck(this, WebSocket);\n    return this.#events.message;\n  }\n  set onmessage(fn) {\n    webidl.brandCheck(this, WebSocket);\n    if (this.#events.message) {\n      this.removeEventListener('message', this.#events.message);\n    }\n    if (typeof fn === 'function') {\n      this.#events.message = fn;\n      this.addEventListener('message', fn);\n    } else {\n      this.#events.message = null;\n    }\n  }\n  get binaryType() {\n    webidl.brandCheck(this, WebSocket);\n    return this[kBinaryType];\n  }\n  set binaryType(type) {\n    webidl.brandCheck(this, WebSocket);\n    if (type !== 'blob' && type !== 'arraybuffer') {\n      this[kBinaryType] = 'blob';\n    } else {\n      this[kBinaryType] = type;\n    }\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n   */\n  #onConnectionEstablished(response) {\n    // processResponse is called when the \"response’s header list has been received and initialized.\"\n    // once this happens, the connection is open\n    this[kResponse] = response;\n    const parser = new ByteParser(this);\n    parser.on('drain', function onParserDrain() {\n      this.ws[kResponse].socket.resume();\n    });\n    response.socket.ws = this;\n    this[kByteParser] = parser;\n\n    // 1. Change the ready state to OPEN (1).\n    this[kReadyState] = states.OPEN;\n\n    // 2. Change the extensions attribute’s value to the extensions in use, if\n    //    it is not the null value.\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\n    const extensions = response.headersList.get('sec-websocket-extensions');\n    if (extensions !== null) {\n      this.#extensions = extensions;\n    }\n\n    // 3. Change the protocol attribute’s value to the subprotocol in use, if\n    //    it is not the null value.\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-1.9\n    const protocol = response.headersList.get('sec-websocket-protocol');\n    if (protocol !== null) {\n      this.#protocol = protocol;\n    }\n\n    // 4. Fire an event named open at the WebSocket object.\n    fireEvent('open', this);\n  }\n}\n\n// https://websockets.spec.whatwg.org/#dom-websocket-connecting\nWebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;\n// https://websockets.spec.whatwg.org/#dom-websocket-open\nWebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;\n// https://websockets.spec.whatwg.org/#dom-websocket-closing\nWebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;\n// https://websockets.spec.whatwg.org/#dom-websocket-closed\nWebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;\nObject.defineProperties(WebSocket.prototype, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors,\n  url: kEnumerableProperty,\n  readyState: kEnumerableProperty,\n  bufferedAmount: kEnumerableProperty,\n  onopen: kEnumerableProperty,\n  onerror: kEnumerableProperty,\n  onclose: kEnumerableProperty,\n  close: kEnumerableProperty,\n  onmessage: kEnumerableProperty,\n  binaryType: kEnumerableProperty,\n  send: kEnumerableProperty,\n  extensions: kEnumerableProperty,\n  protocol: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'WebSocket',\n    writable: false,\n    enumerable: false,\n    configurable: true\n  }\n});\nObject.defineProperties(WebSocket, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors\n});\nwebidl.converters['sequence<DOMString>'] = webidl.sequenceConverter(webidl.converters.DOMString);\nwebidl.converters['DOMString or sequence<DOMString>'] = function (V) {\n  if (webidl.util.Type(V) === 'Object' && Symbol.iterator in V) {\n    return webidl.converters['sequence<DOMString>'](V);\n  }\n  return webidl.converters.DOMString(V);\n};\n\n// This implements the propsal made in https://github.com/whatwg/websockets/issues/42\nwebidl.converters.WebSocketInit = webidl.dictionaryConverter([{\n  key: 'protocols',\n  converter: webidl.converters['DOMString or sequence<DOMString>'],\n  get defaultValue() {\n    return [];\n  }\n}, {\n  key: 'dispatcher',\n  converter: V => V,\n  get defaultValue() {\n    return getGlobalDispatcher();\n  }\n}, {\n  key: 'headers',\n  converter: webidl.nullableConverter(webidl.converters.HeadersInit)\n}]);\nwebidl.converters['DOMString or sequence<DOMString> or WebSocketInit'] = function (V) {\n  if (webidl.util.Type(V) === 'Object' && !(Symbol.iterator in V)) {\n    return webidl.converters.WebSocketInit(V);\n  }\n  return {\n    protocols: webidl.converters['DOMString or sequence<DOMString>'](V)\n  };\n};\nwebidl.converters.WebSocketSendData = function (V) {\n  if (webidl.util.Type(V) === 'Object') {\n    if (isBlobLike(V)) {\n      return webidl.converters.Blob(V, {\n        strict: false\n      });\n    }\n    if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {\n      return webidl.converters.BufferSource(V);\n    }\n  }\n  return webidl.converters.USVString(V);\n};\nmodule.exports = {\n  WebSocket\n};","map":{"version":3,"names":["webidl","require","DOMException","URLSerializer","getGlobalOrigin","staticPropertyDescriptors","states","opcodes","emptyBuffer","kWebSocketURL","kReadyState","kController","kBinaryType","kResponse","kSentClose","kByteParser","isEstablished","isClosing","isValidSubprotocol","failWebsocketConnection","fireEvent","establishWebSocketConnection","WebsocketFrameSend","ByteParser","kEnumerableProperty","isBlobLike","getGlobalDispatcher","types","experimentalWarned","WebSocket","EventTarget","events","open","error","close","message","bufferedAmount","protocol","extensions","constructor","url","protocols","argumentLengthCheck","arguments","header","process","emitWarning","code","options","converters","USVString","baseURL","urlRecord","URL","e","hash","href","endsWith","length","Set","map","p","toLowerCase","size","every","response","onConnectionEstablished","CONNECTING","undefined","reason","brandCheck","clamp","reasonByteLength","Buffer","byteLength","CLOSING","CLOSED","frame","frameData","allocUnsafe","writeUInt16BE","write","socket","createFrame","CLOSE","err","send","data","WebSocketSendData","value","from","buffer","TEXT","isArrayBuffer","BINARY","ArrayBuffer","isView","ab","byteOffset","arrayBuffer","then","readyState","onopen","fn","removeEventListener","addEventListener","onerror","onclose","onmessage","binaryType","type","#onConnectionEstablished","parser","on","onParserDrain","ws","resume","OPEN","headersList","get","prototype","Object","defineProperties","Symbol","toStringTag","writable","enumerable","configurable","sequenceConverter","DOMString","V","util","Type","iterator","WebSocketInit","dictionaryConverter","key","converter","defaultValue","nullableConverter","HeadersInit","Blob","strict","isAnyArrayBuffer","BufferSource","module","exports"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/undici/lib/websocket/websocket.js"],"sourcesContent":["'use strict'\n\nconst { webidl } = require('../fetch/webidl')\nconst { DOMException } = require('../fetch/constants')\nconst { URLSerializer } = require('../fetch/dataURL')\nconst { getGlobalOrigin } = require('../fetch/global')\nconst { staticPropertyDescriptors, states, opcodes, emptyBuffer } = require('./constants')\nconst {\n  kWebSocketURL,\n  kReadyState,\n  kController,\n  kBinaryType,\n  kResponse,\n  kSentClose,\n  kByteParser\n} = require('./symbols')\nconst { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = require('./util')\nconst { establishWebSocketConnection } = require('./connection')\nconst { WebsocketFrameSend } = require('./frame')\nconst { ByteParser } = require('./receiver')\nconst { kEnumerableProperty, isBlobLike } = require('../core/util')\nconst { getGlobalDispatcher } = require('../global')\nconst { types } = require('util')\n\nlet experimentalWarned = false\n\n// https://websockets.spec.whatwg.org/#interface-definition\nclass WebSocket extends EventTarget {\n  #events = {\n    open: null,\n    error: null,\n    close: null,\n    message: null\n  }\n\n  #bufferedAmount = 0\n  #protocol = ''\n  #extensions = ''\n\n  /**\n   * @param {string} url\n   * @param {string|string[]} protocols\n   */\n  constructor (url, protocols = []) {\n    super()\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'WebSocket constructor' })\n\n    if (!experimentalWarned) {\n      experimentalWarned = true\n      process.emitWarning('WebSockets are experimental, expect them to change at any time.', {\n        code: 'UNDICI-WS'\n      })\n    }\n\n    const options = webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'](protocols)\n\n    url = webidl.converters.USVString(url)\n    protocols = options.protocols\n\n    // 1. Let baseURL be this's relevant settings object's API base URL.\n    const baseURL = getGlobalOrigin()\n\n    // 1. Let urlRecord be the result of applying the URL parser to url with baseURL.\n    let urlRecord\n\n    try {\n      urlRecord = new URL(url, baseURL)\n    } catch (e) {\n      // 3. If urlRecord is failure, then throw a \"SyntaxError\" DOMException.\n      throw new DOMException(e, 'SyntaxError')\n    }\n\n    // 4. If urlRecord’s scheme is \"http\", then set urlRecord’s scheme to \"ws\".\n    if (urlRecord.protocol === 'http:') {\n      urlRecord.protocol = 'ws:'\n    } else if (urlRecord.protocol === 'https:') {\n      // 5. Otherwise, if urlRecord’s scheme is \"https\", set urlRecord’s scheme to \"wss\".\n      urlRecord.protocol = 'wss:'\n    }\n\n    // 6. If urlRecord’s scheme is not \"ws\" or \"wss\", then throw a \"SyntaxError\" DOMException.\n    if (urlRecord.protocol !== 'ws:' && urlRecord.protocol !== 'wss:') {\n      throw new DOMException(\n        `Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,\n        'SyntaxError'\n      )\n    }\n\n    // 7. If urlRecord’s fragment is non-null, then throw a \"SyntaxError\"\n    //    DOMException.\n    if (urlRecord.hash || urlRecord.href.endsWith('#')) {\n      throw new DOMException('Got fragment', 'SyntaxError')\n    }\n\n    // 8. If protocols is a string, set protocols to a sequence consisting\n    //    of just that string.\n    if (typeof protocols === 'string') {\n      protocols = [protocols]\n    }\n\n    // 9. If any of the values in protocols occur more than once or otherwise\n    //    fail to match the requirements for elements that comprise the value\n    //    of `Sec-WebSocket-Protocol` fields as defined by The WebSocket\n    //    protocol, then throw a \"SyntaxError\" DOMException.\n    if (protocols.length !== new Set(protocols.map(p => p.toLowerCase())).size) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')\n    }\n\n    if (protocols.length > 0 && !protocols.every(p => isValidSubprotocol(p))) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')\n    }\n\n    // 10. Set this's url to urlRecord.\n    this[kWebSocketURL] = new URL(urlRecord.href)\n\n    // 11. Let client be this's relevant settings object.\n\n    // 12. Run this step in parallel:\n\n    //    1. Establish a WebSocket connection given urlRecord, protocols,\n    //       and client.\n    this[kController] = establishWebSocketConnection(\n      urlRecord,\n      protocols,\n      this,\n      (response) => this.#onConnectionEstablished(response),\n      options\n    )\n\n    // Each WebSocket object has an associated ready state, which is a\n    // number representing the state of the connection. Initially it must\n    // be CONNECTING (0).\n    this[kReadyState] = WebSocket.CONNECTING\n\n    // The extensions attribute must initially return the empty string.\n\n    // The protocol attribute must initially return the empty string.\n\n    // Each WebSocket object has an associated binary type, which is a\n    // BinaryType. Initially it must be \"blob\".\n    this[kBinaryType] = 'blob'\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-close\n   * @param {number|undefined} code\n   * @param {string|undefined} reason\n   */\n  close (code = undefined, reason = undefined) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (code !== undefined) {\n      code = webidl.converters['unsigned short'](code, { clamp: true })\n    }\n\n    if (reason !== undefined) {\n      reason = webidl.converters.USVString(reason)\n    }\n\n    // 1. If code is present, but is neither an integer equal to 1000 nor an\n    //    integer in the range 3000 to 4999, inclusive, throw an\n    //    \"InvalidAccessError\" DOMException.\n    if (code !== undefined) {\n      if (code !== 1000 && (code < 3000 || code > 4999)) {\n        throw new DOMException('invalid code', 'InvalidAccessError')\n      }\n    }\n\n    let reasonByteLength = 0\n\n    // 2. If reason is present, then run these substeps:\n    if (reason !== undefined) {\n      // 1. Let reasonBytes be the result of encoding reason.\n      // 2. If reasonBytes is longer than 123 bytes, then throw a\n      //    \"SyntaxError\" DOMException.\n      reasonByteLength = Buffer.byteLength(reason)\n\n      if (reasonByteLength > 123) {\n        throw new DOMException(\n          `Reason must be less than 123 bytes; received ${reasonByteLength}`,\n          'SyntaxError'\n        )\n      }\n    }\n\n    // 3. Run the first matching steps from the following list:\n    if (this[kReadyState] === WebSocket.CLOSING || this[kReadyState] === WebSocket.CLOSED) {\n      // If this's ready state is CLOSING (2) or CLOSED (3)\n      // Do nothing.\n    } else if (!isEstablished(this)) {\n      // If the WebSocket connection is not yet established\n      // Fail the WebSocket connection and set this's ready state\n      // to CLOSING (2).\n      failWebsocketConnection(this, 'Connection was closed before it was established.')\n      this[kReadyState] = WebSocket.CLOSING\n    } else if (!isClosing(this)) {\n      // If the WebSocket closing handshake has not yet been started\n      // Start the WebSocket closing handshake and set this's ready\n      // state to CLOSING (2).\n      // - If neither code nor reason is present, the WebSocket Close\n      //   message must not have a body.\n      // - If code is present, then the status code to use in the\n      //   WebSocket Close message must be the integer given by code.\n      // - If reason is also present, then reasonBytes must be\n      //   provided in the Close message after the status code.\n\n      const frame = new WebsocketFrameSend()\n\n      // If neither code nor reason is present, the WebSocket Close\n      // message must not have a body.\n\n      // If code is present, then the status code to use in the\n      // WebSocket Close message must be the integer given by code.\n      if (code !== undefined && reason === undefined) {\n        frame.frameData = Buffer.allocUnsafe(2)\n        frame.frameData.writeUInt16BE(code, 0)\n      } else if (code !== undefined && reason !== undefined) {\n        // If reason is also present, then reasonBytes must be\n        // provided in the Close message after the status code.\n        frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength)\n        frame.frameData.writeUInt16BE(code, 0)\n        // the body MAY contain UTF-8-encoded data with value /reason/\n        frame.frameData.write(reason, 2, 'utf-8')\n      } else {\n        frame.frameData = emptyBuffer\n      }\n\n      /** @type {import('stream').Duplex} */\n      const socket = this[kResponse].socket\n\n      socket.write(frame.createFrame(opcodes.CLOSE), (err) => {\n        if (!err) {\n          this[kSentClose] = true\n        }\n      })\n\n      // Upon either sending or receiving a Close control frame, it is said\n      // that _The WebSocket Closing Handshake is Started_ and that the\n      // WebSocket connection is in the CLOSING state.\n      this[kReadyState] = states.CLOSING\n    } else {\n      // Otherwise\n      // Set this's ready state to CLOSING (2).\n      this[kReadyState] = WebSocket.CLOSING\n    }\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-send\n   * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data\n   */\n  send (data) {\n    webidl.brandCheck(this, WebSocket)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'WebSocket.send' })\n\n    data = webidl.converters.WebSocketSendData(data)\n\n    // 1. If this's ready state is CONNECTING, then throw an\n    //    \"InvalidStateError\" DOMException.\n    if (this[kReadyState] === WebSocket.CONNECTING) {\n      throw new DOMException('Sent before connected.', 'InvalidStateError')\n    }\n\n    // 2. Run the appropriate set of steps from the following list:\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-6.1\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-5.2\n\n    if (!isEstablished(this) || isClosing(this)) {\n      return\n    }\n\n    /** @type {import('stream').Duplex} */\n    const socket = this[kResponse].socket\n\n    // If data is a string\n    if (typeof data === 'string') {\n      // If the WebSocket connection is established and the WebSocket\n      // closing handshake has not yet started, then the user agent\n      // must send a WebSocket Message comprised of the data argument\n      // using a text frame opcode; if the data cannot be sent, e.g.\n      // because it would need to be buffered but the buffer is full,\n      // the user agent must flag the WebSocket as full and then close\n      // the WebSocket connection. Any invocation of this method with a\n      // string argument that does not throw an exception must increase\n      // the bufferedAmount attribute by the number of bytes needed to\n      // express the argument as UTF-8.\n\n      const value = Buffer.from(data)\n      const frame = new WebsocketFrameSend(value)\n      const buffer = frame.createFrame(opcodes.TEXT)\n\n      this.#bufferedAmount += value.byteLength\n      socket.write(buffer, () => {\n        this.#bufferedAmount -= value.byteLength\n      })\n    } else if (types.isArrayBuffer(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need\n      // to be buffered but the buffer is full, the user agent must flag\n      // the WebSocket as full and then close the WebSocket connection.\n      // The data to be sent is the data stored in the buffer described\n      // by the ArrayBuffer object. Any invocation of this method with an\n      // ArrayBuffer argument that does not throw an exception must\n      // increase the bufferedAmount attribute by the length of the\n      // ArrayBuffer in bytes.\n\n      const value = Buffer.from(data)\n      const frame = new WebsocketFrameSend(value)\n      const buffer = frame.createFrame(opcodes.BINARY)\n\n      this.#bufferedAmount += value.byteLength\n      socket.write(buffer, () => {\n        this.#bufferedAmount -= value.byteLength\n      })\n    } else if (ArrayBuffer.isView(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The\n      // data to be sent is the data stored in the section of the buffer\n      // described by the ArrayBuffer object that data references. Any\n      // invocation of this method with this kind of argument that does\n      // not throw an exception must increase the bufferedAmount attribute\n      // by the length of data’s buffer in bytes.\n\n      const ab = Buffer.from(data, data.byteOffset, data.byteLength)\n\n      const frame = new WebsocketFrameSend(ab)\n      const buffer = frame.createFrame(opcodes.BINARY)\n\n      this.#bufferedAmount += ab.byteLength\n      socket.write(buffer, () => {\n        this.#bufferedAmount -= ab.byteLength\n      })\n    } else if (isBlobLike(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The data\n      // to be sent is the raw data represented by the Blob object. Any\n      // invocation of this method with a Blob argument that does not throw\n      // an exception must increase the bufferedAmount attribute by the size\n      // of the Blob object’s raw data, in bytes.\n\n      const frame = new WebsocketFrameSend()\n\n      data.arrayBuffer().then((ab) => {\n        const value = Buffer.from(ab)\n        frame.frameData = value\n        const buffer = frame.createFrame(opcodes.BINARY)\n\n        this.#bufferedAmount += value.byteLength\n        socket.write(buffer, () => {\n          this.#bufferedAmount -= value.byteLength\n        })\n      })\n    }\n  }\n\n  get readyState () {\n    webidl.brandCheck(this, WebSocket)\n\n    // The readyState getter steps are to return this's ready state.\n    return this[kReadyState]\n  }\n\n  get bufferedAmount () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#bufferedAmount\n  }\n\n  get url () {\n    webidl.brandCheck(this, WebSocket)\n\n    // The url getter steps are to return this's url, serialized.\n    return URLSerializer(this[kWebSocketURL])\n  }\n\n  get extensions () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#extensions\n  }\n\n  get protocol () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#protocol\n  }\n\n  get onopen () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.open\n  }\n\n  set onopen (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.open) {\n      this.removeEventListener('open', this.#events.open)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.open = fn\n      this.addEventListener('open', fn)\n    } else {\n      this.#events.open = null\n    }\n  }\n\n  get onerror () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.error\n  }\n\n  set onerror (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.error) {\n      this.removeEventListener('error', this.#events.error)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.error = fn\n      this.addEventListener('error', fn)\n    } else {\n      this.#events.error = null\n    }\n  }\n\n  get onclose () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.close\n  }\n\n  set onclose (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.close) {\n      this.removeEventListener('close', this.#events.close)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.close = fn\n      this.addEventListener('close', fn)\n    } else {\n      this.#events.close = null\n    }\n  }\n\n  get onmessage () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.message\n  }\n\n  set onmessage (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.message) {\n      this.removeEventListener('message', this.#events.message)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.message = fn\n      this.addEventListener('message', fn)\n    } else {\n      this.#events.message = null\n    }\n  }\n\n  get binaryType () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this[kBinaryType]\n  }\n\n  set binaryType (type) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (type !== 'blob' && type !== 'arraybuffer') {\n      this[kBinaryType] = 'blob'\n    } else {\n      this[kBinaryType] = type\n    }\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n   */\n  #onConnectionEstablished (response) {\n    // processResponse is called when the \"response’s header list has been received and initialized.\"\n    // once this happens, the connection is open\n    this[kResponse] = response\n\n    const parser = new ByteParser(this)\n    parser.on('drain', function onParserDrain () {\n      this.ws[kResponse].socket.resume()\n    })\n\n    response.socket.ws = this\n    this[kByteParser] = parser\n\n    // 1. Change the ready state to OPEN (1).\n    this[kReadyState] = states.OPEN\n\n    // 2. Change the extensions attribute’s value to the extensions in use, if\n    //    it is not the null value.\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\n    const extensions = response.headersList.get('sec-websocket-extensions')\n\n    if (extensions !== null) {\n      this.#extensions = extensions\n    }\n\n    // 3. Change the protocol attribute’s value to the subprotocol in use, if\n    //    it is not the null value.\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-1.9\n    const protocol = response.headersList.get('sec-websocket-protocol')\n\n    if (protocol !== null) {\n      this.#protocol = protocol\n    }\n\n    // 4. Fire an event named open at the WebSocket object.\n    fireEvent('open', this)\n  }\n}\n\n// https://websockets.spec.whatwg.org/#dom-websocket-connecting\nWebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING\n// https://websockets.spec.whatwg.org/#dom-websocket-open\nWebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN\n// https://websockets.spec.whatwg.org/#dom-websocket-closing\nWebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING\n// https://websockets.spec.whatwg.org/#dom-websocket-closed\nWebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED\n\nObject.defineProperties(WebSocket.prototype, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors,\n  url: kEnumerableProperty,\n  readyState: kEnumerableProperty,\n  bufferedAmount: kEnumerableProperty,\n  onopen: kEnumerableProperty,\n  onerror: kEnumerableProperty,\n  onclose: kEnumerableProperty,\n  close: kEnumerableProperty,\n  onmessage: kEnumerableProperty,\n  binaryType: kEnumerableProperty,\n  send: kEnumerableProperty,\n  extensions: kEnumerableProperty,\n  protocol: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'WebSocket',\n    writable: false,\n    enumerable: false,\n    configurable: true\n  }\n})\n\nObject.defineProperties(WebSocket, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors\n})\n\nwebidl.converters['sequence<DOMString>'] = webidl.sequenceConverter(\n  webidl.converters.DOMString\n)\n\nwebidl.converters['DOMString or sequence<DOMString>'] = function (V) {\n  if (webidl.util.Type(V) === 'Object' && Symbol.iterator in V) {\n    return webidl.converters['sequence<DOMString>'](V)\n  }\n\n  return webidl.converters.DOMString(V)\n}\n\n// This implements the propsal made in https://github.com/whatwg/websockets/issues/42\nwebidl.converters.WebSocketInit = webidl.dictionaryConverter([\n  {\n    key: 'protocols',\n    converter: webidl.converters['DOMString or sequence<DOMString>'],\n    get defaultValue () {\n      return []\n    }\n  },\n  {\n    key: 'dispatcher',\n    converter: (V) => V,\n    get defaultValue () {\n      return getGlobalDispatcher()\n    }\n  },\n  {\n    key: 'headers',\n    converter: webidl.nullableConverter(webidl.converters.HeadersInit)\n  }\n])\n\nwebidl.converters['DOMString or sequence<DOMString> or WebSocketInit'] = function (V) {\n  if (webidl.util.Type(V) === 'Object' && !(Symbol.iterator in V)) {\n    return webidl.converters.WebSocketInit(V)\n  }\n\n  return { protocols: webidl.converters['DOMString or sequence<DOMString>'](V) }\n}\n\nwebidl.converters.WebSocketSendData = function (V) {\n  if (webidl.util.Type(V) === 'Object') {\n    if (isBlobLike(V)) {\n      return webidl.converters.Blob(V, { strict: false })\n    }\n\n    if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {\n      return webidl.converters.BufferSource(V)\n    }\n  }\n\n  return webidl.converters.USVString(V)\n}\n\nmodule.exports = {\n  WebSocket\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}