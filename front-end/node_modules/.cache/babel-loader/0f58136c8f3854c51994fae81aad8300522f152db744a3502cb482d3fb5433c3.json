{"ast":null,"code":"'use strict';\n\nconst {\n  types\n} = require('util');\nconst {\n  hasOwn,\n  toUSVString\n} = require('./util');\n\n/** @type {import('../../types/webidl').Webidl} */\nconst webidl = {};\nwebidl.converters = {};\nwebidl.util = {};\nwebidl.errors = {};\nwebidl.errors.exception = function (message) {\n  return new TypeError(`${message.header}: ${message.message}`);\n};\nwebidl.errors.conversionFailed = function (context) {\n  const plural = context.types.length === 1 ? '' : ' one of';\n  const message = `${context.argument} could not be converted to` + `${plural}: ${context.types.join(', ')}.`;\n  return webidl.errors.exception({\n    header: context.prefix,\n    message\n  });\n};\nwebidl.errors.invalidArgument = function (context) {\n  return webidl.errors.exception({\n    header: context.prefix,\n    message: `\"${context.value}\" is an invalid ${context.type}.`\n  });\n};\n\n// https://webidl.spec.whatwg.org/#implements\nwebidl.brandCheck = function (V, I, opts = undefined) {\n  if (opts?.strict !== false && !(V instanceof I)) {\n    throw new TypeError('Illegal invocation');\n  } else {\n    return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag];\n  }\n};\nwebidl.argumentLengthCheck = function ({\n  length\n}, min, ctx) {\n  if (length < min) {\n    throw webidl.errors.exception({\n      message: `${min} argument${min !== 1 ? 's' : ''} required, ` + `but${length ? ' only' : ''} ${length} found.`,\n      ...ctx\n    });\n  }\n};\nwebidl.illegalConstructor = function () {\n  throw webidl.errors.exception({\n    header: 'TypeError',\n    message: 'Illegal constructor'\n  });\n};\n\n// https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values\nwebidl.util.Type = function (V) {\n  switch (typeof V) {\n    case 'undefined':\n      return 'Undefined';\n    case 'boolean':\n      return 'Boolean';\n    case 'string':\n      return 'String';\n    case 'symbol':\n      return 'Symbol';\n    case 'number':\n      return 'Number';\n    case 'bigint':\n      return 'BigInt';\n    case 'function':\n    case 'object':\n      {\n        if (V === null) {\n          return 'Null';\n        }\n        return 'Object';\n      }\n  }\n};\n\n// https://webidl.spec.whatwg.org/#abstract-opdef-converttoint\nwebidl.util.ConvertToInt = function (V, bitLength, signedness, opts = {}) {\n  let upperBound;\n  let lowerBound;\n\n  // 1. If bitLength is 64, then:\n  if (bitLength === 64) {\n    // 1. Let upperBound be 2^53 − 1.\n    upperBound = Math.pow(2, 53) - 1;\n\n    // 2. If signedness is \"unsigned\", then let lowerBound be 0.\n    if (signedness === 'unsigned') {\n      lowerBound = 0;\n    } else {\n      // 3. Otherwise let lowerBound be −2^53 + 1.\n      lowerBound = Math.pow(-2, 53) + 1;\n    }\n  } else if (signedness === 'unsigned') {\n    // 2. Otherwise, if signedness is \"unsigned\", then:\n\n    // 1. Let lowerBound be 0.\n    lowerBound = 0;\n\n    // 2. Let upperBound be 2^bitLength − 1.\n    upperBound = Math.pow(2, bitLength) - 1;\n  } else {\n    // 3. Otherwise:\n\n    // 1. Let lowerBound be -2^bitLength − 1.\n    lowerBound = Math.pow(-2, bitLength) - 1;\n\n    // 2. Let upperBound be 2^bitLength − 1 − 1.\n    upperBound = Math.pow(2, bitLength - 1) - 1;\n  }\n\n  // 4. Let x be ? ToNumber(V).\n  let x = Number(V);\n\n  // 5. If x is −0, then set x to +0.\n  if (x === 0) {\n    x = 0;\n  }\n\n  // 6. If the conversion is to an IDL type associated\n  //    with the [EnforceRange] extended attribute, then:\n  if (opts.enforceRange === true) {\n    // 1. If x is NaN, +∞, or −∞, then throw a TypeError.\n    if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {\n      throw webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Could not convert ${V} to an integer.`\n      });\n    }\n\n    // 2. Set x to IntegerPart(x).\n    x = webidl.util.IntegerPart(x);\n\n    // 3. If x < lowerBound or x > upperBound, then\n    //    throw a TypeError.\n    if (x < lowerBound || x > upperBound) {\n      throw webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`\n      });\n    }\n\n    // 4. Return x.\n    return x;\n  }\n\n  // 7. If x is not NaN and the conversion is to an IDL\n  //    type associated with the [Clamp] extended\n  //    attribute, then:\n  if (!Number.isNaN(x) && opts.clamp === true) {\n    // 1. Set x to min(max(x, lowerBound), upperBound).\n    x = Math.min(Math.max(x, lowerBound), upperBound);\n\n    // 2. Round x to the nearest integer, choosing the\n    //    even integer if it lies halfway between two,\n    //    and choosing +0 rather than −0.\n    if (Math.floor(x) % 2 === 0) {\n      x = Math.floor(x);\n    } else {\n      x = Math.ceil(x);\n    }\n\n    // 3. Return x.\n    return x;\n  }\n\n  // 8. If x is NaN, +0, +∞, or −∞, then return +0.\n  if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {\n    return 0;\n  }\n\n  // 9. Set x to IntegerPart(x).\n  x = webidl.util.IntegerPart(x);\n\n  // 10. Set x to x modulo 2^bitLength.\n  x = x % Math.pow(2, bitLength);\n\n  // 11. If signedness is \"signed\" and x ≥ 2^bitLength − 1,\n  //    then return x − 2^bitLength.\n  if (signedness === 'signed' && x >= Math.pow(2, bitLength) - 1) {\n    return x - Math.pow(2, bitLength);\n  }\n\n  // 12. Otherwise, return x.\n  return x;\n};\n\n// https://webidl.spec.whatwg.org/#abstract-opdef-integerpart\nwebidl.util.IntegerPart = function (n) {\n  // 1. Let r be floor(abs(n)).\n  const r = Math.floor(Math.abs(n));\n\n  // 2. If n < 0, then return -1 × r.\n  if (n < 0) {\n    return -1 * r;\n  }\n\n  // 3. Otherwise, return r.\n  return r;\n};\n\n// https://webidl.spec.whatwg.org/#es-sequence\nwebidl.sequenceConverter = function (converter) {\n  return V => {\n    // 1. If Type(V) is not Object, throw a TypeError.\n    if (webidl.util.Type(V) !== 'Object') {\n      throw webidl.errors.exception({\n        header: 'Sequence',\n        message: `Value of type ${webidl.util.Type(V)} is not an Object.`\n      });\n    }\n\n    // 2. Let method be ? GetMethod(V, @@iterator).\n    /** @type {Generator} */\n    const method = V?.[Symbol.iterator]?.();\n    const seq = [];\n\n    // 3. If method is undefined, throw a TypeError.\n    if (method === undefined || typeof method.next !== 'function') {\n      throw webidl.errors.exception({\n        header: 'Sequence',\n        message: 'Object is not an iterator.'\n      });\n    }\n\n    // https://webidl.spec.whatwg.org/#create-sequence-from-iterable\n    while (true) {\n      const {\n        done,\n        value\n      } = method.next();\n      if (done) {\n        break;\n      }\n      seq.push(converter(value));\n    }\n    return seq;\n  };\n};\n\n// https://webidl.spec.whatwg.org/#es-to-record\nwebidl.recordConverter = function (keyConverter, valueConverter) {\n  return O => {\n    // 1. If Type(O) is not Object, throw a TypeError.\n    if (webidl.util.Type(O) !== 'Object') {\n      throw webidl.errors.exception({\n        header: 'Record',\n        message: `Value of type ${webidl.util.Type(O)} is not an Object.`\n      });\n    }\n\n    // 2. Let result be a new empty instance of record<K, V>.\n    const result = {};\n    if (!types.isProxy(O)) {\n      // Object.keys only returns enumerable properties\n      const keys = Object.keys(O);\n      for (const key of keys) {\n        // 1. Let typedKey be key converted to an IDL value of type K.\n        const typedKey = keyConverter(key);\n\n        // 2. Let value be ? Get(O, key).\n        // 3. Let typedValue be value converted to an IDL value of type V.\n        const typedValue = valueConverter(O[key]);\n\n        // 4. Set result[typedKey] to typedValue.\n        result[typedKey] = typedValue;\n      }\n\n      // 5. Return result.\n      return result;\n    }\n\n    // 3. Let keys be ? O.[[OwnPropertyKeys]]().\n    const keys = Reflect.ownKeys(O);\n\n    // 4. For each key of keys.\n    for (const key of keys) {\n      // 1. Let desc be ? O.[[GetOwnProperty]](key).\n      const desc = Reflect.getOwnPropertyDescriptor(O, key);\n\n      // 2. If desc is not undefined and desc.[[Enumerable]] is true:\n      if (desc?.enumerable) {\n        // 1. Let typedKey be key converted to an IDL value of type K.\n        const typedKey = keyConverter(key);\n\n        // 2. Let value be ? Get(O, key).\n        // 3. Let typedValue be value converted to an IDL value of type V.\n        const typedValue = valueConverter(O[key]);\n\n        // 4. Set result[typedKey] to typedValue.\n        result[typedKey] = typedValue;\n      }\n    }\n\n    // 5. Return result.\n    return result;\n  };\n};\nwebidl.interfaceConverter = function (i) {\n  return (V, opts = {}) => {\n    if (opts.strict !== false && !(V instanceof i)) {\n      throw webidl.errors.exception({\n        header: i.name,\n        message: `Expected ${V} to be an instance of ${i.name}.`\n      });\n    }\n    return V;\n  };\n};\nwebidl.dictionaryConverter = function (converters) {\n  return dictionary => {\n    const type = webidl.util.Type(dictionary);\n    const dict = {};\n    if (type === 'Null' || type === 'Undefined') {\n      return dict;\n    } else if (type !== 'Object') {\n      throw webidl.errors.exception({\n        header: 'Dictionary',\n        message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`\n      });\n    }\n    for (const options of converters) {\n      const {\n        key,\n        defaultValue,\n        required,\n        converter\n      } = options;\n      if (required === true) {\n        if (!hasOwn(dictionary, key)) {\n          throw webidl.errors.exception({\n            header: 'Dictionary',\n            message: `Missing required key \"${key}\".`\n          });\n        }\n      }\n      let value = dictionary[key];\n      const hasDefault = hasOwn(options, 'defaultValue');\n\n      // Only use defaultValue if value is undefined and\n      // a defaultValue options was provided.\n      if (hasDefault && value !== null) {\n        value = value ?? defaultValue;\n      }\n\n      // A key can be optional and have no default value.\n      // When this happens, do not perform a conversion,\n      // and do not assign the key a value.\n      if (required || hasDefault || value !== undefined) {\n        value = converter(value);\n        if (options.allowedValues && !options.allowedValues.includes(value)) {\n          throw webidl.errors.exception({\n            header: 'Dictionary',\n            message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(', ')}.`\n          });\n        }\n        dict[key] = value;\n      }\n    }\n    return dict;\n  };\n};\nwebidl.nullableConverter = function (converter) {\n  return V => {\n    if (V === null) {\n      return V;\n    }\n    return converter(V);\n  };\n};\n\n// https://webidl.spec.whatwg.org/#es-DOMString\nwebidl.converters.DOMString = function (V, opts = {}) {\n  // 1. If V is null and the conversion is to an IDL type\n  //    associated with the [LegacyNullToEmptyString]\n  //    extended attribute, then return the DOMString value\n  //    that represents the empty string.\n  if (V === null && opts.legacyNullToEmptyString) {\n    return '';\n  }\n\n  // 2. Let x be ? ToString(V).\n  if (typeof V === 'symbol') {\n    throw new TypeError('Could not convert argument of type symbol to string.');\n  }\n\n  // 3. Return the IDL DOMString value that represents the\n  //    same sequence of code units as the one the\n  //    ECMAScript String value x represents.\n  return String(V);\n};\n\n// https://webidl.spec.whatwg.org/#es-ByteString\nwebidl.converters.ByteString = function (V) {\n  // 1. Let x be ? ToString(V).\n  // Note: DOMString converter perform ? ToString(V)\n  const x = webidl.converters.DOMString(V);\n\n  // 2. If the value of any element of x is greater than\n  //    255, then throw a TypeError.\n  for (let index = 0; index < x.length; index++) {\n    if (x.charCodeAt(index) > 255) {\n      throw new TypeError('Cannot convert argument to a ByteString because the character at ' + `index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`);\n    }\n  }\n\n  // 3. Return an IDL ByteString value whose length is the\n  //    length of x, and where the value of each element is\n  //    the value of the corresponding element of x.\n  return x;\n};\n\n// https://webidl.spec.whatwg.org/#es-USVString\nwebidl.converters.USVString = toUSVString;\n\n// https://webidl.spec.whatwg.org/#es-boolean\nwebidl.converters.boolean = function (V) {\n  // 1. Let x be the result of computing ToBoolean(V).\n  const x = Boolean(V);\n\n  // 2. Return the IDL boolean value that is the one that represents\n  //    the same truth value as the ECMAScript Boolean value x.\n  return x;\n};\n\n// https://webidl.spec.whatwg.org/#es-any\nwebidl.converters.any = function (V) {\n  return V;\n};\n\n// https://webidl.spec.whatwg.org/#es-long-long\nwebidl.converters['long long'] = function (V) {\n  // 1. Let x be ? ConvertToInt(V, 64, \"signed\").\n  const x = webidl.util.ConvertToInt(V, 64, 'signed');\n\n  // 2. Return the IDL long long value that represents\n  //    the same numeric value as x.\n  return x;\n};\n\n// https://webidl.spec.whatwg.org/#es-unsigned-long-long\nwebidl.converters['unsigned long long'] = function (V) {\n  // 1. Let x be ? ConvertToInt(V, 64, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 64, 'unsigned');\n\n  // 2. Return the IDL unsigned long long value that\n  //    represents the same numeric value as x.\n  return x;\n};\n\n// https://webidl.spec.whatwg.org/#es-unsigned-long\nwebidl.converters['unsigned long'] = function (V) {\n  // 1. Let x be ? ConvertToInt(V, 32, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 32, 'unsigned');\n\n  // 2. Return the IDL unsigned long value that\n  //    represents the same numeric value as x.\n  return x;\n};\n\n// https://webidl.spec.whatwg.org/#es-unsigned-short\nwebidl.converters['unsigned short'] = function (V, opts) {\n  // 1. Let x be ? ConvertToInt(V, 16, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 16, 'unsigned', opts);\n\n  // 2. Return the IDL unsigned short value that represents\n  //    the same numeric value as x.\n  return x;\n};\n\n// https://webidl.spec.whatwg.org/#idl-ArrayBuffer\nwebidl.converters.ArrayBuffer = function (V, opts = {}) {\n  // 1. If Type(V) is not Object, or V does not have an\n  //    [[ArrayBufferData]] internal slot, then throw a\n  //    TypeError.\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-arraybuffer-instances\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-sharedarraybuffer-instances\n  if (webidl.util.Type(V) !== 'Object' || !types.isAnyArrayBuffer(V)) {\n    throw webidl.errors.conversionFailed({\n      prefix: `${V}`,\n      argument: `${V}`,\n      types: ['ArrayBuffer']\n    });\n  }\n\n  // 2. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    });\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  // Note: resizable ArrayBuffers are currently a proposal.\n\n  // 4. Return the IDL ArrayBuffer value that is a\n  //    reference to the same object as V.\n  return V;\n};\nwebidl.converters.TypedArray = function (V, T, opts = {}) {\n  // 1. Let T be the IDL type V is being converted to.\n\n  // 2. If Type(V) is not Object, or V does not have a\n  //    [[TypedArrayName]] internal slot with a value\n  //    equal to T’s name, then throw a TypeError.\n  if (webidl.util.Type(V) !== 'Object' || !types.isTypedArray(V) || V.constructor.name !== T.name) {\n    throw webidl.errors.conversionFailed({\n      prefix: `${T.name}`,\n      argument: `${V}`,\n      types: [T.name]\n    });\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    });\n  }\n\n  // 4. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  // Note: resizable array buffers are currently a proposal\n\n  // 5. Return the IDL value of type T that is a reference\n  //    to the same object as V.\n  return V;\n};\nwebidl.converters.DataView = function (V, opts = {}) {\n  // 1. If Type(V) is not Object, or V does not have a\n  //    [[DataView]] internal slot, then throw a TypeError.\n  if (webidl.util.Type(V) !== 'Object' || !types.isDataView(V)) {\n    throw webidl.errors.exception({\n      header: 'DataView',\n      message: 'Object is not a DataView.'\n    });\n  }\n\n  // 2. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true,\n  //    then throw a TypeError.\n  if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    });\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  // Note: resizable ArrayBuffers are currently a proposal\n\n  // 4. Return the IDL DataView value that is a reference\n  //    to the same object as V.\n  return V;\n};\n\n// https://webidl.spec.whatwg.org/#BufferSource\nwebidl.converters.BufferSource = function (V, opts = {}) {\n  if (types.isAnyArrayBuffer(V)) {\n    return webidl.converters.ArrayBuffer(V, opts);\n  }\n  if (types.isTypedArray(V)) {\n    return webidl.converters.TypedArray(V, V.constructor);\n  }\n  if (types.isDataView(V)) {\n    return webidl.converters.DataView(V, opts);\n  }\n  throw new TypeError(`Could not convert ${V} to a BufferSource.`);\n};\nwebidl.converters['sequence<ByteString>'] = webidl.sequenceConverter(webidl.converters.ByteString);\nwebidl.converters['sequence<sequence<ByteString>>'] = webidl.sequenceConverter(webidl.converters['sequence<ByteString>']);\nwebidl.converters['record<ByteString, ByteString>'] = webidl.recordConverter(webidl.converters.ByteString, webidl.converters.ByteString);\nmodule.exports = {\n  webidl\n};","map":{"version":3,"names":["types","require","hasOwn","toUSVString","webidl","converters","util","errors","exception","message","TypeError","header","conversionFailed","context","plural","length","argument","join","prefix","invalidArgument","value","type","brandCheck","V","I","opts","undefined","strict","Symbol","toStringTag","prototype","argumentLengthCheck","min","ctx","illegalConstructor","Type","ConvertToInt","bitLength","signedness","upperBound","lowerBound","Math","pow","x","Number","enforceRange","isNaN","POSITIVE_INFINITY","NEGATIVE_INFINITY","IntegerPart","clamp","max","floor","ceil","Object","is","n","r","abs","sequenceConverter","converter","method","iterator","seq","next","done","push","recordConverter","keyConverter","valueConverter","O","result","isProxy","keys","key","typedKey","typedValue","Reflect","ownKeys","desc","getOwnPropertyDescriptor","enumerable","interfaceConverter","i","name","dictionaryConverter","dictionary","dict","options","defaultValue","required","hasDefault","allowedValues","includes","nullableConverter","DOMString","legacyNullToEmptyString","String","ByteString","index","charCodeAt","USVString","boolean","Boolean","any","ArrayBuffer","isAnyArrayBuffer","allowShared","isSharedArrayBuffer","TypedArray","T","isTypedArray","constructor","buffer","DataView","isDataView","BufferSource","module","exports"],"sources":["C:/Users/rares/Desktop/Blockchain/Proiect/node_modules/undici/lib/fetch/webidl.js"],"sourcesContent":["'use strict'\n\nconst { types } = require('util')\nconst { hasOwn, toUSVString } = require('./util')\n\n/** @type {import('../../types/webidl').Webidl} */\nconst webidl = {}\nwebidl.converters = {}\nwebidl.util = {}\nwebidl.errors = {}\n\nwebidl.errors.exception = function (message) {\n  return new TypeError(`${message.header}: ${message.message}`)\n}\n\nwebidl.errors.conversionFailed = function (context) {\n  const plural = context.types.length === 1 ? '' : ' one of'\n  const message =\n    `${context.argument} could not be converted to` +\n    `${plural}: ${context.types.join(', ')}.`\n\n  return webidl.errors.exception({\n    header: context.prefix,\n    message\n  })\n}\n\nwebidl.errors.invalidArgument = function (context) {\n  return webidl.errors.exception({\n    header: context.prefix,\n    message: `\"${context.value}\" is an invalid ${context.type}.`\n  })\n}\n\n// https://webidl.spec.whatwg.org/#implements\nwebidl.brandCheck = function (V, I, opts = undefined) {\n  if (opts?.strict !== false && !(V instanceof I)) {\n    throw new TypeError('Illegal invocation')\n  } else {\n    return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag]\n  }\n}\n\nwebidl.argumentLengthCheck = function ({ length }, min, ctx) {\n  if (length < min) {\n    throw webidl.errors.exception({\n      message: `${min} argument${min !== 1 ? 's' : ''} required, ` +\n               `but${length ? ' only' : ''} ${length} found.`,\n      ...ctx\n    })\n  }\n}\n\nwebidl.illegalConstructor = function () {\n  throw webidl.errors.exception({\n    header: 'TypeError',\n    message: 'Illegal constructor'\n  })\n}\n\n// https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values\nwebidl.util.Type = function (V) {\n  switch (typeof V) {\n    case 'undefined': return 'Undefined'\n    case 'boolean': return 'Boolean'\n    case 'string': return 'String'\n    case 'symbol': return 'Symbol'\n    case 'number': return 'Number'\n    case 'bigint': return 'BigInt'\n    case 'function':\n    case 'object': {\n      if (V === null) {\n        return 'Null'\n      }\n\n      return 'Object'\n    }\n  }\n}\n\n// https://webidl.spec.whatwg.org/#abstract-opdef-converttoint\nwebidl.util.ConvertToInt = function (V, bitLength, signedness, opts = {}) {\n  let upperBound\n  let lowerBound\n\n  // 1. If bitLength is 64, then:\n  if (bitLength === 64) {\n    // 1. Let upperBound be 2^53 − 1.\n    upperBound = Math.pow(2, 53) - 1\n\n    // 2. If signedness is \"unsigned\", then let lowerBound be 0.\n    if (signedness === 'unsigned') {\n      lowerBound = 0\n    } else {\n      // 3. Otherwise let lowerBound be −2^53 + 1.\n      lowerBound = Math.pow(-2, 53) + 1\n    }\n  } else if (signedness === 'unsigned') {\n    // 2. Otherwise, if signedness is \"unsigned\", then:\n\n    // 1. Let lowerBound be 0.\n    lowerBound = 0\n\n    // 2. Let upperBound be 2^bitLength − 1.\n    upperBound = Math.pow(2, bitLength) - 1\n  } else {\n    // 3. Otherwise:\n\n    // 1. Let lowerBound be -2^bitLength − 1.\n    lowerBound = Math.pow(-2, bitLength) - 1\n\n    // 2. Let upperBound be 2^bitLength − 1 − 1.\n    upperBound = Math.pow(2, bitLength - 1) - 1\n  }\n\n  // 4. Let x be ? ToNumber(V).\n  let x = Number(V)\n\n  // 5. If x is −0, then set x to +0.\n  if (x === 0) {\n    x = 0\n  }\n\n  // 6. If the conversion is to an IDL type associated\n  //    with the [EnforceRange] extended attribute, then:\n  if (opts.enforceRange === true) {\n    // 1. If x is NaN, +∞, or −∞, then throw a TypeError.\n    if (\n      Number.isNaN(x) ||\n      x === Number.POSITIVE_INFINITY ||\n      x === Number.NEGATIVE_INFINITY\n    ) {\n      throw webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Could not convert ${V} to an integer.`\n      })\n    }\n\n    // 2. Set x to IntegerPart(x).\n    x = webidl.util.IntegerPart(x)\n\n    // 3. If x < lowerBound or x > upperBound, then\n    //    throw a TypeError.\n    if (x < lowerBound || x > upperBound) {\n      throw webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`\n      })\n    }\n\n    // 4. Return x.\n    return x\n  }\n\n  // 7. If x is not NaN and the conversion is to an IDL\n  //    type associated with the [Clamp] extended\n  //    attribute, then:\n  if (!Number.isNaN(x) && opts.clamp === true) {\n    // 1. Set x to min(max(x, lowerBound), upperBound).\n    x = Math.min(Math.max(x, lowerBound), upperBound)\n\n    // 2. Round x to the nearest integer, choosing the\n    //    even integer if it lies halfway between two,\n    //    and choosing +0 rather than −0.\n    if (Math.floor(x) % 2 === 0) {\n      x = Math.floor(x)\n    } else {\n      x = Math.ceil(x)\n    }\n\n    // 3. Return x.\n    return x\n  }\n\n  // 8. If x is NaN, +0, +∞, or −∞, then return +0.\n  if (\n    Number.isNaN(x) ||\n    (x === 0 && Object.is(0, x)) ||\n    x === Number.POSITIVE_INFINITY ||\n    x === Number.NEGATIVE_INFINITY\n  ) {\n    return 0\n  }\n\n  // 9. Set x to IntegerPart(x).\n  x = webidl.util.IntegerPart(x)\n\n  // 10. Set x to x modulo 2^bitLength.\n  x = x % Math.pow(2, bitLength)\n\n  // 11. If signedness is \"signed\" and x ≥ 2^bitLength − 1,\n  //    then return x − 2^bitLength.\n  if (signedness === 'signed' && x >= Math.pow(2, bitLength) - 1) {\n    return x - Math.pow(2, bitLength)\n  }\n\n  // 12. Otherwise, return x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#abstract-opdef-integerpart\nwebidl.util.IntegerPart = function (n) {\n  // 1. Let r be floor(abs(n)).\n  const r = Math.floor(Math.abs(n))\n\n  // 2. If n < 0, then return -1 × r.\n  if (n < 0) {\n    return -1 * r\n  }\n\n  // 3. Otherwise, return r.\n  return r\n}\n\n// https://webidl.spec.whatwg.org/#es-sequence\nwebidl.sequenceConverter = function (converter) {\n  return (V) => {\n    // 1. If Type(V) is not Object, throw a TypeError.\n    if (webidl.util.Type(V) !== 'Object') {\n      throw webidl.errors.exception({\n        header: 'Sequence',\n        message: `Value of type ${webidl.util.Type(V)} is not an Object.`\n      })\n    }\n\n    // 2. Let method be ? GetMethod(V, @@iterator).\n    /** @type {Generator} */\n    const method = V?.[Symbol.iterator]?.()\n    const seq = []\n\n    // 3. If method is undefined, throw a TypeError.\n    if (\n      method === undefined ||\n      typeof method.next !== 'function'\n    ) {\n      throw webidl.errors.exception({\n        header: 'Sequence',\n        message: 'Object is not an iterator.'\n      })\n    }\n\n    // https://webidl.spec.whatwg.org/#create-sequence-from-iterable\n    while (true) {\n      const { done, value } = method.next()\n\n      if (done) {\n        break\n      }\n\n      seq.push(converter(value))\n    }\n\n    return seq\n  }\n}\n\n// https://webidl.spec.whatwg.org/#es-to-record\nwebidl.recordConverter = function (keyConverter, valueConverter) {\n  return (O) => {\n    // 1. If Type(O) is not Object, throw a TypeError.\n    if (webidl.util.Type(O) !== 'Object') {\n      throw webidl.errors.exception({\n        header: 'Record',\n        message: `Value of type ${webidl.util.Type(O)} is not an Object.`\n      })\n    }\n\n    // 2. Let result be a new empty instance of record<K, V>.\n    const result = {}\n\n    if (!types.isProxy(O)) {\n      // Object.keys only returns enumerable properties\n      const keys = Object.keys(O)\n\n      for (const key of keys) {\n        // 1. Let typedKey be key converted to an IDL value of type K.\n        const typedKey = keyConverter(key)\n\n        // 2. Let value be ? Get(O, key).\n        // 3. Let typedValue be value converted to an IDL value of type V.\n        const typedValue = valueConverter(O[key])\n\n        // 4. Set result[typedKey] to typedValue.\n        result[typedKey] = typedValue\n      }\n\n      // 5. Return result.\n      return result\n    }\n\n    // 3. Let keys be ? O.[[OwnPropertyKeys]]().\n    const keys = Reflect.ownKeys(O)\n\n    // 4. For each key of keys.\n    for (const key of keys) {\n      // 1. Let desc be ? O.[[GetOwnProperty]](key).\n      const desc = Reflect.getOwnPropertyDescriptor(O, key)\n\n      // 2. If desc is not undefined and desc.[[Enumerable]] is true:\n      if (desc?.enumerable) {\n        // 1. Let typedKey be key converted to an IDL value of type K.\n        const typedKey = keyConverter(key)\n\n        // 2. Let value be ? Get(O, key).\n        // 3. Let typedValue be value converted to an IDL value of type V.\n        const typedValue = valueConverter(O[key])\n\n        // 4. Set result[typedKey] to typedValue.\n        result[typedKey] = typedValue\n      }\n    }\n\n    // 5. Return result.\n    return result\n  }\n}\n\nwebidl.interfaceConverter = function (i) {\n  return (V, opts = {}) => {\n    if (opts.strict !== false && !(V instanceof i)) {\n      throw webidl.errors.exception({\n        header: i.name,\n        message: `Expected ${V} to be an instance of ${i.name}.`\n      })\n    }\n\n    return V\n  }\n}\n\nwebidl.dictionaryConverter = function (converters) {\n  return (dictionary) => {\n    const type = webidl.util.Type(dictionary)\n    const dict = {}\n\n    if (type === 'Null' || type === 'Undefined') {\n      return dict\n    } else if (type !== 'Object') {\n      throw webidl.errors.exception({\n        header: 'Dictionary',\n        message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`\n      })\n    }\n\n    for (const options of converters) {\n      const { key, defaultValue, required, converter } = options\n\n      if (required === true) {\n        if (!hasOwn(dictionary, key)) {\n          throw webidl.errors.exception({\n            header: 'Dictionary',\n            message: `Missing required key \"${key}\".`\n          })\n        }\n      }\n\n      let value = dictionary[key]\n      const hasDefault = hasOwn(options, 'defaultValue')\n\n      // Only use defaultValue if value is undefined and\n      // a defaultValue options was provided.\n      if (hasDefault && value !== null) {\n        value = value ?? defaultValue\n      }\n\n      // A key can be optional and have no default value.\n      // When this happens, do not perform a conversion,\n      // and do not assign the key a value.\n      if (required || hasDefault || value !== undefined) {\n        value = converter(value)\n\n        if (\n          options.allowedValues &&\n          !options.allowedValues.includes(value)\n        ) {\n          throw webidl.errors.exception({\n            header: 'Dictionary',\n            message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(', ')}.`\n          })\n        }\n\n        dict[key] = value\n      }\n    }\n\n    return dict\n  }\n}\n\nwebidl.nullableConverter = function (converter) {\n  return (V) => {\n    if (V === null) {\n      return V\n    }\n\n    return converter(V)\n  }\n}\n\n// https://webidl.spec.whatwg.org/#es-DOMString\nwebidl.converters.DOMString = function (V, opts = {}) {\n  // 1. If V is null and the conversion is to an IDL type\n  //    associated with the [LegacyNullToEmptyString]\n  //    extended attribute, then return the DOMString value\n  //    that represents the empty string.\n  if (V === null && opts.legacyNullToEmptyString) {\n    return ''\n  }\n\n  // 2. Let x be ? ToString(V).\n  if (typeof V === 'symbol') {\n    throw new TypeError('Could not convert argument of type symbol to string.')\n  }\n\n  // 3. Return the IDL DOMString value that represents the\n  //    same sequence of code units as the one the\n  //    ECMAScript String value x represents.\n  return String(V)\n}\n\n// https://webidl.spec.whatwg.org/#es-ByteString\nwebidl.converters.ByteString = function (V) {\n  // 1. Let x be ? ToString(V).\n  // Note: DOMString converter perform ? ToString(V)\n  const x = webidl.converters.DOMString(V)\n\n  // 2. If the value of any element of x is greater than\n  //    255, then throw a TypeError.\n  for (let index = 0; index < x.length; index++) {\n    if (x.charCodeAt(index) > 255) {\n      throw new TypeError(\n        'Cannot convert argument to a ByteString because the character at ' +\n        `index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`\n      )\n    }\n  }\n\n  // 3. Return an IDL ByteString value whose length is the\n  //    length of x, and where the value of each element is\n  //    the value of the corresponding element of x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-USVString\nwebidl.converters.USVString = toUSVString\n\n// https://webidl.spec.whatwg.org/#es-boolean\nwebidl.converters.boolean = function (V) {\n  // 1. Let x be the result of computing ToBoolean(V).\n  const x = Boolean(V)\n\n  // 2. Return the IDL boolean value that is the one that represents\n  //    the same truth value as the ECMAScript Boolean value x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-any\nwebidl.converters.any = function (V) {\n  return V\n}\n\n// https://webidl.spec.whatwg.org/#es-long-long\nwebidl.converters['long long'] = function (V) {\n  // 1. Let x be ? ConvertToInt(V, 64, \"signed\").\n  const x = webidl.util.ConvertToInt(V, 64, 'signed')\n\n  // 2. Return the IDL long long value that represents\n  //    the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-long-long\nwebidl.converters['unsigned long long'] = function (V) {\n  // 1. Let x be ? ConvertToInt(V, 64, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 64, 'unsigned')\n\n  // 2. Return the IDL unsigned long long value that\n  //    represents the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-long\nwebidl.converters['unsigned long'] = function (V) {\n  // 1. Let x be ? ConvertToInt(V, 32, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 32, 'unsigned')\n\n  // 2. Return the IDL unsigned long value that\n  //    represents the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-short\nwebidl.converters['unsigned short'] = function (V, opts) {\n  // 1. Let x be ? ConvertToInt(V, 16, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 16, 'unsigned', opts)\n\n  // 2. Return the IDL unsigned short value that represents\n  //    the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#idl-ArrayBuffer\nwebidl.converters.ArrayBuffer = function (V, opts = {}) {\n  // 1. If Type(V) is not Object, or V does not have an\n  //    [[ArrayBufferData]] internal slot, then throw a\n  //    TypeError.\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-arraybuffer-instances\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-sharedarraybuffer-instances\n  if (\n    webidl.util.Type(V) !== 'Object' ||\n    !types.isAnyArrayBuffer(V)\n  ) {\n    throw webidl.errors.conversionFailed({\n      prefix: `${V}`,\n      argument: `${V}`,\n      types: ['ArrayBuffer']\n    })\n  }\n\n  // 2. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  // Note: resizable ArrayBuffers are currently a proposal.\n\n  // 4. Return the IDL ArrayBuffer value that is a\n  //    reference to the same object as V.\n  return V\n}\n\nwebidl.converters.TypedArray = function (V, T, opts = {}) {\n  // 1. Let T be the IDL type V is being converted to.\n\n  // 2. If Type(V) is not Object, or V does not have a\n  //    [[TypedArrayName]] internal slot with a value\n  //    equal to T’s name, then throw a TypeError.\n  if (\n    webidl.util.Type(V) !== 'Object' ||\n    !types.isTypedArray(V) ||\n    V.constructor.name !== T.name\n  ) {\n    throw webidl.errors.conversionFailed({\n      prefix: `${T.name}`,\n      argument: `${V}`,\n      types: [T.name]\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    })\n  }\n\n  // 4. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  // Note: resizable array buffers are currently a proposal\n\n  // 5. Return the IDL value of type T that is a reference\n  //    to the same object as V.\n  return V\n}\n\nwebidl.converters.DataView = function (V, opts = {}) {\n  // 1. If Type(V) is not Object, or V does not have a\n  //    [[DataView]] internal slot, then throw a TypeError.\n  if (webidl.util.Type(V) !== 'Object' || !types.isDataView(V)) {\n    throw webidl.errors.exception({\n      header: 'DataView',\n      message: 'Object is not a DataView.'\n    })\n  }\n\n  // 2. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true,\n  //    then throw a TypeError.\n  if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  // Note: resizable ArrayBuffers are currently a proposal\n\n  // 4. Return the IDL DataView value that is a reference\n  //    to the same object as V.\n  return V\n}\n\n// https://webidl.spec.whatwg.org/#BufferSource\nwebidl.converters.BufferSource = function (V, opts = {}) {\n  if (types.isAnyArrayBuffer(V)) {\n    return webidl.converters.ArrayBuffer(V, opts)\n  }\n\n  if (types.isTypedArray(V)) {\n    return webidl.converters.TypedArray(V, V.constructor)\n  }\n\n  if (types.isDataView(V)) {\n    return webidl.converters.DataView(V, opts)\n  }\n\n  throw new TypeError(`Could not convert ${V} to a BufferSource.`)\n}\n\nwebidl.converters['sequence<ByteString>'] = webidl.sequenceConverter(\n  webidl.converters.ByteString\n)\n\nwebidl.converters['sequence<sequence<ByteString>>'] = webidl.sequenceConverter(\n  webidl.converters['sequence<ByteString>']\n)\n\nwebidl.converters['record<ByteString, ByteString>'] = webidl.recordConverter(\n  webidl.converters.ByteString,\n  webidl.converters.ByteString\n)\n\nmodule.exports = {\n  webidl\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}