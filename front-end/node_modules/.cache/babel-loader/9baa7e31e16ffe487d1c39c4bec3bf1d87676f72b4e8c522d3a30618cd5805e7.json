{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { getCurrentHub, Hub } from '@sentry/hub';\nimport { isInstanceOf, logger } from '@sentry/utils';\nimport { Span as SpanClass, SpanRecorder } from './span';\n/** JSDoc */\nvar Transaction = /** @class */function (_super) {\n  __extends(Transaction, _super);\n  /**\n   * This constructor should never be called manually. Those instrumenting tracing should use\n   * `Sentry.startTransaction()`, and internal methods should use `hub.startTransaction()`.\n   * @internal\n   * @hideconstructor\n   * @hidden\n   */\n  function Transaction(transactionContext, hub) {\n    var _this = _super.call(this, transactionContext) || this;\n    _this._measurements = {};\n    /**\n     * The reference to the current hub.\n     */\n    _this._hub = getCurrentHub();\n    if (isInstanceOf(hub, Hub)) {\n      _this._hub = hub;\n    }\n    _this.name = transactionContext.name ? transactionContext.name : '';\n    _this._trimEnd = transactionContext.trimEnd;\n    // this is because transactions are also spans, and spans have a transaction pointer\n    _this.transaction = _this;\n    return _this;\n  }\n  /**\n   * JSDoc\n   */\n  Transaction.prototype.setName = function (name) {\n    this.name = name;\n  };\n  /**\n   * Attaches SpanRecorder to the span itself\n   * @param maxlen maximum number of spans that can be recorded\n   */\n  Transaction.prototype.initSpanRecorder = function (maxlen) {\n    if (maxlen === void 0) {\n      maxlen = 1000;\n    }\n    if (!this.spanRecorder) {\n      this.spanRecorder = new SpanRecorder(maxlen);\n    }\n    this.spanRecorder.add(this);\n  };\n  /**\n   * Set observed measurements for this transaction.\n   * @hidden\n   */\n  Transaction.prototype.setMeasurements = function (measurements) {\n    this._measurements = __assign({}, measurements);\n  };\n  /**\n   * @inheritDoc\n   */\n  Transaction.prototype.finish = function (endTimestamp) {\n    var _this = this;\n    // This transaction is already finished, so we should not flush it again.\n    if (this.endTimestamp !== undefined) {\n      return undefined;\n    }\n    if (!this.name) {\n      logger.warn('Transaction has no name, falling back to `<unlabeled transaction>`.');\n      this.name = '<unlabeled transaction>';\n    }\n    // just sets the end timestamp\n    _super.prototype.finish.call(this, endTimestamp);\n    if (this.sampled !== true) {\n      // At this point if `sampled !== true` we want to discard the transaction.\n      logger.log('[Tracing] Discarding transaction because its trace was not chosen to be sampled.');\n      return undefined;\n    }\n    var finishedSpans = this.spanRecorder ? this.spanRecorder.spans.filter(function (s) {\n      return s !== _this && s.endTimestamp;\n    }) : [];\n    if (this._trimEnd && finishedSpans.length > 0) {\n      this.endTimestamp = finishedSpans.reduce(function (prev, current) {\n        if (prev.endTimestamp && current.endTimestamp) {\n          return prev.endTimestamp > current.endTimestamp ? prev : current;\n        }\n        return prev;\n      }).endTimestamp;\n    }\n    var transaction = {\n      contexts: {\n        trace: this.getTraceContext()\n      },\n      spans: finishedSpans,\n      start_timestamp: this.startTimestamp,\n      tags: this.tags,\n      timestamp: this.endTimestamp,\n      transaction: this.name,\n      type: 'transaction'\n    };\n    var hasMeasurements = Object.keys(this._measurements).length > 0;\n    if (hasMeasurements) {\n      logger.log('[Measurements] Adding measurements to transaction', JSON.stringify(this._measurements, undefined, 2));\n      transaction.measurements = this._measurements;\n    }\n    return this._hub.captureEvent(transaction);\n  };\n  return Transaction;\n}(SpanClass);\nexport { Transaction };","map":{"version":3,"names":["getCurrentHub","Hub","isInstanceOf","logger","Span","SpanClass","SpanRecorder","Transaction","_super","__extends","transactionContext","hub","_this","call","_measurements","_hub","name","_trimEnd","trimEnd","transaction","prototype","setName","initSpanRecorder","maxlen","spanRecorder","add","setMeasurements","measurements","__assign","finish","endTimestamp","undefined","warn","sampled","log","finishedSpans","spans","filter","s","length","reduce","prev","current","contexts","trace","getTraceContext","start_timestamp","startTimestamp","tags","timestamp","type","hasMeasurements","Object","keys","JSON","stringify","captureEvent"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\@sentry\\tracing\\src\\transaction.ts"],"sourcesContent":["import { getCurrentHub, Hub } from '@sentry/hub';\nimport { Event, Measurements, Transaction as TransactionInterface, TransactionContext } from '@sentry/types';\nimport { isInstanceOf, logger } from '@sentry/utils';\n\nimport { Span as SpanClass, SpanRecorder } from './span';\n\n/** JSDoc */\nexport class Transaction extends SpanClass implements TransactionInterface {\n  public name: string;\n  private _measurements: Measurements = {};\n\n  /**\n   * The reference to the current hub.\n   */\n  private readonly _hub: Hub = (getCurrentHub() as unknown) as Hub;\n\n  private readonly _trimEnd?: boolean;\n\n  /**\n   * This constructor should never be called manually. Those instrumenting tracing should use\n   * `Sentry.startTransaction()`, and internal methods should use `hub.startTransaction()`.\n   * @internal\n   * @hideconstructor\n   * @hidden\n   */\n  public constructor(transactionContext: TransactionContext, hub?: Hub) {\n    super(transactionContext);\n\n    if (isInstanceOf(hub, Hub)) {\n      this._hub = hub as Hub;\n    }\n\n    this.name = transactionContext.name ? transactionContext.name : '';\n\n    this._trimEnd = transactionContext.trimEnd;\n\n    // this is because transactions are also spans, and spans have a transaction pointer\n    this.transaction = this;\n  }\n\n  /**\n   * JSDoc\n   */\n  public setName(name: string): void {\n    this.name = name;\n  }\n\n  /**\n   * Attaches SpanRecorder to the span itself\n   * @param maxlen maximum number of spans that can be recorded\n   */\n  public initSpanRecorder(maxlen: number = 1000): void {\n    if (!this.spanRecorder) {\n      this.spanRecorder = new SpanRecorder(maxlen);\n    }\n    this.spanRecorder.add(this);\n  }\n\n  /**\n   * Set observed measurements for this transaction.\n   * @hidden\n   */\n  public setMeasurements(measurements: Measurements): void {\n    this._measurements = { ...measurements };\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public finish(endTimestamp?: number): string | undefined {\n    // This transaction is already finished, so we should not flush it again.\n    if (this.endTimestamp !== undefined) {\n      return undefined;\n    }\n\n    if (!this.name) {\n      logger.warn('Transaction has no name, falling back to `<unlabeled transaction>`.');\n      this.name = '<unlabeled transaction>';\n    }\n\n    // just sets the end timestamp\n    super.finish(endTimestamp);\n\n    if (this.sampled !== true) {\n      // At this point if `sampled !== true` we want to discard the transaction.\n      logger.log('[Tracing] Discarding transaction because its trace was not chosen to be sampled.');\n      return undefined;\n    }\n\n    const finishedSpans = this.spanRecorder ? this.spanRecorder.spans.filter(s => s !== this && s.endTimestamp) : [];\n\n    if (this._trimEnd && finishedSpans.length > 0) {\n      this.endTimestamp = finishedSpans.reduce((prev: SpanClass, current: SpanClass) => {\n        if (prev.endTimestamp && current.endTimestamp) {\n          return prev.endTimestamp > current.endTimestamp ? prev : current;\n        }\n        return prev;\n      }).endTimestamp;\n    }\n\n    const transaction: Event = {\n      contexts: {\n        trace: this.getTraceContext(),\n      },\n      spans: finishedSpans,\n      start_timestamp: this.startTimestamp,\n      tags: this.tags,\n      timestamp: this.endTimestamp,\n      transaction: this.name,\n      type: 'transaction',\n    };\n\n    const hasMeasurements = Object.keys(this._measurements).length > 0;\n\n    if (hasMeasurements) {\n      logger.log('[Measurements] Adding measurements to transaction', JSON.stringify(this._measurements, undefined, 2));\n      transaction.measurements = this._measurements;\n    }\n\n    return this._hub.captureEvent(transaction);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}