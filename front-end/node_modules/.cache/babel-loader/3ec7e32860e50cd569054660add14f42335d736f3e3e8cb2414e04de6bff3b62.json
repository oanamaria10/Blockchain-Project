{"ast":null,"code":"/* eslint-env browser */\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { decode as decodeDagCBOR } from '@ipld/dag-cbor';\nimport { decode as decodeDigest } from 'multiformats/hashes/digest';\nimport { create as createLink, createLegacy as createLegacyLink } from 'multiformats/link';\nimport { decode as decodeVarint } from './varint.js';\nconst State = {\n  ReadHeaderLength: 0,\n  ReadHeader: 1,\n  ReadBlockLength: 2,\n  ReadBlock: 3\n};\nconst CIDV0_BYTES = {\n  SHA2_256: 0x12,\n  LENGTH: 0x20,\n  DAG_PB: 0x70\n};\n\n/** @extends {TransformStream<Uint8Array, import('./api.js').Block & import('./api.js').Position>} */\nexport class CARReaderStream extends TransformStream {\n  /** @type {Promise<import('./api.js').CARHeader>} */\n  #headerPromise;\n\n  /**\n   * @param {QueuingStrategy<Uint8Array>} [writableStrategy]\n   * An object that optionally defines a queuing strategy for the stream.\n   * @param {QueuingStrategy<import('./api.js').Block & import('./api.js').Position>} [readableStrategy]\n   * An object that optionally defines a queuing strategy for the stream.\n   * Defaults to a CountQueuingStrategy with highWaterMark of `1` to allow\n   * `getHeader` to be called before the stream is consumed.\n   */\n  constructor(writableStrategy, readableStrategy) {\n    const buffer = new Uint8ArrayList();\n    let offset = 0;\n    let prevOffset = offset;\n    let wanted = 8;\n    let state = State.ReadHeaderLength;\n\n    /** @type {(value: import('./api.js').CARHeader) => void} */\n    let resolveHeader;\n    const headerPromise = new Promise(resolve => {\n      resolveHeader = resolve;\n    });\n    super({\n      transform(chunk, controller) {\n        buffer.append(chunk);\n        while (true) {\n          if (buffer.length < wanted) break;\n          if (state === State.ReadHeaderLength) {\n            const [length, bytes] = decodeVarint(buffer);\n            buffer.consume(bytes);\n            prevOffset = offset;\n            offset += bytes;\n            state = State.ReadHeader;\n            wanted = length;\n          } else if (state === State.ReadHeader) {\n            const header = decodeDagCBOR(buffer.slice(0, wanted));\n            resolveHeader && resolveHeader(header);\n            buffer.consume(wanted);\n            prevOffset = offset;\n            offset += wanted;\n            state = State.ReadBlockLength;\n            wanted = 8;\n          } else if (state === State.ReadBlockLength) {\n            const [length, bytes] = decodeVarint(buffer);\n            buffer.consume(bytes);\n            prevOffset = offset;\n            offset += bytes;\n            state = State.ReadBlock;\n            wanted = length;\n          } else if (state === State.ReadBlock) {\n            const _offset = prevOffset;\n            const length = offset - prevOffset + wanted;\n            prevOffset = offset;\n            /** @type {import('multiformats').UnknownLink} */\n            let cid;\n            if (buffer.get(0) === CIDV0_BYTES.SHA2_256 && buffer.get(1) === CIDV0_BYTES.LENGTH) {\n              const bytes = buffer.subarray(0, 34);\n              const multihash = decodeDigest(bytes);\n              // @ts-expect-error\n              cid = createLegacyLink(multihash);\n              buffer.consume(34);\n              offset += 34;\n            } else {\n              const [version, versionBytes] = decodeVarint(buffer);\n              if (version !== 1) throw new Error(`unexpected CID version (${version})`);\n              buffer.consume(versionBytes);\n              offset += versionBytes;\n              const [codec, codecBytes] = decodeVarint(buffer);\n              buffer.consume(codecBytes);\n              offset += codecBytes;\n              const multihashBytes = getMultihashLength(buffer);\n              const multihash = decodeDigest(buffer.subarray(0, multihashBytes));\n              cid = createLink(codec, multihash);\n              buffer.consume(multihashBytes);\n              offset += multihashBytes;\n            }\n            const blockBytes = wanted - (offset - prevOffset);\n            const bytes = buffer.subarray(0, blockBytes);\n            controller.enqueue({\n              cid,\n              bytes,\n              offset: _offset,\n              length,\n              blockOffset: offset,\n              blockLength: blockBytes\n            });\n            buffer.consume(blockBytes);\n            prevOffset = offset;\n            offset += blockBytes;\n            state = State.ReadBlockLength;\n            wanted = 8;\n          }\n        }\n      },\n      flush(controller) {\n        if (state !== State.ReadBlockLength) {\n          controller.error(new Error('unexpected end of data'));\n        }\n      }\n    }, writableStrategy, readableStrategy ?? new CountQueuingStrategy({\n      highWaterMark: 1\n    }));\n    this.#headerPromise = headerPromise;\n  }\n\n  /**\n   * Get the decoded CAR header.\n   */\n  getHeader() {\n    return this.#headerPromise;\n  }\n}\n\n/** @param {Uint8ArrayList} bytes */\nconst getMultihashLength = bytes => {\n  const [, codeBytes] = decodeVarint(bytes);\n  const [length, lengthBytes] = decodeVarint(bytes, codeBytes);\n  return codeBytes + lengthBytes + length;\n};","map":{"version":3,"names":["Uint8ArrayList","decode","decodeDagCBOR","decodeDigest","create","createLink","createLegacy","createLegacyLink","decodeVarint","State","ReadHeaderLength","ReadHeader","ReadBlockLength","ReadBlock","CIDV0_BYTES","SHA2_256","LENGTH","DAG_PB","CARReaderStream","TransformStream","headerPromise","constructor","writableStrategy","readableStrategy","buffer","offset","prevOffset","wanted","state","resolveHeader","Promise","resolve","transform","chunk","controller","append","length","bytes","consume","header","slice","_offset","cid","get","subarray","multihash","version","versionBytes","Error","codec","codecBytes","multihashBytes","getMultihashLength","blockBytes","enqueue","blockOffset","blockLength","flush","error","CountQueuingStrategy","highWaterMark","getHeader","codeBytes","lengthBytes"],"sources":["C:/FACULTATE/Proiect/node_modules/carstream/src/reader.js"],"sourcesContent":["/* eslint-env browser */\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { decode as decodeDagCBOR } from '@ipld/dag-cbor'\nimport { decode as decodeDigest } from 'multiformats/hashes/digest'\nimport { create as createLink, createLegacy as createLegacyLink } from 'multiformats/link'\nimport { decode as decodeVarint } from './varint.js'\n\nconst State = {\n  ReadHeaderLength: 0,\n  ReadHeader: 1,\n  ReadBlockLength: 2,\n  ReadBlock: 3\n}\n\nconst CIDV0_BYTES = {\n  SHA2_256: 0x12,\n  LENGTH: 0x20,\n  DAG_PB: 0x70\n}\n\n/** @extends {TransformStream<Uint8Array, import('./api.js').Block & import('./api.js').Position>} */\nexport class CARReaderStream extends TransformStream {\n  /** @type {Promise<import('./api.js').CARHeader>} */\n  #headerPromise\n\n  /**\n   * @param {QueuingStrategy<Uint8Array>} [writableStrategy]\n   * An object that optionally defines a queuing strategy for the stream.\n   * @param {QueuingStrategy<import('./api.js').Block & import('./api.js').Position>} [readableStrategy]\n   * An object that optionally defines a queuing strategy for the stream.\n   * Defaults to a CountQueuingStrategy with highWaterMark of `1` to allow\n   * `getHeader` to be called before the stream is consumed.\n   */\n  constructor (writableStrategy, readableStrategy) {\n    const buffer = new Uint8ArrayList()\n    let offset = 0\n    let prevOffset = offset\n    let wanted = 8\n    let state = State.ReadHeaderLength\n\n    /** @type {(value: import('./api.js').CARHeader) => void} */\n    let resolveHeader\n    const headerPromise = new Promise(resolve => { resolveHeader = resolve })\n\n    super({\n      transform (chunk, controller) {\n        buffer.append(chunk)\n        while (true) {\n          if (buffer.length < wanted) break\n          if (state === State.ReadHeaderLength) {\n            const [length, bytes] = decodeVarint(buffer)\n            buffer.consume(bytes)\n            prevOffset = offset\n            offset += bytes\n            state = State.ReadHeader\n            wanted = length\n          } else if (state === State.ReadHeader) {\n            const header = decodeDagCBOR(buffer.slice(0, wanted))\n            resolveHeader && resolveHeader(header)\n            buffer.consume(wanted)\n            prevOffset = offset\n            offset += wanted\n            state = State.ReadBlockLength\n            wanted = 8\n          } else if (state === State.ReadBlockLength) {\n            const [length, bytes] = decodeVarint(buffer)\n            buffer.consume(bytes)\n            prevOffset = offset\n            offset += bytes\n            state = State.ReadBlock\n            wanted = length\n          } else if (state === State.ReadBlock) {\n            const _offset = prevOffset\n            const length = offset - prevOffset + wanted\n\n            prevOffset = offset\n            /** @type {import('multiformats').UnknownLink} */\n            let cid\n            if (buffer.get(0) === CIDV0_BYTES.SHA2_256 && buffer.get(1) === CIDV0_BYTES.LENGTH) {\n              const bytes = buffer.subarray(0, 34)\n              const multihash = decodeDigest(bytes)\n              // @ts-expect-error\n              cid = createLegacyLink(multihash)\n              buffer.consume(34)\n              offset += 34\n            } else {\n              const [version, versionBytes] = decodeVarint(buffer)\n              if (version !== 1) throw new Error(`unexpected CID version (${version})`)\n              buffer.consume(versionBytes)\n              offset += versionBytes\n\n              const [codec, codecBytes] = decodeVarint(buffer)\n              buffer.consume(codecBytes)\n              offset += codecBytes\n\n              const multihashBytes = getMultihashLength(buffer)\n              const multihash = decodeDigest(buffer.subarray(0, multihashBytes))\n              cid = createLink(codec, multihash)\n              buffer.consume(multihashBytes)\n              offset += multihashBytes\n            }\n\n            const blockBytes = wanted - (offset - prevOffset)\n            const bytes = buffer.subarray(0, blockBytes)\n            controller.enqueue({ cid, bytes, offset: _offset, length, blockOffset: offset, blockLength: blockBytes })\n\n            buffer.consume(blockBytes)\n            prevOffset = offset\n            offset += blockBytes\n            state = State.ReadBlockLength\n            wanted = 8\n          }\n        }\n      },\n      flush (controller) {\n        if (state !== State.ReadBlockLength) {\n          controller.error(new Error('unexpected end of data'))\n        }\n      }\n    }, writableStrategy, readableStrategy ?? new CountQueuingStrategy({ highWaterMark: 1 }))\n\n    this.#headerPromise = headerPromise\n  }\n\n  /**\n   * Get the decoded CAR header.\n   */\n  getHeader () {\n    return this.#headerPromise\n  }\n}\n\n/** @param {Uint8ArrayList} bytes */\nconst getMultihashLength = bytes => {\n  const [, codeBytes] = decodeVarint(bytes)\n  const [length, lengthBytes] = decodeVarint(bytes, codeBytes)\n  return codeBytes + lengthBytes + length\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}