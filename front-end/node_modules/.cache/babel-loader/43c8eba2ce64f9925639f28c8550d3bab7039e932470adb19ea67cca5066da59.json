{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Bytecode = exports.Instruction = exports.CustomError = exports.ContractFunction = exports.Contract = exports.SourceLocation = exports.SourceFile = exports.ContractFunctionVisibility = exports.ContractFunctionType = exports.ContractType = exports.JumpType = void 0;\nconst ethereumjs_util_1 = require(\"@nomicfoundation/ethereumjs-util\");\nconst abi_helpers_1 = require(\"../../util/abi-helpers\");\n/* eslint-disable @nomicfoundation/hardhat-internal-rules/only-hardhat-error */\nvar JumpType;\n(function (JumpType) {\n  JumpType[JumpType[\"NOT_JUMP\"] = 0] = \"NOT_JUMP\";\n  JumpType[JumpType[\"INTO_FUNCTION\"] = 1] = \"INTO_FUNCTION\";\n  JumpType[JumpType[\"OUTOF_FUNCTION\"] = 2] = \"OUTOF_FUNCTION\";\n  JumpType[JumpType[\"INTERNAL_JUMP\"] = 3] = \"INTERNAL_JUMP\";\n})(JumpType = exports.JumpType || (exports.JumpType = {}));\nvar ContractType;\n(function (ContractType) {\n  ContractType[ContractType[\"CONTRACT\"] = 0] = \"CONTRACT\";\n  ContractType[ContractType[\"LIBRARY\"] = 1] = \"LIBRARY\";\n})(ContractType = exports.ContractType || (exports.ContractType = {}));\nvar ContractFunctionType;\n(function (ContractFunctionType) {\n  ContractFunctionType[ContractFunctionType[\"CONSTRUCTOR\"] = 0] = \"CONSTRUCTOR\";\n  ContractFunctionType[ContractFunctionType[\"FUNCTION\"] = 1] = \"FUNCTION\";\n  ContractFunctionType[ContractFunctionType[\"FALLBACK\"] = 2] = \"FALLBACK\";\n  ContractFunctionType[ContractFunctionType[\"RECEIVE\"] = 3] = \"RECEIVE\";\n  ContractFunctionType[ContractFunctionType[\"GETTER\"] = 4] = \"GETTER\";\n  ContractFunctionType[ContractFunctionType[\"MODIFIER\"] = 5] = \"MODIFIER\";\n  ContractFunctionType[ContractFunctionType[\"FREE_FUNCTION\"] = 6] = \"FREE_FUNCTION\";\n})(ContractFunctionType = exports.ContractFunctionType || (exports.ContractFunctionType = {}));\nvar ContractFunctionVisibility;\n(function (ContractFunctionVisibility) {\n  ContractFunctionVisibility[ContractFunctionVisibility[\"PRIVATE\"] = 0] = \"PRIVATE\";\n  ContractFunctionVisibility[ContractFunctionVisibility[\"INTERNAL\"] = 1] = \"INTERNAL\";\n  ContractFunctionVisibility[ContractFunctionVisibility[\"PUBLIC\"] = 2] = \"PUBLIC\";\n  ContractFunctionVisibility[ContractFunctionVisibility[\"EXTERNAL\"] = 3] = \"EXTERNAL\";\n})(ContractFunctionVisibility = exports.ContractFunctionVisibility || (exports.ContractFunctionVisibility = {}));\nclass SourceFile {\n  constructor(sourceName, content) {\n    this.sourceName = sourceName;\n    this.content = content;\n    this.contracts = [];\n    this.functions = [];\n  }\n  addContract(contract) {\n    if (contract.location.file !== this) {\n      throw new Error(\"Trying to add a contract from another file\");\n    }\n    this.contracts.push(contract);\n  }\n  addFunction(func) {\n    if (func.location.file !== this) {\n      throw new Error(\"Trying to add a function from another file\");\n    }\n    this.functions.push(func);\n  }\n  getContainingFunction(location) {\n    // TODO: Optimize this with a binary search or an internal tree\n    for (const func of this.functions) {\n      if (func.location.contains(location)) {\n        return func;\n      }\n    }\n    return undefined;\n  }\n}\nexports.SourceFile = SourceFile;\nclass SourceLocation {\n  constructor(file, offset, length) {\n    this.file = file;\n    this.offset = offset;\n    this.length = length;\n  }\n  getStartingLineNumber() {\n    if (this._line === undefined) {\n      this._line = 1;\n      for (const c of this.file.content.slice(0, this.offset)) {\n        if (c === \"\\n\") {\n          this._line += 1;\n        }\n      }\n    }\n    return this._line;\n  }\n  getContainingFunction() {\n    return this.file.getContainingFunction(this);\n  }\n  contains(other) {\n    if (this.file !== other.file) {\n      return false;\n    }\n    if (other.offset < this.offset) {\n      return false;\n    }\n    return other.offset + other.length <= this.offset + this.length;\n  }\n  equals(other) {\n    return this.file === other.file && this.offset === other.offset && this.length === other.length;\n  }\n}\nexports.SourceLocation = SourceLocation;\nclass Contract {\n  constructor(name, type, location) {\n    this.name = name;\n    this.type = type;\n    this.location = location;\n    this.localFunctions = [];\n    this.customErrors = [];\n    this._selectorHexToFunction = new Map();\n  }\n  get constructorFunction() {\n    return this._constructor;\n  }\n  get fallback() {\n    return this._fallback;\n  }\n  get receive() {\n    return this._receive;\n  }\n  addLocalFunction(func) {\n    if (func.contract !== this) {\n      throw new Error(\"Function isn't local\");\n    }\n    if (func.visibility === ContractFunctionVisibility.PUBLIC || func.visibility === ContractFunctionVisibility.EXTERNAL) {\n      if (func.type === ContractFunctionType.FUNCTION || func.type === ContractFunctionType.GETTER) {\n        this._selectorHexToFunction.set((0, ethereumjs_util_1.bytesToHex)(func.selector), func);\n      } else if (func.type === ContractFunctionType.CONSTRUCTOR) {\n        this._constructor = func;\n      } else if (func.type === ContractFunctionType.FALLBACK) {\n        this._fallback = func;\n      } else if (func.type === ContractFunctionType.RECEIVE) {\n        this._receive = func;\n      }\n    }\n    this.localFunctions.push(func);\n  }\n  addCustomError(customError) {\n    this.customErrors.push(customError);\n  }\n  addNextLinearizedBaseContract(baseContract) {\n    if (this._fallback === undefined && baseContract._fallback !== undefined) {\n      this._fallback = baseContract._fallback;\n    }\n    if (this._receive === undefined && baseContract._receive !== undefined) {\n      this._receive = baseContract._receive;\n    }\n    for (const baseContractFunction of baseContract.localFunctions) {\n      if (baseContractFunction.type !== ContractFunctionType.GETTER && baseContractFunction.type !== ContractFunctionType.FUNCTION) {\n        continue;\n      }\n      if (baseContractFunction.visibility !== ContractFunctionVisibility.PUBLIC && baseContractFunction.visibility !== ContractFunctionVisibility.EXTERNAL) {\n        continue;\n      }\n      const selectorHex = (0, ethereumjs_util_1.bytesToHex)(baseContractFunction.selector);\n      if (!this._selectorHexToFunction.has(selectorHex)) {\n        this._selectorHexToFunction.set(selectorHex, baseContractFunction);\n      }\n    }\n  }\n  getFunctionFromSelector(selector) {\n    return this._selectorHexToFunction.get((0, ethereumjs_util_1.bytesToHex)(selector));\n  }\n  /**\n   * We compute selectors manually, which is particularly hard. We do this\n   * because we need to map selectors to AST nodes, and it seems easier to start\n   * from the AST node. This is surprisingly super hard: things like inherited\n   * enums, structs and ABIv2 complicate it.\n   *\n   * As we know that that can fail, we run a heuristic that tries to correct\n   * incorrect selectors. What it does is checking the `evm.methodIdentifiers`\n   * compiler output, and detect missing selectors. Then we take those and\n   * find contract functions with the same name. If there are multiple of those\n   * we can't do anything. If there is a single one, it must have an incorrect\n   * selector, so we update it with the `evm.methodIdentifiers`'s value.\n   */\n  correctSelector(functionName, selector) {\n    const functions = Array.from(this._selectorHexToFunction.values()).filter(cf => cf.name === functionName);\n    if (functions.length !== 1) {\n      return false;\n    }\n    const functionToCorrect = functions[0];\n    if (functionToCorrect.selector !== undefined) {\n      this._selectorHexToFunction.delete((0, ethereumjs_util_1.bytesToHex)(functionToCorrect.selector));\n    }\n    functionToCorrect.selector = selector;\n    this._selectorHexToFunction.set((0, ethereumjs_util_1.bytesToHex)(selector), functionToCorrect);\n    return true;\n  }\n}\nexports.Contract = Contract;\nclass ContractFunction {\n  constructor(name, type, location, contract, visibility, isPayable, selector, paramTypes) {\n    this.name = name;\n    this.type = type;\n    this.location = location;\n    this.contract = contract;\n    this.visibility = visibility;\n    this.isPayable = isPayable;\n    this.selector = selector;\n    this.paramTypes = paramTypes;\n    if (contract !== undefined && !contract.location.contains(location)) {\n      throw new Error(\"Incompatible contract and function location\");\n    }\n  }\n  isValidCalldata(calldata) {\n    if (this.paramTypes === undefined) {\n      // if we don't know the param types, we just assume that the call is valid\n      return true;\n    }\n    return abi_helpers_1.AbiHelpers.isValidCalldata(this.paramTypes, calldata);\n  }\n}\nexports.ContractFunction = ContractFunction;\nclass CustomError {\n  /**\n   * Return a CustomError from the given ABI information: the name\n   * of the error and its inputs. Returns undefined if it can't build\n   * the CustomError.\n   */\n  static fromABI(name, inputs) {\n    const selector = abi_helpers_1.AbiHelpers.computeSelector(name, inputs);\n    if (selector !== undefined) {\n      return new CustomError(selector, name, inputs);\n    }\n  }\n  constructor(selector, name, paramTypes) {\n    this.selector = selector;\n    this.name = name;\n    this.paramTypes = paramTypes;\n  }\n}\nexports.CustomError = CustomError;\nclass Instruction {\n  constructor(pc, opcode, jumpType, pushData, location) {\n    this.pc = pc;\n    this.opcode = opcode;\n    this.jumpType = jumpType;\n    this.pushData = pushData;\n    this.location = location;\n  }\n  /**\n   * Checks equality with another Instruction.\n   */\n  equals(other) {\n    if (this.pc !== other.pc) {\n      return false;\n    }\n    if (this.opcode !== other.opcode) {\n      return false;\n    }\n    if (this.jumpType !== other.jumpType) {\n      return false;\n    }\n    if (this.pushData !== undefined) {\n      if (other.pushData === undefined) {\n        return false;\n      }\n      if (!this.pushData.equals(other.pushData)) {\n        return false;\n      }\n    } else if (other.pushData !== undefined) {\n      return false;\n    }\n    if (this.location !== undefined) {\n      if (other.location === undefined) {\n        return false;\n      }\n      if (!this.location.equals(other.location)) {\n        return false;\n      }\n    } else if (other.location !== undefined) {\n      return false;\n    }\n    return true;\n  }\n}\nexports.Instruction = Instruction;\nclass Bytecode {\n  constructor(contract, isDeployment, normalizedCode, instructions, libraryAddressPositions, immutableReferences, compilerVersion) {\n    this.contract = contract;\n    this.isDeployment = isDeployment;\n    this.normalizedCode = normalizedCode;\n    this.instructions = instructions;\n    this.libraryAddressPositions = libraryAddressPositions;\n    this.immutableReferences = immutableReferences;\n    this.compilerVersion = compilerVersion;\n    this._pcToInstruction = new Map();\n    for (const inst of instructions) {\n      this._pcToInstruction.set(inst.pc, inst);\n    }\n  }\n  getInstruction(pc) {\n    const inst = this._pcToInstruction.get(pc);\n    if (inst === undefined) {\n      throw new Error(`There's no instruction at pc ${pc}`);\n    }\n    return inst;\n  }\n  hasInstruction(pc) {\n    return this._pcToInstruction.has(pc);\n  }\n  /**\n   * Checks equality with another Bytecode.\n   */\n  equals(other) {\n    if (this._pcToInstruction.size !== other._pcToInstruction.size) {\n      return false;\n    }\n    for (const [key, val] of this._pcToInstruction) {\n      const otherVal = other._pcToInstruction.get(key);\n      if (otherVal === undefined || !val.equals(otherVal)) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\nexports.Bytecode = Bytecode;","map":{"version":3,"names":["ethereumjs_util_1","require","abi_helpers_1","JumpType","exports","ContractType","ContractFunctionType","ContractFunctionVisibility","SourceFile","constructor","sourceName","content","contracts","functions","addContract","contract","location","file","Error","push","addFunction","func","getContainingFunction","contains","undefined","SourceLocation","offset","length","getStartingLineNumber","_line","c","slice","other","equals","Contract","name","type","localFunctions","customErrors","_selectorHexToFunction","Map","constructorFunction","_constructor","fallback","_fallback","receive","_receive","addLocalFunction","visibility","PUBLIC","EXTERNAL","FUNCTION","GETTER","set","bytesToHex","selector","CONSTRUCTOR","FALLBACK","RECEIVE","addCustomError","customError","addNextLinearizedBaseContract","baseContract","baseContractFunction","selectorHex","has","getFunctionFromSelector","get","correctSelector","functionName","Array","from","values","filter","cf","functionToCorrect","delete","ContractFunction","isPayable","paramTypes","isValidCalldata","calldata","AbiHelpers","CustomError","fromABI","inputs","computeSelector","Instruction","pc","opcode","jumpType","pushData","Bytecode","isDeployment","normalizedCode","instructions","libraryAddressPositions","immutableReferences","compilerVersion","_pcToInstruction","inst","getInstruction","hasInstruction","size","key","val","otherVal"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\internal\\hardhat-network\\stack-traces\\model.ts"],"sourcesContent":["import { bytesToHex as bufferToHex } from \"@nomicfoundation/ethereumjs-util\";\n\nimport { AbiHelpers } from \"../../util/abi-helpers\";\n\nimport { Opcode } from \"./opcodes\";\n\n/* eslint-disable @nomicfoundation/hardhat-internal-rules/only-hardhat-error */\n\nexport enum JumpType {\n  NOT_JUMP,\n  INTO_FUNCTION,\n  OUTOF_FUNCTION,\n  INTERNAL_JUMP,\n}\n\nexport enum ContractType {\n  CONTRACT,\n  LIBRARY,\n}\n\nexport enum ContractFunctionType {\n  CONSTRUCTOR,\n  FUNCTION,\n  FALLBACK,\n  RECEIVE,\n  GETTER,\n  MODIFIER,\n  FREE_FUNCTION,\n}\n\nexport enum ContractFunctionVisibility {\n  PRIVATE,\n  INTERNAL,\n  PUBLIC,\n  EXTERNAL,\n}\n\nexport class SourceFile {\n  public readonly contracts: Contract[] = [];\n  public readonly functions: ContractFunction[] = [];\n\n  constructor(\n    public readonly sourceName: string,\n    public readonly content: string\n  ) {}\n\n  public addContract(contract: Contract) {\n    if (contract.location.file !== this) {\n      throw new Error(\"Trying to add a contract from another file\");\n    }\n\n    this.contracts.push(contract);\n  }\n\n  public addFunction(func: ContractFunction) {\n    if (func.location.file !== this) {\n      throw new Error(\"Trying to add a function from another file\");\n    }\n\n    this.functions.push(func);\n  }\n\n  public getContainingFunction(\n    location: SourceLocation\n  ): ContractFunction | undefined {\n    // TODO: Optimize this with a binary search or an internal tree\n\n    for (const func of this.functions) {\n      if (func.location.contains(location)) {\n        return func;\n      }\n    }\n\n    return undefined;\n  }\n}\n\nexport class SourceLocation {\n  private _line: number | undefined;\n\n  constructor(\n    public readonly file: SourceFile,\n    public readonly offset: number,\n    public readonly length: number\n  ) {}\n\n  public getStartingLineNumber(): number {\n    if (this._line === undefined) {\n      this._line = 1;\n\n      for (const c of this.file.content.slice(0, this.offset)) {\n        if (c === \"\\n\") {\n          this._line += 1;\n        }\n      }\n    }\n\n    return this._line;\n  }\n\n  public getContainingFunction(): ContractFunction | undefined {\n    return this.file.getContainingFunction(this);\n  }\n\n  public contains(other: SourceLocation) {\n    if (this.file !== other.file) {\n      return false;\n    }\n\n    if (other.offset < this.offset) {\n      return false;\n    }\n\n    return other.offset + other.length <= this.offset + this.length;\n  }\n\n  public equals(other: SourceLocation) {\n    return (\n      this.file === other.file &&\n      this.offset === other.offset &&\n      this.length === other.length\n    );\n  }\n}\n\nexport class Contract {\n  public readonly localFunctions: ContractFunction[] = [];\n  public readonly customErrors: CustomError[] = [];\n\n  private _constructor: ContractFunction | undefined;\n  private _fallback: ContractFunction | undefined;\n  private _receive: ContractFunction | undefined;\n  private readonly _selectorHexToFunction: Map<string, ContractFunction> =\n    new Map();\n\n  constructor(\n    public readonly name: string,\n    public readonly type: ContractType,\n    public readonly location: SourceLocation\n  ) {}\n\n  public get constructorFunction(): ContractFunction | undefined {\n    return this._constructor;\n  }\n\n  public get fallback(): ContractFunction | undefined {\n    return this._fallback;\n  }\n\n  public get receive(): ContractFunction | undefined {\n    return this._receive;\n  }\n\n  public addLocalFunction(func: ContractFunction) {\n    if (func.contract !== this) {\n      throw new Error(\"Function isn't local\");\n    }\n\n    if (\n      func.visibility === ContractFunctionVisibility.PUBLIC ||\n      func.visibility === ContractFunctionVisibility.EXTERNAL\n    ) {\n      if (\n        func.type === ContractFunctionType.FUNCTION ||\n        func.type === ContractFunctionType.GETTER\n      ) {\n        this._selectorHexToFunction.set(bufferToHex(func.selector!), func);\n      } else if (func.type === ContractFunctionType.CONSTRUCTOR) {\n        this._constructor = func;\n      } else if (func.type === ContractFunctionType.FALLBACK) {\n        this._fallback = func;\n      } else if (func.type === ContractFunctionType.RECEIVE) {\n        this._receive = func;\n      }\n    }\n\n    this.localFunctions.push(func);\n  }\n\n  public addCustomError(customError: CustomError) {\n    this.customErrors.push(customError);\n  }\n\n  public addNextLinearizedBaseContract(baseContract: Contract) {\n    if (this._fallback === undefined && baseContract._fallback !== undefined) {\n      this._fallback = baseContract._fallback;\n    }\n    if (this._receive === undefined && baseContract._receive !== undefined) {\n      this._receive = baseContract._receive;\n    }\n\n    for (const baseContractFunction of baseContract.localFunctions) {\n      if (\n        baseContractFunction.type !== ContractFunctionType.GETTER &&\n        baseContractFunction.type !== ContractFunctionType.FUNCTION\n      ) {\n        continue;\n      }\n\n      if (\n        baseContractFunction.visibility !== ContractFunctionVisibility.PUBLIC &&\n        baseContractFunction.visibility !== ContractFunctionVisibility.EXTERNAL\n      ) {\n        continue;\n      }\n\n      const selectorHex = bufferToHex(baseContractFunction.selector!);\n      if (!this._selectorHexToFunction.has(selectorHex)) {\n        this._selectorHexToFunction.set(selectorHex, baseContractFunction);\n      }\n    }\n  }\n\n  public getFunctionFromSelector(\n    selector: Uint8Array\n  ): ContractFunction | undefined {\n    return this._selectorHexToFunction.get(bufferToHex(selector));\n  }\n\n  /**\n   * We compute selectors manually, which is particularly hard. We do this\n   * because we need to map selectors to AST nodes, and it seems easier to start\n   * from the AST node. This is surprisingly super hard: things like inherited\n   * enums, structs and ABIv2 complicate it.\n   *\n   * As we know that that can fail, we run a heuristic that tries to correct\n   * incorrect selectors. What it does is checking the `evm.methodIdentifiers`\n   * compiler output, and detect missing selectors. Then we take those and\n   * find contract functions with the same name. If there are multiple of those\n   * we can't do anything. If there is a single one, it must have an incorrect\n   * selector, so we update it with the `evm.methodIdentifiers`'s value.\n   */\n  public correctSelector(functionName: string, selector: Buffer): boolean {\n    const functions = Array.from(this._selectorHexToFunction.values()).filter(\n      (cf) => cf.name === functionName\n    );\n\n    if (functions.length !== 1) {\n      return false;\n    }\n\n    const functionToCorrect = functions[0];\n\n    if (functionToCorrect.selector !== undefined) {\n      this._selectorHexToFunction.delete(\n        bufferToHex(functionToCorrect.selector)\n      );\n    }\n\n    functionToCorrect.selector = selector;\n    this._selectorHexToFunction.set(bufferToHex(selector), functionToCorrect);\n    return true;\n  }\n}\n\nexport class ContractFunction {\n  constructor(\n    public readonly name: string,\n    public readonly type: ContractFunctionType,\n    public readonly location: SourceLocation,\n    public readonly contract?: Contract,\n    public readonly visibility?: ContractFunctionVisibility,\n    public readonly isPayable?: boolean,\n    public selector?: Uint8Array,\n    public readonly paramTypes?: any[]\n  ) {\n    if (contract !== undefined && !contract.location.contains(location)) {\n      throw new Error(\"Incompatible contract and function location\");\n    }\n  }\n\n  public isValidCalldata(calldata: Uint8Array): boolean {\n    if (this.paramTypes === undefined) {\n      // if we don't know the param types, we just assume that the call is valid\n      return true;\n    }\n\n    return AbiHelpers.isValidCalldata(this.paramTypes, calldata);\n  }\n}\n\nexport class CustomError {\n  /**\n   * Return a CustomError from the given ABI information: the name\n   * of the error and its inputs. Returns undefined if it can't build\n   * the CustomError.\n   */\n  public static fromABI(name: string, inputs: any[]): CustomError | undefined {\n    const selector = AbiHelpers.computeSelector(name, inputs);\n\n    if (selector !== undefined) {\n      return new CustomError(selector, name, inputs);\n    }\n  }\n\n  private constructor(\n    public readonly selector: Uint8Array,\n    public readonly name: string,\n    public readonly paramTypes: any[]\n  ) {}\n}\n\nexport class Instruction {\n  constructor(\n    public readonly pc: number,\n    public readonly opcode: Opcode,\n    public readonly jumpType: JumpType,\n    public readonly pushData?: Buffer,\n    public readonly location?: SourceLocation\n  ) {}\n\n  /**\n   * Checks equality with another Instruction.\n   */\n  public equals(other: Instruction): boolean {\n    if (this.pc !== other.pc) {\n      return false;\n    }\n\n    if (this.opcode !== other.opcode) {\n      return false;\n    }\n\n    if (this.jumpType !== other.jumpType) {\n      return false;\n    }\n\n    if (this.pushData !== undefined) {\n      if (other.pushData === undefined) {\n        return false;\n      }\n\n      if (!this.pushData.equals(other.pushData)) {\n        return false;\n      }\n    } else if (other.pushData !== undefined) {\n      return false;\n    }\n\n    if (this.location !== undefined) {\n      if (other.location === undefined) {\n        return false;\n      }\n\n      if (!this.location.equals(other.location)) {\n        return false;\n      }\n    } else if (other.location !== undefined) {\n      return false;\n    }\n\n    return true;\n  }\n}\n\ninterface ImmutableReference {\n  start: number;\n  length: number;\n}\n\nexport class Bytecode {\n  private readonly _pcToInstruction: Map<number, Instruction> = new Map();\n\n  constructor(\n    public readonly contract: Contract,\n    public readonly isDeployment: boolean,\n    public readonly normalizedCode: Buffer,\n    public readonly instructions: Instruction[],\n    public readonly libraryAddressPositions: number[],\n    public readonly immutableReferences: ImmutableReference[],\n    public readonly compilerVersion: string\n  ) {\n    for (const inst of instructions) {\n      this._pcToInstruction.set(inst.pc, inst);\n    }\n  }\n\n  public getInstruction(pc: number): Instruction {\n    const inst = this._pcToInstruction.get(pc);\n\n    if (inst === undefined) {\n      throw new Error(`There's no instruction at pc ${pc}`);\n    }\n\n    return inst;\n  }\n\n  public hasInstruction(pc: number): boolean {\n    return this._pcToInstruction.has(pc);\n  }\n\n  /**\n   * Checks equality with another Bytecode.\n   */\n  public equals(other: Bytecode): boolean {\n    if (this._pcToInstruction.size !== other._pcToInstruction.size) {\n      return false;\n    }\n\n    for (const [key, val] of this._pcToInstruction) {\n      const otherVal = other._pcToInstruction.get(key);\n      if (otherVal === undefined || !val.equals(otherVal)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}