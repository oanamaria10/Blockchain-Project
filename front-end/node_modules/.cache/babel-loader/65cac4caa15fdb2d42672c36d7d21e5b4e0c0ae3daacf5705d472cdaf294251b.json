{"ast":null,"code":"import * as API from '@ucanto/interface';\nimport { Signature, Message, Receipt, sha256 } from '@ucanto/core';\n\n/**\n * Creates a connection to a service.\n *\n * @template {Record<string, any>} T\n * @param {API.ConnectionOptions<T>} options\n * @returns {API.ConnectionView<T>}\n */\nexport const connect = options => new Connection(options);\n\n/**\n * @template {Record<string, any>} T\n * @implements {API.ConnectionView<T>}\n */\nclass Connection {\n  /**\n   * @param {API.ConnectionOptions<T>} options\n   */\n  constructor(options) {\n    this.id = options.id;\n    this.options = options;\n    this.codec = options.codec;\n    this.channel = options.channel;\n    this.hasher = options.hasher || sha256;\n  }\n  /**\n   * Execute invocations.\n   *\n   * @template {API.Capability} C\n   * @template {API.Tuple<API.ServiceInvocation<C, T>>} I\n   * @param {I} invocations\n   * @returns {Promise<API.InferReceipts<I, T>>}\n   */\n  async execute(...invocations) {\n    return execute(invocations, this);\n  }\n}\n\n/**\n * @template {API.Capability} C\n * @template {Record<string, any>} T\n * @template {API.Tuple<API.ServiceInvocation<C, T>>} I\n * @param {API.Connection<T>} connection\n * @param {I} invocations\n * @returns {Promise<API.InferReceipts<I, T>>}\n */\nexport const execute = async (invocations, connection) => {\n  const input = await Message.build({\n    invocations\n  });\n  const request = await connection.codec.encode(input, connection);\n  const response = await connection.channel.request(request);\n  // We may fail to decode the response if content type is not supported\n  // or if data was corrupted. We do not want to throw in such case however,\n  // because client will get an Error object as opposed to a receipt, to retain\n  // consistent client API with two kinds of errors we encode caught error as\n  // a receipts per workflow invocation.\n  try {\n    const output = await connection.codec.decode(response);\n    const receipts = input.invocationLinks.map(link => output.get(link));\n    return /** @type {API.InferReceipts<I, T>} */receipts;\n  } catch (error) {\n    // No third party code is run during decode and we know\n    // we only throw an Error\n    const {\n      message,\n      name = 'Error',\n      ...cause\n    } = /** @type {Error} */error;\n    const receipts = [];\n    for await (const ran of input.invocationLinks) {\n      const receipt = await Receipt.issue({\n        ran,\n        result: {\n          error: {\n            ...cause,\n            name,\n            message\n          }\n        },\n        // @ts-expect-error - we can not really sign a receipt without having\n        // an access to a signer which client does not have. In the future\n        // we will change client API requiring a signer to be passed in but\n        // for now we just use a dummy signer.\n        issuer: {\n          did() {\n            return connection.id.did();\n          },\n          sign() {\n            return Signature.createNonStandard('', new Uint8Array());\n          }\n        }\n      });\n      receipts.push(receipt);\n    }\n    return /** @type {API.InferReceipts<I, T>} */receipts;\n  }\n};","map":{"version":3,"names":["API","Signature","Message","Receipt","sha256","connect","options","Connection","constructor","id","codec","channel","hasher","execute","invocations","connection","input","build","request","encode","response","output","decode","receipts","invocationLinks","map","link","get","error","message","name","cause","ran","receipt","issue","result","issuer","did","sign","createNonStandard","Uint8Array","push"],"sources":["C:/FACULTATE/Proiect/node_modules/@ucanto/client/src/connection.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport { Signature, Message, Receipt, sha256 } from '@ucanto/core'\n\n/**\n * Creates a connection to a service.\n *\n * @template {Record<string, any>} T\n * @param {API.ConnectionOptions<T>} options\n * @returns {API.ConnectionView<T>}\n */\nexport const connect = options => new Connection(options)\n\n/**\n * @template {Record<string, any>} T\n * @implements {API.ConnectionView<T>}\n */\nclass Connection {\n  /**\n   * @param {API.ConnectionOptions<T>} options\n   */\n  constructor(options) {\n    this.id = options.id\n    this.options = options\n    this.codec = options.codec\n    this.channel = options.channel\n    this.hasher = options.hasher || sha256\n  }\n  /**\n   * Execute invocations.\n   *\n   * @template {API.Capability} C\n   * @template {API.Tuple<API.ServiceInvocation<C, T>>} I\n   * @param {I} invocations\n   * @returns {Promise<API.InferReceipts<I, T>>}\n   */\n  async execute(...invocations) {\n    return execute(invocations, this)\n  }\n}\n\n/**\n * @template {API.Capability} C\n * @template {Record<string, any>} T\n * @template {API.Tuple<API.ServiceInvocation<C, T>>} I\n * @param {API.Connection<T>} connection\n * @param {I} invocations\n * @returns {Promise<API.InferReceipts<I, T>>}\n */\nexport const execute = async (invocations, connection) => {\n  const input = await Message.build({ invocations })\n  const request = await connection.codec.encode(input, connection)\n  const response = await connection.channel.request(request)\n  // We may fail to decode the response if content type is not supported\n  // or if data was corrupted. We do not want to throw in such case however,\n  // because client will get an Error object as opposed to a receipt, to retain\n  // consistent client API with two kinds of errors we encode caught error as\n  // a receipts per workflow invocation.\n  try {\n    const output = await connection.codec.decode(response)\n    const receipts = input.invocationLinks.map(link => output.get(link))\n    return /** @type {API.InferReceipts<I, T>} */ (receipts)\n  } catch (error) {\n    // No third party code is run during decode and we know\n    // we only throw an Error\n    const { message, name = 'Error', ...cause } = /** @type {Error} */ (error)\n    const receipts = []\n    for await (const ran of input.invocationLinks) {\n      const receipt = await Receipt.issue({\n        ran,\n        result: { error: { ...cause, name, message } },\n        // @ts-expect-error - we can not really sign a receipt without having\n        // an access to a signer which client does not have. In the future\n        // we will change client API requiring a signer to be passed in but\n        // for now we just use a dummy signer.\n        issuer: {\n          did() {\n            return connection.id.did()\n          },\n          sign() {\n            return Signature.createNonStandard('', new Uint8Array())\n          },\n        },\n      })\n\n      receipts.push(receipt)\n    }\n\n    return /** @type {API.InferReceipts<I, T>} */ (receipts)\n  }\n}\n"],"mappings":"AAAA,OAAO,KAAKA,GAAG,MAAM,mBAAmB;AACxC,SAASC,SAAS,EAAEC,OAAO,EAAEC,OAAO,EAAEC,MAAM,QAAQ,cAAc;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,OAAO,GAAGC,OAAO,IAAI,IAAIC,UAAU,CAACD,OAAO,CAAC;;AAEzD;AACA;AACA;AACA;AACA,MAAMC,UAAU,CAAC;EACf;AACF;AACA;EACEC,WAAWA,CAACF,OAAO,EAAE;IACnB,IAAI,CAACG,EAAE,GAAGH,OAAO,CAACG,EAAE;IACpB,IAAI,CAACH,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACI,KAAK,GAAGJ,OAAO,CAACI,KAAK;IAC1B,IAAI,CAACC,OAAO,GAAGL,OAAO,CAACK,OAAO;IAC9B,IAAI,CAACC,MAAM,GAAGN,OAAO,CAACM,MAAM,IAAIR,MAAM;EACxC;EACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMS,OAAOA,CAAC,GAAGC,WAAW,EAAE;IAC5B,OAAOD,OAAO,CAACC,WAAW,EAAE,IAAI,CAAC;EACnC;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMD,OAAO,GAAG,MAAAA,CAAOC,WAAW,EAAEC,UAAU,KAAK;EACxD,MAAMC,KAAK,GAAG,MAAMd,OAAO,CAACe,KAAK,CAAC;IAAEH;EAAY,CAAC,CAAC;EAClD,MAAMI,OAAO,GAAG,MAAMH,UAAU,CAACL,KAAK,CAACS,MAAM,CAACH,KAAK,EAAED,UAAU,CAAC;EAChE,MAAMK,QAAQ,GAAG,MAAML,UAAU,CAACJ,OAAO,CAACO,OAAO,CAACA,OAAO,CAAC;EAC1D;EACA;EACA;EACA;EACA;EACA,IAAI;IACF,MAAMG,MAAM,GAAG,MAAMN,UAAU,CAACL,KAAK,CAACY,MAAM,CAACF,QAAQ,CAAC;IACtD,MAAMG,QAAQ,GAAGP,KAAK,CAACQ,eAAe,CAACC,GAAG,CAACC,IAAI,IAAIL,MAAM,CAACM,GAAG,CAACD,IAAI,CAAC,CAAC;IACpE,OAAO,sCAAwCH,QAAQ;EACzD,CAAC,CAAC,OAAOK,KAAK,EAAE;IACd;IACA;IACA,MAAM;MAAEC,OAAO;MAAEC,IAAI,GAAG,OAAO;MAAE,GAAGC;IAAM,CAAC,GAAG,oBAAsBH,KAAM;IAC1E,MAAML,QAAQ,GAAG,EAAE;IACnB,WAAW,MAAMS,GAAG,IAAIhB,KAAK,CAACQ,eAAe,EAAE;MAC7C,MAAMS,OAAO,GAAG,MAAM9B,OAAO,CAAC+B,KAAK,CAAC;QAClCF,GAAG;QACHG,MAAM,EAAE;UAAEP,KAAK,EAAE;YAAE,GAAGG,KAAK;YAAED,IAAI;YAAED;UAAQ;QAAE,CAAC;QAC9C;QACA;QACA;QACA;QACAO,MAAM,EAAE;UACNC,GAAGA,CAAA,EAAG;YACJ,OAAOtB,UAAU,CAACN,EAAE,CAAC4B,GAAG,CAAC,CAAC;UAC5B,CAAC;UACDC,IAAIA,CAAA,EAAG;YACL,OAAOrC,SAAS,CAACsC,iBAAiB,CAAC,EAAE,EAAE,IAAIC,UAAU,CAAC,CAAC,CAAC;UAC1D;QACF;MACF,CAAC,CAAC;MAEFjB,QAAQ,CAACkB,IAAI,CAACR,OAAO,CAAC;IACxB;IAEA,OAAO,sCAAwCV,QAAQ;EACzD;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}