{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyProviderWrappers = exports.createProvider = exports.isHDAccountsConfig = void 0;\nconst constants_1 = require(\"../../constants\");\nconst date_1 = require(\"../../util/date\");\nconst util_1 = require(\"./util\");\nfunction isHDAccountsConfig(accounts) {\n  return accounts !== undefined && Object.keys(accounts).includes(\"mnemonic\");\n}\nexports.isHDAccountsConfig = isHDAccountsConfig;\nfunction isResolvedHttpNetworkConfig(netConfig) {\n  return \"url\" in netConfig;\n}\n// This function is let's you import a provider dynamically in a pretty\n// type-safe way.\n// `ProviderNameT` and `name` must be the same literal string. TS enforces it.\n// `ModuleT` and `filePath` must also be the same, but this is not enforced.\nfunction importProvider(filePath, name) {\n  const mod = require(filePath);\n  return mod[name];\n}\nasync function createProvider(config, networkName, artifacts, experimentalHardhatNetworkMessageTraceHooks = [], extenders = []) {\n  let eip1193Provider;\n  const networkConfig = config.networks[networkName];\n  const paths = config.paths;\n  if (networkName === constants_1.HARDHAT_NETWORK_NAME) {\n    const hardhatNetConfig = networkConfig;\n    const {\n      createHardhatNetworkProvider\n    } = await Promise.resolve().then(() => __importStar(require(\"../../hardhat-network/provider/provider\")));\n    let forkConfig;\n    if (hardhatNetConfig.forking?.enabled === true && hardhatNetConfig.forking?.url !== undefined) {\n      forkConfig = {\n        jsonRpcUrl: hardhatNetConfig.forking?.url,\n        blockNumber: hardhatNetConfig.forking?.blockNumber,\n        httpHeaders: hardhatNetConfig.forking.httpHeaders\n      };\n    }\n    const accounts = (0, util_1.normalizeHardhatNetworkAccountsConfig)(hardhatNetConfig.accounts);\n    const {\n      getForkCacheDirPath\n    } = require(\"../../hardhat-network/provider/utils/disk-cache\");\n    eip1193Provider = await createHardhatNetworkProvider({\n      chainId: hardhatNetConfig.chainId,\n      networkId: hardhatNetConfig.chainId,\n      hardfork: hardhatNetConfig.hardfork,\n      blockGasLimit: hardhatNetConfig.blockGasLimit,\n      initialBaseFeePerGas: hardhatNetConfig.initialBaseFeePerGas,\n      minGasPrice: hardhatNetConfig.minGasPrice,\n      throwOnTransactionFailures: hardhatNetConfig.throwOnTransactionFailures,\n      throwOnCallFailures: hardhatNetConfig.throwOnCallFailures,\n      automine: hardhatNetConfig.mining.auto,\n      intervalMining: hardhatNetConfig.mining.interval,\n      // This cast is valid because of the config validation and resolution\n      mempoolOrder: hardhatNetConfig.mining.mempool.order,\n      chains: hardhatNetConfig.chains,\n      coinbase: hardhatNetConfig.coinbase,\n      genesisAccounts: accounts,\n      allowUnlimitedContractSize: hardhatNetConfig.allowUnlimitedContractSize,\n      allowBlocksWithSameTimestamp: hardhatNetConfig.allowBlocksWithSameTimestamp ?? false,\n      initialDate: hardhatNetConfig.initialDate !== undefined ? (0, date_1.parseDateString)(hardhatNetConfig.initialDate) : undefined,\n      experimentalHardhatNetworkMessageTraceHooks,\n      forkConfig,\n      forkCachePath: paths !== undefined ? getForkCacheDirPath(paths) : undefined,\n      enableTransientStorage: hardhatNetConfig.enableTransientStorage ?? false\n    }, {\n      enabled: hardhatNetConfig.loggingEnabled\n    }, artifacts);\n  } else {\n    const HttpProvider = importProvider(\"./http\", \"HttpProvider\");\n    const httpNetConfig = networkConfig;\n    eip1193Provider = new HttpProvider(httpNetConfig.url, networkName, httpNetConfig.httpHeaders, httpNetConfig.timeout);\n  }\n  let wrappedProvider = eip1193Provider;\n  for (const extender of extenders) {\n    wrappedProvider = await extender(wrappedProvider, config, networkName);\n  }\n  wrappedProvider = applyProviderWrappers(wrappedProvider, networkConfig, extenders);\n  const BackwardsCompatibilityProviderAdapter = importProvider(\"./backwards-compatibility\", \"BackwardsCompatibilityProviderAdapter\");\n  return new BackwardsCompatibilityProviderAdapter(wrappedProvider);\n}\nexports.createProvider = createProvider;\nfunction applyProviderWrappers(provider, netConfig, extenders) {\n  // These dependencies are lazy-loaded because they are really big.\n  const LocalAccountsProvider = importProvider(\"./accounts\", \"LocalAccountsProvider\");\n  const HDWalletProvider = importProvider(\"./accounts\", \"HDWalletProvider\");\n  const FixedSenderProvider = importProvider(\"./accounts\", \"FixedSenderProvider\");\n  const AutomaticSenderProvider = importProvider(\"./accounts\", \"AutomaticSenderProvider\");\n  const AutomaticGasProvider = importProvider(\"./gas-providers\", \"AutomaticGasProvider\");\n  const FixedGasProvider = importProvider(\"./gas-providers\", \"FixedGasProvider\");\n  const AutomaticGasPriceProvider = importProvider(\"./gas-providers\", \"AutomaticGasPriceProvider\");\n  const FixedGasPriceProvider = importProvider(\"./gas-providers\", \"FixedGasPriceProvider\");\n  const ChainIdValidatorProvider = importProvider(\"./chainId\", \"ChainIdValidatorProvider\");\n  if (isResolvedHttpNetworkConfig(netConfig)) {\n    const accounts = netConfig.accounts;\n    if (Array.isArray(accounts)) {\n      provider = new LocalAccountsProvider(provider, accounts);\n    } else if (isHDAccountsConfig(accounts)) {\n      provider = new HDWalletProvider(provider, accounts.mnemonic, accounts.path, accounts.initialIndex, accounts.count, accounts.passphrase);\n    }\n    // TODO: Add some extension mechanism for account plugins here\n  }\n  if (netConfig.from !== undefined) {\n    provider = new FixedSenderProvider(provider, netConfig.from);\n  } else {\n    provider = new AutomaticSenderProvider(provider);\n  }\n  if (netConfig.gas === undefined || netConfig.gas === \"auto\") {\n    provider = new AutomaticGasProvider(provider, netConfig.gasMultiplier);\n  } else {\n    provider = new FixedGasProvider(provider, netConfig.gas);\n  }\n  if (netConfig.gasPrice === undefined || netConfig.gasPrice === \"auto\") {\n    // If you use a LocalAccountsProvider or HDWalletProvider, your transactions\n    // are signed locally. This requires having all of their fields available,\n    // including the gasPrice / maxFeePerGas & maxPriorityFeePerGas.\n    //\n    // We never use those providers when using Hardhat Network, but sign within\n    // Hardhat Network itself. This means that we don't need to provide all the\n    // fields, as the missing ones will be resolved there.\n    //\n    // Hardhat Network handles this in a more performant way, so we don't use\n    // the AutomaticGasPriceProvider for it unless there are provider extenders.\n    // The reason for this is that some extenders (like hardhat-ledger's) might\n    // do the signing themselves, and that needs the gas price to be set.\n    if (isResolvedHttpNetworkConfig(netConfig) || extenders.length > 0) {\n      provider = new AutomaticGasPriceProvider(provider);\n    }\n  } else {\n    provider = new FixedGasPriceProvider(provider, netConfig.gasPrice);\n  }\n  if (isResolvedHttpNetworkConfig(netConfig) && netConfig.chainId !== undefined) {\n    provider = new ChainIdValidatorProvider(provider, netConfig.chainId);\n  }\n  return provider;\n}\nexports.applyProviderWrappers = applyProviderWrappers;","map":{"version":3,"names":["constants_1","require","date_1","util_1","isHDAccountsConfig","accounts","undefined","Object","keys","includes","exports","isResolvedHttpNetworkConfig","netConfig","importProvider","filePath","name","mod","createProvider","config","networkName","artifacts","experimentalHardhatNetworkMessageTraceHooks","extenders","eip1193Provider","networkConfig","networks","paths","HARDHAT_NETWORK_NAME","hardhatNetConfig","createHardhatNetworkProvider","Promise","resolve","then","__importStar","forkConfig","forking","enabled","url","jsonRpcUrl","blockNumber","httpHeaders","normalizeHardhatNetworkAccountsConfig","getForkCacheDirPath","chainId","networkId","hardfork","blockGasLimit","initialBaseFeePerGas","minGasPrice","throwOnTransactionFailures","throwOnCallFailures","automine","mining","auto","intervalMining","interval","mempoolOrder","mempool","order","chains","coinbase","genesisAccounts","allowUnlimitedContractSize","allowBlocksWithSameTimestamp","initialDate","parseDateString","forkCachePath","enableTransientStorage","loggingEnabled","HttpProvider","httpNetConfig","timeout","wrappedProvider","extender","applyProviderWrappers","BackwardsCompatibilityProviderAdapter","provider","LocalAccountsProvider","HDWalletProvider","FixedSenderProvider","AutomaticSenderProvider","AutomaticGasProvider","FixedGasProvider","AutomaticGasPriceProvider","FixedGasPriceProvider","ChainIdValidatorProvider","Array","isArray","mnemonic","path","initialIndex","count","passphrase","from","gas","gasMultiplier","gasPrice","length"],"sources":["C:\\Users\\rares\\Desktop\\Blockchain\\Proiect\\node_modules\\hardhat\\src\\internal\\core\\providers\\construction.ts"],"sourcesContent":["import type {\n  Artifacts,\n  BoundExperimentalHardhatNetworkMessageTraceHook,\n  EIP1193Provider,\n  EthereumProvider,\n  HardhatConfig,\n  HardhatNetworkConfig,\n  HDAccountsUserConfig,\n  HttpNetworkAccountsUserConfig,\n  HttpNetworkConfig,\n  NetworkConfig,\n  ProviderExtender,\n} from \"../../../types\";\n\nimport type {\n  ForkConfig,\n  MempoolOrder,\n} from \"../../hardhat-network/provider/node-types\";\nimport type * as DiskCacheT from \"../../hardhat-network/provider/utils/disk-cache\";\nimport { HARDHAT_NETWORK_NAME } from \"../../constants\";\nimport { parseDateString } from \"../../util/date\";\n\nimport { normalizeHardhatNetworkAccountsConfig } from \"./util\";\n\nexport function isHDAccountsConfig(\n  accounts?: HttpNetworkAccountsUserConfig\n): accounts is HDAccountsUserConfig {\n  return accounts !== undefined && Object.keys(accounts).includes(\"mnemonic\");\n}\n\nfunction isResolvedHttpNetworkConfig(\n  netConfig: Partial<NetworkConfig>\n): netConfig is HttpNetworkConfig {\n  return \"url\" in netConfig;\n}\n\n// This function is let's you import a provider dynamically in a pretty\n// type-safe way.\n// `ProviderNameT` and `name` must be the same literal string. TS enforces it.\n// `ModuleT` and `filePath` must also be the same, but this is not enforced.\nfunction importProvider<ModuleT, ProviderNameT extends keyof ModuleT>(\n  filePath: string,\n  name: ProviderNameT\n): ModuleT[ProviderNameT] {\n  const mod = require(filePath);\n  return mod[name];\n}\n\nexport async function createProvider(\n  config: HardhatConfig,\n  networkName: string,\n  artifacts?: Artifacts,\n  experimentalHardhatNetworkMessageTraceHooks: BoundExperimentalHardhatNetworkMessageTraceHook[] = [],\n  extenders: ProviderExtender[] = []\n): Promise<EthereumProvider> {\n  let eip1193Provider: EIP1193Provider;\n  const networkConfig = config.networks[networkName];\n  const paths = config.paths;\n\n  if (networkName === HARDHAT_NETWORK_NAME) {\n    const hardhatNetConfig = networkConfig as HardhatNetworkConfig;\n\n    const { createHardhatNetworkProvider } = await import(\n      \"../../hardhat-network/provider/provider\"\n    );\n\n    let forkConfig: ForkConfig | undefined;\n\n    if (\n      hardhatNetConfig.forking?.enabled === true &&\n      hardhatNetConfig.forking?.url !== undefined\n    ) {\n      forkConfig = {\n        jsonRpcUrl: hardhatNetConfig.forking?.url,\n        blockNumber: hardhatNetConfig.forking?.blockNumber,\n        httpHeaders: hardhatNetConfig.forking.httpHeaders,\n      };\n    }\n\n    const accounts = normalizeHardhatNetworkAccountsConfig(\n      hardhatNetConfig.accounts\n    );\n\n    const { getForkCacheDirPath } =\n      require(\"../../hardhat-network/provider/utils/disk-cache\") as typeof DiskCacheT;\n\n    eip1193Provider = await createHardhatNetworkProvider(\n      {\n        chainId: hardhatNetConfig.chainId,\n        networkId: hardhatNetConfig.chainId,\n        hardfork: hardhatNetConfig.hardfork,\n        blockGasLimit: hardhatNetConfig.blockGasLimit,\n        initialBaseFeePerGas: hardhatNetConfig.initialBaseFeePerGas,\n        minGasPrice: hardhatNetConfig.minGasPrice,\n        throwOnTransactionFailures: hardhatNetConfig.throwOnTransactionFailures,\n        throwOnCallFailures: hardhatNetConfig.throwOnCallFailures,\n        automine: hardhatNetConfig.mining.auto,\n        intervalMining: hardhatNetConfig.mining.interval,\n        // This cast is valid because of the config validation and resolution\n        mempoolOrder: hardhatNetConfig.mining.mempool.order as MempoolOrder,\n        chains: hardhatNetConfig.chains,\n        coinbase: hardhatNetConfig.coinbase,\n        genesisAccounts: accounts,\n        allowUnlimitedContractSize: hardhatNetConfig.allowUnlimitedContractSize,\n        allowBlocksWithSameTimestamp:\n          hardhatNetConfig.allowBlocksWithSameTimestamp ?? false,\n        initialDate:\n          hardhatNetConfig.initialDate !== undefined\n            ? parseDateString(hardhatNetConfig.initialDate)\n            : undefined,\n        experimentalHardhatNetworkMessageTraceHooks,\n        forkConfig,\n        forkCachePath:\n          paths !== undefined ? getForkCacheDirPath(paths) : undefined,\n        enableTransientStorage:\n          hardhatNetConfig.enableTransientStorage ?? false,\n      },\n      {\n        enabled: hardhatNetConfig.loggingEnabled,\n      },\n      artifacts\n    );\n  } else {\n    const HttpProvider = importProvider<\n      typeof import(\"./http\"),\n      \"HttpProvider\"\n    >(\"./http\", \"HttpProvider\");\n    const httpNetConfig = networkConfig as HttpNetworkConfig;\n\n    eip1193Provider = new HttpProvider(\n      httpNetConfig.url!,\n      networkName,\n      httpNetConfig.httpHeaders,\n      httpNetConfig.timeout\n    );\n  }\n\n  let wrappedProvider = eip1193Provider;\n\n  for (const extender of extenders) {\n    wrappedProvider = await extender(wrappedProvider, config, networkName);\n  }\n\n  wrappedProvider = applyProviderWrappers(\n    wrappedProvider,\n    networkConfig,\n    extenders\n  );\n\n  const BackwardsCompatibilityProviderAdapter = importProvider<\n    typeof import(\"./backwards-compatibility\"),\n    \"BackwardsCompatibilityProviderAdapter\"\n  >(\"./backwards-compatibility\", \"BackwardsCompatibilityProviderAdapter\");\n\n  return new BackwardsCompatibilityProviderAdapter(wrappedProvider);\n}\n\nexport function applyProviderWrappers(\n  provider: EIP1193Provider,\n  netConfig: Partial<NetworkConfig>,\n  extenders: ProviderExtender[]\n): EIP1193Provider {\n  // These dependencies are lazy-loaded because they are really big.\n  const LocalAccountsProvider = importProvider<\n    typeof import(\"./accounts\"),\n    \"LocalAccountsProvider\"\n  >(\"./accounts\", \"LocalAccountsProvider\");\n  const HDWalletProvider = importProvider<\n    typeof import(\"./accounts\"),\n    \"HDWalletProvider\"\n  >(\"./accounts\", \"HDWalletProvider\");\n  const FixedSenderProvider = importProvider<\n    typeof import(\"./accounts\"),\n    \"FixedSenderProvider\"\n  >(\"./accounts\", \"FixedSenderProvider\");\n  const AutomaticSenderProvider = importProvider<\n    typeof import(\"./accounts\"),\n    \"AutomaticSenderProvider\"\n  >(\"./accounts\", \"AutomaticSenderProvider\");\n\n  const AutomaticGasProvider = importProvider<\n    typeof import(\"./gas-providers\"),\n    \"AutomaticGasProvider\"\n  >(\"./gas-providers\", \"AutomaticGasProvider\");\n  const FixedGasProvider = importProvider<\n    typeof import(\"./gas-providers\"),\n    \"FixedGasProvider\"\n  >(\"./gas-providers\", \"FixedGasProvider\");\n  const AutomaticGasPriceProvider = importProvider<\n    typeof import(\"./gas-providers\"),\n    \"AutomaticGasPriceProvider\"\n  >(\"./gas-providers\", \"AutomaticGasPriceProvider\");\n  const FixedGasPriceProvider = importProvider<\n    typeof import(\"./gas-providers\"),\n    \"FixedGasPriceProvider\"\n  >(\"./gas-providers\", \"FixedGasPriceProvider\");\n  const ChainIdValidatorProvider = importProvider<\n    typeof import(\"./chainId\"),\n    \"ChainIdValidatorProvider\"\n  >(\"./chainId\", \"ChainIdValidatorProvider\");\n\n  if (isResolvedHttpNetworkConfig(netConfig)) {\n    const accounts = netConfig.accounts;\n\n    if (Array.isArray(accounts)) {\n      provider = new LocalAccountsProvider(provider, accounts);\n    } else if (isHDAccountsConfig(accounts)) {\n      provider = new HDWalletProvider(\n        provider,\n        accounts.mnemonic,\n        accounts.path,\n        accounts.initialIndex,\n        accounts.count,\n        accounts.passphrase\n      );\n    }\n\n    // TODO: Add some extension mechanism for account plugins here\n  }\n\n  if (netConfig.from !== undefined) {\n    provider = new FixedSenderProvider(provider, netConfig.from);\n  } else {\n    provider = new AutomaticSenderProvider(provider);\n  }\n\n  if (netConfig.gas === undefined || netConfig.gas === \"auto\") {\n    provider = new AutomaticGasProvider(provider, netConfig.gasMultiplier);\n  } else {\n    provider = new FixedGasProvider(provider, netConfig.gas);\n  }\n\n  if (netConfig.gasPrice === undefined || netConfig.gasPrice === \"auto\") {\n    // If you use a LocalAccountsProvider or HDWalletProvider, your transactions\n    // are signed locally. This requires having all of their fields available,\n    // including the gasPrice / maxFeePerGas & maxPriorityFeePerGas.\n    //\n    // We never use those providers when using Hardhat Network, but sign within\n    // Hardhat Network itself. This means that we don't need to provide all the\n    // fields, as the missing ones will be resolved there.\n    //\n    // Hardhat Network handles this in a more performant way, so we don't use\n    // the AutomaticGasPriceProvider for it unless there are provider extenders.\n    // The reason for this is that some extenders (like hardhat-ledger's) might\n    // do the signing themselves, and that needs the gas price to be set.\n    if (isResolvedHttpNetworkConfig(netConfig) || extenders.length > 0) {\n      provider = new AutomaticGasPriceProvider(provider);\n    }\n  } else {\n    provider = new FixedGasPriceProvider(provider, netConfig.gasPrice);\n  }\n\n  if (\n    isResolvedHttpNetworkConfig(netConfig) &&\n    netConfig.chainId !== undefined\n  ) {\n    provider = new ChainIdValidatorProvider(provider, netConfig.chainId);\n  }\n\n  return provider;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}