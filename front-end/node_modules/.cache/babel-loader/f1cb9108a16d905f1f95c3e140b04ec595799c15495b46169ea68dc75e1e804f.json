{"ast":null,"code":"import { encode as dagCborEncode } from '@ipld/dag-cbor';\nimport varint from 'varint';\n\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('./api').Block} Block\n * @typedef {import('./coding').CarEncoder} CarEncoder\n * @typedef {import('./coding').IteratorChannel_Writer<Uint8Array>} IteratorChannel_Writer\n */\n\nconst CAR_V1_VERSION = 1;\n\n/**\n * Create a header from an array of roots.\n *\n * @param {CID[]} roots\n * @returns {Uint8Array}\n */\nexport function createHeader(roots) {\n  const headerBytes = dagCborEncode({\n    version: CAR_V1_VERSION,\n    roots\n  });\n  const varintBytes = varint.encode(headerBytes.length);\n  const header = new Uint8Array(varintBytes.length + headerBytes.length);\n  header.set(varintBytes, 0);\n  header.set(headerBytes, varintBytes.length);\n  return header;\n}\n\n/**\n * @param {IteratorChannel_Writer} writer\n * @returns {CarEncoder}\n */\nfunction createEncoder(writer) {\n  // none of this is wrapped in a mutex, that needs to happen above this to\n  // avoid overwrites\n\n  return {\n    /**\n     * @param {CID[]} roots\n     * @returns {Promise<void>}\n     */\n    async setRoots(roots) {\n      const bytes = createHeader(roots);\n      await writer.write(bytes);\n    },\n    /**\n     * @param {Block} block\n     * @returns {Promise<void>}\n     */\n    async writeBlock(block) {\n      const {\n        cid,\n        bytes\n      } = block;\n      await writer.write(new Uint8Array(varint.encode(cid.bytes.length + bytes.length)));\n      await writer.write(cid.bytes);\n      if (bytes.length) {\n        // zero-length blocks are valid, but it'd be safer if we didn't write them\n        await writer.write(bytes);\n      }\n    },\n    /**\n     * @returns {Promise<void>}\n     */\n    async close() {\n      await writer.end();\n    },\n    /**\n     * @returns {number}\n     */\n    version() {\n      return CAR_V1_VERSION;\n    }\n  };\n}\nexport { createEncoder };","map":{"version":3,"names":["encode","dagCborEncode","varint","CAR_V1_VERSION","createHeader","roots","headerBytes","version","varintBytes","length","header","Uint8Array","set","createEncoder","writer","setRoots","bytes","write","writeBlock","block","cid","close","end"],"sources":["C:/FACULTATE/Proiect/node_modules/@web3-storage/upload-client/node_modules/@ipld/car/src/encoder.js"],"sourcesContent":["import { encode as dagCborEncode } from '@ipld/dag-cbor'\nimport varint from 'varint'\n\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('./api').Block} Block\n * @typedef {import('./coding').CarEncoder} CarEncoder\n * @typedef {import('./coding').IteratorChannel_Writer<Uint8Array>} IteratorChannel_Writer\n */\n\nconst CAR_V1_VERSION = 1\n\n/**\n * Create a header from an array of roots.\n *\n * @param {CID[]} roots\n * @returns {Uint8Array}\n */\nexport function createHeader (roots) {\n  const headerBytes = dagCborEncode({ version: CAR_V1_VERSION, roots })\n  const varintBytes = varint.encode(headerBytes.length)\n  const header = new Uint8Array(varintBytes.length + headerBytes.length)\n  header.set(varintBytes, 0)\n  header.set(headerBytes, varintBytes.length)\n  return header\n}\n\n/**\n * @param {IteratorChannel_Writer} writer\n * @returns {CarEncoder}\n */\nfunction createEncoder (writer) {\n  // none of this is wrapped in a mutex, that needs to happen above this to\n  // avoid overwrites\n\n  return {\n    /**\n     * @param {CID[]} roots\n     * @returns {Promise<void>}\n     */\n    async setRoots (roots) {\n      const bytes = createHeader(roots)\n      await writer.write(bytes)\n    },\n\n    /**\n     * @param {Block} block\n     * @returns {Promise<void>}\n     */\n    async writeBlock (block) {\n      const { cid, bytes } = block\n      await writer.write(new Uint8Array(varint.encode(cid.bytes.length + bytes.length)))\n      await writer.write(cid.bytes)\n      if (bytes.length) {\n        // zero-length blocks are valid, but it'd be safer if we didn't write them\n        await writer.write(bytes)\n      }\n    },\n\n    /**\n     * @returns {Promise<void>}\n     */\n    async close () {\n      await writer.end()\n    },\n\n    /**\n     * @returns {number}\n     */\n    version () {\n      return CAR_V1_VERSION\n    }\n  }\n}\n\nexport { createEncoder }\n"],"mappings":"AAAA,SAASA,MAAM,IAAIC,aAAa,QAAQ,gBAAgB;AACxD,OAAOC,MAAM,MAAM,QAAQ;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,cAAc,GAAG,CAAC;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,YAAYA,CAAEC,KAAK,EAAE;EACnC,MAAMC,WAAW,GAAGL,aAAa,CAAC;IAAEM,OAAO,EAAEJ,cAAc;IAAEE;EAAM,CAAC,CAAC;EACrE,MAAMG,WAAW,GAAGN,MAAM,CAACF,MAAM,CAACM,WAAW,CAACG,MAAM,CAAC;EACrD,MAAMC,MAAM,GAAG,IAAIC,UAAU,CAACH,WAAW,CAACC,MAAM,GAAGH,WAAW,CAACG,MAAM,CAAC;EACtEC,MAAM,CAACE,GAAG,CAACJ,WAAW,EAAE,CAAC,CAAC;EAC1BE,MAAM,CAACE,GAAG,CAACN,WAAW,EAAEE,WAAW,CAACC,MAAM,CAAC;EAC3C,OAAOC,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA,SAASG,aAAaA,CAAEC,MAAM,EAAE;EAC9B;EACA;;EAEA,OAAO;IACL;AACJ;AACA;AACA;IACI,MAAMC,QAAQA,CAAEV,KAAK,EAAE;MACrB,MAAMW,KAAK,GAAGZ,YAAY,CAACC,KAAK,CAAC;MACjC,MAAMS,MAAM,CAACG,KAAK,CAACD,KAAK,CAAC;IAC3B,CAAC;IAED;AACJ;AACA;AACA;IACI,MAAME,UAAUA,CAAEC,KAAK,EAAE;MACvB,MAAM;QAAEC,GAAG;QAAEJ;MAAM,CAAC,GAAGG,KAAK;MAC5B,MAAML,MAAM,CAACG,KAAK,CAAC,IAAIN,UAAU,CAACT,MAAM,CAACF,MAAM,CAACoB,GAAG,CAACJ,KAAK,CAACP,MAAM,GAAGO,KAAK,CAACP,MAAM,CAAC,CAAC,CAAC;MAClF,MAAMK,MAAM,CAACG,KAAK,CAACG,GAAG,CAACJ,KAAK,CAAC;MAC7B,IAAIA,KAAK,CAACP,MAAM,EAAE;QAChB;QACA,MAAMK,MAAM,CAACG,KAAK,CAACD,KAAK,CAAC;MAC3B;IACF,CAAC;IAED;AACJ;AACA;IACI,MAAMK,KAAKA,CAAA,EAAI;MACb,MAAMP,MAAM,CAACQ,GAAG,CAAC,CAAC;IACpB,CAAC;IAED;AACJ;AACA;IACIf,OAAOA,CAAA,EAAI;MACT,OAAOJ,cAAc;IACvB;EACF,CAAC;AACH;AAEA,SAASU,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}