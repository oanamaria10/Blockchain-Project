{"ast":null,"code":"/**\n * Blob Capabilities.\n *\n * Blob is a fixed size byte array addressed by the multihash.\n * Usually blobs are used to represent set of IPLD blocks at different byte ranges.\n *\n * These can be imported directly with:\n * ```js\n * import * as Blob from '@web3-storage/capabilities/blob'\n * ```\n *\n * @module\n */\nimport { equals } from 'uint8arrays/equals';\nimport { capability, Schema, fail, ok } from '@ucanto/validator';\nimport { equalBlob, equalWith, SpaceDID } from './utils.js';\n\n/**\n * Agent capabilities for Blob protocol\n */\n\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `space/blob/` prefixed capability for the (memory) space identified\n * by DID in the `with` field.\n */\nexport const blob = capability({\n  can: 'space/blob/*',\n  /**\n   * DID of the (memory) space where Blob is intended to\n   * be stored.\n   */\n  with: SpaceDID,\n  derives: equalWith\n});\n\n/**\n * Blob description for being ingested by the service.\n */\nexport const content = Schema.struct({\n  /**\n   * A multihash digest of the blob payload bytes, uniquely identifying blob.\n   */\n  digest: Schema.bytes(),\n  /**\n   * Number of bytes contained by this blob. Service will provision write target\n   * for this exact size. Attempt to write a larger Blob file will fail.\n   */\n  size: Schema.integer()\n});\n\n/**\n * `space/blob/add` capability allows agent to store a Blob into a (memory) space\n * identified by did:key in the `with` field. Agent should compute blob multihash\n * and size and provide it under `nb.blob` field, allowing a service to provision\n * a write location for the agent to PUT desired Blob into.\n */\nexport const add = capability({\n  can: 'space/blob/add',\n  /**\n   * DID of the (memory) space where Blob is intended to\n   * be stored.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * Blob to be added on the space.\n     */\n    blob: content\n  }),\n  derives: equalBlob\n});\n\n/**\n * Capability can be used to remove the stored Blob from the (memory)\n * space identified by `with` field.\n */\nexport const remove = capability({\n  can: 'space/blob/remove',\n  /**\n   * DID of the (memory) space where Blob is stored.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * A multihash digest of the blob payload bytes, uniquely identifying blob.\n     */\n    digest: Schema.bytes()\n  }),\n  derives: (claimed, delegated) => {\n    if (claimed.with !== delegated.with) {\n      return fail(`Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`);\n    } else if (delegated.nb.digest && !equals(delegated.nb.digest, claimed.nb.digest)) {\n      return fail(`Link ${claimed.nb.digest ? `${claimed.nb.digest}` : ''} violates imposed ${delegated.nb.digest} constraint.`);\n    }\n    return ok({});\n  }\n});\n\n/**\n * Capability can be invoked to request a list of stored Blobs in the\n * (memory) space identified by `with` field.\n */\nexport const list = capability({\n  can: 'space/blob/list',\n  /**\n   * DID of the (memory) space where Blobs to be listed are stored.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * A pointer that can be moved back and forth on the list.\n     * It can be used to paginate a list for instance.\n     */\n    cursor: Schema.string().optional(),\n    /**\n     * Maximum number of items per page.\n     */\n    size: Schema.integer().optional()\n  }),\n  derives: (claimed, delegated) => {\n    if (claimed.with !== delegated.with) {\n      return fail(`Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`);\n    }\n    return ok({});\n  }\n});\n\n/**\n * Capability can be used to get the stored Blob from the (memory)\n * space identified by `with` field.\n */\nexport const get = capability({\n  can: 'space/blob/get/0/1',\n  /**\n   * DID of the (memory) space where Blob is stored.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * A multihash digest of the blob payload bytes, uniquely identifying blob.\n     */\n    digest: Schema.bytes()\n  }),\n  derives: (claimed, delegated) => {\n    if (claimed.with !== delegated.with) {\n      return fail(`Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`);\n    } else if (delegated.nb.digest && !equals(delegated.nb.digest, claimed.nb.digest)) {\n      return fail(`Link ${claimed.nb.digest ? `${claimed.nb.digest}` : ''} violates imposed ${delegated.nb.digest} constraint.`);\n    }\n    return ok({});\n  }\n});\n\n// ⚠️ We export imports here so they are not omitted in generated typedefs\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Schema };","map":{"version":3,"names":["equals","capability","Schema","fail","ok","equalBlob","equalWith","SpaceDID","blob","can","with","derives","content","struct","digest","bytes","size","integer","add","nb","remove","claimed","delegated","list","cursor","string","optional","get"],"sources":["C:/FACULTATE/Proiect/node_modules/@web3-storage/capabilities/src/blob.js"],"sourcesContent":["/**\n * Blob Capabilities.\n *\n * Blob is a fixed size byte array addressed by the multihash.\n * Usually blobs are used to represent set of IPLD blocks at different byte ranges.\n *\n * These can be imported directly with:\n * ```js\n * import * as Blob from '@web3-storage/capabilities/blob'\n * ```\n *\n * @module\n */\nimport { equals } from 'uint8arrays/equals'\nimport { capability, Schema, fail, ok } from '@ucanto/validator'\nimport { equalBlob, equalWith, SpaceDID } from './utils.js'\n\n/**\n * Agent capabilities for Blob protocol\n */\n\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `space/blob/` prefixed capability for the (memory) space identified\n * by DID in the `with` field.\n */\nexport const blob = capability({\n  can: 'space/blob/*',\n  /**\n   * DID of the (memory) space where Blob is intended to\n   * be stored.\n   */\n  with: SpaceDID,\n  derives: equalWith,\n})\n\n/**\n * Blob description for being ingested by the service.\n */\nexport const content = Schema.struct({\n  /**\n   * A multihash digest of the blob payload bytes, uniquely identifying blob.\n   */\n  digest: Schema.bytes(),\n  /**\n   * Number of bytes contained by this blob. Service will provision write target\n   * for this exact size. Attempt to write a larger Blob file will fail.\n   */\n  size: Schema.integer(),\n})\n\n/**\n * `space/blob/add` capability allows agent to store a Blob into a (memory) space\n * identified by did:key in the `with` field. Agent should compute blob multihash\n * and size and provide it under `nb.blob` field, allowing a service to provision\n * a write location for the agent to PUT desired Blob into.\n */\nexport const add = capability({\n  can: 'space/blob/add',\n  /**\n   * DID of the (memory) space where Blob is intended to\n   * be stored.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * Blob to be added on the space.\n     */\n    blob: content,\n  }),\n  derives: equalBlob,\n})\n\n/**\n * Capability can be used to remove the stored Blob from the (memory)\n * space identified by `with` field.\n */\nexport const remove = capability({\n  can: 'space/blob/remove',\n  /**\n   * DID of the (memory) space where Blob is stored.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * A multihash digest of the blob payload bytes, uniquely identifying blob.\n     */\n    digest: Schema.bytes(),\n  }),\n  derives: (claimed, delegated) => {\n    if (claimed.with !== delegated.with) {\n      return fail(\n        `Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`\n      )\n    } else if (\n      delegated.nb.digest &&\n      !equals(delegated.nb.digest, claimed.nb.digest)\n    ) {\n      return fail(\n        `Link ${\n          claimed.nb.digest ? `${claimed.nb.digest}` : ''\n        } violates imposed ${delegated.nb.digest} constraint.`\n      )\n    }\n    return ok({})\n  },\n})\n\n/**\n * Capability can be invoked to request a list of stored Blobs in the\n * (memory) space identified by `with` field.\n */\nexport const list = capability({\n  can: 'space/blob/list',\n  /**\n   * DID of the (memory) space where Blobs to be listed are stored.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * A pointer that can be moved back and forth on the list.\n     * It can be used to paginate a list for instance.\n     */\n    cursor: Schema.string().optional(),\n    /**\n     * Maximum number of items per page.\n     */\n    size: Schema.integer().optional(),\n  }),\n  derives: (claimed, delegated) => {\n    if (claimed.with !== delegated.with) {\n      return fail(\n        `Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`\n      )\n    }\n    return ok({})\n  },\n})\n\n/**\n * Capability can be used to get the stored Blob from the (memory)\n * space identified by `with` field.\n */\nexport const get = capability({\n  can: 'space/blob/get/0/1',\n  /**\n   * DID of the (memory) space where Blob is stored.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * A multihash digest of the blob payload bytes, uniquely identifying blob.\n     */\n    digest: Schema.bytes(),\n  }),\n  derives: (claimed, delegated) => {\n    if (claimed.with !== delegated.with) {\n      return fail(\n        `Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`\n      )\n    } else if (\n      delegated.nb.digest &&\n      !equals(delegated.nb.digest, claimed.nb.digest)\n    ) {\n      return fail(\n        `Link ${\n          claimed.nb.digest ? `${claimed.nb.digest}` : ''\n        } violates imposed ${delegated.nb.digest} constraint.`\n      )\n    }\n    return ok({})\n  },\n})\n\n// ⚠️ We export imports here so they are not omitted in generated typedefs\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Schema }\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,MAAM,QAAQ,oBAAoB;AAC3C,SAASC,UAAU,EAAEC,MAAM,EAAEC,IAAI,EAAEC,EAAE,QAAQ,mBAAmB;AAChE,SAASC,SAAS,EAAEC,SAAS,EAAEC,QAAQ,QAAQ,YAAY;;AAE3D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,IAAI,GAAGP,UAAU,CAAC;EAC7BQ,GAAG,EAAE,cAAc;EACnB;AACF;AACA;AACA;EACEC,IAAI,EAAEH,QAAQ;EACdI,OAAO,EAAEL;AACX,CAAC,CAAC;;AAEF;AACA;AACA;AACA,OAAO,MAAMM,OAAO,GAAGV,MAAM,CAACW,MAAM,CAAC;EACnC;AACF;AACA;EACEC,MAAM,EAAEZ,MAAM,CAACa,KAAK,CAAC,CAAC;EACtB;AACF;AACA;AACA;EACEC,IAAI,EAAEd,MAAM,CAACe,OAAO,CAAC;AACvB,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,GAAG,GAAGjB,UAAU,CAAC;EAC5BQ,GAAG,EAAE,gBAAgB;EACrB;AACF;AACA;AACA;EACEC,IAAI,EAAEH,QAAQ;EACdY,EAAE,EAAEjB,MAAM,CAACW,MAAM,CAAC;IAChB;AACJ;AACA;IACIL,IAAI,EAAEI;EACR,CAAC,CAAC;EACFD,OAAO,EAAEN;AACX,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA,OAAO,MAAMe,MAAM,GAAGnB,UAAU,CAAC;EAC/BQ,GAAG,EAAE,mBAAmB;EACxB;AACF;AACA;EACEC,IAAI,EAAEH,QAAQ;EACdY,EAAE,EAAEjB,MAAM,CAACW,MAAM,CAAC;IAChB;AACJ;AACA;IACIC,MAAM,EAAEZ,MAAM,CAACa,KAAK,CAAC;EACvB,CAAC,CAAC;EACFJ,OAAO,EAAEA,CAACU,OAAO,EAAEC,SAAS,KAAK;IAC/B,IAAID,OAAO,CAACX,IAAI,KAAKY,SAAS,CAACZ,IAAI,EAAE;MACnC,OAAOP,IAAI,CACR,oBAAmBmB,SAAS,CAACZ,IAAK,mBAAkBW,OAAO,CAACX,IAAK,GACpE,CAAC;IACH,CAAC,MAAM,IACLY,SAAS,CAACH,EAAE,CAACL,MAAM,IACnB,CAACd,MAAM,CAACsB,SAAS,CAACH,EAAE,CAACL,MAAM,EAAEO,OAAO,CAACF,EAAE,CAACL,MAAM,CAAC,EAC/C;MACA,OAAOX,IAAI,CACR,QACCkB,OAAO,CAACF,EAAE,CAACL,MAAM,GAAI,GAAEO,OAAO,CAACF,EAAE,CAACL,MAAO,EAAC,GAAG,EAC9C,qBAAoBQ,SAAS,CAACH,EAAE,CAACL,MAAO,cAC3C,CAAC;IACH;IACA,OAAOV,EAAE,CAAC,CAAC,CAAC,CAAC;EACf;AACF,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA,OAAO,MAAMmB,IAAI,GAAGtB,UAAU,CAAC;EAC7BQ,GAAG,EAAE,iBAAiB;EACtB;AACF;AACA;EACEC,IAAI,EAAEH,QAAQ;EACdY,EAAE,EAAEjB,MAAM,CAACW,MAAM,CAAC;IAChB;AACJ;AACA;AACA;IACIW,MAAM,EAAEtB,MAAM,CAACuB,MAAM,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC;IAClC;AACJ;AACA;IACIV,IAAI,EAAEd,MAAM,CAACe,OAAO,CAAC,CAAC,CAACS,QAAQ,CAAC;EAClC,CAAC,CAAC;EACFf,OAAO,EAAEA,CAACU,OAAO,EAAEC,SAAS,KAAK;IAC/B,IAAID,OAAO,CAACX,IAAI,KAAKY,SAAS,CAACZ,IAAI,EAAE;MACnC,OAAOP,IAAI,CACR,oBAAmBmB,SAAS,CAACZ,IAAK,mBAAkBW,OAAO,CAACX,IAAK,GACpE,CAAC;IACH;IACA,OAAON,EAAE,CAAC,CAAC,CAAC,CAAC;EACf;AACF,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA,OAAO,MAAMuB,GAAG,GAAG1B,UAAU,CAAC;EAC5BQ,GAAG,EAAE,oBAAoB;EACzB;AACF;AACA;EACEC,IAAI,EAAEH,QAAQ;EACdY,EAAE,EAAEjB,MAAM,CAACW,MAAM,CAAC;IAChB;AACJ;AACA;IACIC,MAAM,EAAEZ,MAAM,CAACa,KAAK,CAAC;EACvB,CAAC,CAAC;EACFJ,OAAO,EAAEA,CAACU,OAAO,EAAEC,SAAS,KAAK;IAC/B,IAAID,OAAO,CAACX,IAAI,KAAKY,SAAS,CAACZ,IAAI,EAAE;MACnC,OAAOP,IAAI,CACR,oBAAmBmB,SAAS,CAACZ,IAAK,mBAAkBW,OAAO,CAACX,IAAK,GACpE,CAAC;IACH,CAAC,MAAM,IACLY,SAAS,CAACH,EAAE,CAACL,MAAM,IACnB,CAACd,MAAM,CAACsB,SAAS,CAACH,EAAE,CAACL,MAAM,EAAEO,OAAO,CAACF,EAAE,CAACL,MAAM,CAAC,EAC/C;MACA,OAAOX,IAAI,CACR,QACCkB,OAAO,CAACF,EAAE,CAACL,MAAM,GAAI,GAAEO,OAAO,CAACF,EAAE,CAACL,MAAO,EAAC,GAAG,EAC9C,qBAAoBQ,SAAS,CAACH,EAAE,CAACL,MAAO,cAC3C,CAAC;IACH;IACA,OAAOV,EAAE,CAAC,CAAC,CAAC,CAAC;EACf;AACF,CAAC,CAAC;;AAEF;AACA;AACA,SAASF,MAAM","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}