{"ast":null,"code":"import { CID, format, toJSON, fromJSON } from './cid.js';\n// This way TS will also expose all the types from module\nexport * from './link/interface.js';\nconst DAG_PB_CODE = 0x70;\n// eslint-disable-next-line\nconst SHA_256_CODE = 0x12;\n/**\n * Simplified version of `create` for CIDv0.\n */\nexport function createLegacy(digest) {\n  return CID.create(0, DAG_PB_CODE, digest);\n}\n/**\n * Simplified version of `create` for CIDv1.\n *\n * @param code - Content encoding format code.\n * @param digest - Miltihash of the content.\n */\nexport function create(code, digest) {\n  return CID.create(1, code, digest);\n}\n/**\n * Type predicate returns true if value is the link.\n */\nexport function isLink(value) {\n  if (value == null) {\n    return false;\n  }\n  const withSlash = value;\n  if (withSlash['/'] != null && withSlash['/'] === withSlash.bytes) {\n    return true;\n  }\n  const withAsCID = value;\n  if (withAsCID.asCID === value) {\n    return true;\n  }\n  return false;\n}\n/**\n * Takes cid in a string representation and creates an instance. If `base`\n * decoder is not provided will use a default from the configuration. It will\n * throw an error if encoding of the CID is not compatible with supplied (or\n * a default decoder).\n */\nexport function parse(source, base) {\n  return CID.parse(source, base);\n}\nexport { format, toJSON, fromJSON };\n/**\n * Decoded a CID from its binary representation. The byte array must contain\n * only the CID with no additional bytes.\n *\n * An error will be thrown if the bytes provided do not contain a valid\n * binary representation of a CID.\n */\nexport function decode(bytes) {\n  return CID.decode(bytes);\n}","map":{"version":3,"names":["CID","format","toJSON","fromJSON","DAG_PB_CODE","SHA_256_CODE","createLegacy","digest","create","code","isLink","value","withSlash","bytes","withAsCID","asCID","parse","source","base","decode"],"sources":["C:\\FACULTATE\\Proiect\\node_modules\\@web3-storage\\data-segment\\node_modules\\multiformats\\src\\link.ts"],"sourcesContent":["import { CID, format, toJSON, fromJSON } from './cid.js'\nimport type * as API from './link/interface.js'\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\nconst DAG_PB_CODE = 0x70\n// eslint-disable-next-line\nconst SHA_256_CODE = 0x12\n\n/**\n * Simplified version of `create` for CIDv0.\n */\nexport function createLegacy (digest: API.MultihashDigest<typeof SHA_256_CODE>): API.LegacyLink {\n  return CID.create(0, DAG_PB_CODE, digest)\n}\n\n/**\n * Simplified version of `create` for CIDv1.\n *\n * @param code - Content encoding format code.\n * @param digest - Miltihash of the content.\n */\nexport function create <Data, Code extends number, Alg extends number> (code: Code, digest: API.MultihashDigest<Alg>): API.Link<Data, Code, Alg> {\n  return CID.create(1, code, digest)\n}\n\n/**\n * Type predicate returns true if value is the link.\n */\nexport function isLink <L extends API.Link<unknown, number, number, 0 | 1>> (value: unknown | L): value is L & CID {\n  if (value == null) {\n    return false\n  }\n\n  const withSlash = value as { '/'?: Uint8Array, bytes: Uint8Array }\n\n  if (withSlash['/'] != null && withSlash['/'] === withSlash.bytes) {\n    return true\n  }\n\n  const withAsCID = value as { 'asCID'?: unknown }\n\n  if (withAsCID.asCID === value) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Takes cid in a string representation and creates an instance. If `base`\n * decoder is not provided will use a default from the configuration. It will\n * throw an error if encoding of the CID is not compatible with supplied (or\n * a default decoder).\n */\nexport function parse <Prefix extends string, Data, Code extends number, Alg extends number, Ver extends API.Version> (source: API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>, base?: API.MultibaseDecoder<Prefix>): API.Link<Data, Code, Alg, Ver> {\n  return CID.parse(source, base)\n}\n\nexport { format, toJSON, fromJSON }\n\n/**\n * Decoded a CID from its binary representation. The byte array must contain\n * only the CID with no additional bytes.\n *\n * An error will be thrown if the bytes provided do not contain a valid\n * binary representation of a CID.\n */\nexport function decode <Data, Code extends number, Alg extends number, Ver extends API.Version> (bytes: API.ByteView<API.Link<Data, Code, Alg, Ver>>): API.Link<Data, Code, Alg, Ver> {\n  return CID.decode(bytes)\n}\n"],"mappings":"AAAA,SAASA,GAAG,EAAEC,MAAM,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,UAAU;AAExD;AACA,cAAc,qBAAqB;AAEnC,MAAMC,WAAW,GAAG,IAAI;AACxB;AACA,MAAMC,YAAY,GAAG,IAAI;AAEzB;;;AAGA,OAAM,SAAUC,YAAYA,CAAEC,MAAgD;EAC5E,OAAOP,GAAG,CAACQ,MAAM,CAAC,CAAC,EAAEJ,WAAW,EAAEG,MAAM,CAAC;AAC3C;AAEA;;;;;;AAMA,OAAM,SAAUC,MAAMA,CAAkDC,IAAU,EAAEF,MAAgC;EAClH,OAAOP,GAAG,CAACQ,MAAM,CAAC,CAAC,EAAEC,IAAI,EAAEF,MAAM,CAAC;AACpC;AAEA;;;AAGA,OAAM,SAAUG,MAAMA,CAAuDC,KAAkB;EAC7F,IAAIA,KAAK,IAAI,IAAI,EAAE;IACjB,OAAO,KAAK;EACd;EAEA,MAAMC,SAAS,GAAGD,KAAgD;EAElE,IAAIC,SAAS,CAAC,GAAG,CAAC,IAAI,IAAI,IAAIA,SAAS,CAAC,GAAG,CAAC,KAAKA,SAAS,CAACC,KAAK,EAAE;IAChE,OAAO,IAAI;EACb;EAEA,MAAMC,SAAS,GAAGH,KAA8B;EAEhD,IAAIG,SAAS,CAACC,KAAK,KAAKJ,KAAK,EAAE;IAC7B,OAAO,IAAI;EACb;EAEA,OAAO,KAAK;AACd;AAEA;;;;;;AAMA,OAAM,SAAUK,KAAKA,CAAkGC,MAA4D,EAAEC,IAAmC;EACtN,OAAOlB,GAAG,CAACgB,KAAK,CAACC,MAAM,EAAEC,IAAI,CAAC;AAChC;AAEA,SAASjB,MAAM,EAAEC,MAAM,EAAEC,QAAQ;AAEjC;;;;;;;AAOA,OAAM,SAAUgB,MAAMA,CAA2EN,KAAmD;EAClJ,OAAOb,GAAG,CAACmB,MAAM,CAACN,KAAK,CAAC;AAC1B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}