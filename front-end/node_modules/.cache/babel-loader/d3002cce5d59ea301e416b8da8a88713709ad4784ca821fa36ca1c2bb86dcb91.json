{"ast":null,"code":"/**\n * Access Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Access from '@web3-storage/capabilities/access'\n * ```\n *\n * @module\n */\nimport { capability, URI, DID, Schema, fail, ok } from '@ucanto/validator';\nimport * as Types from '@ucanto/interface';\nimport { attest } from './ucan.js';\nimport { equalWith, equal, and, SpaceDID, checkLink } from './utils.js';\nexport { top } from './top.js';\n\n/**\n * @deprecated - Use `ucan.attest` instead.\n */\nexport const session = attest;\n\n/**\n * Account identifier.\n */\nexport const Account = DID.match({\n  method: 'mailto'\n});\n\n/**\n * Describes the capability requested.\n */\nexport const CapabilityRequest = Schema.struct({\n  /**\n   * If set to `\"*\"` it corresponds to \"sudo\" access.\n   */\n  can: Schema.string()\n});\n\n/**\n * Authorization request describing set of desired capabilities.\n */\nexport const AuthorizationRequest = Schema.struct({\n  /**\n   * DID of the Account authorization is requested from.\n   */\n  iss: Account,\n  /**\n   * Capabilities agent wishes to be granted.\n   */\n  att: CapabilityRequest.array()\n});\n\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `access/` prefixed capability for the agent identified\n * by did:key in the `with` field.\n */\nexport const access = capability({\n  can: 'access/*',\n  with: URI.match({\n    protocol: 'did:'\n  })\n});\n\n/**\n * Capability can be invoked by an agent to request set of capabilities from\n * the account.\n */\nexport const authorize = capability({\n  can: 'access/authorize',\n  with: DID.match({\n    method: 'key'\n  }),\n  /**\n   * Authorization request describing set of desired capabilities\n   */\n  nb: AuthorizationRequest,\n  derives: (child, parent) => {\n    return and(equalWith(child, parent)) || and(equal(child.nb.iss, parent.nb.iss, 'iss')) || and(subsetCapabilities(child.nb.att, parent.nb.att)) || ok({});\n  }\n});\n\n/**\n * Capability is delegated by us to the user allowing them to complete the\n * authorization flow. It allows us to ensure that user clicks the link and\n * we don't have some rogue agent trying to impersonate user clicking the link\n * in order to get access to their account.\n */\nexport const confirm = capability({\n  can: 'access/confirm',\n  with: DID,\n  nb: Schema.struct({\n    /**\n     * Link to the `access/authorize` request that this delegation was created\n     * for.\n     */\n    cause: Schema.link({\n      version: 1\n    }),\n    iss: Account,\n    aud: Schema.did(),\n    att: CapabilityRequest.array()\n  }),\n  derives: (claim, proof) => {\n    return and(equalWith(claim, proof)) || and(equal(claim.nb.iss, proof.nb.iss, 'iss')) || and(equal(claim.nb.aud, proof.nb.aud, 'aud')) || and(subsetCapabilities(claim.nb.att, proof.nb.att)) || and(checkLink(claim.nb.cause, proof.nb.cause, 'nb.cause')) || ok({});\n  }\n});\nexport const claim = capability({\n  can: 'access/claim',\n  with: DID.match({\n    method: 'key'\n  }).or(DID.match({\n    method: 'mailto'\n  }))\n});\n\n// https://github.com/storacha/specs/blob/main/w3-access.md#accessdelegate\nexport const delegate = capability({\n  can: 'access/delegate',\n  /**\n   * Field MUST be a space DID with a storage provider. Delegation will be stored just like any other DAG stored using store/add capability.\n   *\n   * @see https://github.com/storacha/specs/blob/main/w3-access.md#delegate-with\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    // keys SHOULD be CIDs, but we won't require it in the schema\n    /**\n     * @type {Schema.Schema<AccessDelegateDelegations>}\n     */\n    delegations: Schema.dictionary({\n      value: Schema.Link.match()\n    })\n  }),\n  derives: (claim, proof) => {\n    return and(equalWith(claim, proof)) || and(subsetsNbDelegations(claim, proof)) || ok({});\n  }\n});\n\n/**\n * @typedef {Schema.Dictionary<string, Types.Link<unknown, number, number, 0 | 1>>} AccessDelegateDelegations\n */\n\n/**\n * Parsed Capability for access/delegate\n *\n * @typedef {object} ParsedAccessDelegate\n * @property {string} can\n * @property {object} nb\n * @property {AccessDelegateDelegations} [nb.delegations]\n */\n\n/**\n * returns whether the claimed ucan is proves by the proof ucan.\n * both are access/delegate, or at least have same semantics for `nb.delegations`, which is a set of delegations.\n * checks that the claimed delegation set is equal to or less than the proven delegation set.\n * usable with {import('@ucanto/interface').Derives}.\n *\n * @param {ParsedAccessDelegate} claim\n * @param {ParsedAccessDelegate} proof\n */\nfunction subsetsNbDelegations(claim, proof) {\n  const missingProofs = setDifference(delegatedCids(claim), new Set(delegatedCids(proof)));\n  if (missingProofs.size > 0) {\n    return fail(`unauthorized nb.delegations ${[...missingProofs].join(', ')}`);\n  }\n  return ok({});\n}\n\n/**\n * Checks that set of requested capabilities is a subset of the capabilities\n * that had been allowed by the owner or the delegate.\n *\n * ⚠️ This function does not currently check that say `store/add` is allowed\n * when say `store/*` was delegated, because it seems very unlikely that we\n * will ever encounter delegations for `access/authorize` at all.\n *\n * @param {Schema.Infer<CapabilityRequest>[]} claim\n * @param {Schema.Infer<CapabilityRequest>[]} proof\n */\nconst subsetCapabilities = (claim, proof) => {\n  const allowed = new Set(proof.map(p => p.can));\n  // If everything is allowed, no need to check further because it contains\n  // all the capabilities.\n  if (allowed.has('*')) {\n    return ok({});\n  }\n\n  // Otherwise we compute delta between what is allowed and what is requested.\n  const escalated = setDifference(claim.map(c => c.can), allowed);\n  if (escalated.size > 0) {\n    return fail(`unauthorized nb.att.can ${[...escalated].join(', ')}`);\n  }\n  return ok({});\n};\n\n/**\n * iterate delegated UCAN CIDs from an access/delegate capability.nb.delegations value.\n *\n * @param {ParsedAccessDelegate} delegate\n * @returns {Iterable<string>}\n */\nfunction* delegatedCids(delegate) {\n  for (const d of Object.values(delegate.nb.delegations || {})) {\n    yield d.toString();\n  }\n}\n\n/**\n * @template S\n * @param {Iterable<S>} minuend - set to subtract from\n * @param {Set<S>} subtrahend - subtracted from minuend\n */\nfunction setDifference(minuend, subtrahend) {\n  /** @type {Set<S>} */\n  const difference = new Set();\n  for (const e of minuend) {\n    if (!subtrahend.has(e)) {\n      difference.add(e);\n    }\n  }\n  return difference;\n}","map":{"version":3,"names":["capability","URI","DID","Schema","fail","ok","Types","attest","equalWith","equal","and","SpaceDID","checkLink","top","session","Account","match","method","CapabilityRequest","struct","can","string","AuthorizationRequest","iss","att","array","access","with","protocol","authorize","nb","derives","child","parent","subsetCapabilities","confirm","cause","link","version","aud","did","claim","proof","or","delegate","delegations","dictionary","value","Link","subsetsNbDelegations","missingProofs","setDifference","delegatedCids","Set","size","join","allowed","map","p","has","escalated","c","d","Object","values","toString","minuend","subtrahend","difference","e","add"],"sources":["C:/FACULTATE/Proiect/node_modules/@web3-storage/capabilities/src/access.js"],"sourcesContent":["/**\n * Access Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Access from '@web3-storage/capabilities/access'\n * ```\n *\n * @module\n */\nimport { capability, URI, DID, Schema, fail, ok } from '@ucanto/validator'\nimport * as Types from '@ucanto/interface'\nimport { attest } from './ucan.js'\nimport { equalWith, equal, and, SpaceDID, checkLink } from './utils.js'\nexport { top } from './top.js'\n\n/**\n * @deprecated - Use `ucan.attest` instead.\n */\nexport const session = attest\n\n/**\n * Account identifier.\n */\nexport const Account = DID.match({ method: 'mailto' })\n\n/**\n * Describes the capability requested.\n */\nexport const CapabilityRequest = Schema.struct({\n  /**\n   * If set to `\"*\"` it corresponds to \"sudo\" access.\n   */\n  can: Schema.string(),\n})\n\n/**\n * Authorization request describing set of desired capabilities.\n */\nexport const AuthorizationRequest = Schema.struct({\n  /**\n   * DID of the Account authorization is requested from.\n   */\n  iss: Account,\n  /**\n   * Capabilities agent wishes to be granted.\n   */\n  att: CapabilityRequest.array(),\n})\n\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `access/` prefixed capability for the agent identified\n * by did:key in the `with` field.\n */\nexport const access = capability({\n  can: 'access/*',\n  with: URI.match({ protocol: 'did:' }),\n})\n\n/**\n * Capability can be invoked by an agent to request set of capabilities from\n * the account.\n */\nexport const authorize = capability({\n  can: 'access/authorize',\n  with: DID.match({ method: 'key' }),\n  /**\n   * Authorization request describing set of desired capabilities\n   */\n  nb: AuthorizationRequest,\n  derives: (child, parent) => {\n    return (\n      and(equalWith(child, parent)) ||\n      and(equal(child.nb.iss, parent.nb.iss, 'iss')) ||\n      and(subsetCapabilities(child.nb.att, parent.nb.att)) ||\n      ok({})\n    )\n  },\n})\n\n/**\n * Capability is delegated by us to the user allowing them to complete the\n * authorization flow. It allows us to ensure that user clicks the link and\n * we don't have some rogue agent trying to impersonate user clicking the link\n * in order to get access to their account.\n */\nexport const confirm = capability({\n  can: 'access/confirm',\n  with: DID,\n  nb: Schema.struct({\n    /**\n     * Link to the `access/authorize` request that this delegation was created\n     * for.\n     */\n    cause: Schema.link({ version: 1 }),\n    iss: Account,\n    aud: Schema.did(),\n    att: CapabilityRequest.array(),\n  }),\n  derives: (claim, proof) => {\n    return (\n      and(equalWith(claim, proof)) ||\n      and(equal(claim.nb.iss, proof.nb.iss, 'iss')) ||\n      and(equal(claim.nb.aud, proof.nb.aud, 'aud')) ||\n      and(subsetCapabilities(claim.nb.att, proof.nb.att)) ||\n      and(checkLink(claim.nb.cause, proof.nb.cause, 'nb.cause')) ||\n      ok({})\n    )\n  },\n})\n\nexport const claim = capability({\n  can: 'access/claim',\n  with: DID.match({ method: 'key' }).or(DID.match({ method: 'mailto' })),\n})\n\n// https://github.com/storacha/specs/blob/main/w3-access.md#accessdelegate\nexport const delegate = capability({\n  can: 'access/delegate',\n  /**\n   * Field MUST be a space DID with a storage provider. Delegation will be stored just like any other DAG stored using store/add capability.\n   *\n   * @see https://github.com/storacha/specs/blob/main/w3-access.md#delegate-with\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    // keys SHOULD be CIDs, but we won't require it in the schema\n    /**\n     * @type {Schema.Schema<AccessDelegateDelegations>}\n     */\n    delegations: Schema.dictionary({\n      value: Schema.Link.match(),\n    }),\n  }),\n  derives: (claim, proof) => {\n    return (\n      and(equalWith(claim, proof)) ||\n      and(subsetsNbDelegations(claim, proof)) ||\n      ok({})\n    )\n  },\n})\n\n/**\n * @typedef {Schema.Dictionary<string, Types.Link<unknown, number, number, 0 | 1>>} AccessDelegateDelegations\n */\n\n/**\n * Parsed Capability for access/delegate\n *\n * @typedef {object} ParsedAccessDelegate\n * @property {string} can\n * @property {object} nb\n * @property {AccessDelegateDelegations} [nb.delegations]\n */\n\n/**\n * returns whether the claimed ucan is proves by the proof ucan.\n * both are access/delegate, or at least have same semantics for `nb.delegations`, which is a set of delegations.\n * checks that the claimed delegation set is equal to or less than the proven delegation set.\n * usable with {import('@ucanto/interface').Derives}.\n *\n * @param {ParsedAccessDelegate} claim\n * @param {ParsedAccessDelegate} proof\n */\nfunction subsetsNbDelegations(claim, proof) {\n  const missingProofs = setDifference(\n    delegatedCids(claim),\n    new Set(delegatedCids(proof))\n  )\n  if (missingProofs.size > 0) {\n    return fail(`unauthorized nb.delegations ${[...missingProofs].join(', ')}`)\n  }\n  return ok({})\n}\n\n/**\n * Checks that set of requested capabilities is a subset of the capabilities\n * that had been allowed by the owner or the delegate.\n *\n * ⚠️ This function does not currently check that say `store/add` is allowed\n * when say `store/*` was delegated, because it seems very unlikely that we\n * will ever encounter delegations for `access/authorize` at all.\n *\n * @param {Schema.Infer<CapabilityRequest>[]} claim\n * @param {Schema.Infer<CapabilityRequest>[]} proof\n */\nconst subsetCapabilities = (claim, proof) => {\n  const allowed = new Set(proof.map((p) => p.can))\n  // If everything is allowed, no need to check further because it contains\n  // all the capabilities.\n  if (allowed.has('*')) {\n    return ok({})\n  }\n\n  // Otherwise we compute delta between what is allowed and what is requested.\n  const escalated = setDifference(\n    claim.map((c) => c.can),\n    allowed\n  )\n\n  if (escalated.size > 0) {\n    return fail(`unauthorized nb.att.can ${[...escalated].join(', ')}`)\n  }\n\n  return ok({})\n}\n\n/**\n * iterate delegated UCAN CIDs from an access/delegate capability.nb.delegations value.\n *\n * @param {ParsedAccessDelegate} delegate\n * @returns {Iterable<string>}\n */\nfunction* delegatedCids(delegate) {\n  for (const d of Object.values(delegate.nb.delegations || {})) {\n    yield d.toString()\n  }\n}\n\n/**\n * @template S\n * @param {Iterable<S>} minuend - set to subtract from\n * @param {Set<S>} subtrahend - subtracted from minuend\n */\nfunction setDifference(minuend, subtrahend) {\n  /** @type {Set<S>} */\n  const difference = new Set()\n  for (const e of minuend) {\n    if (!subtrahend.has(e)) {\n      difference.add(e)\n    }\n  }\n  return difference\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}